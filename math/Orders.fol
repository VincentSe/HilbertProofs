(*
   The class of orders : graphs that are reflexive, anti-symmetric and transitive.
*)

EXTENDS Functions

IsOrder(o) == IsGraph(o)
   \* Reflexivity
   /\ (\A x : \A y : (<<x,y>> \in o) => (<<x,x>> \in o /\ <<y,y>> \in o))
   \* transitivity
   /\ (\A x : \A y : \A z : ((<<x,y>> \in o) /\ (<<y,z>> \in o)) => (<<x,z>> \in o))
   \* anti-symmetry
   /\ (\A x : \A y : ((<<x,y>> \in o) /\ (<<y,x>> \in o)) => x = y)

\* Because f[x] is a CHOOSE, this only allows functions which domains
\* contain Domain(u)
IsIncreasing(f, u, v) == \A x : \A y : (<<x,y>> \in u) => (<<f[x], f[y]>> \in v)

IsMinimum(m, part, order) == (m \in part) /\ \A x : (x \in part) => <<m,x>> \in order

\* Usually reflexivity is rather stated in terms of the domain :
orderDomainReflexive == \A o : \A x : IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o
THEOREM orderDomainReflexive
PROOF
VARIABLES g,o,x,y;
domainExists   BECAUSE THEOREM;
x \in Domain(o) <=> IsDefinedOn(o,x)   BECAUSE \A(g <- o, x <- x);
x \in Domain(o) => \E y : <<x,y>> \in o   BECAUSE EquivToImpl;
IsOrder(o) => IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndRight2;
IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndLeft;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE \A(x <- x, y <- y);
IsOrder(o) => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
<<x,y>> \in o => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE SwitchHypos;
IsDefinedOn(o,x) => (\E y : IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE Q_SCHEME;
(\E y : IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE Q_SCHEME;
IsDefinedOn(o,x) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE TI;
x \in Domain(o) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE TI;
IsOrder(o) => (x \in Domain(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE SwitchHypos;
IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o /\ <<y,y>> \in o   BECAUSE HypoImplToAnd;
<<x,x>> \in o /\ <<y,y>> \in o => <<x,x>> \in o   BECAUSE DropAndRight;
IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o   BECAUSE TI;
orderDomainReflexive   BECAUSE GENERALIZATION;
QED

\* An injection f transports an order o
IsInInjectOrder(o,f,x) == x \in (Image(f) \X Image(f)) /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o
injectOrder(o,f) == CHOOSE b : \A x : x \in b <=> IsInInjectOrder(o,f,x)

injectOrderExists == \A o : \A f : \A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)
THEOREM injectOrderExists
PROOF
\* By separation in Image(f) \X Image(f)
VARIABLES a,b,c,f,o,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in (Image(f) \X Image(f)) /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o)
   BECAUSE \A(a <- Image(f) \X Image(f));
(\E b : \A x : x \in b <=> IsInInjectOrder(o,f,x)) => (\A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x))   BECAUSE CHOOSE injectOrder(o,f);
\A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE MODUS_PONENS;
injectOrderExists   BECAUSE GENERALIZATION;
QED

doubleEquiv(a,b,c,d) == (a <=> b) => ((c <=> d) => ((a /\ c) <=> (b /\ d)))   PROPO_TAUTO doubleEquiv

injectOrderCouples == \A o : \A f : \A x : \A y : <<x,y>> \in injectOrder(o,f) <=>
   (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
THEOREM injectOrderCouples
PROOF
VARIABLES a,b,f,o,x,y;
injectOrderExists   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE \A(o <- o, f <- f, x <- <<x,y>>);
cartesianProductCouples   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f)) <=> <<x,y>> \in (Image(f) \X Image(f))
   BECAUSE \A(x <- Image(f), y <- Image(f), a <- x, b <- y);
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
\A x : \A a : \A y : \A b : (x = a /\ y = b)
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,a), pre(f,b)>> \in o)   BECAUSE E_SCHEME;
(x = fst(<<x,y>>) /\ y = snd(<<x,y>>))
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o)
   BECAUSE \A(x <- x, a <- fst(<<x,y>>), y <- y, b <- snd(<<x,y>>));
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o   BECAUSE MODUS_PONENS;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE doubleEquiv;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> <<x,y>> \in injectOrder(o,f)   BECAUSE TransitEquiv2;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivSymmetry;
injectOrderCouples   BECAUSE GENERALIZATION;
QED

injectOrderIsOrder == \A o : \A f : (IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))
THEOREM injectOrderIsOrder
PROOF
VARIABLES a,b,d,f,g,i,j,o,x,y,z;
\* Proof that injectOrder(o,f) is a graph
injectOrderExists   BECAUSE THEOREM;
x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE \A(o <- o, f <- f, x <- x);
x \in injectOrder(o,f) => IsInInjectOrder(o,f,x)   BECAUSE EquivToImpl;
IsInInjectOrder(o,f,x) => x \in (Image(f) \X Image(f))   BECAUSE DropAndRight;
cartesianProductExists   BECAUSE THEOREM;
x \in (Image(f) \X Image(f)) <=> (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))
   BECAUSE \A(i <- Image(f), j <- Image(f), x <- x);
x \in (Image(f) \X Image(f)) => (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f)) => IsCouple(x)   BECAUSE DropAndRight2;
x \in (Image(f) \X Image(f)) => IsCouple(x)   BECAUSE TI;
IsInInjectOrder(o,f,x) => IsCouple(x)   BECAUSE TI;
x \in injectOrder(o,f) => IsCouple(x)   BECAUSE TI;
IsGraph(injectOrder(o,f))   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => IsGraph(injectOrder(o,f))   BECAUSE PT1;

\* Proof that injectOrder(o,f) is reflexive
IsOrder(o) => (IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))   BECAUSE DropAndRight2;
(IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndLeft;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))   BECAUSE TI;
(IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE HypoImplToAnd;
injectOrderCouples   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- y);
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivToImpl;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE DropAndLeft;
<<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE TI;
IsOrder(o) => IsOrder(o)   BECAUSE ImplySelf;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE MergeImplicationsAnd;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE TI;

   \* Lemma : \A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>>) \in o => <<d,d>> \in injectOrder
<<d,d>> \in injectOrder(o,f) <=> (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- d, y <- d);
d \in Image(f) => (d \in Image(f) /\ d \in Image(f))   BECAUSE AndSelf;
<<pre(f,d), pre(f,d)>> \in o => <<pre(f,d), pre(f,d)>> \in o   BECAUSE ImplySelf;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE MergeImplicationsAnd;
(d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE TI;
\A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;

   \* <<x, x>>
(x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o) => <<x,x>> \in injectOrder(o,f)
   BECAUSE \A(d <- x);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => x \in Image(f)   BECAUSE DropAndRight2;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE DropAndRight;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE DropAndLeft;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => x \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o)
   BECAUSE CombineImplicationsEnd;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,x>> \in injectOrder(o,f)   BECAUSE TI;

   \* <<y, y>>
(y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o) => <<y,y>> \in injectOrder(o,f)
   BECAUSE \A(d <- y);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => y \in Image(f)   BECAUSE DropAndBoth;
<<x,y>> \in injectOrder(o,f) => y \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE DropAndLeft;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE DropAndLeft;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => y \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o)
   BECAUSE CombineImplicationsEnd;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<y,y>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))
   BECAUSE CombineImplicationsEnd;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE HypoAndToImpl;
\A y : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(o)   BECAUSE DropAndRight;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;

\* Proof that injectOrder(o,f) is anti-symmetric
\A x : \A y: <<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE GENERALIZATION;
<<y,x>> \in injectOrder(o,f) => <<pre(f,y), pre(f,x)>> \in o   BECAUSE \A(x <- y, y <- x);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)   BECAUSE DropAndLeft;
(\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => pre(f,x) = pre(f,y)   BECAUSE HypoImplToAnd;

(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,y>> \in injectOrder(o,f)   BECAUSE DropAndRight2;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => (x \in Image(f) /\ y \in Image(f))   BECAUSE DropAndRight;
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))   BECAUSE CombineImplicationsEnd;
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))   BECAUSE MergeImplicationsAnd;
funcUniqueImage   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE \A(f <- f, x <- x, y <- y);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f)) => x = y   BECAUSE TI;
massageHypos(a,b,c,d) == ((c /\ d) /\ (a /\ b)) => (a /\ b /\ c /\ d)   PROPO_TAUTO;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)))
   => (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))   BECAUSE massageHypos;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))) => x = y   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE HypoAndToImpl;
\A y: (IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that injectOrder(o,f) is transitive
<<y,z>> \in injectOrder(o,f) => <<pre(f,y), pre(f,z)>> \in o   BECAUSE \A(x <- y, y <- z);
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)   BECAUSE DropAndBoth;
(\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE \A(x <- pre(f,x), y <- pre(f,y), z <- pre(f,z));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<pre(f,x), pre(f,z)>> \in o
   BECAUSE HypoImplToAnd;
\A x : \A y : <<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE GENERALIZATION;
<<y,z>> \in injectOrder(o,f) => (y \in Image(f) /\ z \in Image(f))   BECAUSE \A(x <- y, y <- z);
(y \in Image(f) /\ z \in Image(f)) => z \in Image(f)   BECAUSE DropAndLeft;
<<y,z>> \in injectOrder(o,f) => z \in Image(f)   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f)) => x \in Image(f)   BECAUSE DropAndRight;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE MergeImplicationsAnd;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))   BECAUSE DropAndRight;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)   BECAUSE CombineImplicationsEnd;
<<x,z>> \in injectOrder(o,f) <=> (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- z);
(x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o) => <<x,z>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<x,z>> \in injectOrder(o,f))   BECAUSE HypoAndToImpl;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE SwitchHypos;
\A z : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE GENERALIZATION;
IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A y : IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))))   BECAUSE CombineImplicationsEnd;
(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))) /\ (\A x : \A y : \A z : (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => <<x,z>> \in injectOrder(o,f)))   BECAUSE CombineImplicationsEnd;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))   BECAUSE CombineImplicationsEnd;
injectOrderIsOrder   BECAUSE GENERALIZATION;
QED

\* When two orders have disjoint domains, their union is an order
disjointOrders == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v)
THEOREM disjointOrders
PROOF
\* Proof that disjointOrders is a graph
VARIABLES g,u,v,x,y,z;
unionInc   BECAUSE THEOREM;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
x \in (u \union v) => (x \in u \/ x \in v)   BECAUSE EquivToImpl;
IsOrder(u) => IsGraph(u)   BECAUSE DropAndRight3;
IsGraph(u) => (x \in u => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u) => (x \in u => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE DropAndRight;
(IsOrder(u) /\ IsOrder(v)) => (x \in u => IsCouple(x))   BECAUSE TI;
x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
\A u : x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(v) => IsGraph(v)   BECAUSE DropAndRight3;
IsGraph(v) => (x \in v => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(v) => (x \in v => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE DropAndLeft;
(IsOrder(u) /\ IsOrder(v)) => (x \in v => IsCouple(x))   BECAUSE TI;
x \in v => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
(x \in u \/ x \in v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE CombineImplicationsStart;
x \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : (IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => IsGraph(u \union v)   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE DropAndRight;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsGraph(u \union v)   BECAUSE TI;

\* Proof that u \union v is reflexive.
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
selectSecond(a,b,c,d) == (a /\ b /\ c /\ d) => b   PROPO_TAUTO;
IsOrder(u) => (\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE selectSecond;
(\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE DropAndRight;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)   BECAUSE HypoImplToAnd;
unionFirstInc   BECAUSE THEOREM;
<<x,x>> \in u => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in u => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in u /\ <<y,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
\A u : IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(u <- v);
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE DropAndLeft;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
unionSecondInc   BECAUSE THEOREM;
<<x,x>> \in v => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in v => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in v /\ <<y,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE CombineImplicationsStart;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => ((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   BECAUSE DistribAndOrLeft;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE HypoAndToImpl;
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in u \/ <<x,y>> \in v)
   => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE SwitchHypos;
<<x,y>> \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE SwitchHypos;
\A y : (IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;

\* Proof that u \union v is anti-symmetric
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
implyNotAnd(a,b,c) == (a => ~(b /\ c)) => ((a /\ b) => ~c)   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => <<y,y>> \notin v   BECAUSE implyNotAnd;

(<<x,x>> \in v /\ <<y,y>> \in v) => <<y,y>> \in v   BECAUSE DropAndLeft;
(IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<x,y>> \in v) => <<y,y>> \in v   BECAUSE TI;
andContrapos(a,b,c) == ((a /\ b) => c) => (~c => (a => ~b))   PROPO_TAUTO;
<<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;

\A x : \A y : IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<y,x>> \in v => (<<y,y>> \in v /\ <<x,x>> \in v))   BECAUSE \A(x <- y, y <- x);
(<<y,y>> \in v /\ <<x,x>> \in v) => <<y,y>> \in v   BECAUSE DropAndRight;
(IsOrder(v) /\ <<y,x>> \in v) => (<<y,y>> \in v /\ <<x,x>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<y,x>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,x>> \notin v   BECAUSE HypoImplToAnd;

<<y,x>> \in (u \union v) <=> (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in (u \union v) => (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v)   BECAUSE CombineImplicationsEnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCases(a,b,c,d) == (~a /\ ~b /\ ((c \/ a) /\ (d \/ b))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE TI;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE DropAndLeft;
(\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,x>> \in u) => (IsOrder(u) => x = y)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(u) => x = y)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(u))
   => x = y   BECAUSE HypoImplToAnd;
flipLast(a,b,c,d) == ((a /\ b /\ c) => d) => ((a /\ c) => (b => d))   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<x,y>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<x,y>> \notin u   BECAUSE HypoImplToAnd;
\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,x>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,x>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,x>> \notin u)   BECAUSE CombineImplicationsEnd;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCasesRight(a,b,c,d) == (~a /\ ~b /\ ((a \/ c) /\ (b \/ d))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE TI;
\A u : IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE GENERALIZATION;
IsOrder(v) => ((<<x,y>> \in v /\ <<y,x>> \in v) => x = y)   BECAUSE \A(u <- v);
(<<x,y>> \in v /\ <<y,x>> \in v) => (IsOrder(v) => x = y)   BECAUSE SwitchHypos;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(v) => x = y)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(v))
   => x = y   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)
   BECAUSE CombineImplicationsStart;
exclMid(a,b,c,d) == (a /\ b /\ c) => ((c /\ d /\ b /\ a) \/ (~d /\ a /\ b))   PROPO_TAUTO;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   BECAUSE exclMid;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE TI;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that u \union v is transitive.
\* If <<y,y>> \in u, because u and v are disjoint, <<y,y>> \notin v and then by reflexivity of v,
\* <<y,z>> \notin v and <<x,y>> \notin v. Else <<y,y>> \notin u, then by reflexivity of u,
\* <<y,z>> \notin u and <<x,y>> \notin u.
IsOrder(v) => (<<y,z>> \in v => (<<y,y>> \in v /\ <<z,z>> \in v))   BECAUSE \A(x <- y, y <- z);
(IsOrder(v) /\ <<y,z>> \in v) => (<<y,y>> \in v /\ <<z,z>> \in v)   BECAUSE HypoImplToAnd;
(<<y,y>> \in v /\ <<z,z>> \in v) => <<y,y>> \in v   BECAUSE DropAndRight;
(IsOrder(v) /\ <<y,z>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,z>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => (<<x,y>> \notin v /\ <<y,z>> \notin v)  BECAUSE CombineImplicationsEnd;

<<y,z>> \in (u \union v) <=> (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in (u \union v) => (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE TI;

IsOrder(u) => (\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE DropAndBoth;
(\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)
   => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(u) => <<x,z>> \in u)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in u   BECAUSE HypoImplToAnd;
<<x,z>> \in u => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,z>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,z>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,z>> \notin u)   BECAUSE CombineImplicationsEnd;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE TI;
\A u : (<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE GENERALIZATION;
(<<x,y>> \in v /\ <<y,z>> \in v) => (IsOrder(v) => <<x,z>> \in v)   BECAUSE \A(u <- v);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(v) => <<x,z>> \in v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in v   BECAUSE HypoImplToAnd;
<<x,z>> \in v => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE CombineImplicationsStart;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE TI;
\A z : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;

(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))))   BECAUSE CombineImplicationsEnd;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))) /\ (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v)))   BECAUSE CombineImplicationsEnd;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v)   BECAUSE CombineImplicationsEnd;
disjointOrders   BECAUSE GENERALIZATION;
QED

\* Not only can two disjoint orders be united, then can also be glued together,
\* which will later define the addition of natural numbers.
disjointOrderAddition == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointOrderAddition
PROOF
VARIABLES a,b,c,g,i,j,o,p,u,v,x,y,z,part;
\* Proof that u \union v \union (Domain(u) \X Domain(v)) is a graph : union of 3 graphs
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
unionInc   BECAUSE THEOREM;
x \in woAdd(u,v) <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
cartesianProductExists   BECAUSE THEOREM;
x \in woAdd(u,v)
   => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
x \in (Domain(u) \X Domain(v)) <=> (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))
   BECAUSE \A(i <- Domain(u), j <- Domain(v), x <- x);
x \in (Domain(u) \X Domain(v)) => (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v)) => IsCouple(x)   BECAUSE DropAndRight2;
x \in (Domain(u) \X Domain(v)) => IsCouple(x)   BECAUSE TI;
IsOrder(u \union v) => IsGraph(u \union v)   BECAUSE DropAndRight3;
(\A x : x \in (u \union v) => IsCouple(x)) => (x \in (u \union v) => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u \union v) => (x \in (u \union v) => IsCouple(x))   BECAUSE TI;
mergeWithHypo(a,b,c,d) == (a => b) => ((c => (d => b)) => ((d \/ a) => (c => b)))   PROPO_TAUTO;
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE mergeWithHypo;
x \in woAdd(u,v) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE TI;
IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(u \union v) => IsGraph(woAdd(u,v))   BECAUSE Q_SCHEME;
disjointOrders   BECAUSE THEOREM;
IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v) => IsGraph(woAdd(u,v))   BECAUSE TI;

\* Proof that orderAddition is reflexive : <<x,y>> \in woAdd(u,v) => (x \in Domain(u) \/ x \in Domain(v))
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,y>>);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)
   BECAUSE EquivToImpl;
domainExists   BECAUSE THEOREM;
x \in Domain(u \union v) <=> IsDefinedOn(u \union v, x)   BECAUSE \A(g <- u \union v, x <- x);
(\E y : <<x,y>> \in u \union v) => x \in Domain(u \union v)   BECAUSE EquivToImplReverse;
<<x,y>> \in u \union v => (\E y : <<x,y>> \in u \union v)   BECAUSE \E(y <- y);
<<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE TI;
cartesianProductCouples   BECAUSE THEOREM;
x \in Domain(u) /\ y \in Domain(v) <=> <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u) /\ y \in Domain(v)   BECAUSE EquivToImplReverse;
x \in Domain(u) /\ y \in Domain(v) => x \in Domain(u)   BECAUSE DropAndRight;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
x \in Domain(u) => \E y : <<x,y>> \in u   BECAUSE EquivToImpl;
unionFirstInc   BECAUSE THEOREM;
<<x,y>> \in u => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in u) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(u) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(u) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in woAdd(u,v) => x \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) => IsOrder(u \union v)   BECAUSE ImplySelf;
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ x \in Domain(u \union v)   BECAUSE MergeImplicationsAnd;
orderDomainReflexive   BECAUSE THEOREM;
IsOrder(u \union v) /\ x \in Domain(u \union v) => <<x,x>> \in u \union v   BECAUSE \A(o <- u \union v, x <- x);
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
disjointOrders   BECAUSE THEOREM;
IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);

\* Proof that orderAddition is anti-symmetric : if both <<x,y>> and <<y,x>> are in the addition,
\* then they're in u \union v and not in the product glue

\* Proof that orderAddition is transitive : if <<x,y>> and <<y,z>> are in the addition,
\*    - <<x,y>> and <<y,z>> are is u \union v then <<x,z>> too be it's an order
\*    - else either <<x,y>> or <<y,z>> are in the product glue
<<y,z>> \in woAdd(u,v) <=> (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,z>>);
<<y,z>> \in woAdd(u,v) => (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))
   => (((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ <<y,z>> \in (u \union v))
        \/ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ <<y,z>> \in Domain(u) \X Domain(v)))
   BECAUSE DistribAndOrLeft;
<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)
   => (((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ <<y,z>> \in (u \union v))
        \/ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ <<y,z>> \in Domain(u) \X Domain(v)))
   BECAUSE TI;
\* Kill the double-glue case
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE DropAndLeft;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE GENERALIZATION;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE \A(x <- y, y <- z);
<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v)
   => y \in Domain(u) /\ y \in Domain(v)   BECAUSE MergeImplicationsAnd; \* Impossible, u and v are disjoint

QED

EmptyOrHasMinimum(part, order) == (part = {}) \/ (\E m : IsMinimum(m, part, order))

minOfTwoParts == \A o : \A a : \A b :
      (EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o)
        /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)
THEOREM minOfTwoParts
PROOF
VARIABLES a,b,m,o,x,y,z;
\* If a is not empty, then it has a minimum
ma(a,o) == CHOOSE m : IsMinimum(m, a, o);
killCase(a,b) == ((a \/ b) /\ ~a) => b   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ a # {}) => \E m : IsMinimum(m, a, o)   BECAUSE killCase;
(\E m : IsMinimum(m, a, o)) => IsMinimum(ma(a,o), a, o)   BECAUSE CHOOSE ma(a,o);
(EmptyOrHasMinimum(a,o) /\ a # {}) => IsMinimum(ma(a,o), a, o)   BECAUSE TI;

   \* ma(a,o) is below b
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)
   => ((ma(a,o) \in a /\ x \in b) => <<ma(a,o), x>> \in o)   BECAUSE \A(x <- ma(a,o), y <- x);
pullHypo(a,b,c,d) == (a => ((b /\ c) => d)) => ((a /\ b) => (c => d))   PROPO_TAUTO;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE pullHypo;
IsMinimum(ma(a,o), a, o) => ma(a,o) \in a   BECAUSE DropAndRight;
(EmptyOrHasMinimum(a,o) /\ a # {}) => ma(a,o) \in a   BECAUSE TI;
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) => (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)   BECAUSE ImplySelf;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)   BECAUSE MergeImplicationsAnd;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;

   \* ma(a,o) is the minimum of (a \union b)
IsMinimum(ma(a,o), a, o) => \A x : x \in a => <<ma(a,o),x>> \in o   BECAUSE DropAndLeft;
(\A x : x \in a => <<ma(a,o),x>> \in o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE \A(x <- x);
IsMinimum(ma(a,o), a, o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)) => EmptyOrHasMinimum(a,o)   BECAUSE DropAndRight;
a # {} => a # {}   BECAUSE ImplySelf;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (EmptyOrHasMinimum(a,o) /\ a # {})   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a, o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
shuffleHypos(a,b,c) == (b /\ a /\ c) => (a /\ (b /\ c))   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))    BECAUSE shuffleHypos;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))   BECAUSE CombineImplicationsEnd;
((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE TI;
unionInc   BECAUSE THEOREM;
x \in (a \union b) <=> (x \in a \/ x \in b)   BECAUSE \A(x <- a, y <- b, z <- x);
x \in (a \union b) => (x \in a \/ x \in b)   BECAUSE EquivToImpl;
((x \in a \/ x \in b) => <<ma(a,o),x>> \in o) => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
\A x : (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE GENERALIZATION;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (\A x : (x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE Q_SCHEME;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in a   BECAUSE TI;
unionFirstInc   BECAUSE THEOREM;
ma(a,o) \in a => ma(a,o) \in (a \union b)   BECAUSE \A(x <- a, y <- b, z <- ma(a,o)); 
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in (a \union b)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a \union b, o) BECAUSE CombineImplicationsEnd;
IsMinimum(ma(a,o), a \union b, o) => \E m : IsMinimum(m, a \union b, o)   BECAUSE \E(m <- ma(a,o));
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => \E m : IsMinimum(m, a \union b, o) BECAUSE TI;
(\E m : IsMinimum(m, a \union b, o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE IntroOrRight;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => EmptyOrHasMinimum(a \union b, o) BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE HypoAndToImpl;
addHypo(a,b,c) == (a /\ b /\ c) => (a /\ c)   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))   BECAUSE addHypo;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE TI;

\* If a is empty
emptyUnion   BECAUSE THEOREM;
{} \union b = b   BECAUSE \A(a <- b);
\A x : \A y : x = y => (x \union b = b <=> y \union b = b)   BECAUSE E_SCHEME;
a = {} => (a \union b = b <=> {} \union b = b)   BECAUSE \A(x <- a, y <- {});
a = {} => a \union b = b   BECAUSE ImplyEquivTrue;
\A x : \A y : x = y => (EmptyOrHasMinimum(x,o) <=> EmptyOrHasMinimum(y,o))   BECAUSE E_SCHEME;
a \union b = b => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE \A(x <- a \union b, y <- b);
a = {} => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE TI;
(a = {} /\ EmptyOrHasMinimum(b,o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE HypoEquivToAndReverse;
(EmptyOrHasMinimum(b,o) /\ a = {}) => (a = {} /\ EmptyOrHasMinimum(b,o))   BECAUSE AndSymmetry;
(EmptyOrHasMinimum(b,o) /\ a = {}) => EmptyOrHasMinimum(a \union b, o)   BECAUSE TI;
EmptyOrHasMinimum(b,o) => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE HypoAndToImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(b,o)   BECAUSE DropAndBoth;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;

(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))   BECAUSE CombineImplicationsEnd;
((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;
a = {} \/ a # {}   BECAUSE ExcludedMiddle;
(a = {} \/ a # {}) => ((EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o))   BECAUSE SwitchHypos;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)   BECAUSE MODUS_PONENS;
minOfTwoParts   BECAUSE GENERALIZATION;
QED


(*
   The class of well-orders, orders where each nonempty subset has a minimum.
   They allow to count :
      - in the well-order, take the minimum and call it zero
      - in the nonzero elements of the well-order, take the minimum and call it one
      - in the elements of the well-order that are neither zero nor one,
        take the minimum and call it two
      - iterate

   For this reason, some well-orders (the finite ones) define the natural numbers.
   The well-orders are stable under disjoint unions, which they call addition.
   They are also stable under cartesian products, which they call multiplication.
*)
IsWellOrder(w) == IsOrder(w) /\ (\A p : (p \subseteq Domain(w)) => EmptyOrHasMinimum(p, w))

injectWOIsWO == \A o : \A f : (IsWellOrder(o) /\ IsFunction(f)) => IsWellOrder(injectOrder(o,f))
THEOREM injectWOIsWO

disjointWOAddition == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v))
   => IsWellOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointWOAddition
PROOF
VARIABLES a,b,c,g,i,j,m,o,p,u,v,x,y,z,part;
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
disjointOrderAddition   BECAUSE THEOREM;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v \union (Domain(u) \X Domain(v)))
   BECAUSE \A(u <- u, v <- v);
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(u)   BECAUSE DropAndRight2;
IsWellOrder(u) => IsOrder(u)   BECAUSE DropAndRight;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(v)   BECAUSE DropAndBoth;
IsWellOrder(v) => IsOrder(v)   BECAUSE DropAndRight;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(v)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => AreDisjoint(u,v)   BECAUSE DropAndLeft;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE CombineImplicationsEnd;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   BECAUSE CombineImplicationsEnd;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(woAdd(u,v))   BECAUSE TI;

\* Proof that wellOrderAddition has all minimums
\* Prove part \subseteq Domain(woAdd(u,v)) => part = (part \intersect Domain(u)) \union (part \intersect Domain(v))
\* and call theorem minOfTwoParts with those two parts
domainExists   BECAUSE THEOREM;
z \in Domain(woAdd(u,v))
   <=> IsDefinedOn(woAdd(u,v),z)   BECAUSE \A(g <- woAdd(u,v), x <- z);
z \in Domain(woAdd(u,v))
   => \E y : <<z,y>> \in woAdd(u,v)   BECAUSE EquivToImpl;
unionInc   BECAUSE THEOREM;
<<z,y>> \in woAdd(u,v)
   <=> (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<z,y>>);
<<z,y>> \in woAdd(u,v)
   => (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
cartesianProductCouples   BECAUSE THEOREM;
(z \in Domain(u) /\ y \in Domain(v)) <=> <<z,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- z, b <- y);
<<z,y>> \in (Domain(u) \X Domain(v)) => (z \in Domain(u) /\ y \in Domain(v))   BECAUSE EquivToImplReverse;
(z \in Domain(u) /\ y \in Domain(v)) => z \in Domain(u)   BECAUSE DropAndRight;
<<z,y>> \in (Domain(u) \X Domain(v)) => z \in Domain(u)   BECAUSE TI;
<<z,y>> \in (u \union v) <=> (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<z,y>>);
<<z,y>> \in (u \union v) => (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE EquivToImpl;
domainInc   BECAUSE THEOREM;
<<z,y>> \in u => z \in Domain(u)   BECAUSE \A(g <- u, x <- z, y <- y);
<<z,y>> \in v => z \in Domain(v)   BECAUSE \A(g <- v, x <- z, y <- y);
(<<z,y>> \in u \/ <<z,y>> \in v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE MergeImplicationsOr;
<<z,y>> \in (u \union v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE MergeImplicationsOr;
<<z,y>> \in woAdd(u,v)
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE TI;
dropRedOr(a,z) == ((a \/ z) \/ a) => (a \/ z)   PROPO_TAUTO;
((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE dropRedOr;
<<z,y>> \in woAdd(u,v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(\E y : <<z,y>> \in woAdd(u,v)) => (\E y : z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : z \in Domain(u) \/ z \in Domain(v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : <<z,y>> \in woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in Domain(woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in (Domain(u) \union Domain(v)) <=> (z \in Domain(u) \/ z \in Domain(v))
   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- z);
(z \in Domain(u) \/ z \in Domain(v)) => z \in (Domain(u) \union Domain(v))   BECAUSE EquivToImplReverse;
z \in Domain(woAdd(u,v)) => z \in (Domain(u) \union Domain(v))   BECAUSE TI;
Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v))   BECAUSE GENERALIZATION;
transitInclusion   BECAUSE THEOREM;
(part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))
   => part \subseteq (Domain(u) \union Domain(v))   BECAUSE \A(a <- part, b <- Domain(woAdd(u,v)), c <- (Domain(u) \union Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))   BECAUSE IntroAndLeft;
part \subseteq Domain(woAdd(u,v)) => part \subseteq (Domain(u) \union Domain(v))   BECAUSE TI;
distribIntersectUnion   BECAUSE THEOREM;
(part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   BECAUSE \A(a <- part, b <- Domain(u), c <- Domain(v));
intersectSuper   BECAUSE THEOREM;
part \subseteq (Domain(u) \union Domain(v)) => (part \intersect (Domain(u) \union Domain(v))) = part
   BECAUSE \A(a <- part, b <- Domain(u) \union Domain(v));
part \subseteq Domain(woAdd(u,v)) => (part \intersect (Domain(u) \union Domain(v))) = part   BECAUSE TI;
((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE E_SCHEME;
(part \intersect (Domain(u) \union Domain(v))) = part => ((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v))))   BECAUSE IntroAndLeft;
(part \intersect (Domain(u) \union Domain(v))) = part => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq (Domain(u) \union Domain(v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq Domain(woAdd(u,v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;

IsWellOrder(u) => (\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))   BECAUSE DropAndLeft;
(\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE \A(p <- part \intersect Domain(u));
IsWellOrder(u)
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)
   => (IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE SwitchHypos;
intersectionExists   BECAUSE THEOREM;
z \in (part \intersect Domain(u)) <=> (z \in part /\ z \in Domain(u))   BECAUSE \A(u <- part, v <- Domain(u), x <- z);
z \in (part \intersect Domain(u)) => (z \in part /\ z \in Domain(u))   BECAUSE EquivToImpl;
(z \in part /\ z \in Domain(u)) => z \in Domain(u)   BECAUSE DropAndLeft;
z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)   BECAUSE GENERALIZATION;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE MODUS_PONENS;
\A u : IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE GENERALIZATION;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), v)   BECAUSE \A(u <- v);

\* Proof of EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))
IsMinimum(m, part \intersect Domain(u), u)
   => \A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u   BECAUSE DropAndLeft;
(\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in u   BECAUSE HypoImplToAnd;
x \in woAdd(u,v)
   <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => x \in woAdd(u,v)   BECAUSE EquivToImplReverse;
x \in (u \union v) => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
x \in (u \union v) => x \in woAdd(u,v)   BECAUSE TI;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
(x \in u \/ x \in v) => x \in (u \union v)   BECAUSE EquivToImplReverse;
x \in u => (x \in u \/ x \in v)   BECAUSE IntroOrLeft;
x \in u => x \in (u \union v)   BECAUSE TI;
x \in u => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in u => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in u => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(u), u) => (\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(u), u) => m \in (part \intersect Domain(u))   BECAUSE DropAndRight;
IsMinimum(m, part \intersect Domain(u), u) => IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE CombineImplicationsEnd;
(\E m : IsMinimum(m, part \intersect Domain(u), u)) => \E m : IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(u) = {}) => (part \intersect Domain(u) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE TI;

IsMinimum(m, part \intersect Domain(v), v)
   => \A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v   BECAUSE DropAndLeft;
(\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in v   BECAUSE HypoImplToAnd;
x \in v => (x \in u \/ x \in v)   BECAUSE IntroOrRight;
x \in v => x \in (u \union v)   BECAUSE TI;
x \in v => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in v => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in v => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(v), v) => (\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(v), v) => m \in (part \intersect Domain(v))   BECAUSE DropAndRight;
IsMinimum(m, part \intersect Domain(v), v) => IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE CombineImplicationsEnd;
(\E m : IsMinimum(m, part \intersect Domain(v), v)) => \E m : IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(v) = {}) => (part \intersect Domain(v) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(v), v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE TI;

\* Domination of first part by second part
\A u : \A z : z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE GENERALIZATION;
x \in (part \intersect Domain(u)) => x \in Domain(u)   BECAUSE \A(u <- u, z <- x);
y \in (part \intersect Domain(v)) => y \in Domain(v)   BECAUSE \A(u <- v, z <- y);
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => (x \in Domain(u) /\ y \in Domain(v))   BECAUSE MergeImplicationsAnd;
(x \in Domain(u) /\ y \in Domain(v)) <=> <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
(x \in Domain(u) /\ y \in Domain(v)) => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE TI;
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,y>>);
(<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v))) => <<x,y>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,y>> \in (Domain(u) \X Domain(v)) => (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,y>> \in (Domain(u) \X Domain(v)) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE GENERALIZATION;

minOfTwoParts   BECAUSE THEOREM;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))
    /\ (\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)))
   => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))
   BECAUSE \A(o <- woAdd(u,v), a <- part \intersect Domain(u), b <- part \intersect Domain(v));
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE IntroAndLeft;
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))   BECAUSE TI;
\A a : \A b : a = b => (EmptyOrHasMinimum(a, woAdd(u,v)) <=> EmptyOrHasMinimum(b, woAdd(u,v)))   BECAUSE E_SCHEME;
part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))
   BECAUSE \A(a <- part, b <- (part \intersect Domain(u)) \union (part \intersect Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE TI;
(part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE HypoEquivToAndReverse;
part \subseteq Domain(woAdd(u,v)) => part \subseteq Domain(woAdd(u,v))   BECAUSE ImplySelf;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => (part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => (part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v)))   BECAUSE AndSymmetry;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE HypoAndToImpl;
\A part : (IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE \A(part <- p);
\A p : (IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE Q_SCHEME;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsWellOrder(u) /\ IsWellOrder(v))   BECAUSE DropAndRight;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(woAdd(u,v))   BECAUSE CombineImplicationsEnd;
disjointWOAddition   BECAUSE GENERALIZATION;
QED

pasteTags(dom, tag) == productFunc(identity(dom), const(dom, tag))

\* Define a well-order on the disjoint union of two well-orders.
\* This order simply pastes v after u.
wellOrderAddition(u,v) == injectOrder(u, pasteTags(Domain(u),{}))
   \union injectOrder(v, pasteTags(Domain(v),ordinalOne))
   \union ((Domain(u)\X{{}}) \X (Domain(v)\X{ordinalOne})) \* this puts v after u

woAddIsWo == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v)) => IsWellOrder(wellOrderAddition(u,v))
THEOREM woAddIsWo
PROOF
VARIABLES a,b,c,d,f,i,j,g,o,u,v,x,y,z,tag;
\* Give shorter names
Ione(u) == injectOrder(u, pasteTags(Domain(u),{}));
Itwo(v) == injectOrder(v, pasteTags(Domain(v),ordinalOne));
DO(u,v) == Ione(u) \union Itwo(v);

\* Proof that DO is an order
productFuncIsFunc   BECAUSE THEOREM;
(IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y)))
   => IsFunction(pasteTags(Domain(u),y))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),y));
identityInject   BECAUSE THEOREM;
IsInjection(identity(Domain(u)))   BECAUSE \A(d <- Domain(u));
IsFunction(identity(Domain(u)))   BECAUSE DropAndRight;
constFunc   BECAUSE THEOREM;
IsFunction(const(Domain(u),y))   BECAUSE \A(d <- Domain(u), c <- y);
IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y))   BECAUSE IntroAndRight;
IsFunction(pasteTags(Domain(u),y))   BECAUSE MODUS_PONENS;
injectOrderIsOrder   BECAUSE THEOREM;
(IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))
   => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),y));
IsOrder(u) => (IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))   BECAUSE IntroAndLeft;
IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE TI;
\A u : \A y : IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE GENERALIZATION;
IsOrder(u) => IsOrder(Ione(u))   BECAUSE \A(u <- u, y <- {});
IsOrder(v) => IsOrder(Itwo(v))   BECAUSE \A(u <- v, y <- ordinalOne);
	   \* Proof that AreDisjoint(Ione(u),Itwo(v))
disjointOrders   BECAUSE THEOREM;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u),Itwo(v)))
   => IsOrder(Ione(u) \union Itwo(v))   BECAUSE \A(u <- Ione(u), v <- Itwo(v));
noCommonElements   BECAUSE THEOREM;
AreDisjoint(Ione(u),Itwo(v)) <=> \A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE \A(x <- Ione(u), y <- Itwo(v));
(\A z : ~(z \in Ione(u) /\ z \in Itwo(v))) => AreDisjoint(Ione(u),Itwo(v))   BECAUSE EquivToImplReverse;
injectOrderExists   BECAUSE THEOREM;
z \in Ione(u) <=> IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),{}), x <- z);
z \in Itwo(v) <=> IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE \A(o <- v, f <- pasteTags(Domain(v),ordinalOne), x <- z);
IsInInjectOrder(u,pasteTags(Domain(u),tag),z)
   => z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag)))   BECAUSE DropAndRight;
cartesianProductExists   BECAUSE THEOREM;
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) <=> (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))
   BECAUSE \A(i <- Image(pasteTags(Domain(u),tag)), j <- Image(pasteTags(Domain(u),tag)), x <- z);
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE EquivToImpl;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE TI;
(IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag))) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE DropAndLeft;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE TI;
productFuncVal   BECAUSE THEOREM;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => (IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),tag), x <- x, y <- snd(z));
(IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag)) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE DropAndLeft;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
imageExists   BECAUSE THEOREM;
snd(z) \in Image(pasteTags(Domain(u),tag)) <=> Reaches(pasteTags(Domain(u),tag),snd(z))   BECAUSE \A(g <- pasteTags(Domain(u),tag), y <- snd(z));
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)   BECAUSE EquivToImpl;
(\E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE Q_SCHEME;
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
constExists   BECAUSE THEOREM;
<<x,snd(snd(z))>> \in const(Domain(u),tag) <=> (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE \A(d <- Domain(u), c <- tag, x <- <<x,snd(snd(z))>>);
<<x,snd(snd(z))>> \in const(Domain(u),tag) => (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE EquivToImpl;
(IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)
   => snd(<<x,snd(snd(z))>>) = tag   BECAUSE DropAndLeft;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => snd(<<x,snd(snd(z))>>) = tag   BECAUSE TI;
sndExists   BECAUSE THEOREM;
snd(snd(z)) = snd(<<x,snd(snd(z))>>)   BECAUSE \A(a <- x, b <- snd(snd(z)));
snd(<<x,snd(snd(z))>>) = tag => tag = snd(<<x,snd(snd(z))>>)   BECAUSE E_SCHEME;
(tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>)) => tag = snd(snd(z))  BECAUSE E_SCHEME;
tag = snd(<<x,snd(snd(z))>>) => (tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>))   BECAUSE IntroAndLeft;
tag = snd(<<x,snd(snd(z))>>) => tag = snd(snd(z))  BECAUSE TI;
snd(<<x,snd(snd(z))>>) = tag => tag = snd(snd(z))  BECAUSE TI;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => tag = snd(snd(z))  BECAUSE TI;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => \E x : tag = snd(snd(z))  BECAUSE Q_SCHEME;
(\E x : tag = snd(snd(z))) => tag = snd(snd(z))   BECAUSE Q_SCHEME;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => tag = snd(snd(z))   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE TI;
\A u : \A tag : IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE GENERALIZATION;
IsInInjectOrder(u,pasteTags(Domain(u),{}),z) => {} = snd(snd(z))   BECAUSE \A(u <- u, tag <- {});
IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z) => ordinalOne = snd(snd(z))   BECAUSE \A(u <- v, tag <- ordinalOne);
z \in Ione(u) => IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE EquivToImpl;
z \in Ione(u) => {} = snd(snd(z))   BECAUSE TI;
z \in Itwo(v) => IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE EquivToImpl;
z \in Itwo(v) => ordinalOne = snd(snd(z))   BECAUSE TI;

(z \in Ione(u) /\ z \in Itwo(v)) => ({} = snd(snd(z)) /\ ordinalOne = snd(snd(z)))   BECAUSE MergeImplicationsAnd;
({} = snd(snd(z)) /\ ordinalOne = snd(snd(z))) => {} = ordinalOne   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => {} = ordinalOne   BECAUSE TI;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => ordinalOne = {}   BECAUSE TI;
ordinalOne # {} => ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE Contraposition;
oneIsNotZero   BECAUSE THEOREM;
~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE MODUS_PONENS;
\A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE GENERALIZATION;
AreDisjoint(Ione(u),Itwo(v))   BECAUSE MODUS_PONENS;
(IsOrder(u) /\ IsOrder(v)) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)))   BECAUSE MergeImplicationsAnd;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u), Itwo(v)))   BECAUSE IntroAndLeft;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => IsOrder(Ione(u) \union Itwo(v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(DO(u,v))   BECAUSE TI;

QED


(*
   At the moment, the addition and multiplication of well-orders are not commutative,
   even for finite ones. wellOrderAddition(u,v) and wellOrderAddition(v,u) are
   isomorphic as well-orders, but not equal.

   It would be convenient to fix one representative in each well-order isomorphy
   class, so that addition and multiplication get their usual properties. The
   ordinals achieve that, they find canonical elements for the well-orders' domains.
*)
TransitiveSet(x) == \A a : a \in x => a \subseteq x

(*
   Predicate asserting that the set x is strictly well-ordered by the membership
   relation \in. In those sets, \in behaves like < on the natural numbers. Actually,
   those sets start with the natural numbers and \in will be the definition of <.
*)
WellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ (\A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c) \* transitive
   /\ (\A p : (p # {} /\ p \subseteq x) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)) \* existence of minimums

(*
   The class of ordinals, which starts with the natural numbers. This predicate
   rigorously defines what could be naively stated as
      0 = {}
      n = { 0, ..., n-1 }
*)
IsOrdinal(o) == TransitiveSet(o) /\ WellOrderedByIn(o)

\* The empty set is the smallest ordinal, called "zero" as an ordinal
ordinalZero == IsOrdinal( {} )
THEOREM ordinalZero
PROOF
\* Just check implications starting with the false formula x \in {}
VARIABLES a,b,c,p,x;
\* Proof of TransitiveSet( {} )
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
a \in {} => a \subseteq {}   BECAUSE Explosion;
TransitiveSet( {} )   BECAUSE GENERALIZATION;

\* Proof of irreflexive
a \in {} => a \notin a   BECAUSE Explosion;
\A a : a \in {} => a \notin a   BECAUSE GENERALIZATION;

\* Proof of transitive order
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c)
   => (a \in {} /\ b \in {} /\ c \in {})   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {}) => a \in {}   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in {}   BECAUSE TI;
a \in {} => a \in c   BECAUSE Explosion;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE TI;
\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE GENERALIZATION;

\* Proof of minimums
includedInEmpty   BECAUSE THEOREM;
p \subseteq {} => p = {}   BECAUSE \A(x <- p);
(p \subseteq {} => p = {}) <=> (~(p \subseteq {}) \/ p = {})   BECAUSE BooleanImplication;
~(p \subseteq {}) \/ p = {}   BECAUSE MODUS_PONENS;
p = {} \/ ~(p \subseteq {})   BECAUSE OrSymmetry;
~~(p = {} \/ ~(p \subseteq {}))   BECAUSE IntroNotNot;
~(p = {} \/ ~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE Explosion;
~(p = {} \/ ~(p \subseteq {})) <=> (p # {} /\ ~~(p \subseteq {}))   BECAUSE DistribNotOr;
(p # {} /\ ~~(p \subseteq {})) => ~(p = {} \/ ~(p \subseteq {}))   BECAUSE EquivToImplReverse;
(p # {} /\ ~~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TI;
p \subseteq {} => ~~(p \subseteq {})   BECAUSE IntroNotNot;
p # {} => p # {}   BECAUSE ImplySelf;
(p # {} /\ p \subseteq {}) => (p # {} /\ ~~(p \subseteq {}))   BECAUSE MergeImplicationsAnd;
(p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TI;
\A p : (p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE GENERALIZATION;

\* Conclude with PT6
(\A a : a \in {} => a \notin a)
   /\ (\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c)   BECAUSE IntroAndRight;
WellOrderedByIn( {} )   BECAUSE IntroAndRight;
ordinalZero   BECAUSE IntroAndRight;
QED

\* The +1 operation on ordinals
successor(o) == o \union { o }

ordinalSuccessorStable == \A o : IsOrdinal(o) => IsOrdinal( successor(o) )
THEOREM ordinalSuccessorStable

IsLimitOrdinal(o) == IsOrdinal(o) /\ o # {} /\ \A x : x \in o => o # successor(x)

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE o : IsLimitOrdinal(o) /\ \A x : x \in o => ~IsLimitOrdinal(x)
naturalNumbersExist == IsLimitOrdinal(Nat) /\ \A x : x \in Nat => ~IsLimitOrdinal(x)
THEOREM naturalNumbersExist

(*
   The addition function on natural numbers. It could be declared as an operator
   natAddition(x,y) == CHOOSE z : ...
   however it would be recursive (or use well-orders). Keep it a simple function here.
*)
natAddition == CHOOSE f : IsFunction(f)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in f) \* f : Nat \X Nat -> Nat
   /\ (\A x : x \in Nat => << <<x,{}>>, x >> \in f) \* f(x,0) = x
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : << <<x,y>>, u >> \in f /\ << <<x,successor(y)>>, successor(u) >> \in f) \* f(x,y+1) = f(x,y)+1

natAdditionExists == IsFunction(natAddition)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in natAddition)
   /\ (\A x : x \in Nat => << <<x,{}>>, x >> \in natAddition)
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : << <<x,y>>, u >> \in natAddition /\ << <<x,successor(y)>>, successor(u) >> \in natAddition)

THEOREM natAdditionExists

(*
   The multiplication function on natural numbers.
*)
natMultiplication == CHOOSE f : IsFunction(f)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in f) \* f : Nat \X Nat -> Nat
   /\ (\A x : x \in Nat => << <<x,{}>>, {} >> \in f) \* f(x,0) = 0
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : \E v : << <<x,y>>, u >> \in f /\ << <<x,successor(y)>>, v>> \in f
	                  /\ << <<u,x>>, v >> \in natAddition) \* u=f(x,y) and v=f(x,y+1) and v=u+x, ie f(x,y+1) = f(x,y)+x

natMultiplicationExists == IsFunction(natMultiplication)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in natMultiplication)
   /\ (\A x : x \in Nat => << <<x,{}>>, {} >> \in natMultiplication)
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : \E v : << <<x,y>>, u >> \in natMultiplication /\ << <<x,successor(y)>>, v>> \in natMultiplication /\ << <<u,x>>, v >> \in natAddition)

THEOREM natMultiplicationExists