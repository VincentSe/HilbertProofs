(*
   The elements of a ZFC set are not ordered. There is only one set
   with elements x and y : { x, y } = { y, x }. Likewise with any
   number of elements, by the axiom of extensionality the set is
   the same, independently of the order in which its elements were
   listed.

   Couples introduce an order between two elements, because <<x,y>>
   and <<y,x>> are different. Here we discuss the more general
   structure of order, that applies to a set with any number of
   elements.

   Order is fundamental for numbers. When we measure things with
   numbers, we're often only interested in the order the numbers
   place on the things : which are bigger, faster, stronger, ...
   The geometry of the real numbers comes from their order, which
   tells when a point on a line lies between two other points.
   Deeper still, orders are the very definition of natural numbers :
   they are the finite well-orders. We will see that addition and
   multiplication, often introduced at school for natural numbers,
   are actually operations on orders.

   Orders also serve for optimization. In the dictionary, the
   alphabetical order allows to find any word among more than
   100 000 words in a few seconds. This is true for any collection
   of objects, in a book, house, factory or even human society :
   when ordered, the objects are much faster to find and easier
   to manipulate.
*)

EXTENDS Functions

IsOrder(o) == IsGraph(o)
   \* Reflexivity
   /\ (\A x : \A y : (<<x,y>> \in o) => (<<x,x>> \in o /\ <<y,y>> \in o))
   \* transitivity
   /\ (\A x : \A y : \A z : ((<<x,y>> \in o) /\ (<<y,z>> \in o)) => (<<x,z>> \in o))
   \* anti-symmetry
   /\ (\A x : \A y : ((<<x,y>> \in o) /\ (<<y,x>> \in o)) => x = y)

\* Because f[x] is a CHOOSE, this only allows functions which domains
\* contain Domain(u)
IsIncreasing(f, u, v) == \A x : \A y : (<<x,y>> \in u) => (<<f[x], f[y]>> \in v)

IsMinimum(m, part, order) == (m \in part) /\ \A x : (x \in part) => <<m,x>> \in order

\* Usually reflexivity is rather stated in terms of the domain :
orderDomainReflexive == \A o : \A x : IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o
THEOREM orderDomainReflexive
PROOF
VARIABLES g,o,x,y;
h(o,x) == IsOrder(o) /\ x \in Domain(o);
h(o,x) => IsOrder(o)   BECAUSE S12;
h(o,x) => x \in Domain(o)   BECAUSE S22;
domainExists   BECAUSE THEOREM;
x \in Domain(o) <=> IsDefinedOn(o,x)   BECAUSE \A(g <- o, x <- x);
x \in Domain(o) => IsDefinedOn(o,x)   BECAUSE EquivToImpl;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE S24;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE \A(x <- x, y <- y);
h(o,x) => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI2;
h(o,x) /\ <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE HypoImplToAnd;
(<<x,x>> \in o /\ <<y,y>> \in o) => <<x,x>> \in o   BECAUSE S12;
h(o,x) /\ <<x,y>> \in o => <<x,x>> \in o   BECAUSE TI;
h(o,x) => (<<x,y>> \in o => <<x,x>> \in o)   BECAUSE HypoAndToImpl;
\A y : h(o,x) => (<<x,y>> \in o => <<x,x>> \in o)   BECAUSE GENERALIZATION;
h(o,x) => (\A y : <<x,y>> \in o => <<x,x>> \in o)   BECAUSE Q_SCHEME;
(\A y : <<x,y>> \in o => <<x,x>> \in o)
   => (IsDefinedOn(o,x) => \E y : <<x,x>> \in o)   BECAUSE Q_SCHEME;
h(o,x) => (IsDefinedOn(o,x) => \E y : <<x,x>> \in o)   BECAUSE TI;
h(o,x) => IsDefinedOn(o,x)   BECAUSE TI;
h(o,x) => \E y : <<x,x>> \in o   BECAUSE KillMiddleHypo;
(\E y : <<x,x>> \in o) => <<x,x>> \in o   BECAUSE Q_SCHEME;
h(o,x) => <<x,x>> \in o   BECAUSE TI;
orderDomainReflexive   BECAUSE GENERALIZATION;
QED

\* An injection f transports an order o
IsInInjectOrder(o,f,x) == x \in (Image(f) \X Image(f)) /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o
injectOrder(o,f) == CHOOSE b : \A x : x \in b <=> IsInInjectOrder(o,f,x)

injectOrderExists == \A o : \A f : \A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)
THEOREM injectOrderExists
PROOF
\* By separation in Image(f) \X Image(f)
VARIABLES a,b,c,f,o,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> IsInInjectOrder(o,f,x)   BECAUSE \A(a <- Image(f) \X Image(f));
\A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE CHOOSE injectOrder(o,f);
injectOrderExists   BECAUSE GENERALIZATION;
QED

doubleEquiv(a,b,c,d) == (a <=> b) => ((c <=> d) => ((a /\ c) <=> (b /\ d)))   PROPO_TAUTO doubleEquiv

injectOrderCouples == \A o : \A f : \A x : \A y : <<x,y>> \in injectOrder(o,f) <=>
   (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
THEOREM injectOrderCouples
PROOF
VARIABLES a,b,f,o,x,y;
injectOrderExists   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE \A(o <- o, f <- f, x <- <<x,y>>);
cartesianProductCouples   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f)) <=> <<x,y>> \in (Image(f) \X Image(f))
   BECAUSE \A(x <- Image(f), y <- Image(f), a <- x, b <- y);
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
\A x : \A a : \A y : \A b : (x = a /\ y = b)
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,a), pre(f,b)>> \in o)   BECAUSE E_SCHEME;
(x = fst(<<x,y>>) /\ y = snd(<<x,y>>))
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o)
   BECAUSE \A(x <- x, a <- fst(<<x,y>>), y <- y, b <- snd(<<x,y>>));
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o   BECAUSE MODUS_PONENS;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE doubleEquiv;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> <<x,y>> \in injectOrder(o,f)   BECAUSE TransitEquiv2;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivSymmetry;
injectOrderCouples   BECAUSE GENERALIZATION;
QED

injectOrderIsOrder == \A o : \A f : (IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))
THEOREM injectOrderIsOrder
PROOF
VARIABLES a,b,d,f,g,i,j,o,x,y,z;
\* Proof that injectOrder(o,f) is a graph
injectOrderExists   BECAUSE THEOREM;
x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE \A(o <- o, f <- f, x <- x);
x \in injectOrder(o,f) => IsInInjectOrder(o,f,x)   BECAUSE EquivToImpl;
IsInInjectOrder(o,f,x) => x \in (Image(f) \X Image(f))   BECAUSE S12;
cartesianProductExists   BECAUSE THEOREM;
x \in (Image(f) \X Image(f)) <=> (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))
   BECAUSE \A(i <- Image(f), j <- Image(f), x <- x);
x \in (Image(f) \X Image(f)) => (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f)) => IsCouple(x)   BECAUSE S13;
x \in (Image(f) \X Image(f)) => IsCouple(x)   BECAUSE TI;
IsInInjectOrder(o,f,x) => IsCouple(x)   BECAUSE TI;
x \in injectOrder(o,f) => IsCouple(x)   BECAUSE TI;
IsGraph(injectOrder(o,f))   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => IsGraph(injectOrder(o,f))   BECAUSE PT1;

\* Proof that injectOrder(o,f) is reflexive
IsOrder(o) => (IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))   BECAUSE S13;
(IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE S22;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))   BECAUSE TI;
(IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE HypoImplToAnd;
injectOrderCouples   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- y);
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivToImpl;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE S22;
<<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE TI;
IsOrder(o) => IsOrder(o)   BECAUSE ImplySelf;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE MergeImplicationsAnd;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE TI;

   \* Lemma : \A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>>) \in o => <<d,d>> \in injectOrder
<<d,d>> \in injectOrder(o,f) <=> (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- d, y <- d);
d \in Image(f) => (d \in Image(f) /\ d \in Image(f))   BECAUSE AndSelf;
<<pre(f,d), pre(f,d)>> \in o => <<pre(f,d), pre(f,d)>> \in o   BECAUSE ImplySelf;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE MergeImplicationsAnd;
(d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE TI;
\A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;

   \* <<x, x>>
(x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o) => <<x,x>> \in injectOrder(o,f)
   BECAUSE \A(d <- x);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => x \in Image(f)   BECAUSE S13;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE S12;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE S22;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => x \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o)
   BECAUSE CIA;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,x>> \in injectOrder(o,f)   BECAUSE TI;

   \* <<y, y>>
(y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o) => <<y,y>> \in injectOrder(o,f)
   BECAUSE \A(d <- y);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => y \in Image(f)   BECAUSE S23;
<<x,y>> \in injectOrder(o,f) => y \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE S22;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE S22;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => y \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o)
   BECAUSE CIA;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<y,y>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))
   BECAUSE CIA;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE HypoAndToImpl;
\A y : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(o)   BECAUSE S12;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;

\* Proof that injectOrder(o,f) is anti-symmetric
\A x : \A y: <<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE GENERALIZATION;
<<y,x>> \in injectOrder(o,f) => <<pre(f,y), pre(f,x)>> \in o   BECAUSE \A(x <- y, y <- x);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)   BECAUSE S22;
(\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => pre(f,x) = pre(f,y)   BECAUSE HypoImplToAnd;

(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,y>> \in injectOrder(o,f)   BECAUSE S13;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => (x \in Image(f) /\ y \in Image(f))   BECAUSE S12;
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))   BECAUSE CIA;
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))   BECAUSE MergeImplicationsAnd;
funcUniqueImage   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE \A(f <- f, x <- x, y <- y);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f)) => x = y   BECAUSE TI;
massageHypos(a,b,c,d) == ((c /\ d) /\ (a /\ b)) => (a /\ b /\ c /\ d)   PROPO_TAUTO;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)))
   => (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))   BECAUSE massageHypos;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))) => x = y   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE HypoAndToImpl;
\A y: (IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that injectOrder(o,f) is transitive
<<y,z>> \in injectOrder(o,f) => <<pre(f,y), pre(f,z)>> \in o   BECAUSE \A(x <- y, y <- z);
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)   BECAUSE S23;
(\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE \A(x <- pre(f,x), y <- pre(f,y), z <- pre(f,z));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<pre(f,x), pre(f,z)>> \in o
   BECAUSE HypoImplToAnd;
\A x : \A y : <<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE GENERALIZATION;
<<y,z>> \in injectOrder(o,f) => (y \in Image(f) /\ z \in Image(f))   BECAUSE \A(x <- y, y <- z);
(y \in Image(f) /\ z \in Image(f)) => z \in Image(f)   BECAUSE S22;
<<y,z>> \in injectOrder(o,f) => z \in Image(f)   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f)) => x \in Image(f)   BECAUSE S12;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE MergeImplicationsAnd;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))   BECAUSE S12;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)   BECAUSE CIA;
<<x,z>> \in injectOrder(o,f) <=> (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- z);
(x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o) => <<x,z>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<x,z>> \in injectOrder(o,f))   BECAUSE HypoAndToImpl;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE SwitchHypos;
\A z : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE GENERALIZATION;
IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A y : IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))))   BECAUSE CIA;
(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))) /\ (\A x : \A y : \A z : (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => <<x,z>> \in injectOrder(o,f)))   BECAUSE CIA;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))   BECAUSE CIA;
injectOrderIsOrder   BECAUSE GENERALIZATION;
QED

\* When two orders have disjoint domains, their union is an order
disjointOrders == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v)
THEOREM disjointOrders
PROOF
\* Proof that disjointOrders is a graph
VARIABLES g,u,v,x,y,z;
unionInc   BECAUSE THEOREM;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
x \in (u \union v) => (x \in u \/ x \in v)   BECAUSE EquivToImpl;
IsOrder(u) => IsGraph(u)   BECAUSE S14;
IsGraph(u) => (x \in u => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u) => (x \in u => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE S12;
(IsOrder(u) /\ IsOrder(v)) => (x \in u => IsCouple(x))   BECAUSE TI;
x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
\A u : x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(v) => IsGraph(v)   BECAUSE S14;
IsGraph(v) => (x \in v => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(v) => (x \in v => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE S22;
(IsOrder(u) /\ IsOrder(v)) => (x \in v => IsCouple(x))   BECAUSE TI;
x \in v => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
(x \in u \/ x \in v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE CombineImplicationsStart;
x \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : (IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => IsGraph(u \union v)   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE S12;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsGraph(u \union v)   BECAUSE TI;

\* Proof that u \union v is reflexive.
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
selectSecond(a,b,c,d) == (a /\ b /\ c /\ d) => b   PROPO_TAUTO;
IsOrder(u) => (\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE selectSecond;
(\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE S12;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)   BECAUSE HypoImplToAnd;
unionFirstInc   BECAUSE THEOREM;
<<x,x>> \in u => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in u => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in u /\ <<y,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
\A u : IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(u <- v);
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE S22;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
unionSecondInc   BECAUSE THEOREM;
<<x,x>> \in v => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in v => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in v /\ <<y,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE CombineImplicationsStart;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => ((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   BECAUSE DistribAndOrLeft;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE HypoAndToImpl;
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in u \/ <<x,y>> \in v)
   => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE SwitchHypos;
<<x,y>> \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE SwitchHypos;
\A y : (IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;

\* Proof that u \union v is anti-symmetric
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
implyNotAnd(a,b,c) == (a => ~(b /\ c)) => ((a /\ b) => ~c)   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => <<y,y>> \notin v   BECAUSE implyNotAnd;

(<<x,x>> \in v /\ <<y,y>> \in v) => <<y,y>> \in v   BECAUSE S22;
(IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<x,y>> \in v) => <<y,y>> \in v   BECAUSE TI;
andContrapos(a,b,c) == ((a /\ b) => c) => (~c => (a => ~b))   PROPO_TAUTO;
<<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;

\A x : \A y : IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<y,x>> \in v => (<<y,y>> \in v /\ <<x,x>> \in v))   BECAUSE \A(x <- y, y <- x);
(<<y,y>> \in v /\ <<x,x>> \in v) => <<y,y>> \in v   BECAUSE S12;
(IsOrder(v) /\ <<y,x>> \in v) => (<<y,y>> \in v /\ <<x,x>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<y,x>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,x>> \notin v   BECAUSE HypoImplToAnd;

<<y,x>> \in (u \union v) <=> (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in (u \union v) => (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v)   BECAUSE CIA;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCases(a,b,c,d) == (~a /\ ~b /\ ((c \/ a) /\ (d \/ b))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE TI;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE S22;
(\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,x>> \in u) => (IsOrder(u) => x = y)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(u) => x = y)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(u))
   => x = y   BECAUSE HypoImplToAnd;
flipLast(a,b,c,d) == ((a /\ b /\ c) => d) => ((a /\ c) => (b => d))   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<x,y>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<x,y>> \notin u   BECAUSE HypoImplToAnd;
\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,x>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,x>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,x>> \notin u)   BECAUSE CIA;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCasesRight(a,b,c,d) == (~a /\ ~b /\ ((a \/ c) /\ (b \/ d))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE TI;
\A u : IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE GENERALIZATION;
IsOrder(v) => ((<<x,y>> \in v /\ <<y,x>> \in v) => x = y)   BECAUSE \A(u <- v);
(<<x,y>> \in v /\ <<y,x>> \in v) => (IsOrder(v) => x = y)   BECAUSE SwitchHypos;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(v) => x = y)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(v))
   => x = y   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)
   BECAUSE CombineImplicationsStart;
exclMid(a,b,c,d) == (a /\ b /\ c) => ((c /\ d /\ b /\ a) \/ (~d /\ a /\ b))   PROPO_TAUTO;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   BECAUSE exclMid;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE TI;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that u \union v is transitive.
\* If <<y,y>> \in u, because u and v are disjoint, <<y,y>> \notin v and then by reflexivity of v,
\* <<y,z>> \notin v and <<x,y>> \notin v. Else <<y,y>> \notin u, then by reflexivity of u,
\* <<y,z>> \notin u and <<x,y>> \notin u.
IsOrder(v) => (<<y,z>> \in v => (<<y,y>> \in v /\ <<z,z>> \in v))   BECAUSE \A(x <- y, y <- z);
(IsOrder(v) /\ <<y,z>> \in v) => (<<y,y>> \in v /\ <<z,z>> \in v)   BECAUSE HypoImplToAnd;
(<<y,y>> \in v /\ <<z,z>> \in v) => <<y,y>> \in v   BECAUSE S12;
(IsOrder(v) /\ <<y,z>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,z>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => (<<x,y>> \notin v /\ <<y,z>> \notin v)  BECAUSE CIA;

<<y,z>> \in (u \union v) <=> (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in (u \union v) => (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE TI;

IsOrder(u) => (\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE S23;
(\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)
   => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(u) => <<x,z>> \in u)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in u   BECAUSE HypoImplToAnd;
<<x,z>> \in u => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,z>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,z>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,z>> \notin u)   BECAUSE CIA;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE TI;
\A u : (<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE GENERALIZATION;
(<<x,y>> \in v /\ <<y,z>> \in v) => (IsOrder(v) => <<x,z>> \in v)   BECAUSE \A(u <- v);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(v) => <<x,z>> \in v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in v   BECAUSE HypoImplToAnd;
<<x,z>> \in v => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE CombineImplicationsStart;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE TI;
\A z : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;

(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))))   BECAUSE CIA;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))) /\ (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v)))   BECAUSE CIA;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v)   BECAUSE CIA;
disjointOrders   BECAUSE GENERALIZATION;
QED

(*
   Not only can two disjoint orders be united, then can also be glued together,
   the second coming completely after then first, which defines their addition.

   On natural numbers (finite well-orders, see below), this is the usual addition.
*)
disjointOrderAddition == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointOrderAddition
PROOF
VARIABLES a,b,c,g,i,j,o,p,u,v,x,y,z,part;
\* Proof that u \union v \union (Domain(u) \X Domain(v)) is a graph : union of 3 graphs
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
h(u,v) == IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v); \* The hypothesis
unionInc   BECAUSE THEOREM;
x \in woAdd(u,v) <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
cartesianProductExists   BECAUSE THEOREM;
x \in woAdd(u,v)
   => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
x \in (Domain(u) \X Domain(v)) <=> (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))
   BECAUSE \A(i <- Domain(u), j <- Domain(v), x <- x);
x \in (Domain(u) \X Domain(v)) => (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v)) => IsCouple(x)   BECAUSE S13;
x \in (Domain(u) \X Domain(v)) => IsCouple(x)   BECAUSE TI;
IsOrder(u \union v) => IsGraph(u \union v)   BECAUSE S14;
(\A x : x \in (u \union v) => IsCouple(x)) => (x \in (u \union v) => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u \union v) => (x \in (u \union v) => IsCouple(x))   BECAUSE TI;
mergeWithHypo(a,b,c,d) == (a => b) => ((c => (d => b)) => ((d \/ a) => (c => b)))   PROPO_TAUTO;
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE mergeWithHypo;
x \in woAdd(u,v) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE TI;
IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(u \union v) => IsGraph(woAdd(u,v))   BECAUSE Q_SCHEME;
disjointOrders   BECAUSE THEOREM;
IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
h(u,v) => IsGraph(woAdd(u,v))   BECAUSE TI;

\* Proof that orderAddition is reflexive : <<x,y>> \in woAdd(u,v) => (x \in Domain(u) \/ x \in Domain(v))
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,y>>);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)
   BECAUSE EquivToImpl;
domainExists   BECAUSE THEOREM;
x \in Domain(u \union v) <=> IsDefinedOn(u \union v, x)   BECAUSE \A(g <- u \union v, x <- x);
(\E y : <<x,y>> \in u \union v) => x \in Domain(u \union v)   BECAUSE EquivToImplReverse;
<<x,y>> \in u \union v => (\E y : <<x,y>> \in u \union v)   BECAUSE \E(y <- y);
<<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE TI;
cartesianProductCouples   BECAUSE THEOREM;
x \in Domain(u) /\ y \in Domain(v) <=> <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u) /\ y \in Domain(v)   BECAUSE EquivToImplReverse;
x \in Domain(u) /\ y \in Domain(v) => x \in Domain(u)   BECAUSE S12;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
x \in Domain(u) => \E y : <<x,y>> \in u   BECAUSE EquivToImpl;
unionFirstInc   BECAUSE THEOREM;
<<x,y>> \in u => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in u) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(u) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(u) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in woAdd(u,v) => x \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) => IsOrder(u \union v)   BECAUSE ImplySelf;
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ x \in Domain(u \union v)   BECAUSE MergeImplicationsAnd;
orderDomainReflexive   BECAUSE THEOREM;
IsOrder(u \union v) /\ x \in Domain(u \union v) => <<x,x>> \in u \union v   BECAUSE \A(o <- u \union v, x <- x);
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
disjointOrders   BECAUSE THEOREM;
h(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in woAdd(u,v)   BECAUSE ImplySelf;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v)   BECAUSE MergeImplicationsAnd;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
<<x,x>> \in (u \union v) => <<x,x>> \in woAdd(u,v)   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,x>>);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v)   BECAUSE TI;

IsOrder(u \union v) => IsGraph(u \union v) /\ (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE S13;
IsGraph(u \union v) /\ (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v)) => (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE S22;
IsOrder(u \union v) => (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))
   => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE \A(x <- x, y <- y);
IsOrder(u \union v) => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
h(u,v) => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v) => <<x,x>> \in u \union v /\ <<y,y>> \in u \union v   BECAUSE HypoImplToAnd;
<<x,x>> \in u \union v /\ <<y,y>> \in u \union v => <<y,y>> \in u \union v   BECAUSE S22;
h(u,v) /\ (<<x,y>> \in u \union v) => <<y,y>> \in u \union v   BECAUSE TI;
\A x : <<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE GENERALIZATION;
<<y,y>> \in u \union v => y \in Domain(u \union v)   BECAUSE \A(x <- y);
h(u,v) /\ <<x,y>> \in u \union v => y \in Domain(u \union v)   BECAUSE TI;
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE S22;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
x \in Domain(v) <=> IsDefinedOn(v, x)   BECAUSE \A(g <- v, x <- x);
x \in Domain(v) => \E y : <<x,y>> \in v   BECAUSE EquivToImpl;
unionSecondInc   BECAUSE THEOREM;
<<x,y>> \in v => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in v) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(v) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
\A x : x \in Domain(v) => x \in Domain(u \union v)   BECAUSE GENERALIZATION;
y \in Domain(v) => y \in Domain(u \union v)   BECAUSE \A(x <- y);
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(u \union v)   BECAUSE TI;
(h(u,v) /\ <<x,y>> \in u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
semiDistrib(a,b,c) == a /\ (b \/ c) => (a /\ b) \/ c   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v))
   => (h(u,v) /\ <<x,y>> \in u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE semiDistrib;
h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)) => y \in Domain(u \union v)   BECAUSE TI;
h(u,v) => h(u,v)   BECAUSE ImplySelf;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v))   BECAUSE MergeImplicationsAnd;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => y \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) /\ y \in Domain(u \union v) => <<y,y>> \in u \union v   BECAUSE \A(o <- u \union v, x <- y);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => h(u,v)   BECAUSE S12;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v)   BECAUSE TI;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ y \in Domain(u \union v)   BECAUSE CIA;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<y,y>> \in u \union v   BECAUSE TI;
<<y,y>> \in (u \union v) => <<y,y>> \in woAdd(u,v)   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,y>>);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<y,y>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v)   BECAUSE CIA;
h(u,v) => (<<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A y : h(u,v) => (<<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE Q_SCHEME;


\* Proof that orderAddition is transitive : if <<x,y>> and <<y,z>> are in the addition,
\*    - <<x,y>> and <<y,z>> are is u \union v then <<x,z>> too be it's an order
\*    - else either <<x,y>> or <<y,z>> are in the product glue
<<y,z>> \in woAdd(u,v) <=> (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,z>>);
<<y,z>> \in woAdd(u,v) => (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)
   => ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
        /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
\* Kill the double-glue case
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE S22;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(v) => IsOrder(v)   BECAUSE ImplySelf;
IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v) => IsOrder(v) /\ y \in Domain(v)
   BECAUSE MergeImplicationsAnd;
IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v) => <<y,y>> \in v   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE GENERALIZATION;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE \A(x <- y, y <- z);
IsOrder(u) /\ y \in Domain(u) => <<y,y>> \in u   BECAUSE \A(o <- u, x <- y);
IsOrder(u) => IsOrder(u)   BECAUSE ImplySelf;
IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v) => IsOrder(u) /\ y \in Domain(u)
   BECAUSE MergeImplicationsAnd;
IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v) => <<y,y>> \in u   BECAUSE TI;
(IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v))
   => <<y,y>> \in u /\ <<y,y>> \in v  BECAUSE MergeImplicationsAnd; \* Impossible, u and v are disjoint
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
~(<<y,y>> \in u /\ <<y,y>> \in v)
   => ~((IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v)))   BECAUSE Contraposition;
AreDisjoint(u,v)
   => ~((IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v)))   BECAUSE TI;
pullHypos(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => ((b /\ d /\ a) => ~(c /\ e))   PROPO_TAUTO;
h(u,v) => ~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v))   BECAUSE pullHypos;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => ~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v))
      /\ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
        /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
killCase(a,b,c,d) == (~(a /\ b) /\ ((c \/ b) /\ (d \/ a))) => (c /\ d) \/ (b /\ d) \/ (c /\ a)   PROPO_TAUTO;
~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v)) /\ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE killCase;

h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE TI;
pushHypo(a,b,c) == ((a /\ b) => c) => ((a /\ b) => (a /\ c))   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => h(u,v) /\ ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))
   BECAUSE pushHypo;

IsOrder(u \union v) => (\A x : \A y : \A z : ((<<x,y>> \in u \union v) /\ (<<y,z>> \in u \union v)) => (<<x,z>> \in u \union v))
   BECAUSE S23;
(\A x : \A y : \A z : ((<<x,y>> \in u \union v) /\ (<<y,z>> \in u \union v)) => (<<x,z>> \in u \union v))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u \union v)
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE TI;
h(u,v) => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) => <<x,z>> \in u \union v   BECAUSE HypoImplToAnd;
<<x,z>> \in woAdd(u,v) <=> (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,z>>);
(<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v))) => <<x,z>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,z>> \in u \union v => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
<<x,z>> \in u \union v => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

<<y,z>> \in u \union v <=> <<y,z>> \in u \/ <<y,z>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in u \union v => <<y,z>> \in u \/ <<y,z>> \in v   BECAUSE EquivToImpl;
<<x,y>> \in Domain(u) \X Domain(v) => <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE ImplySelf;
(<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => y \in Domain(v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE MergeImplicationsAnd;
y \in Domain(v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)
   => (y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v   BECAUSE semiDistrib;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v
   => (y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v   BECAUSE TI;
\* Proof first case is impossible
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(u) => IsGraph(u) /\ (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE S13;
IsGraph(u) /\ (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE S22;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)) => ((<<y,z>> \in u) => (<<y,y>> \in u /\ <<z,z>> \in u))   BECAUSE \A(x <- y, y <- z);
IsOrder(u) => ((<<y,z>> \in u) => (<<y,y>> \in u /\ <<z,z>> \in u))   BECAUSE TI;
IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE HypoImplToAnd;
<<y,y>> \in u /\ <<z,z>> \in u => <<y,y>> \in u   BECAUSE S12;
IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u   BECAUSE TI;
(IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)) => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE MergeImplicationsAnd;
~(<<y,y>> \in u /\ <<y,y>> \in v) => ~((IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)))   BECAUSE Contraposition;
AreDisjoint(u,v) => ~((IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)))   BECAUSE TI;
shuffleNot(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => (b /\ d /\ a => ~(e /\ c))   PROPO_TAUTO;
h(u,v) => ~(y \in Domain(v) /\ <<y,z>> \in u)   BECAUSE shuffleNot;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => ~(y \in Domain(v) /\ <<y,z>> \in u) /\ ((y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v)   BECAUSE MergeImplicationsAnd;
distribNot(a,b) == ~a /\ (a \/ b) => b   PROPO_TAUTO;
~(y \in Domain(v) /\ <<y,z>> \in u) /\ ((y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v)
   => <<y,z>> \in v   BECAUSE distribNot;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => <<y,z>> \in v   BECAUSE TI;
selectHypo(a,b,c,d) == (a => b) => (c /\ (a /\ d) => b)   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => x \in Domain(u)   BECAUSE selectHypo;
\A u : IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE GENERALIZATION;
IsOrder(v) /\ <<y,z>> \in v => <<y,y>> \in v /\ <<z,z>> \in v   BECAUSE \A(u <- v);
<<y,y>> \in v /\ <<z,z>> \in v => <<z,z>> \in v   BECAUSE S22;
IsOrder(v) /\ <<y,z>> \in v => <<z,z>> \in v   BECAUSE TI;
z \in Domain(v) <=> IsDefinedOn(v, z)   BECAUSE \A(g <- v, x <- z);
(\E y : <<z,y>> \in v) => z \in Domain(v)   BECAUSE EquivToImplReverse;
<<z,z>> \in v => (\E y : <<z,y>> \in v)   BECAUSE \E(y <- z);
<<z,z>> \in v => z \in Domain(v)   BECAUSE TI;
IsOrder(v) /\ <<y,z>> \in v => z \in Domain(v)   BECAUSE TI;
IsOrder(v) => (<<y,z>> \in v => z \in Domain(v))   BECAUSE HypoAndToImpl;
<<y,z>> \in v => (IsOrder(v) => z \in Domain(v))   BECAUSE SwitchHypos;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => (IsOrder(v) => z \in Domain(v))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) /\ IsOrder(v) => z \in Domain(v)   BECAUSE HypoImplToAnd;
repeatHypo(a,b,c,d) == a /\ b /\ c /\ d => a /\ b /\ c /\ d /\ b   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) /\ IsOrder(v)   BECAUSE repeatHypo;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => z \in Domain(v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => x \in Domain(u) /\ z \in Domain(v)   BECAUSE CIA;
x \in Domain(u) /\ z \in Domain(v) <=> <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- z);
x \in Domain(u) /\ z \in Domain(v) => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE EquivToImpl;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE TI;
<<x,z>> \in (Domain(u) \X Domain(v)) => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,z>> \in (Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

\* (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
<<x,y>> \in u \union v <=> <<x,y>> \in u \/ <<x,y>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in u \union v => <<x,y>> \in u \/ <<x,y>> \in v   BECAUSE EquivToImpl;
<<y,z>> \in Domain(u) \X Domain(v) => <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE ImplySelf;
y \in Domain(u) /\ z \in Domain(v) <=> <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- y, b <- z);
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u) /\ z \in Domain(v)   BECAUSE EquivToImplReverse;
y \in Domain(u) /\ z \in Domain(v) => y \in Domain(u)   BECAUSE S12;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE TI;
<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)
   => (<<x,y>> \in u \/ <<x,y>> \in v) /\ y \in Domain(u)   BECAUSE MergeImplicationsAnd;
semiDistribRight(a,b,c) == (b \/ c) /\ a => (b \/ (c /\ a))   PROPO_TAUTO;
(<<x,y>> \in u \/ <<x,y>> \in v) /\ y \in Domain(u)
   => <<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u))   BECAUSE semiDistribRight;
<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)
   => <<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u))   BECAUSE TI; \* second case is impossible
IsOrder(u) /\ y \in Domain(u) => <<y,y>> \in u   BECAUSE \A(o <- u, x <- y);
IsOrder(v) => IsGraph(v) /\ (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE S13;
IsGraph(v) /\ (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))
   => (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE S22;
IsOrder(v) => (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)) => ((<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(x <- x, y <- y);
IsOrder(v) => ((<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
IsOrder(v) /\ <<x,y>> \in v => <<x,x>> \in v /\ <<y,y>> \in v   BECAUSE HypoImplToAnd;
<<x,x>> \in v /\ <<y,y>> \in v => <<y,y>> \in v   BECAUSE S22;
IsOrder(v) /\ <<x,y>> \in v => <<y,y>> \in v   BECAUSE TI;
(IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)) => <<y,y>> \in v /\ <<y,y>> \in u   BECAUSE MergeImplicationsAnd;
<<y,y>> \in v /\ <<y,y>> \in u => <<y,y>> \in u /\ <<y,y>> \in v  BECAUSE AndSymmetry;
(IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)) => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE TI;
~(<<y,y>> \in u /\ <<y,y>> \in v) => ~((IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)))   BECAUSE Contraposition;
AreDisjoint(u,v) => ~((IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)))   BECAUSE TI;
shuffleNotBis(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => (d /\ b /\ a => ~(c /\ e))   PROPO_TAUTO;
h(u,v) => ~(<<x,y>> \in v /\ y \in Domain(u))   BECAUSE shuffleNotBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => ~(<<x,y>> \in v /\ y \in Domain(u)) /\ (<<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u)))   BECAUSE MergeImplicationsAnd;
distribNotBis(a,b) == ~a /\ (b \/ a) => b   PROPO_TAUTO;
~(<<x,y>> \in v /\ y \in Domain(u)) /\ (<<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u)))
   => <<x,y>> \in u   BECAUSE distribNotBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => <<x,y>> \in u   BECAUSE TI;
y \in Domain(u) /\ z \in Domain(v) <=> <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- y, b <- z);
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u) /\ z \in Domain(v)   BECAUSE EquivToImplReverse;
y \in Domain(u) /\ z \in Domain(v) => z \in Domain(v)   BECAUSE S22;
<<y,z>> \in Domain(u) \X Domain(v) => z \in Domain(v)   BECAUSE TI;
selectHypoBis(a,b,c,d) == (d => b) => (c /\ (a /\ d) => b)   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => z \in Domain(v)   BECAUSE selectHypoBis;
\A y : \A z : IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE GENERALIZATION;
IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u /\ <<y,y>> \in u   BECAUSE \A(y <- x, z <- y);
<<x,x>> \in u /\ <<y,y>> \in u => <<x,x>> \in u   BECAUSE S12;
IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
(\E y : <<x,y>> \in u) => x \in Domain(u)   BECAUSE EquivToImplReverse;
<<x,x>> \in u => (\E y : <<x,y>> \in u)   BECAUSE \E(y <- x);
<<x,x>> \in u => x \in Domain(u)   BECAUSE TI;
IsOrder(u) /\ <<x,y>> \in u => x \in Domain(u)   BECAUSE TI;
IsOrder(u) => (<<x,y>> \in u => x \in Domain(u))   BECAUSE HypoAndToImpl;
<<x,y>> \in u => (IsOrder(u) => x \in Domain(u))   BECAUSE SwitchHypos;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => (IsOrder(u) => x \in Domain(u))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ IsOrder(u) => x \in Domain(u)   BECAUSE HypoImplToAnd;
repeatHypoBis(a,b,c,d) == a /\ b /\ c /\ d => a /\ b /\ c /\ d /\ a   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ IsOrder(u)   BECAUSE repeatHypoBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => x \in Domain(u)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => x \in Domain(u) /\ z \in Domain(v)   BECAUSE CIA;
x \in Domain(u) /\ z \in Domain(v) <=> <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- z);
x \in Domain(u) /\ z \in Domain(v) => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE EquivToImpl;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE TI;
<<x,z>> \in (Domain(u) \X Domain(v)) => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,z>> \in (Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

(h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)) => <<x,z>> \in woAdd(u,v)   BECAUSE CombineImplicationsStart;
(h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))) => <<x,z>> \in woAdd(u,v)   BECAUSE CombineImplicationsStart;
DistribAndOrLeft4(a,b,c,d) == (a /\ (b \/ c \/ d)) => ((a /\ b) \/ (a /\ c) \/ (a /\ d))   PROPO_TAUTO;
h(u,v) /\ ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))
   => ((h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v))
        \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v))
	\/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))))   BECAUSE DistribAndOrLeft4;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)) => ((h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v))
        \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v))
	\/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A z : h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A y : h(u,v) => (\A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;

\* Proof that orderAddition is anti-symmetric
\A z : h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE GENERALIZATION;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v))
   => ((<<x,y>> \in u \union v /\ <<y,x>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v)))   BECAUSE \A(z <- x);
\* Prove the second case is impossible : ~(<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
\* The third case is the same as the second, by generalizing then swapping x and y
<<y,x>> \in u \union v <=> <<y,x>> \in u \/ <<y,x>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in u \union v => <<y,x>> \in u \/ <<y,x>> \in v   BECAUSE EquivToImpl;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v
   => x \in Domain(u) /\ y \in Domain(v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE MergeImplicationsAnd;
multiDistrib(a,b,c,d) == a /\ b /\ (c \/ d) => (b /\ c) \/ (a /\ d)   PROPO_TAUTO;
x \in Domain(u) /\ y \in Domain(v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)
   => (y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v)   BECAUSE multiDistrib;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v
   => (y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v)   BECAUSE TI;

\A u : \A x : \A y : IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u   BECAUSE GENERALIZATION;
IsOrder(u) /\ <<y,x>> \in u => <<y,y>> \in u   BECAUSE \A(u <- u, x <- y, y <- x);
IsOrder(u) => (<<y,x>> \in u => <<y,y>> \in u)   BECAUSE HypoAndToImpl;
<<y,x>> \in u => (IsOrder(u) => <<y,y>> \in u)   BECAUSE SwitchHypos;
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(v) => (y \in Domain(v) => <<y,y>> \in v)   BECAUSE HypoAndToImpl;
y \in Domain(v) => (IsOrder(v) => <<y,y>> \in v)   BECAUSE SwitchHypos;
y \in Domain(v) /\ <<y,x>> \in u => (IsOrder(v) => <<y,y>> \in v) /\ (IsOrder(u) => <<y,y>> \in u)
   BECAUSE MergeImplicationsAnd;
factorTwoHypos(a,b,c,d) == ((a => b) /\ (c => d)) => ((a /\ c) => (b /\ d))   PROPO_TAUTO;
(IsOrder(v) => <<y,y>> \in v) /\ (IsOrder(u) => <<y,y>> \in u)
   => (IsOrder(v) /\ IsOrder(u) => <<y,y>> \in v /\ <<y,y>> \in u)   BECAUSE factorTwoHypos;
y \in Domain(v) /\ <<y,x>> \in u => (IsOrder(v) /\ IsOrder(u) => <<y,y>> \in v /\ <<y,y>> \in u)
   BECAUSE TI;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => <<y,y>> \in v /\ <<y,y>> \in u
   BECAUSE HypoImplToAnd;
<<y,y>> \in v /\ <<y,y>> \in u => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE AndSymmetry;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => <<y,y>> \in u /\ <<y,y>> \in v
   BECAUSE TI;
~~(<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE Contraposition;
(<<y,y>> \in u /\ <<y,y>> \in v) => ~~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE IntroNotNot;
(<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE TI;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => ~AreDisjoint(u,v)   BECAUSE TI;
pullH(a,b,c,d) == (a /\ (b /\ c) => ~d) => (a => ~(c /\ b /\ d))   PROPO_TAUTO;
(y \in Domain(v) /\ <<y,x>> \in u) => ~h(u,v)   BECAUSE pullH;

<<x,x>> \in u /\ <<y,y>> \in u => <<y,y>> \in u   BECAUSE S22;
IsOrder(u) /\ <<x,y>> \in u => <<y,y>> \in u   BECAUSE TI;
\A u : \A x : \A y : IsOrder(u) /\ <<x,y>> \in u => <<y,y>> \in u   BECAUSE GENERALIZATION;
IsOrder(v) /\ <<y,x>> \in v => <<x,x>> \in v   BECAUSE \A(u <- v, x <- y, y <- x);
IsOrder(v) => (<<y,x>> \in v => <<x,x>> \in v)   BECAUSE HypoAndToImpl;
<<y,x>> \in v => (IsOrder(v) => <<x,x>> \in v)   BECAUSE SwitchHypos;
IsOrder(u) /\ x \in Domain(u) => <<x,x>> \in u   BECAUSE \A(o <- u, x <- x);
IsOrder(u) => (x \in Domain(u) => <<x,x>> \in u)   BECAUSE HypoAndToImpl;
x \in Domain(u) => (IsOrder(u) => <<x,x>> \in u)   BECAUSE SwitchHypos;
x \in Domain(u) /\ <<y,x>> \in v => (IsOrder(u) => <<x,x>> \in u) /\ (IsOrder(v) => <<x,x>> \in v)
   BECAUSE MergeImplicationsAnd;
(IsOrder(u) => <<x,x>> \in u) /\ (IsOrder(v) => <<x,x>> \in v)
   => (IsOrder(u) /\ IsOrder(v) => <<x,x>> \in u /\ <<x,x>> \in v)   BECAUSE factorTwoHypos;
x \in Domain(u) /\ <<y,x>> \in v => (IsOrder(u) /\ IsOrder(v) => <<x,x>> \in u /\ <<x,x>> \in v)
   BECAUSE TI;
x \in Domain(u) /\ <<y,x>> \in v /\ (IsOrder(u) /\ IsOrder(v)) => <<x,x>> \in u /\ <<x,x>> \in v
   BECAUSE HypoImplToAnd;
\A y : (<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE GENERALIZATION;
(<<x,x>> \in u /\ <<x,x>> \in v) => ~AreDisjoint(u,v)   BECAUSE \A(y <- x);
x \in Domain(u) /\ <<y,x>> \in v /\ (IsOrder(u) /\ IsOrder(v)) => ~AreDisjoint(u,v)   BECAUSE TI;
pullHbis(a,b,c,d) == (a /\ (b /\ c) => ~d) => (a => ~(b /\ c /\ d))   PROPO_TAUTO;
(x \in Domain(u) /\ <<y,x>> \in v) => ~h(u,v)   BECAUSE pullHbis;

(y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v) => ~h(u,v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v => ~h(u,v)   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v => ~h(u,v)   BECAUSE GENERALIZATION;
<<y,x>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in u \union v => ~h(u,v)   BECAUSE \A(x <- y, y <- x);
<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v) => <<y,x>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in u \union v   BECAUSE AndSymmetry;
<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v) => ~h(u,v)   BECAUSE TI;

IsOrder(u \union v) => (\A x : \A y : ((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE S22;
(\A x : \A y : ((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)
   => (((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u \union v) => (((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE TI;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => (IsOrder(u \union v) => x = y)   BECAUSE SwitchHypos;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v)   BECAUSE MergeImplicationsOr;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v))
   \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
   \/ (<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v))
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v) \/ ~h(u,v)  BECAUSE MergeImplicationsOr;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v))
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v) \/ ~h(u,v)  BECAUSE TI;
dropRedundantCases(a,b,c,d) == (a => c) => ((a /\ b => (c => d) \/ ~a \/ ~a) => (a /\ b => d))   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v)) => x = y   BECAUSE dropRedundantCases;
h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE HypoAndToImpl;
\A y : h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE GENERALIZATION;
h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE Q_SCHEME;

h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v)) /\ (\A x : \A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsOrder(woAdd(u,v))   BECAUSE CIA;
disjointOrderAddition   BECAUSE GENERALIZATION;
QED

(*
   Now the multiplication of orders, which is the usual multiplication on
   natural numbers.
*)
OrderMultiplication(u,v) == CHOOSE m : \A x : x \in m
   <=> IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
       /\ ((fst(fst(x)) # fst(snd(x)) /\ << fst(fst(x)), fst(snd(x))>> \in u)
             \/ (fst(fst(x)) = fst(snd(x)) /\ << snd(fst(x)), snd(snd(x))>> \in v))

orderMultiplicationIsOrder == \A u : \A v : (IsOrder(u) /\ IsOrder(v))
   => IsOrder(OrderMultiplication(u,v))
\* THEOREM orderMultiplicationIsOrder


EmptyOrHasMinimum(part, order) == (part = {}) \/ (\E m : IsMinimum(m, part, order))

minOfTwoParts == \A o : \A a : \A b :
      (EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o)
        /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)
THEOREM minOfTwoParts
PROOF
VARIABLES a,b,m,o,x,y,z;
\* If a is not empty, then it has a minimum
ma(a,o) == CHOOSE m : IsMinimum(m, a, o);
killCase(a,b) == ((a \/ b) /\ ~a) => b   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ a # {}) => \E m : IsMinimum(m, a, o)   BECAUSE killCase;
(\E m : IsMinimum(m, a, o)) => IsMinimum(ma(a,o), a, o)   BECAUSE CHOOSE ma(a,o);
(EmptyOrHasMinimum(a,o) /\ a # {}) => IsMinimum(ma(a,o), a, o)   BECAUSE TI;

   \* ma(a,o) is below b
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)
   => ((ma(a,o) \in a /\ x \in b) => <<ma(a,o), x>> \in o)   BECAUSE \A(x <- ma(a,o), y <- x);
pullHypo(a,b,c,d) == (a => ((b /\ c) => d)) => ((a /\ b) => (c => d))   PROPO_TAUTO;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE pullHypo;
IsMinimum(ma(a,o), a, o) => ma(a,o) \in a   BECAUSE S12;
(EmptyOrHasMinimum(a,o) /\ a # {}) => ma(a,o) \in a   BECAUSE TI;
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) => (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)   BECAUSE ImplySelf;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)   BECAUSE MergeImplicationsAnd;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;

   \* ma(a,o) is the minimum of (a \union b)
IsMinimum(ma(a,o), a, o) => \A x : x \in a => <<ma(a,o),x>> \in o   BECAUSE S22;
(\A x : x \in a => <<ma(a,o),x>> \in o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE \A(x <- x);
IsMinimum(ma(a,o), a, o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)) => EmptyOrHasMinimum(a,o)   BECAUSE S12;
a # {} => a # {}   BECAUSE ImplySelf;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (EmptyOrHasMinimum(a,o) /\ a # {})   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a, o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
shuffleHypos(a,b,c) == (b /\ a /\ c) => (a /\ (b /\ c))   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))    BECAUSE shuffleHypos;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))   BECAUSE CIA;
((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE TI;
unionInc   BECAUSE THEOREM;
x \in (a \union b) <=> (x \in a \/ x \in b)   BECAUSE \A(x <- a, y <- b, z <- x);
x \in (a \union b) => (x \in a \/ x \in b)   BECAUSE EquivToImpl;
((x \in a \/ x \in b) => <<ma(a,o),x>> \in o) => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
\A x : (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE GENERALIZATION;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (\A x : (x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE Q_SCHEME;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in a   BECAUSE TI;
unionFirstInc   BECAUSE THEOREM;
ma(a,o) \in a => ma(a,o) \in (a \union b)   BECAUSE \A(x <- a, y <- b, z <- ma(a,o));
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in (a \union b)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a \union b, o) BECAUSE CIA;
IsMinimum(ma(a,o), a \union b, o) => \E m : IsMinimum(m, a \union b, o)   BECAUSE \E(m <- ma(a,o));
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => \E m : IsMinimum(m, a \union b, o) BECAUSE TI;
(\E m : IsMinimum(m, a \union b, o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE IntroOrRight;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => EmptyOrHasMinimum(a \union b, o) BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE HypoAndToImpl;
addHypo(a,b,c) == (a /\ b /\ c) => (a /\ c)   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))   BECAUSE addHypo;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE TI;

\* If a is empty
emptyUnion   BECAUSE THEOREM;
{} \union b = b   BECAUSE \A(a <- b);
\A x : \A y : x = y => (x \union b = b <=> y \union b = b)   BECAUSE E_SCHEME;
a = {} => (a \union b = b <=> {} \union b = b)   BECAUSE \A(x <- a, y <- {});
a = {} => a \union b = b   BECAUSE ImplyEquivTrue;
\A x : \A y : x = y => (EmptyOrHasMinimum(x,o) <=> EmptyOrHasMinimum(y,o))   BECAUSE E_SCHEME;
a \union b = b => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE \A(x <- a \union b, y <- b);
a = {} => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE TI;
(a = {} /\ EmptyOrHasMinimum(b,o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE HypoEquivToAndReverse;
(EmptyOrHasMinimum(b,o) /\ a = {}) => (a = {} /\ EmptyOrHasMinimum(b,o))   BECAUSE AndSymmetry;
(EmptyOrHasMinimum(b,o) /\ a = {}) => EmptyOrHasMinimum(a \union b, o)   BECAUSE TI;
EmptyOrHasMinimum(b,o) => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE HypoAndToImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(b,o)   BECAUSE S23;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;

(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))   BECAUSE CIA;
((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;
a = {} \/ a # {}   BECAUSE ExcludedMiddle;
(a = {} \/ a # {}) => ((EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o))   BECAUSE SwitchHypos;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)   BECAUSE MODUS_PONENS;
minOfTwoParts   BECAUSE GENERALIZATION;
QED


(*
   The class of well-orders, orders where each nonempty subset has a minimum.
   They allow to count :
      - in the well-order, take the minimum and call it zero
      - in the nonzero elements of the well-order, take the minimum and call it one
      - in the elements of the well-order that are neither zero nor one,
        take the minimum and call it two
      - iterate

   For this reason, some well-orders (the finite ones) define the natural numbers.
   The well-orders are stable under addition and multiplication, as defined above.
*)
IsWellOrder(w) == IsOrder(w) /\ (\A p : (p \subseteq Domain(w)) => EmptyOrHasMinimum(p, w))

injectWOIsWO == \A o : \A f : (IsWellOrder(o) /\ IsFunction(f)) => IsWellOrder(injectOrder(o,f))
\* THEOREM injectWOIsWO

disjointWOAddition == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v))
   => IsWellOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointWOAddition
PROOF
VARIABLES a,b,c,g,i,j,m,o,p,u,v,x,y,z,part;
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
disjointOrderAddition   BECAUSE THEOREM;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v \union (Domain(u) \X Domain(v)))
   BECAUSE \A(u <- u, v <- v);
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(u)   BECAUSE S13;
IsWellOrder(u) => IsOrder(u)   BECAUSE S12;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(v)   BECAUSE S23;
IsWellOrder(v) => IsOrder(v)   BECAUSE S12;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(v)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => AreDisjoint(u,v)   BECAUSE S22;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE CIA;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   BECAUSE CIA;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(woAdd(u,v))   BECAUSE TI;

\* Proof that wellOrderAddition has all minimums
\* Prove part \subseteq Domain(woAdd(u,v)) => part = (part \intersect Domain(u)) \union (part \intersect Domain(v))
\* and call theorem minOfTwoParts with those two parts
domainExists   BECAUSE THEOREM;
z \in Domain(woAdd(u,v))
   <=> IsDefinedOn(woAdd(u,v),z)   BECAUSE \A(g <- woAdd(u,v), x <- z);
z \in Domain(woAdd(u,v))
   => \E y : <<z,y>> \in woAdd(u,v)   BECAUSE EquivToImpl;
unionInc   BECAUSE THEOREM;
<<z,y>> \in woAdd(u,v)
   <=> (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<z,y>>);
<<z,y>> \in woAdd(u,v)
   => (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
cartesianProductCouples   BECAUSE THEOREM;
(z \in Domain(u) /\ y \in Domain(v)) <=> <<z,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- z, b <- y);
<<z,y>> \in (Domain(u) \X Domain(v)) => (z \in Domain(u) /\ y \in Domain(v))   BECAUSE EquivToImplReverse;
(z \in Domain(u) /\ y \in Domain(v)) => z \in Domain(u)   BECAUSE S12;
<<z,y>> \in (Domain(u) \X Domain(v)) => z \in Domain(u)   BECAUSE TI;
<<z,y>> \in (u \union v) <=> (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<z,y>>);
<<z,y>> \in (u \union v) => (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE EquivToImpl;
domainInc   BECAUSE THEOREM;
<<z,y>> \in u => z \in Domain(u)   BECAUSE \A(g <- u, x <- z, y <- y);
<<z,y>> \in v => z \in Domain(v)   BECAUSE \A(g <- v, x <- z, y <- y);
(<<z,y>> \in u \/ <<z,y>> \in v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE MergeImplicationsOr;
<<z,y>> \in (u \union v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE MergeImplicationsOr;
<<z,y>> \in woAdd(u,v)
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE TI;
dropRedOr(a,z) == ((a \/ z) \/ a) => (a \/ z)   PROPO_TAUTO;
((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE dropRedOr;
<<z,y>> \in woAdd(u,v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(\E y : <<z,y>> \in woAdd(u,v)) => (\E y : z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : z \in Domain(u) \/ z \in Domain(v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : <<z,y>> \in woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in Domain(woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in (Domain(u) \union Domain(v)) <=> (z \in Domain(u) \/ z \in Domain(v))
   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- z);
(z \in Domain(u) \/ z \in Domain(v)) => z \in (Domain(u) \union Domain(v))   BECAUSE EquivToImplReverse;
z \in Domain(woAdd(u,v)) => z \in (Domain(u) \union Domain(v))   BECAUSE TI;
Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v))   BECAUSE GENERALIZATION;
transitInclusion   BECAUSE THEOREM;
(part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))
   => part \subseteq (Domain(u) \union Domain(v))   BECAUSE \A(a <- part, b <- Domain(woAdd(u,v)), c <- (Domain(u) \union Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))   BECAUSE IntroAndLeft;
part \subseteq Domain(woAdd(u,v)) => part \subseteq (Domain(u) \union Domain(v))   BECAUSE TI;
distribIntersectUnion   BECAUSE THEOREM;
(part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   BECAUSE \A(a <- part, b <- Domain(u), c <- Domain(v));
intersectSuper   BECAUSE THEOREM;
part \subseteq (Domain(u) \union Domain(v)) => (part \intersect (Domain(u) \union Domain(v))) = part
   BECAUSE \A(a <- part, b <- Domain(u) \union Domain(v));
part \subseteq Domain(woAdd(u,v)) => (part \intersect (Domain(u) \union Domain(v))) = part   BECAUSE TI;
((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE E_SCHEME;
(part \intersect (Domain(u) \union Domain(v))) = part => ((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v))))   BECAUSE IntroAndLeft;
(part \intersect (Domain(u) \union Domain(v))) = part => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq (Domain(u) \union Domain(v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq Domain(woAdd(u,v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;

IsWellOrder(u) => (\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))   BECAUSE S22;
(\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE \A(p <- part \intersect Domain(u));
IsWellOrder(u)
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)
   => (IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE SwitchHypos;
intersectionExists   BECAUSE THEOREM;
z \in (part \intersect Domain(u)) <=> (z \in part /\ z \in Domain(u))   BECAUSE \A(u <- part, v <- Domain(u), x <- z);
z \in (part \intersect Domain(u)) => (z \in part /\ z \in Domain(u))   BECAUSE EquivToImpl;
(z \in part /\ z \in Domain(u)) => z \in Domain(u)   BECAUSE S22;
z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)   BECAUSE GENERALIZATION;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE MODUS_PONENS;
\A u : IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE GENERALIZATION;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), v)   BECAUSE \A(u <- v);

\* Proof of EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))
IsMinimum(m, part \intersect Domain(u), u)
   => \A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u   BECAUSE S22;
(\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in u   BECAUSE HypoImplToAnd;
x \in woAdd(u,v)
   <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => x \in woAdd(u,v)   BECAUSE EquivToImplReverse;
x \in (u \union v) => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
x \in (u \union v) => x \in woAdd(u,v)   BECAUSE TI;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
(x \in u \/ x \in v) => x \in (u \union v)   BECAUSE EquivToImplReverse;
x \in u => (x \in u \/ x \in v)   BECAUSE IntroOrLeft;
x \in u => x \in (u \union v)   BECAUSE TI;
x \in u => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in u => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in u => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(u), u) => (\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(u), u) => m \in (part \intersect Domain(u))   BECAUSE S12;
IsMinimum(m, part \intersect Domain(u), u) => IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE CIA;
(\E m : IsMinimum(m, part \intersect Domain(u), u)) => \E m : IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(u) = {}) => (part \intersect Domain(u) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE TI;

IsMinimum(m, part \intersect Domain(v), v)
   => \A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v   BECAUSE S22;
(\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in v   BECAUSE HypoImplToAnd;
x \in v => (x \in u \/ x \in v)   BECAUSE IntroOrRight;
x \in v => x \in (u \union v)   BECAUSE TI;
x \in v => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in v => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in v => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(v), v) => (\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(v), v) => m \in (part \intersect Domain(v))   BECAUSE S12;
IsMinimum(m, part \intersect Domain(v), v) => IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE CIA;
(\E m : IsMinimum(m, part \intersect Domain(v), v)) => \E m : IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(v) = {}) => (part \intersect Domain(v) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(v), v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE TI;

\* Domination of first part by second part
\A u : \A z : z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE GENERALIZATION;
x \in (part \intersect Domain(u)) => x \in Domain(u)   BECAUSE \A(u <- u, z <- x);
y \in (part \intersect Domain(v)) => y \in Domain(v)   BECAUSE \A(u <- v, z <- y);
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => (x \in Domain(u) /\ y \in Domain(v))   BECAUSE MergeImplicationsAnd;
(x \in Domain(u) /\ y \in Domain(v)) <=> <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
(x \in Domain(u) /\ y \in Domain(v)) => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE TI;
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,y>>);
(<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v))) => <<x,y>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,y>> \in (Domain(u) \X Domain(v)) => (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,y>> \in (Domain(u) \X Domain(v)) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE GENERALIZATION;

minOfTwoParts   BECAUSE THEOREM;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))
    /\ (\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)))
   => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))
   BECAUSE \A(o <- woAdd(u,v), a <- part \intersect Domain(u), b <- part \intersect Domain(v));
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE IntroAndLeft;
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))   BECAUSE TI;
\A a : \A b : a = b => (EmptyOrHasMinimum(a, woAdd(u,v)) <=> EmptyOrHasMinimum(b, woAdd(u,v)))   BECAUSE E_SCHEME;
part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))
   BECAUSE \A(a <- part, b <- (part \intersect Domain(u)) \union (part \intersect Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE TI;
(part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE HypoEquivToAndReverse;
part \subseteq Domain(woAdd(u,v)) => part \subseteq Domain(woAdd(u,v))   BECAUSE ImplySelf;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => (part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => (part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v)))   BECAUSE AndSymmetry;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE HypoAndToImpl;
\A part : (IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE \A(part <- p);
\A p : (IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE Q_SCHEME;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsWellOrder(u) /\ IsWellOrder(v))   BECAUSE S12;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(woAdd(u,v))   BECAUSE CIA;
disjointWOAddition   BECAUSE GENERALIZATION;
QED

pasteTags(dom, tag) == productFunc(identity(dom), const(dom, tag))

\* Define a well-order on the disjoint union of two well-orders.
\* This order simply pastes v after u.
wellOrderAddition(u,v) == injectOrder(u, pasteTags(Domain(u),{}))
   \union injectOrder(v, pasteTags(Domain(v),ordinalOne))
   \union ((Domain(u)\X{{}}) \X (Domain(v)\X{ordinalOne})) \* this puts v after u

(*
woAddIsWo == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v)) => IsWellOrder(wellOrderAddition(u,v))
THEOREM woAddIsWo
PROOF
VARIABLES a,b,c,d,f,i,j,g,o,u,v,x,y,z,tag;
\* Give shorter names
Ione(u) == injectOrder(u, pasteTags(Domain(u),{}));
Itwo(v) == injectOrder(v, pasteTags(Domain(v),ordinalOne));
DO(u,v) == Ione(u) \union Itwo(v);

\* Proof that DO is an order
productFuncIsFunc   BECAUSE THEOREM;
(IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y)))
   => IsFunction(pasteTags(Domain(u),y))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),y));
identityBiject   BECAUSE THEOREM;
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))   BECAUSE \A(d <- Domain(u));
bijectionsExists   BECAUSE THEOREM;
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))
   <=> IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE \A(d <- Domain(u), i <- Domain(u), f <- identity(Domain(u)));
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))
   => IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE EquivToImpl;
IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE MODUS_PONENS;
IsInjection(identity(Domain(u)))   BECAUSE S13;
IsFunction(identity(Domain(u)))   BECAUSE S12;
constFunc   BECAUSE THEOREM;
IsFunction(const(Domain(u),y))   BECAUSE \A(d <- Domain(u), c <- y);
IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y))   BECAUSE IntroAndRight;
IsFunction(pasteTags(Domain(u),y))   BECAUSE MODUS_PONENS;
injectOrderIsOrder   BECAUSE THEOREM;
(IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))
   => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),y));
IsOrder(u) => (IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))   BECAUSE IntroAndLeft;
IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE TI;
\A u : \A y : IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE GENERALIZATION;
IsOrder(u) => IsOrder(Ione(u))   BECAUSE \A(u <- u, y <- {});
IsOrder(v) => IsOrder(Itwo(v))   BECAUSE \A(u <- v, y <- ordinalOne);
	   \* Proof that AreDisjoint(Ione(u),Itwo(v))
disjointOrders   BECAUSE THEOREM;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u),Itwo(v)))
   => IsOrder(Ione(u) \union Itwo(v))   BECAUSE \A(u <- Ione(u), v <- Itwo(v));
noCommonElements   BECAUSE THEOREM;
AreDisjoint(Ione(u),Itwo(v)) <=> \A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE \A(x <- Ione(u), y <- Itwo(v));
(\A z : ~(z \in Ione(u) /\ z \in Itwo(v))) => AreDisjoint(Ione(u),Itwo(v))   BECAUSE EquivToImplReverse;
injectOrderExists   BECAUSE THEOREM;
z \in Ione(u) <=> IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),{}), x <- z);
z \in Itwo(v) <=> IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE \A(o <- v, f <- pasteTags(Domain(v),ordinalOne), x <- z);
IsInInjectOrder(u,pasteTags(Domain(u),tag),z)
   => z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag)))   BECAUSE S12;
cartesianProductExists   BECAUSE THEOREM;
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) <=> (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))
   BECAUSE \A(i <- Image(pasteTags(Domain(u),tag)), j <- Image(pasteTags(Domain(u),tag)), x <- z);
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE EquivToImpl;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE TI;
(IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag))) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE S22;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE TI;
productFuncVal   BECAUSE THEOREM;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => (IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),tag), x <- x, y <- snd(z));
(IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag)) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE S22;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
imageExists   BECAUSE THEOREM;
snd(z) \in Image(pasteTags(Domain(u),tag)) <=> Reaches(pasteTags(Domain(u),tag),snd(z))   BECAUSE \A(g <- pasteTags(Domain(u),tag), y <- snd(z));
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)   BECAUSE EquivToImpl;
(\E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE Q_SCHEME;
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
constExists   BECAUSE THEOREM;
<<x,snd(snd(z))>> \in const(Domain(u),tag) <=> (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE \A(d <- Domain(u), c <- tag, x <- <<x,snd(snd(z))>>);
<<x,snd(snd(z))>> \in const(Domain(u),tag) => (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE EquivToImpl;
(IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)
   => snd(<<x,snd(snd(z))>>) = tag   BECAUSE S22;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => snd(<<x,snd(snd(z))>>) = tag   BECAUSE TI;
sndExists   BECAUSE THEOREM;
snd(snd(z)) = snd(<<x,snd(snd(z))>>)   BECAUSE \A(a <- x, b <- snd(snd(z)));
snd(<<x,snd(snd(z))>>) = tag => tag = snd(<<x,snd(snd(z))>>)   BECAUSE E_SCHEME;
(tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>)) => tag = snd(snd(z))  BECAUSE E_SCHEME;
tag = snd(<<x,snd(snd(z))>>) => (tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>))   BECAUSE IntroAndLeft;
tag = snd(<<x,snd(snd(z))>>) => tag = snd(snd(z))  BECAUSE TI;
snd(<<x,snd(snd(z))>>) = tag => tag = snd(snd(z))  BECAUSE TI;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => tag = snd(snd(z))  BECAUSE TI;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => \E x : tag = snd(snd(z))  BECAUSE Q_SCHEME;
(\E x : tag = snd(snd(z))) => tag = snd(snd(z))   BECAUSE Q_SCHEME;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => tag = snd(snd(z))   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE TI;
\A u : \A tag : IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE GENERALIZATION;
IsInInjectOrder(u,pasteTags(Domain(u),{}),z) => {} = snd(snd(z))   BECAUSE \A(u <- u, tag <- {});
IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z) => ordinalOne = snd(snd(z))   BECAUSE \A(u <- v, tag <- ordinalOne);
z \in Ione(u) => IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE EquivToImpl;
z \in Ione(u) => {} = snd(snd(z))   BECAUSE TI;
z \in Itwo(v) => IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE EquivToImpl;
z \in Itwo(v) => ordinalOne = snd(snd(z))   BECAUSE TI;

(z \in Ione(u) /\ z \in Itwo(v)) => ({} = snd(snd(z)) /\ ordinalOne = snd(snd(z)))   BECAUSE MergeImplicationsAnd;
({} = snd(snd(z)) /\ ordinalOne = snd(snd(z))) => {} = ordinalOne   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => {} = ordinalOne   BECAUSE TI;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => ordinalOne = {}   BECAUSE TI;
ordinalOne # {} => ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE Contraposition;
oneIsNotZero   BECAUSE THEOREM;
~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE MODUS_PONENS;
\A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE GENERALIZATION;
AreDisjoint(Ione(u),Itwo(v))   BECAUSE MODUS_PONENS;
(IsOrder(u) /\ IsOrder(v)) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)))   BECAUSE MergeImplicationsAnd;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u), Itwo(v)))   BECAUSE IntroAndLeft;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => IsOrder(Ione(u) \union Itwo(v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(DO(u,v))   BECAUSE TI;
QED
*)

(*
   At the moment, the addition and multiplication of well-orders are not commutative,
   even for finite ones. wellOrderAddition(u,v) and wellOrderAddition(v,u) are
   isomorphic as well-orders, but not equal.

   It would be convenient to fix one representative in each well-order isomorphy
   class, so that addition and multiplication get their usual properties. The
   ordinals achieve that, they find canonical elements for the well-orders' domains.
*)
IsTransitiveSet(x) == \A a : a \in x => a \subseteq x

(*
   Predicate asserting that the set x is strictly well-ordered by the membership
   relation \in. In those sets, \in behaves like < on the natural numbers. Actually,
   those sets start with the natural numbers and \in will be the definition of <.
*)
IsMinimumForIn(m, part) == m \in part /\ \A b : b \in part => (b = m \/ m \in b)
IsTransitiveIn(x) == \A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c
IsWellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ IsTransitiveIn(x)
   /\ (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))

(*
   The class of ordinals, which starts with the natural numbers. This predicate
   rigorously defines what could be naively stated as
      0 = {}
      n = { 0, ..., n-1 }
*)
IsOrdinal(o) == IsTransitiveSet(o) /\ IsWellOrderedByIn(o)

ordinalsWellFounded == \A o : IsOrdinal(o) => o \notin o
THEOREM ordinalsWellFounded
PROOF
VARIABLES a,o;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A a : a \in o => a \notin a)   BECAUSE S13;
IsOrdinal(o) => (\A a : a \in o => a \notin a)   BECAUSE TI;
(\A a : a \in o => a \notin a) => (o \in o => o \notin o)   BECAUSE \A(a <- o);
IsOrdinal(o) => (o \in o => o \notin o)   BECAUSE TI;
absurd(a,b) == (a => (b => ~b)) => (a => ~b)   PROPO_TAUTO;
IsOrdinal(o) => o \notin o   BECAUSE absurd;
ordinalsWellFounded   BECAUSE GENERALIZATION;
QED

ordinalIsTotalOrder == \A o : \A x : \A y : IsOrdinal(o) /\ x \in o /\ y \in o
   => x \in y \/ x = y \/ y \in x
THEOREM ordinalIsTotalOrder
PROOF
VARIABLES a,b,c,d,m,o,p,x,y,z;
\* Because o is an ordinal, the pair {x,y} \subseteq o has a minimum m.
\* This minimum is either x or y.
h(o,x,y) == IsOrdinal(o) /\ x \in o /\ y \in o;
h(o,x,y) => IsOrdinal(o)   BECAUSE S13;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p)) => ({x,y} \subseteq o => {x,y} = {} \/ \E m : IsMinimumForIn(m, {x,y}))   BECAUSE \A(p <- {x,y});
IsOrdinal(o) => ({x,y} \subseteq o => {x,y} = {} \/ \E m : IsMinimumForIn(m, {x,y}))   BECAUSE TI2;
h(o,x,y) => ({x,y} \subseteq o => {x,y} = {} \/ \E m : IsMinimumForIn(m, {x,y}))   BECAUSE TI;
pairExists   BECAUSE THEOREM;
z \in { x, y } <=> (z = x \/ z = y)   BECAUSE \A(c <- x, d <- y, y <- z);
z \in { x, y } => (z = x \/ z = y)   BECAUSE EquivToImpl;
h(o,x,y) => (z \in { x, y } => (z = x \/ z = y))   BECAUSE PT1;
h(o,x,y) /\ z \in { x, y } => (z = x \/ z = y)   BECAUSE HypoImplToAnd;
\A z : \A x : z = x => (z \in o <=> x \in o)   BECAUSE E_SCHEME;
z = x => (z \in o <=> x \in o)   BECAUSE \A(z <- z, x <- x);
h(o,x,y) => x \in o   BECAUSE S23;
mergeImpl(a,b,c,h) == (a => (b <=> c)) => ((h => c) => (h => (a => b)))   PROPO_TAUTO;
h(o,x,y) => (z = x => z \in o)   BECAUSE mergeImpl;
z = y => (z \in o <=> y \in o)   BECAUSE \A(z <- z, x <- y);
h(o,x,y) => y \in o   BECAUSE S22;
h(o,x,y) => (z = y => z \in o)   BECAUSE mergeImpl;
mergeImplB(h,a,b,c) == (h => (a => c)) => ((h => (b => c)) => (h => ((a \/ b) => c)))   PROPO_TAUTO;
h(o,x,y) => (z = x \/ z = y => z \in o)   BECAUSE mergeImplB;
h(o,x,y) /\ z \in {x,y} => h(o,x,y)   BECAUSE S12;
h(o,x,y) /\ z \in {x,y} => (z = x \/ z = y => z \in o)   BECAUSE TI;
h(o,x,y) /\ z \in {x,y} => z \in o   BECAUSE KillMiddleHypo;
h(o,x,y) => (z \in {x,y} => z \in o)   BECAUSE HypoAndToImpl;
\A z : h(o,x,y) => (z \in {x,y} => z \in o)   BECAUSE GENERALIZATION;
h(o,x,y) => {x,y} \subseteq o   BECAUSE Q_SCHEME;
h(o,x,y) => {x,y} = {} \/ \E m : IsMinimumForIn(m, {x,y})   BECAUSE KillMiddleHypo;
emptySetExistsUniquely   BECAUSE THEOREM;
{a,b} = {} <=> \A x : x \notin {a,b}   BECAUSE \A(c <- {a,b});
{a,b} = {} => \A x : x \notin {a,b}   BECAUSE EquivToImpl;
~(\A x : x \notin {a,b}) => {a,b} # {}   BECAUSE Contraposition;
(\E x : x \in {a,b}) <=> ~(\A x : x \notin {a,b})   BECAUSE Q_SCHEME;
(\E x : x \in {a,b}) => ~(\A x : x \notin {a,b})   BECAUSE EquivToImpl;
a \in {a,b} => (\E x : x \in {a,b})   BECAUSE \E(x <- a);
a \in {a,b} => {a,b} # {}   BECAUSE TI2;
a \in { a,b } <=> (a = a \/ a = b)   BECAUSE \A(c <- a, d <- b, y <- a);
(a = a \/ a = b) => a \in { a,b }   BECAUSE EquivToImplReverse;
equalSelf   BECAUSE THEOREM;
a = a   BECAUSE \A(a <- a);
a = a \/ a = b   BECAUSE IntroOrLeft;
a \in { a,b }   BECAUSE MODUS_PONENS;
{a,b} # {}   BECAUSE MODUS_PONENS;
\A a : \A b : {a,b} # {}   BECAUSE GENERALIZATION;
{x,y} # {}   BECAUSE \A(a <- x, b <- y);
killCase(a,b,h) == ~a => ((h => a \/ b) => (h => b))   PROPO_TAUTO;
h(o,x,y) => \E m : IsMinimumForIn(m, {x,y})   BECAUSE killCase;
\* Prove m is x or y
hm(o,x,y,m) == h(o,x,y) /\ IsMinimumForIn(m, {x,y});
hm(o,x,y,m) => IsMinimumForIn(m, {x,y})   BECAUSE S22;
IsMinimumForIn(m, {x,y}) => m \in {x,y}   BECAUSE S12;
m \in { x, y } <=> (m = x \/ m = y)   BECAUSE \A(c <- x, d <- y, y <- m);
m \in { x, y } => (m = x \/ m = y)   BECAUSE EquivToImpl;
hm(o,x,y,m) => m = x \/ m = y   BECAUSE TI2;
\A m : \A a : m = a => (IsMinimumForIn(m, {x,y}) <=> IsMinimumForIn(a, {x,y}))   BECAUSE E_SCHEME;
m = x => (IsMinimumForIn(m, {x,y}) <=> IsMinimumForIn(x, {x,y}))   BECAUSE \A(m <- m, a <- x);
m = y => (IsMinimumForIn(m, {x,y}) <=> IsMinimumForIn(y, {x,y}))   BECAUSE \A(m <- m, a <- y);
mergeImplC(a,b,c,d,e) == (a => (b <=> c)) => ((d => (b <=> e)) => (b /\ (a \/ d) => c \/ e))   PROPO_TAUTO;
IsMinimumForIn(m, {x,y}) /\ (m = x \/ m = y) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})   BECAUSE mergeImplC;
hm(o,x,y,m) => IsMinimumForIn(m, {x,y}) /\ (m = x \/ m = y)   BECAUSE CIA;
hm(o,x,y,m) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})   BECAUSE TI;
h(o,x,y) => (IsMinimumForIn(m, {x,y}) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y}))   BECAUSE HypoAndToImpl;
\A m : h(o,x,y) => (IsMinimumForIn(m, {x,y}) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y}))   BECAUSE GENERALIZATION;
h(o,x,y) => (\A m : IsMinimumForIn(m, {x,y}) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y}))   BECAUSE Q_SCHEME;
(\A m : IsMinimumForIn(m, {x,y}) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})) => ((\E m : IsMinimumForIn(m, {x,y})) => \E m : IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y}))   BECAUSE Q_SCHEME;
h(o,x,y) => ((\E m : IsMinimumForIn(m, {x,y})) => \E m : IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y}))   BECAUSE TI;
h(o,x,y) => \E m : IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})   BECAUSE KillMiddleHypo;
(\E m : IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})   BECAUSE Q_SCHEME;
h(o,x,y) => IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y})   BECAUSE TI;

\* Prove the 3 possible cases
IsMinimumForIn(x, {x,y}) => \A b : b \in {x,y} => (b = x \/ x \in b)   BECAUSE S22;
(\A b : b \in {x,y} => (b = x \/ x \in b)) => (y \in {x,y} => (y = x \/ x \in y))   BECAUSE \A(b <- y);
IsMinimumForIn(x, {x,y}) => (y \in {x,y} => (y = x \/ x \in y))   BECAUSE TI;
y \in { x, y } <=> (y = x \/ y = y)   BECAUSE \A(c <- x, d <- y, y <- y);
y = y   BECAUSE \A(a <- y);
y = x \/ y = y   BECAUSE IntroOrRight;
y \in { x, y }   BECAUSE MODUS_PONENS;
IsMinimumForIn(x, {x,y}) => y \in { x, y }   BECAUSE PT1;
IsMinimumForIn(x, {x,y}) => (y = x \/ x \in y)   BECAUSE KillMiddleHypo;
IsMinimumForIn(y, {x,y}) => \A b : b \in {x,y} => (b = y \/ y \in b)   BECAUSE S22;
(\A b : b \in {x,y} => (b = y \/ y \in b)) => (x \in {x,y} => (x = y \/ y \in x))   BECAUSE \A(b <- x);
IsMinimumForIn(y, {x,y}) => (x \in {x,y} => (x = y \/ y \in x))   BECAUSE TI;
x \in { x, y } <=> (x = x \/ x = y)   BECAUSE \A(c <- x, d <- y, y <- x);
x = x   BECAUSE \A(a <- x);
x = x \/ x = y   BECAUSE IntroOrLeft;
x \in { x, y }   BECAUSE MODUS_PONENS;
IsMinimumForIn(y, {x,y}) => x \in { x, y }   BECAUSE PT1;
IsMinimumForIn(y, {x,y}) => (x = y \/ y \in x)   BECAUSE KillMiddleHypo;
IsMinimumForIn(x, {x,y}) \/ IsMinimumForIn(y, {x,y}) => (y = x \/ x \in y) \/ (x = y \/ y \in x)   BECAUSE MergeImplicationsOr;
y = x => x = y   BECAUSE E_SCHEME;
shuffleCases(a,b,c,d) == (a => b) => ((a \/ c) \/ (b \/ d) => c \/ b \/ d)   PROPO_TAUTO;
(y = x \/ x \in y) \/ (x = y \/ y \in x) => x \in y \/ x = y \/ y \in x   BECAUSE shuffleCases;
h(o,x,y) => x \in y \/ x = y \/ y \in x   BECAUSE TI2;
ordinalIsTotalOrder   BECAUSE GENERALIZATION;
QED

(*
   The strict order \in between the elements of an ordinal p
   extends to p itself, ie p \union {p} is an ordinal and p
   is its maximum.
*)
ordinalComparesWithOwnElements == \A o : \A p : IsOrdinal(p) /\ o \in p
   => o # p /\ p \notin o
THEOREM ordinalComparesWithOwnElements
PROOF
VARIABLES a,o,p,x,z;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(p) => p \notin p   BECAUSE \A(o <- p);
\A o : \A p : o = p => (o \in x <=> p \in x)   BECAUSE E_SCHEME;
o = p => (o \in x <=> p \in x)   BECAUSE \A(o <- o, p <- p);
\A x : o = p => (o \in x <=> p \in x)   BECAUSE GENERALIZATION;
o = p => (o \in p <=> p \in p)   BECAUSE \A(x <- p);
IsOrdinal(p) /\ o = p => p \notin p /\ (o \in p <=> p \in p)   BECAUSE MergeImplicationsAnd;
absurd(a,b,c,d) == (a /\ b => ~c /\ (d <=> c)) => (a /\ d => ~b)   PROPO_TAUTO;
IsOrdinal(p) /\ o \in p => o # p   BECAUSE absurd;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
IsTransitiveSet(p) => (o \in p => o \subseteq p)   BECAUSE \A(a <- o);
IsOrdinal(p) => (o \in p => o \subseteq p)   BECAUSE TI;
IsOrdinal(p) /\ o \in p => o \subseteq p   BECAUSE HypoImplToAnd;
o \subseteq p => (p \in o => p \in p)   BECAUSE \A(z <- p);
IsOrdinal(p) /\ o \in p => (p \in o => p \in p)   BECAUSE TI;
absurdAgain(a,b,c,d) == (a => ~b) => ((a /\ c => (d => b)) => (a /\ c => ~d))   PROPO_TAUTO;
IsOrdinal(p) /\ o \in p => p \notin o   BECAUSE absurdAgain;
IsOrdinal(p) /\ o \in p => o # p /\ p \notin o   BECAUSE CIA;
ordinalComparesWithOwnElements   BECAUSE GENERALIZATION;
QED

elemOfOrdinalIsOrdinal == \A o : \A x : IsOrdinal(o) /\ x \in o => IsOrdinal(x)
THEOREM elemOfOrdinalIsOrdinal
PROOF
VARIABLES a,b,c,o,p,x,z;
h(o,x) == IsOrdinal(o) /\ x \in o;
\* Proof that h(o,x) => IsTransitiveSet(x)
h(o,x) => IsOrdinal(o)   BECAUSE S12;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
h(o,x) => IsTransitiveSet(o)   BECAUSE TI;
IsTransitiveSet(o) => (x \in o => x \subseteq o)   BECAUSE \A(a <- x);
h(o,x) => (x \in o => x \subseteq o)   BECAUSE TI;
h(o,x) => x \in o   BECAUSE S22;
h(o,x) => x \subseteq o   BECAUSE KillMiddleHypo;
x \subseteq o => (a \in x => a \in o)   BECAUSE \A(z <- a);
h(o,x) => (a \in x => a \in o)   BECAUSE TI;
hh(a,o,x) == h(o,x) /\ a \in x;
hh(a,o,x) => a \in o   BECAUSE HypoImplToAnd;
IsTransitiveSet(o) => (a \in o => a \subseteq o)   BECAUSE \A(a <- a);
h(o,x) => (a \in o => a \subseteq o)   BECAUSE TI;
hh(a,o,x) => h(o,x)   BECAUSE S12;
hh(a,o,x) => (a \in o => a \subseteq o)   BECAUSE TI;
hh(a,o,x) => a \subseteq o   BECAUSE KillMiddleHypo;
a \subseteq o => (z \in a => z \in o)   BECAUSE \A(z <- z);
hh(a,o,x) => (z \in a => z \in o)   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o   BECAUSE HypoImplToAnd;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => IsTransitiveIn(o)   BECAUSE S23;
(\A a : \A b : \A c : (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c) => a \in c)
   => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE \A(a <- z, b <- a, c <- x);
IsWellOrderedByIn(o) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
IsOrdinal(o) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
h(o,x) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) /\ z \in a => hh(a,o,x)   BECAUSE S12;
hh(a,o,x) /\ z \in a => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) /\ z \in a => a \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o   BECAUSE CIA;
hh(a,o,x) => x \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => x \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o   BECAUSE CIA;
hh(a,o,x) /\ z \in a => z \in a   BECAUSE S22;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o /\ z \in a   BECAUSE CIA;
hh(a,o,x) => a \in x   BECAUSE S22;
hh(a,o,x) /\ z \in a => a \in x   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x   BECAUSE CIA;
hh(a,o,x) /\ z \in a => z \in x   BECAUSE KillMiddleHypo;
hh(a,o,x) => (z \in a => z \in x)   BECAUSE HypoAndToImpl;
\A z : hh(a,o,x) => (z \in a => z \in x)   BECAUSE GENERALIZATION;
hh(a,o,x) => a \subseteq x   BECAUSE Q_SCHEME;
h(o,x) => (a \in x => a \subseteq x)   BECAUSE HypoAndToImpl;
\A a : h(o,x) => (a \in x => a \subseteq x)   BECAUSE GENERALIZATION;
h(o,x) => IsTransitiveSet(x)   BECAUSE Q_SCHEME;

\* Proof of h(o,x) => IsWellOrderedByIn(x)
IsWellOrderedByIn(o) => \A a : a \in o => a \notin a   BECAUSE S13;
(\A a : a \in o => a \notin a) => (a \in o => a \notin a)   BECAUSE \A(a <- a);
IsWellOrderedByIn(o) => (a \in o => a \notin a)   BECAUSE TI;
IsOrdinal(o) => (a \in o => a \notin a)   BECAUSE TI;
h(o,x) => (a \in o => a \notin a)   BECAUSE TI;
hh(a,o,x) => (a \in o => a \notin a)   BECAUSE TI;
hh(a,o,x) => a \notin a   BECAUSE KillMiddleHypo;
h(o,x) => (a \in x => a \notin a)   BECAUSE HypoAndToImpl;
\A a : h(o,x) => (a \in x => a \notin a)   BECAUSE GENERALIZATION;
h(o,x) => (\A a : a \in x => a \notin a)   BECAUSE Q_SCHEME;

\* Proof of transitivity of the well-order
transitX(a,b,c,o,x) == h(o,x) /\ (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c);
transitX(a,b,c,o,x) => h(o,x)   BECAUSE S12;
transitX(a,b,c,o,x) => (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c)   BECAUSE S22;
(a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => (a \in x /\ b \in x /\ c \in x)   BECAUSE S13;
transitX(a,b,c,o,x) => (a \in x /\ b \in x /\ c \in x)   BECAUSE TI;
(a \in x /\ b \in x /\ c \in x) => a \in x   BECAUSE S13;
(a \in x /\ b \in x /\ c \in x) => b \in x   BECAUSE S23;
(a \in x /\ b \in x /\ c \in x) => c \in x   BECAUSE S22;
transitX(a,b,c,o,x) => a \in x   BECAUSE TI;
transitX(a,b,c,o,x) => b \in x   BECAUSE TI;
transitX(a,b,c,o,x) => c \in x   BECAUSE TI;
transitX(a,b,c,o,x) => h(o,x) /\ a \in x   BECAUSE CIA;
transitX(a,b,c,o,x) => h(o,x) /\ b \in x   BECAUSE CIA;
transitX(a,b,c,o,x) => h(o,x) /\ c \in x   BECAUSE CIA;
\A a : hh(a,o,x) => a \in o   BECAUSE GENERALIZATION;
hh(b,o,x) => b \in o   BECAUSE \A(a <- b);
hh(c,o,x) => c \in o   BECAUSE \A(a <- c);
transitX(a,b,c,o,x) => a \in o   BECAUSE TI;
transitX(a,b,c,o,x) => b \in o   BECAUSE TI;
transitX(a,b,c,o,x) => c \in o   BECAUSE TI;
(a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in b   BECAUSE S23;
(a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => b \in c   BECAUSE S22;
transitX(a,b,c,o,x) => a \in b   BECAUSE TI;
transitX(a,b,c,o,x) => b \in c   BECAUSE TI;
transitX(a,b,c,o,x) => a \in o /\ b \in o   BECAUSE CIA;
transitX(a,b,c,o,x) => a \in o /\ b \in o /\ c \in o   BECAUSE CIA;
transitX(a,b,c,o,x) => a \in o /\ b \in o /\ c \in o /\ a \in b   BECAUSE CIA;
transitX(a,b,c,o,x) => a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c   BECAUSE CIA;
IsTransitiveIn(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)
   BECAUSE \A(a <- a, b <- b, c <- c);
IsWellOrderedByIn(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
IsOrdinal(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
h(o,x) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
transitX(a,b,c,o,x) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
transitX(a,b,c,o,x) => a \in c   BECAUSE KillMiddleHypo;
h(o,x) => ((a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE HypoAndToImpl;
h(o,x) => ((a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE HypoAndToImpl;
\A c : h(o,x) => ((a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,x) => (\A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE Q_SCHEME;
\A b : h(o,x) => (\A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,x) => (\A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE Q_SCHEME;
\A a : h(o,x) => (\A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,x) => IsTransitiveIn(x)   BECAUSE Q_SCHEME;

minPart(o,p,x) == h(o,x) /\ p \subseteq x;
minPart(o,p,x) => h(o,x)   BECAUSE S12;
minPart(o,p,x) => p \subseteq x   BECAUSE S22;
minPart(o,p,x) => x \subseteq o   BECAUSE TI;
transitInclusion   BECAUSE THEOREM;
p \subseteq x /\ x \subseteq o => p \subseteq o   BECAUSE \A(a <- p, b <- x, c <- o);
minPart(o,p,x) => p \subseteq x /\ x \subseteq o   BECAUSE CIA;
minPart(o,p,x) => p \subseteq o   BECAUSE TI;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p)) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE \A(p <- p);
IsWellOrderedByIn(o) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
IsOrdinal(o) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
h(o,x) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
minPart(o,p,x) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
minPart(o,p,x) => (p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE KillMiddleHypo;
h(o,x) => (p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
\A p : h(o,x) => (p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
h(o,x) => (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;

h(o,x) => IsWellOrderedByIn(x)   BECAUSE CIA2;
h(o,x) => IsOrdinal(x)   BECAUSE CIA;
elemOfOrdinalIsOrdinal   BECAUSE GENERALIZATION;
QED

includedOrdinals == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p) /\ o \subseteq p
   => o \in p \/ o = p
THEOREM includedOrdinals
PROOF
VARIABLES a,b,c,o,m,p,u,v,x,y,z;
bothInclusions   BECAUSE THEOREM;
(o \subseteq p /\ p \subseteq o) => o = p   BECAUSE \A(a <- o, b <- p);
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p) /\ o \subseteq p;
h(o,p) => o \subseteq p   BECAUSE S22;
contraPos(a,b,c,h) == ((a /\ b) => c) => ((h => a) => (h /\ ~c => ~b))   PROPO_TAUTO;
h(o,p) /\ o # p => ~(p \subseteq o)   BECAUSE contraPos;

\* Proof that p \ o is not empty
setDifferenceExists   BECAUSE THEOREM;
z \in (p \ o) <=> (z \in p /\ z \notin o)   BECAUSE \A(u <- p, v <- o, x <- z);
(z \in p /\ z \notin o) => z \in (p \ o)   BECAUSE EquivToImplReverse;
z \notin (p \ o) => ~(z \in p /\ z \notin o)   BECAUSE Contraposition;
(\E z : z \in p \ o) <=> ~\A z : z \notin (p \ o)   BECAUSE Q_SCHEME;
~(\A z : z \notin p \ o) => (\E z : z \in p \ o)   BECAUSE EquivToImplReverse;
boolImpl(a,b) == ~(a /\ ~b) => (a => b)   PROPO_TAUTO;
~(z \in p /\ z \notin o) => (z \in p => z \in o)   BECAUSE boolImpl;
z \notin p \ o => (z \in p => z \in o)   BECAUSE TI;
(\A z : z \notin p \ o) => p \subseteq o   BECAUSE Q_SCHEME;
~(p \subseteq o) => ~\A z : z \notin p \ o   BECAUSE Contraposition;
h(o,p) /\ o # p => \E z : z \in (p \ o)   BECAUSE TI2;
emptySetExistsUniquely   BECAUSE THEOREM;
(p \ o) = {} <=> \A x : x \notin p \ o   BECAUSE \A(c <- p \ o);
(p \ o) = {} => \A x : x \notin p \ o   BECAUSE EquivToImpl;
~(\A x : x \notin p \ o) => (p \ o) # {}   BECAUSE Contraposition;
(\E x : x \in (p \ o)) <=> ~\A x : x \notin p \ o   BECAUSE Q_SCHEME;
(\E x : x \in (p \ o)) => ~\A x : x \notin p \ o   BECAUSE EquivToImpl;
z \in (p \ o) => \E x : x \in (p \ o)   BECAUSE \E(x <- z);
(\E z : z \in (p \ o)) => \E z : \E x : x \in (p \ o)   BECAUSE Q_SCHEME;
(\E z : \E x : x \in (p \ o)) => \E x : x \in (p \ o)   BECAUSE Q_SCHEME;
(\E z : z \in (p \ o)) => ~\A x : x \notin p \ o   BECAUSE TI2;
h(o,p) /\ o # p => (p \ o) # {}   BECAUSE TI2;

\* Take m the minimum of p \ o as a subset of ordinal p
h(o,p) => IsOrdinal(p)  BECAUSE S23;
IsWellOrderedByIn(x) => (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p)) => (p \ o \subseteq x => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE \A(p <- p\o);
IsWellOrderedByIn(x) => (p \ o \subseteq x => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE TI;
\A x : IsWellOrderedByIn(x) => (p \ o \subseteq x => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE GENERALIZATION;
IsWellOrderedByIn(p) => (p \ o \subseteq p => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE \A(x <- p);
IsOrdinal(p) => IsWellOrderedByIn(p)   BECAUSE S22;
h(o,p) => (p \ o \subseteq p => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE TI2;
z \in (p \ o) => (z \in p /\ z \notin o)   BECAUSE EquivToImpl;
(z \in p /\ z \notin o) => z \in p   BECAUSE S12;
z \in p \ o => z \in p   BECAUSE TI;
p \ o \subseteq p   BECAUSE GENERALIZATION;
h(o,p) => p \ o \subseteq p   BECAUSE PT1;
h(o,p) => (p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE KillMiddleHypo;
h(o,p) /\ o # p => h(o,p)   BECAUSE S12;
h(o,p) /\ o # p => (p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE TI;
killCase(h,a,b) == (h => ~a) => ((h => a \/ b) => (h => b))   PROPO_TAUTO;
h(o,p) /\ o # p => \E m : IsMinimumForIn(m, p\o)   BECAUSE killCase;
hh(o,p,m) == h(o,p) /\ o # p /\ IsMinimumForIn(m, p\o);

\* Then show that m = o by double inclusion.
\* If x \in m, below minimum so x \in o.
hh(o,p,m) => IsMinimumForIn(m, p\o)   BECAUSE S22;
hh(o,p,m) => h(o,p)   BECAUSE S13;
IsMinimumForIn(m, p\o) => m \in p\o   BECAUSE S12;
IsMinimumForIn(m, p\o) => \A b : b \in p\o => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in p\o => (b = m \/ m \in b)) => (x \in p\o => (x = m \/ m \in x))   BECAUSE \A(b <- x);
hh(o,p,m) => (x \in p\o => (x = m \/ m \in x))   BECAUSE TI2;
hh(o,p,m) => m \in p\o   BECAUSE TI;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(p) /\ m \in p => IsOrdinal(m)   BECAUSE \A(o <- p, x <- m);
m \in (p \ o) <=> (m \in p /\ m \notin o)   BECAUSE \A(u <- p, v <- o, x <- m);
m \in (p \ o) => (m \in p /\ m \notin o)   BECAUSE EquivToImpl;
(m \in p /\ m \notin o) => m \in p   BECAUSE S12;
hh(o,p,m) => m \in p   BECAUSE TI2;
hh(o,p,m) => IsOrdinal(p)   BECAUSE TI;
hh(o,p,m) => IsOrdinal(p) /\ m \in p   BECAUSE CIA;
hh(o,p,m) => IsOrdinal(m)   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ x \in m => x # m /\ m \notin x   BECAUSE \A(o <- x, p <- m);
x \in m => x \in m   BECAUSE ImplySelf;
hh(o,p,m) /\ x \in m => IsOrdinal(m) /\ x \in m   BECAUSE MergeImplicationsAnd;
hh(o,p,m) /\ x \in m => x # m /\ m \notin x   BECAUSE TI;
x # m /\ m \notin x => ~(x = m \/ m \in x)   BECAUSE FactorNotOr;
hh(o,p,m) /\ x \in m => ~(x = m \/ m \in x)   BECAUSE TI;
hh(o,p,m) /\ x \in m => hh(o,p,m)   BECAUSE S12;
hh(o,p,m) /\ x \in m => (x \in p\o => (x = m \/ m \in x))   BECAUSE TI;
contrapos(h,a,b) == (h => ~a) => ((h => (b => a)) => (h => ~b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in m => x \notin p\o   BECAUSE contrapos;
x \in (p \ o) <=> (x \in p /\ x \notin o)   BECAUSE \A(u <- p, v <- o, x <- x);
(x \in p /\ x \notin o) => x \in (p \ o)   BECAUSE EquivToImplReverse;
x \notin (p \ o) => ~(x \in p /\ x \notin o)   BECAUSE Contraposition;
hh(o,p,m) /\ x \in m => ~(x \in p /\ x \notin o)   BECAUSE TI;
IsTransitiveSet(p) => (m \in p => m \subseteq p)   BECAUSE \A(a <- m);
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
hh(o,p,m) => (m \in p => m \subseteq p)   BECAUSE TI2;
hh(o,p,m) => m \subseteq p   BECAUSE KillMiddleHypo;
m \subseteq p => (x \in m => x \in p)   BECAUSE \A(z <- x);
hh(o,p,m) => (x \in m => x \in p)   BECAUSE TI;
hh(o,p,m) /\ x \in m => x \in p   BECAUSE HypoImplToAnd;
killCaseB(h,a,b) == (h => a) => ((h => ~(a /\ ~b)) => (h => b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in m => x \in o   BECAUSE killCaseB;

\* If x \in o, then by total order of p, x \in m.
ordinalIsTotalOrder   BECAUSE THEOREM;
IsOrdinal(p) /\ x \in p /\ m \in p => x \in m \/ x = m \/ m \in x   BECAUSE \A(o <- p, x <- x, y <- m);
hh(o,p,m) /\ x \in o => x \in o   BECAUSE S22;
o \subseteq p => (x \in o => x \in p)   BECAUSE \A(z <- x);
hh(o,p,m) => (x \in o => x \in p)   BECAUSE TI2;
hh(o,p,m) /\ x \in o => x \in p   BECAUSE HypoImplToAnd;
hh(o,p,m) /\ x \in o => hh(o,p,m)   BECAUSE S12;
hh(o,p,m) /\ x \in o => m \in p   BECAUSE TI;
hh(o,p,m) /\ x \in o => IsOrdinal(p)   BECAUSE TI;
hh(o,p,m) /\ x \in o => IsOrdinal(p) /\ x \in p   BECAUSE CIA;
hh(o,p,m) /\ x \in o => IsOrdinal(p) /\ x \in p /\ m \in p   BECAUSE CIA;
hh(o,p,m) /\ x \in o => x \in m \/ x = m \/ m \in x   BECAUSE TI;
(m \in p /\ m \notin o) => m \notin o   BECAUSE S22;
hh(o,p,m) => m \notin o   BECAUSE TI2;
\A x : \A m : x = m => (x \notin o <=> m \notin o)   BECAUSE E_SCHEME;
x = m => (x \notin o <=> m \notin o)   BECAUSE \A(x <- x, m <- m);
implyEquivTrue(a,b,h,t) == (h => t) => ((b => (~a <=> t)) => (h /\ a => ~b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in o => x # m   BECAUSE implyEquivTrue;
IsTransitiveSet(o) => (x \in o => x \subseteq o)   BECAUSE \A(a <- x);
h(o,p) => IsOrdinal(o)  BECAUSE S13;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
hh(o,p,m) => IsOrdinal(o)   BECAUSE TI;
hh(o,p,m) => (x \in o => x \subseteq o)   BECAUSE TI2;
hh(o,p,m) /\ x \in o => x \subseteq o   BECAUSE HypoImplToAnd;
x \subseteq o => (m \in x => m \in o)   BECAUSE \A(z <- m);
hh(o,p,m) /\ x \in o => (m \in x => m \in o)   BECAUSE TI;
hh(o,p,m) /\ x \in o => hh(o,p,m)   BECAUSE S12;
hh(o,p,m) /\ x \in o => m \notin o   BECAUSE TI;
killCaseC(h,a,b) == (h => ~a) => ((h => (b => a)) => (h => ~b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in o => m \notin x   BECAUSE killCaseC;
killCaseD(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
hh(o,p,m) /\ x \in o => x \in m   BECAUSE killCaseD;

hIntroEquiv(h,a,b) == (h /\ a => b) => ((h /\ b => a) => (h => (a <=> b)))   PROPO_TAUTO;
hh(o,p,m) => (x \in o <=> x \in m)   BECAUSE hIntroEquiv;
\A x : hh(o,p,m) => (x \in o <=> x \in m)   BECAUSE GENERALIZATION;
hh(o,p,m) => (\A x : x \in o <=> x \in m)   BECAUSE Q_SCHEME;
extensionality   BECAUSE AXIOM;
(\A x : x \in o <=> x \in m) => o = m   BECAUSE \A(a <- o, b <- m);
hh(o,p,m) => o = m   BECAUSE TI;
\A o : \A m : o = m => (o \in p <=> m \in p)   BECAUSE E_SCHEME;
o = m => (o \in p <=> m \in p)   BECAUSE \A(o <- o, m <- m);
hh(o,p,m) => (o \in p <=> m \in p)   BECAUSE TI;
killCaseE(h,a,t) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hh(o,p,m) => o \in p   BECAUSE killCaseE;
h(o,p) /\ o # p => (IsMinimumForIn(m, p\o) => o \in p)   BECAUSE HypoAndToImpl;
\A m : h(o,p) /\ o # p => (IsMinimumForIn(m, p\o) => o \in p)   BECAUSE GENERALIZATION;
h(o,p) /\ o # p => (\A m : IsMinimumForIn(m, p\o) => o \in p)   BECAUSE Q_SCHEME;
(\A m : IsMinimumForIn(m, p\o) => o \in p) => ((\E m : IsMinimumForIn(m, p\o)) => \E m : o \in p)   BECAUSE Q_SCHEME;
h(o,p) /\ o # p => ((\E m : IsMinimumForIn(m, p\o)) => \E m : o \in p)   BECAUSE TI;
h(o,p) /\ o # p => \E m : o \in p   BECAUSE KillMiddleHypo;
(\E m : o \in p) => o \in p   BECAUSE Q_SCHEME;
h(o,p) /\ o # p => o \in p   BECAUSE TI;
boolImplB(h,a,b) == (h /\ ~a => b) => (h => b \/ a)   PROPO_TAUTO;
h(o,p) => o \in p \/ o = p   BECAUSE boolImplB;
includedOrdinals   BECAUSE GENERALIZATION;
QED

intersectOrdinalsIsOrdinal == \A o : \A q : IsOrdinal(o) /\ IsOrdinal(q) => IsOrdinal(o \intersect q)
THEOREM intersectOrdinalsIsOrdinal
PROOF
VARIABLES a,b,c,o,p,q,u,v,x,z;
\* Qroof that o \intersect q is a transitive set
h(o,q) == IsOrdinal(o) /\ IsOrdinal(q);
h(o,q) => IsOrdinal(o)   BECAUSE S12;
h(o,q) => IsOrdinal(q)   BECAUSE S22;
ht(o,q,a) == h(o,q) /\ a \in (o \intersect q);
ht(o,q,a) => h(o,q)   BECAUSE S12;
ht(o,q,a) => a \in (o \intersect q)   BECAUSE S22;
intersectionExists   BECAUSE THEOREM;
a \in (o \intersect q) <=> (a \in o /\ a \in q)   BECAUSE \A(u <- o, v <- q, x <- a);
a \in (o \intersect q) => (a \in o /\ a \in q)   BECAUSE EquivToImpl;
a \in o /\ a \in q => a \in o   BECAUSE S12;
a \in (o \intersect q) => a \in o   BECAUSE TI;
a \in o /\ a \in q => a \in q   BECAUSE S22;
ht(o,q,a) => a \in o   BECAUSE TI2;
ht(o,q,a) => a \in q   BECAUSE TI2;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
IsOrdinal(q) => IsTransitiveSet(q)   BECAUSE S12;
ht(o,q,a) => IsTransitiveSet(o)   BECAUSE TI2;
ht(o,q,a) => IsTransitiveSet(q)   BECAUSE TI2;
IsTransitiveSet(o) => (a \in o => a \subseteq o)   BECAUSE \A(a <- a);
IsTransitiveSet(q) => (a \in q => a \subseteq q)   BECAUSE \A(a <- a);
ht(o,q,a) => (a \in o => a \subseteq o)   BECAUSE TI;
ht(o,q,a) => (a \in q => a \subseteq q)   BECAUSE TI;
ht(o,q,a) => a \subseteq o   BECAUSE KillMiddleHypo;
ht(o,q,a) => a \subseteq q   BECAUSE KillMiddleHypo;
a \subseteq o => (z \in a => z \in o)   BECAUSE \A(z <- z);
a \subseteq q => (z \in a => z \in q)   BECAUSE \A(z <- z);
ht(o,q,a) => (z \in a => z \in o)   BECAUSE TI;
ht(o,q,a) => (z \in a => z \in q)   BECAUSE TI;
mergeImpl(h,a,b,c) == (h => (a => b)) => ((h => (a => c)) => (h /\ a => b /\ c))   PROPO_TAUTO;
ht(o,q,a) /\ z \in a => z \in o /\ z \in q   BECAUSE mergeImpl;
z \in (o \intersect q) <=> (z \in o /\ z \in q)   BECAUSE \A(u <- o, v <- q, x <- z);
(z \in o /\ z \in q) => z \in (o \intersect q)   BECAUSE EquivToImplReverse;
ht(o,q,a) /\ z \in a => z \in o \intersect q   BECAUSE TI;
ht(o,q,a) => (z \in a => z \in o \intersect q)   BECAUSE HypoAndToImpl;
\A z : ht(o,q,a) => (z \in a => z \in o \intersect q)   BECAUSE GENERALIZATION;
ht(o,q,a) => a \subseteq (o \intersect q)   BECAUSE Q_SCHEME;
h(o,q) => (a \in o \intersect q => a \subseteq (o \intersect q))   BECAUSE HypoAndToImpl;
\A a : h(o,q) => (a \in o \intersect q => a \subseteq (o \intersect q))   BECAUSE GENERALIZATION;
h(o,q) => IsTransitiveSet(o \intersect q)   BECAUSE Q_SCHEME;

\* Proof that o \intersect q is irreflexive
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A a : a \in o => a \notin a)   BECAUSE S13;
h(o,q) => (\A a : a \in o => a \notin a)   BECAUSE TI2;
(\A a : a \in o => a \notin a) => (a \in o => a \notin a)   BECAUSE \A(a <- a);
ht(o,q,a) => (a \in o => a \notin a)   BECAUSE TI2;
ht(o,q,a) => a \notin a   BECAUSE KillMiddleHypo;
h(o,q) => (a \in o \intersect q => a \notin a)   BECAUSE HypoAndToImpl;
\A a : h(o,q) => (a \in o \intersect q => a \notin a)   BECAUSE GENERALIZATION;
h(o,q) => (\A a : a \in o \intersect q => a \notin a)   BECAUSE Q_SCHEME;

\* Proof that o \intersect q is transitive for \in
htt(o,q,a,b,c) == h(o,q) /\ (a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c);
htt(o,q,a,b,c) => h(o,q)   BECAUSE S12;
htt(o,q,a,b,c) => (a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c)   BECAUSE S22;
\A a : a \in (o \intersect q) => a \in o   BECAUSE GENERALIZATION;
(a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c)
   => a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q   BECAUSE S13;
(a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c) => a \in b   BECAUSE S23;
(a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c) => b \in c   BECAUSE S22;
a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q => a \in o \intersect q   BECAUSE S13;
htt(o,q,a,b,c) => a \in o \intersect q   BECAUSE TI2;
htt(o,q,a,b,c) => a \in o   BECAUSE TI;
a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q => b \in o \intersect q   BECAUSE S23;
htt(o,q,a,b,c) => b \in o \intersect q   BECAUSE TI2;
b \in (o \intersect q) => b \in o   BECAUSE \A(a <- b);
htt(o,q,a,b,c) => b \in o   BECAUSE TI;
a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q => c \in o \intersect q   BECAUSE S22;
htt(o,q,a,b,c) => c \in o \intersect q   BECAUSE TI2;
c \in (o \intersect q) => c \in o   BECAUSE \A(a <- c);
htt(o,q,a,b,c) => c \in o   BECAUSE TI;
IsWellOrderedByIn(o) => IsTransitiveIn(o)   BECAUSE S23;
IsTransitiveIn(o) => ((a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c) => a \in c)   BECAUSE \A(a <- a, b <- b, c <- c);
IsOrdinal(o) => ((a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c) => a \in c)   BECAUSE TI2;
htt(o,q,a,b,c) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI2;
htt(o,q,a,b,c) => a \in o /\ b \in o   BECAUSE CIA;
htt(o,q,a,b,c) => a \in o /\ b \in o /\ c \in o   BECAUSE CIA;
htt(o,q,a,b,c) => a \in b   BECAUSE TI;
htt(o,q,a,b,c) => a \in o /\ b \in o /\ c \in o /\ a \in b   BECAUSE CIA;
htt(o,q,a,b,c) => b \in c   BECAUSE TI;
htt(o,q,a,b,c) => a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c   BECAUSE CIA;
htt(o,q,a,b,c) => a \in c   BECAUSE KillMiddleHypo;
h(o,q) => ((a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c) => a \in c)   BECAUSE HypoAndToImpl;
\A c : h(o,q) => ((a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,q) => (\A c : a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A b : h(o,q) => (\A c : a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(o,q) => (\A b : \A c : a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A a : h(o,q) => (\A b : \A c : a \in o \intersect q /\ b \in o \intersect q /\ c \in o \intersect q /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(o,q) => IsTransitiveIn(o \intersect q)   BECAUSE Q_SCHEME;

\* Proof that o \intersect q has all minimums.
\* p \subseteq o \intersect q and p not empty means p \subseteq o.
\* There is a minimum m \in p because o is an ordinal.
hm(o,q,p) == h(o,q) /\ p \subseteq (o \intersect q);
hm(o,q,p) => h(o,q)   BECAUSE S12;
hm(o,q,p) => p \subseteq (o \intersect q)   BECAUSE S22;
p \subseteq (o \intersect q) => (z \in p => z \in o \intersect q)   BECAUSE \A(z <- z);
hm(o,q,p) => (z \in p => z \in o \intersect q)   BECAUSE TI;
hm(o,q,p) /\ z \in p => z \in o \intersect q   BECAUSE HypoImplToAnd;
z \in (o \intersect q) => (z \in o /\ z \in q)   BECAUSE EquivToImpl;
(z \in o /\ z \in q) => z \in o   BECAUSE S12;
hm(o,q,p) /\ z \in p => z \in o   BECAUSE TI2;
hm(o,q,p) => (z \in p => z \in o)   BECAUSE HypoAndToImpl;
\A z : hm(o,q,p) => (z \in p => z \in o)   BECAUSE GENERALIZATION;
hm(o,q,p) => p \subseteq o   BECAUSE Q_SCHEME;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p)) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE \A(p <- p);
IsWellOrderedByIn(o) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
h(o,q) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI2;
hm(o,q,p) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
hm(o,q,p) => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE KillMiddleHypo;
h(o,q) => (p \subseteq o \intersect q => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
\A p : h(o,q) => (p \subseteq o \intersect q => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
h(o,q) => (\A p : p \subseteq (o \intersect q) => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;

h(o,q) => (\A a : a \in o \intersect q => a \notin a) /\ IsTransitiveIn(o \intersect q)   BECAUSE CIA;
h(o,q) => IsWellOrderedByIn(o \intersect q)   BECAUSE CIA;
h(o,q) => IsOrdinal(o \intersect q)   BECAUSE CIA;
intersectOrdinalsIsOrdinal   BECAUSE GENERALIZATION;
QED

ordinalComparisonLarge == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p)
   => o \subseteq p \/ p \subseteq o
THEOREM ordinalComparisonLarge
PROOF
VARIABLES a,b,c,d,o,p,q,u,v,x,y,z;
\* o \intersect p is an ordinal included in both o and p
\* By the previous theorem, either (o \intersect p) \in o or (o \intersect p) = o
\* Same (o \intersect p) \in p or (o \intersect p) = p
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p);
h(o,p) => IsOrdinal(o)   BECAUSE S12;
h(o,p) => IsOrdinal(p)   BECAUSE S22;
intersectOrdinalsIsOrdinal   BECAUSE THEOREM;
h(o,p) => IsOrdinal(o \intersect p)   BECAUSE \A(o <- o, q <- p);
intersectIncludes   BECAUSE THEOREM;
(o \intersect p) \subseteq p   BECAUSE \A(a <- o, b <- p);
(p \intersect o) \subseteq o   BECAUSE \A(a <- p, b <- o);
intersectSymmetry   BECAUSE THEOREM;
(p \intersect o) = (o \intersect p)   BECAUSE \A(x <- p, y <- o);
\A x : \A y : x = y => (x \subseteq o <=> y \subseteq o)   BECAUSE E_SCHEME;
(p \intersect o) = (o \intersect p) => (p \intersect o \subseteq o <=> o \intersect p \subseteq o)   BECAUSE \A(x <- p \intersect o, y <- o \intersect p);
(p \intersect o \subseteq o <=> o \intersect p \subseteq o)   BECAUSE MODUS_PONENS;
o \intersect p \subseteq o   BECAUSE MODUS_PONENS;
includedOrdinals   BECAUSE THEOREM;
IsOrdinal(o \intersect p) /\ IsOrdinal(p) /\ (o \intersect p) \subseteq p
   => (o \intersect p) \in p \/ (o \intersect p) = p   BECAUSE \A(o <- o \intersect p, p <- p);
IsOrdinal(o \intersect p) /\ IsOrdinal(o) /\ (o \intersect p) \subseteq o
   => (o \intersect p) \in o \/ (o \intersect p) = o   BECAUSE \A(o <- o \intersect p, p <- o);
h(o,p) => IsOrdinal(o \intersect p) /\ IsOrdinal(p)   BECAUSE CIA;
h(o,p) => (o \intersect p) \subseteq p   BECAUSE PT1;
h(o,p) => IsOrdinal(o \intersect p) /\ IsOrdinal(p) /\ (o \intersect p) \subseteq p   BECAUSE CIA;
h(o,p) => (o \intersect p) \in p \/ (o \intersect p) = p   BECAUSE TI;
h(o,p) => IsOrdinal(o \intersect p) /\ IsOrdinal(o)   BECAUSE CIA;
h(o,p) => (o \intersect p) \subseteq o   BECAUSE PT1;
h(o,p) => IsOrdinal(o \intersect p) /\ IsOrdinal(o) /\ (o \intersect p) \subseteq o   BECAUSE CIA;
h(o,p) => (o \intersect p) \in o \/ (o \intersect p) = o   BECAUSE TI;
h(o,p) => ((o \intersect p) \in o \/ (o \intersect p) = o) /\ ((o \intersect p) \in p \/ (o \intersect p) = p)   BECAUSE CIA;

\* But both \in would yield (o \intersect p) \in (o \intersect p), absurd
intersectionExists   BECAUSE THEOREM;
(o \intersect p) \in (o \intersect p) <=> ((o \intersect p) \in o /\ (o \intersect p) \in p)   BECAUSE \A(u <- o, v <- p, x <- o \intersect p);
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(o \intersect p) => (o \intersect p) \notin (o \intersect p)   BECAUSE \A(o <- o \intersect p);
h(o,p) => (o \intersect p) \notin (o \intersect p)   BECAUSE TI;
((o \intersect p) \in o /\ (o \intersect p) \in p) => (o \intersect p) \in (o \intersect p)   BECAUSE EquivToImplReverse;
(o \intersect p) \notin (o \intersect p) => ~((o \intersect p) \in o /\ (o \intersect p) \in p)   BECAUSE Contraposition;
h(o,p) => ~((o \intersect p) \in o /\ (o \intersect p) \in p)   BECAUSE TI;
h(o,p) => ((o \intersect p) \in o \/ (o \intersect p) = o)
          /\ ((o \intersect p) \in p \/ (o \intersect p) = p)
	  /\ ~((o \intersect p) \in o /\ (o \intersect p) \in p)   BECAUSE CIA;
killCase(a,b,c,d) == (a \/ b) /\ (c \/ d) /\ ~(a /\ c) => b \/ d   PROPO_TAUTO;
((o \intersect p) \in o \/ (o \intersect p) = o)
          /\ ((o \intersect p) \in p \/ (o \intersect p) = p)
	  /\ ~((o \intersect p) \in o /\ (o \intersect p) \in p) => (o \intersect p) = o \/ (o \intersect p) = p   BECAUSE killCase;
h(o,p) => (o \intersect p) = o \/ (o \intersect p) = p   BECAUSE TI;

\A x : \A y : x = y => (z \in x <=> z \in y)   BECAUSE E_SCHEME;
o \intersect p = o => (z \in o \intersect p <=> z \in o)   BECAUSE \A(x <- o \intersect p, y <- o);
z \in (o \intersect p) <=> (z \in o /\ z \in p)   BECAUSE \A(u <- o, v <- p, x <- z);
mergeEquiv(a,b,c,d) == (a => (b <=> c)) => ((b <=> c /\ d) => (a => (c => d)))   PROPO_TAUTO;
o \intersect p = o => (z \in o => z \in p)   BECAUSE mergeEquiv;
\A z : o \intersect p = o => (z \in o => z \in p)   BECAUSE GENERALIZATION;
o \intersect p = o => o \subseteq p   BECAUSE Q_SCHEME;

o \intersect p = p => (z \in o \intersect p <=> z \in p)   BECAUSE \A(x <- o \intersect p, y <- p);
mergeEquivB(a,b,c,d) == (a => (b <=> c)) => ((b <=> d /\ c) => (a => (c => d)))   PROPO_TAUTO;
o \intersect p = p => (z \in p => z \in o)   BECAUSE mergeEquivB;
\A z : o \intersect p = p => (z \in p => z \in o)   BECAUSE GENERALIZATION;
o \intersect p = p => p \subseteq o   BECAUSE Q_SCHEME;
o \intersect p = o \/ o \intersect p = p => o \subseteq p \/ p \subseteq o    BECAUSE MergeImplicationsOr;
h(o,p) => o \subseteq p \/ p \subseteq o    BECAUSE TI;
ordinalComparisonLarge   BECAUSE GENERALIZATION;
QED

ordinalComparison == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p)
   => o \in p \/ o = p \/ p \in o
THEOREM ordinalComparison
PROOF
\* Combine ordinalComparisonLarge and includedOrdinals
VARIABLES o,p;
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p);
h(o,p) => IsOrdinal(o)   BECAUSE S12;
h(o,p) => IsOrdinal(p)   BECAUSE S22;
ordinalComparisonLarge   BECAUSE THEOREM;
h(o,p) => o \subseteq p \/ p \subseteq o   BECAUSE \A(o <- o, p <- p);
includedOrdinals   BECAUSE THEOREM;
h(o,p) /\ o \subseteq p => o \in p \/ o = p   BECAUSE \A(o <- o, p <- p);
IsOrdinal(p) /\ IsOrdinal(o) /\ p \subseteq o => p \in o \/ p = o   BECAUSE \A(o <- p, p <- o);
IsOrdinal(p) /\ IsOrdinal(o) => (p \subseteq o => p \in o \/ p = o)   BECAUSE HypoAndToImpl;
h(o,p) => IsOrdinal(p) /\ IsOrdinal(o)   BECAUSE CIA;
h(o,p) => (p \subseteq o => p \in o \/ p = o)   BECAUSE TI;
mergeImpl(a,b,c,d,h) == (h => a \/ b) => ((h /\ a => c) => (((h => (b => d)) => (h => c \/ d))))   PROPO_TAUTO;
h(o,p) => (o \in p \/ o = p) \/ (p \in o \/ p = o)   BECAUSE mergeImpl;
p = o => o = p   BECAUSE E_SCHEME;
killCase(a,b,c,d) == (a => b) => ((c \/ b) \/ (d \/ a) => c \/ b \/ d)   PROPO_TAUTO;
(o \in p \/ o = p) \/ (p \in o \/ p = o) => o \in p \/ o = p \/ p \in o   BECAUSE killCase;
h(o,p) => o \in p \/ o = p \/ p \in o   BECAUSE TI;
ordinalComparison   BECAUSE GENERALIZATION;
QED

unionOrdinalsIsOrdinal == \A u : (\A x : x \in u => IsOrdinal(x)) => IsOrdinal(UNION u)
THEOREM unionOrdinalsIsOrdinal
PROOF
VARIABLES a,b,c,m,o,p,q,t,u,v,x,y,z;
h(u) == \A x : x \in u => IsOrdinal(x);
\* Proof that UNION u is transitive
unionExists   BECAUSE AXIOM;
(a \in UNION u <=> \E t : t \in u /\ a \in t)   BECAUSE \A(b <- u, z <- a);
a \in UNION u => \E t : t \in u /\ a \in t   BECAUSE EquivToImpl;
ht(a,u,t) == h(u) /\ t \in u /\ a \in t;
ht(a,u,t) => h(u)   BECAUSE S13;
ht(a,u,t) => t \in u   BECAUSE S23;
h(u) => (t \in u => IsOrdinal(t))   BECAUSE \A(x <- t);
ht(a,u,t) => (t \in u => IsOrdinal(t))   BECAUSE TI;
ht(a,u,t) => IsOrdinal(t)   BECAUSE KillMiddleHypo;
IsOrdinal(t) => IsTransitiveSet(t)   BECAUSE S12;
IsTransitiveSet(x) => (a \in x => a \subseteq x)  BECAUSE \A(a <- a);
\A x : IsTransitiveSet(x) => (a \in x => a \subseteq x)  BECAUSE GENERALIZATION;
IsTransitiveSet(t) => (a \in t => a \subseteq t)  BECAUSE \A(x <- t);
ht(a,u,t) => (a \in t => a \subseteq t)   BECAUSE TI2;
t \in u /\ a \in t => a \in t   BECAUSE S22;
ht(a,u,t) => a \in t   BECAUSE S22;
ht(a,u,t) => a \subseteq t   BECAUSE KillMiddleHypo;
a \subseteq t => (z \in a => z \in t)   BECAUSE \A(z <- z);
ht(a,u,t) => (z \in a => z \in t)   BECAUSE TI;
ht(a,u,t) /\ z \in a => z \in t   BECAUSE HypoImplToAnd;
inInUnion   BECAUSE THEOREM;
z \in t /\ t \in u => z \in UNION u   BECAUSE \A(a <- z, b <- t, c <- u);
ht(a,u,t) /\ z \in a => ht(a,u,t)   BECAUSE S12;
ht(a,u,t) /\ z \in a => t \in u   BECAUSE TI;
ht(a,u,t) /\ z \in a => z \in t /\ t \in u   BECAUSE CIA;
ht(a,u,t) /\ z \in a => z \in UNION u   BECAUSE TI;
ht(a,u,t) => (z \in a => z \in UNION u)   BECAUSE HypoAndToImpl;
\A z : ht(a,u,t) => (z \in a => z \in UNION u)   BECAUSE GENERALIZATION;
ht(a,u,t) => a \subseteq UNION u   BECAUSE Q_SCHEME;
pushHypos(h,a,b,c) == (h /\ a /\ b => c) => (h => (a /\ b => c))   PROPO_TAUTO;
h(u) => ((t \in u /\ a \in t) => a \subseteq UNION u)   BECAUSE pushHypos;
\A t : h(u) => ((t \in u /\ a \in t) => a \subseteq UNION u)   BECAUSE GENERALIZATION;
h(u) => (\A t : (t \in u /\ a \in t) => a \subseteq UNION u)   BECAUSE Q_SCHEME;
(\A t : (t \in u /\ a \in t) => a \subseteq UNION u) => ((\E t : t \in u /\ a \in t) => \E t : a \subseteq UNION u)   BECAUSE Q_SCHEME;
h(u) => ((\E t : t \in u /\ a \in t) => \E t : a \subseteq UNION u)   BECAUSE TI;
mergeImpl(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(u) /\ a \in UNION u => \E t : a \subseteq UNION u   BECAUSE mergeImpl;
(\E t : a \subseteq UNION u) => a \subseteq UNION u   BECAUSE Q_SCHEME;
h(u) /\ a \in UNION u => a \subseteq UNION u   BECAUSE TI;
h(u) => (a \in UNION u => a \subseteq UNION u)   BECAUSE HypoAndToImpl;
\A a : h(u) => (a \in UNION u => a \subseteq UNION u)   BECAUSE GENERALIZATION;
h(u) => IsTransitiveSet(UNION u)   BECAUSE Q_SCHEME;

\* Proof that UNION u is irreflexive
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(t) /\ a \in t => IsOrdinal(a)   BECAUSE \A(o <- t, x <- a);
ht(a,u,t) => IsOrdinal(t) /\ a \in t   BECAUSE CIA;
ht(a,u,t) => IsOrdinal(a)   BECAUSE TI;
h(u) => (t \in u /\ a \in t => IsOrdinal(a))   BECAUSE pushHypos;
\A t : h(u) => (t \in u /\ a \in t => IsOrdinal(a))   BECAUSE GENERALIZATION;
h(u) => (\A t : t \in u /\ a \in t => IsOrdinal(a))   BECAUSE Q_SCHEME;
(\A t : t \in u /\ a \in t => IsOrdinal(a)) => ((\E t : t \in u /\ a \in t) => \E t : IsOrdinal(a))   BECAUSE Q_SCHEME;
h(u) => ((\E t : t \in u /\ a \in t) => \E t : IsOrdinal(a))   BECAUSE TI;
h(u) /\ a \in UNION u => \E t : IsOrdinal(a)   BECAUSE mergeImpl;
(\E t : IsOrdinal(a)) => IsOrdinal(a)   BECAUSE Q_SCHEME;
h(u) /\ a \in UNION u => IsOrdinal(a)   BECAUSE TI;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(a) => a \notin a   BECAUSE \A(o <- a);
h(u) /\ a \in UNION u => a \notin a   BECAUSE TI;
h(u) => (a \in UNION u => a \notin a)   BECAUSE HypoAndToImpl;
\A a : h(u) => (a \in UNION u => a \notin a)   BECAUSE GENERALIZATION;
h(u) => (\A a : a \in UNION u => a \notin a)   BECAUSE Q_SCHEME;

\* Proof that \in is transitive on UNION u.
\* h(u) /\ c \in UNION u /\ b \in c /\ a \in b => a \in c.
\A a : ht(a,u,t) => IsOrdinal(t)   BECAUSE GENERALIZATION;
ht(c,u,t) => IsOrdinal(t)   BECAUSE \A(a <- c);
\A a : ht(a,u,t) => a \in t   BECAUSE GENERALIZATION;
ht(c,u,t) => c \in t   BECAUSE \A(a <- c);
IsOrdinal(t) /\ c \in t => IsOrdinal(c)   BECAUSE \A(o <- t, x <- c);
ht(c,u,t) => IsOrdinal(t) /\ c \in t   BECAUSE CIA;
ht(c,u,t) => IsOrdinal(c)   BECAUSE TI;
IsOrdinal(c) => IsTransitiveSet(c)   BECAUSE S12;
IsTransitiveSet(c) => (b \in c => b \subseteq c)   BECAUSE \A(a <- b);
ht(c,u,t) => (b \in c => b \subseteq c)   BECAUSE TI2;
ht(c,u,t) /\ b \in c => b \subseteq c   BECAUSE HypoImplToAnd;
b \subseteq c => (a \in b => a \in c)   BECAUSE \A(z <- a);
ht(c,u,t) /\ b \in c => (a \in b => a \in c)  BECAUSE TI;
ht(c,u,t) /\ b \in c /\ a \in b => a \in c  BECAUSE HypoImplToAnd;
ht(c,u,t) => (b \in c /\ a \in b => a \in c)  BECAUSE pushHypos;
h(u) => ((t \in u /\ c \in t) => (b \in c /\ a \in b => a \in c))  BECAUSE pushHypos;
\A t : h(u) => ((t \in u /\ c \in t) => (b \in c /\ a \in b => a \in c))  BECAUSE GENERALIZATION;
h(u) => (\A t : (t \in u /\ c \in t) => (b \in c /\ a \in b => a \in c))  BECAUSE Q_SCHEME;
(\A t : (t \in u /\ c \in t) => (b \in c /\ a \in b => a \in c)) => ((\E t : t \in u /\ c \in t) => (\E t : b \in c /\ a \in b => a \in c))   BECAUSE Q_SCHEME;
h(u) => ((\E t : t \in u /\ c \in t) => (\E t : b \in c /\ a \in b => a \in c))  BECAUSE TI;
(c \in UNION u <=> \E t : t \in u /\ c \in t)   BECAUSE \A(b <- u, z <- c);
c \in UNION u => \E t : t \in u /\ c \in t   BECAUSE EquivToImpl;
h(u) /\ c \in UNION u => (\E t : b \in c /\ a \in b => a \in c)  BECAUSE mergeImpl;
(\E t : b \in c /\ a \in b => a \in c) => (b \in c /\ a \in b => a \in c)   BECAUSE Q_SCHEME;
h(u) /\ c \in UNION u => (b \in c /\ a \in b => a \in c)  BECAUSE TI;
pullHypos(a,b,c,d) == (a => (b /\ c => d)) => (a /\ b /\ c => d)   PROPO_TAUTO;
h(u) /\ c \in UNION u /\ b \in c /\ a \in b => a \in c  BECAUSE pullHypos;
\* Add quantifiers for IsTransitiveIn
shuffleHypos(a,c,d,e,h) == h /\ (a /\ c /\ d /\ e) => h /\ c /\ e /\ d   PROPO_TAUTO;
h(u) /\ (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c)
   => h(u) /\ c \in UNION u /\ b \in c /\ a \in b   BECAUSE shuffleHypos;
h(u) /\ (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c)
   => a \in c   BECAUSE TI;
h(u) => (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE HypoAndToImpl;
\A c : h(u) => (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(u) => (\A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A b : h(u) => (\A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(u) => (\A b : \A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A a : h(u) => (\A b : \A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(u) => IsTransitiveIn(UNION u)   BECAUSE Q_SCHEME;

\* Proof that minimums exist
hm(u,p,z,t) == h(u) /\ p \subseteq (UNION u) /\ p # {} /\ (z \in p /\ t \in u /\ z \in t);
hm(u,p,z,t) => h(u)   BECAUSE S14;
hm(u,p,z,t) => p # {}   BECAUSE S23;
hm(u,p,z,t) => p \subseteq (UNION u)   BECAUSE S24;
hm(u,p,z,t) => z \in p /\ t \in u /\ z \in t   BECAUSE S22;
notEmpty   BECAUSE THEOREM;
p # {} => \E z : z \in p   BECAUSE \A(x <- p);
\* z is in one the ordinals of u, which minimum we will take
z \in p /\ t \in u /\ z \in t => z \in p   BECAUSE S13;
z \in p /\ t \in u /\ z \in t => t \in u   BECAUSE S23;
z \in p /\ t \in u /\ z \in t => z \in t   BECAUSE S22;
hm(u,p,z,t) => z \in p   BECAUSE TI;
p \subseteq (UNION u) => (z \in p => z \in UNION u)   BECAUSE \A(z <- z);
hm(u,p,z,t) => (z \in p => z \in UNION u)   BECAUSE TI;
hm(u,p,z,t) => z \in UNION u   BECAUSE KillMiddleHypo;
z \in UNION u <=> \E t : t \in u /\ z \in t   BECAUSE \A(b <- u, z <- z);
z \in UNION u => \E t : t \in u /\ z \in t   BECAUSE EquivToImpl;
hm(u,p,z,t) => t \in u   BECAUSE TI;
h(u) => (t \in u => IsOrdinal(t))   BECAUSE \A(x <- t);
hm(u,p,z,t) => (t \in u => IsOrdinal(t))   BECAUSE TI;
hm(u,p,z,t) => IsOrdinal(t)   BECAUSE KillMiddleHypo; \* Take the minimum of p in this ordinal
IsWellOrderedByIn(t) => (\A p : p \subseteq t => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq t => p = {} \/ \E m : IsMinimumForIn(m, p)) => (q \subseteq t => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE \A(p <- q);
IsWellOrderedByIn(t) => (q \subseteq t => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE TI;
\A z : IsWellOrderedByIn(t) => (q \subseteq t => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE GENERALIZATION;
IsWellOrderedByIn(t) => (q \subseteq t => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE \A(z <- p);
IsOrdinal(t) => IsWellOrderedByIn(t)   BECAUSE S22;
hm(u,p,z,t) => (q \subseteq t => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE TI2; \* take q = p \intersect t
\A q : hm(u,p,z,t) => (q \subseteq t => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE GENERALIZATION;
hm(u,p,z,t) => ((p \intersect t) \subseteq t => (p \intersect t) = {} \/ \E m : IsMinimumForIn(m, p \intersect t))   BECAUSE \A(q <- p \intersect t);
intersectIncludes   BECAUSE THEOREM;
(p \intersect t) \subseteq t   BECAUSE \A(a <- p, b <- t);
hm(u,p,z,t) => (p \intersect t) \subseteq t   BECAUSE PT1;
hm(u,p,z,t) => (p \intersect t) = {} \/ \E m : IsMinimumForIn(m, p \intersect t)   BECAUSE KillMiddleHypo;
emptySetExistsUniquely   BECAUSE THEOREM;
(p \intersect t) = {} <=> \A x : x \notin (p \intersect t)   BECAUSE \A(c <- p \intersect t);
(p \intersect t) = {} => \A x : x \notin (p \intersect t)   BECAUSE EquivToImpl;
(\A x : x \notin (p \intersect t)) => z \notin (p \intersect t)   BECAUSE \A(x <- z);
(p \intersect t) = {} => z \notin (p \intersect t)   BECAUSE TI;
~(z \notin (p \intersect t)) => (p \intersect t) # {}   BECAUSE Contraposition;
t \in u /\ z \in t => z \in t   BECAUSE S22;
hm(u,p,z,t) => z \in t   BECAUSE TI;
hm(u,p,z,t) => z \in p /\ z \in t   BECAUSE CIA;
intersectionExists   BECAUSE THEOREM;
z \in (p \intersect t) <=> (z \in p /\ z \in t)   BECAUSE \A(u <- p, v <- t, x <- z);
(z \in p /\ z \in t) => z \in (p \intersect t)   BECAUSE EquivToImplReverse;
z \in (p \intersect t) => ~(z \notin (p \intersect t))   BECAUSE IntroNotNot;
hm(u,p,z,t) => ~(z \notin (p \intersect t))   BECAUSE TI2;
hm(u,p,z,t) => (p \intersect t) # {}   BECAUSE TI;
killCase(a,b,h) == (h => ~a) => ((h => a \/ b) => (h => b))   PROPO_TAUTO;
hm(u,p,z,t) => \E m : IsMinimumForIn(m, p \intersect t)   BECAUSE killCase; \* Show that this minimum works for all UNION u
hmin(u,p,z,t,m) == hm(u,p,z,t) /\ IsMinimumForIn(m, p \intersect t);
hmin(u,p,z,t,m) => hm(u,p,z,t)   BECAUSE S12;
hmin(u,p,z,t,m) => IsMinimumForIn(m, p \intersect t)   BECAUSE S22;
IsMinimumForIn(m, p \intersect t) => m \in (p \intersect t)   BECAUSE S12;
hmin(u,p,z,t,m) => m \in (p \intersect t)   BECAUSE TI;
m \in (p \intersect t) <=> (m \in p /\ m \in t)   BECAUSE \A(u <- p, v <- t, x <- m);
m \in (p \intersect t) => (m \in p /\ m \in t)   BECAUSE EquivToImpl;
(m \in p /\ m \in t) => m \in t   BECAUSE S22;
(m \in p /\ m \in t) => m \in p   BECAUSE S12;
hmin(u,p,z,t,m) => m \in p   BECAUSE TI2; \* First condition for IsMinimumForIn(m, p)
hmin(u,p,z,t,m) => m \in t   BECAUSE TI2;
IsOrdinal(t) /\ m \in t => IsOrdinal(m)   BECAUSE \A(o <- t, x <- m);
hmin(u,p,z,t,m) => IsOrdinal(t)   BECAUSE TI;
hmin(u,p,z,t,m) => IsOrdinal(t) /\ m \in t   BECAUSE CIA;
hmin(u,p,z,t,m) => IsOrdinal(m)   BECAUSE TI;

ordinalComparison   BECAUSE THEOREM;
IsOrdinal(b) /\ IsOrdinal(m) => b \in m \/ b = m \/ m \in b   BECAUSE \A(o <- b, p <- m);
\* First case impossible : if there was a b \in m and \in p,
\* then b \in t by transitivity of t,
\* that b would be in p \intersect t, contradicting the minimality of m
hh(u,p,z,t,m,b) == hmin(u,p,z,t,m) /\ b \in p /\ b \in m;
hh(u,p,z,t,m,b) => hmin(u,p,z,t,m)   BECAUSE S13;
hh(u,p,z,t,m,b) => b \in p   BECAUSE S23;
hh(u,p,z,t,m,b) => b \in m   BECAUSE S22;
IsOrdinal(t) => IsTransitiveSet(t)   BECAUSE S12;
IsTransitiveSet(t) => (m \in t => m \subseteq t)   BECAUSE \A(a <- m);
hmin(u,p,z,t,m) => (m \in t => m \subseteq t)   BECAUSE TI2;
hmin(u,p,z,t,m) => m \subseteq t   BECAUSE KillMiddleHypo;
m \subseteq t => (b \in m => b \in t)   BECAUSE \A(z <- b);
hh(u,p,z,t,m,b) => (b \in m => b \in t)   BECAUSE TI2;
hh(u,p,z,t,m,b) => b \in t   BECAUSE KillMiddleHypo;
hh(u,p,z,t,m,b) => b \in p /\ b \in t   BECAUSE CIA;
b \in (p \intersect t) <=> (b \in p /\ b \in t)   BECAUSE \A(u <- p, v <- t, x <- b);
(b \in p /\ b \in t) => b \in (p \intersect t)   BECAUSE EquivToImplReverse;
hh(u,p,z,t,m,b) => b \in p \intersect t   BECAUSE TI;
IsMinimumForIn(m, p \intersect t) => \A b : b \in p \intersect t => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in p \intersect t => (b = m \/ m \in b)) => (b \in p \intersect t => (b = m \/ m \in b))   BECAUSE \A(b <- b);
IsMinimumForIn(m, p \intersect t) => (b \in p \intersect t => (b = m \/ m \in b))   BECAUSE TI;
hh(u,p,z,t,m,b) => (b \in p \intersect t => (b = m \/ m \in b))   BECAUSE TI2;
hh(u,p,z,t,m,b) => b = m \/ m \in b   BECAUSE KillMiddleHypo;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ b \in m => b # m /\ m \notin b   BECAUSE \A(o <- b, p <- m);
hh(u,p,z,t,m,b) => IsOrdinal(m)   BECAUSE TI;
hh(u,p,z,t,m,b) => IsOrdinal(m) /\ b \in m   BECAUSE CIA;
hh(u,p,z,t,m,b) => b # m /\ m \notin b   BECAUSE TI;
absurd(h,b,c,d) == (h /\ b => c \/ d) => ((h /\ b => ~c /\ ~d) => (h => ~b))   PROPO_TAUTO;
hmin(u,p,z,t,m) /\ b \in p => b \notin m   BECAUSE absurd;

hmin(u,p,z,t,m) => p \subseteq UNION u   BECAUSE TI;
p \subseteq UNION u => (b \in p => b \in UNION u)   BECAUSE \A(z <- b);
hmin(u,p,z,t,m) => (b \in p => b \in UNION u)   BECAUSE TI;
hmin(u,p,z,t,m) /\ b \in p => b \in UNION u   BECAUSE HypoImplToAnd;
\A a : h(u) /\ a \in UNION u => IsOrdinal(a)   BECAUSE GENERALIZATION;
h(u) /\ b \in UNION u => IsOrdinal(b)   BECAUSE \A(a <- b);
hmin(u,p,z,t,m) /\ b \in p => hmin(u,p,z,t,m)   BECAUSE S12;
hmin(u,p,z,t,m) /\ b \in p => h(u)   BECAUSE TI2;
hmin(u,p,z,t,m) /\ b \in p => h(u) /\ b \in UNION u   BECAUSE CIA;
hmin(u,p,z,t,m) /\ b \in p => IsOrdinal(b)   BECAUSE TI;
hmin(u,p,z,t,m) /\ b \in p => IsOrdinal(m)   BECAUSE TI;
hmin(u,p,z,t,m) /\ b \in p => IsOrdinal(b) /\ IsOrdinal(m)   BECAUSE CIA;
hmin(u,p,z,t,m) /\ b \in p => b \in m \/ b = m \/ m \in b   BECAUSE TI;

killCaseB(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~a) => (h => b \/ c))   PROPO_TAUTO;
hmin(u,p,z,t,m) /\ b \in p => b = m \/ m \in b   BECAUSE killCaseB;
hmin(u,p,z,t,m) => (b \in p => b = m \/ m \in b)   BECAUSE HypoAndToImpl;
\A b : hmin(u,p,z,t,m) => (b \in p => b = m \/ m \in b)   BECAUSE GENERALIZATION;
hmin(u,p,z,t,m) => (\A b : b \in p => b = m \/ m \in b)   BECAUSE Q_SCHEME;
hmin(u,p,z,t,m) => IsMinimumForIn(m, p)   BECAUSE CIA;

\* Discharge existential hypotheses
IsMinimumForIn(m, p) => \E m : IsMinimumForIn(m, p)   BECAUSE \E(m <- m);
hmin(u,p,z,t,m) => \E m : IsMinimumForIn(m, p)   BECAUSE TI;
hm(u,p,z,t) => (IsMinimumForIn(m, p \intersect t) => \E m : IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
\A m : hm(u,p,z,t) => (IsMinimumForIn(m, p \intersect t) => \E m : IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
hm(u,p,z,t) => (\A m : IsMinimumForIn(m, p \intersect t) => \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
(\A m : IsMinimumForIn(m, p \intersect t) => \E m : IsMinimumForIn(m, p)) => ((\E m : IsMinimumForIn(m, p \intersect t)) => \E m : \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
hm(u,p,z,t) => ((\E m : IsMinimumForIn(m, p \intersect t)) => \E m : \E m : IsMinimumForIn(m, p))   BECAUSE TI;
hm(u,p,z,t) => \E m : \E m : IsMinimumForIn(m, p)   BECAUSE KillMiddleHypo;
(\E m : \E m : IsMinimumForIn(m, p)) => \E m : IsMinimumForIn(m, p)   BECAUSE Q_SCHEME;
hm(u,p,z,t) => \E m : IsMinimumForIn(m, p)   BECAUSE TI;

h(u) /\ p \subseteq (UNION u) /\ p # {}
   => ((z \in p /\ t \in u /\ z \in t) => \E m : IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
pullHypo(a,b,c,d) == (a /\ b /\ c => d) => (a => (b /\ c => d))   PROPO_TAUTO;
((z \in p /\ t \in u /\ z \in t) => \E m : IsMinimumForIn(m, p)) => (z \in p => (t \in u /\ z \in t => \E m : IsMinimumForIn(m, p)))   BECAUSE pullHypo;
h(u) /\ p \subseteq (UNION u) /\ p # {}
   => (z \in p => (t \in u /\ z \in t => \E m : IsMinimumForIn(m, p)))   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p
   => (t \in u /\ z \in t => \E m : IsMinimumForIn(m, p))   BECAUSE HypoImplToAnd;
\A t : h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p
   => (t \in u /\ z \in t => \E m : IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p
   => (\A t : t \in u /\ z \in t => \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
(\A t : t \in u /\ z \in t => \E m : IsMinimumForIn(m, p)) => ((\E t : t \in u /\ z \in t) => \E t : \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p
   => ((\E t : t \in u /\ z \in t) => \E t : \E m : IsMinimumForIn(m, p))   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p => p \subseteq UNION u   BECAUSE S24;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p => z \in p   BECAUSE S22;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p => p \subseteq (UNION u) /\ z \in p   BECAUSE CIA;
p \subseteq (UNION u) /\ z \in p => z \in UNION u   BECAUSE HypoImplToAnd;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p => z \in UNION u   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p => (\E t : t \in u /\ z \in t)   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p
   => (\E t : \E m : IsMinimumForIn(m, p))   BECAUSE KillMiddleHypo;
(\E t : \E m : IsMinimumForIn(m, p)) => (\E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
h(u) /\ p \subseteq (UNION u) /\ p # {} /\ z \in p => (\E m : IsMinimumForIn(m, p))   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} => (z \in p => (\E m : IsMinimumForIn(m, p)))   BECAUSE HypoAndToImpl;
\A z : h(u) /\ p \subseteq (UNION u) /\ p # {} => (z \in p => (\E m : IsMinimumForIn(m, p)))   BECAUSE GENERALIZATION;
h(u) /\ p \subseteq (UNION u) /\ p # {} => (\A z : z \in p => (\E m : IsMinimumForIn(m, p)))   BECAUSE Q_SCHEME;
(\A z : z \in p => (\E m : IsMinimumForIn(m, p))) => ((\E z : z \in p) => \E z : (\E m : IsMinimumForIn(m, p)))   BECAUSE Q_SCHEME;
h(u) /\ p \subseteq (UNION u) /\ p # {} => ((\E z : z \in p) => (\E z : \E m : IsMinimumForIn(m, p)))   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} => p # {}   BECAUSE S22;
h(u) /\ p \subseteq (UNION u) /\ p # {} => \E z : z \in p   BECAUSE TI;
h(u) /\ p \subseteq (UNION u) /\ p # {} => (\E z : \E m : IsMinimumForIn(m, p))   BECAUSE KillMiddleHypo;
(\E z : \E m : IsMinimumForIn(m, p)) => (\E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
h(u) /\ p \subseteq (UNION u) /\ p # {} => \E m : IsMinimumForIn(m, p)   BECAUSE TI;
pushCase(a,b,c) == (a /\ ~b => c) => (a => b \/ c)   PROPO_TAUTO;
h(u) /\ p \subseteq (UNION u) => (p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE pushCase;
h(u) => (p \subseteq (UNION u) => (p = {} \/ \E m : IsMinimumForIn(m, p)))   BECAUSE HypoAndToImpl;
\A p : h(u) => (p \subseteq (UNION u) => (p = {} \/ \E m : IsMinimumForIn(m, p)))   BECAUSE GENERALIZATION;
h(u) => (\A p : p \subseteq (UNION u) => (p = {} \/ \E m : IsMinimumForIn(m, p)))   BECAUSE Q_SCHEME;

h(u) => (\A a : a \in UNION u => a \notin a) /\ IsTransitiveIn(UNION u)   BECAUSE CIA;
h(u) => IsWellOrderedByIn(UNION u)   BECAUSE CIA;
h(u) => IsOrdinal(UNION u)   BECAUSE CIA;
unionOrdinalsIsOrdinal   BECAUSE GENERALIZATION;
QED

\* The only increasing bijection between two ordinals is the identity function.
\* Which means two ordinals in increasing bijection are equal.
bijectOrdinalsEqual == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p)
        /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   => o = p
THEOREM bijectOrdinalsEqual
PROOF
VARIABLES a,b,d,f,g,i,o,p,x,y,z;
\* If f is not the identity, there is a minimum element m(o,p) such that
\* f[m(o,p)] # m(o,p). But then we will show that m(o,p) \in p and
\* f doesn't reach it, contradicting f is bijection.
cf(o,p) == CHOOSE f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y];
\* By separation, take the subset of o where cf[x] # x
\A a : \E b : \A x : x \in b <=> x \in a /\ cf(o,p)[x] # x   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in o /\ cf(o,p)[x] # x   BECAUSE \A(a <- o);
cb(o,p) == CHOOSE b : \A x : x \in b <=> x \in o /\ cf(o,p)[x] # x;
\A x : x \in cb(o,p) <=> x \in o /\ cf(o,p)[x] # x   BECAUSE CHOOSE cb(o,p);
cm(o,p) == CHOOSE m : IsMinimumForIn(m, cb(o,p)); \* we will show that m does not exist
IsMinimumForIn(cm(o,p), cb(o,p)) => cm(o,p) \in cb(o,p)   BECAUSE S12;
cm(o,p) \in cb(o,p) <=> cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE \A(x <- cm(o,p));
cm(o,p) \in cb(o,p) => cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE EquivToImpl;
cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p) => cm(o,p) \in o   BECAUSE S12;
cm(o,p) \in cb(o,p) => cm(o,p) \in o   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => cm(o,p) \in o   BECAUSE TI;
\* The hypotheses and all their implications. Prove that h(o,p) is false,
\* in other words ~IsMinimumForIn(cm(o,p), cb(o,p)).
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p)
        /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   /\ IsMinimumForIn(cm(o,p), cb(o,p));
h(o,p) => h(o,p)   BECAUSE ImplySelf;
h(o,p) => IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE S22;
h(o,p) => IsOrdinal(o) /\ IsOrdinal(p)   BECAUSE S13;
IsOrdinal(o) /\ IsOrdinal(p) => IsOrdinal(p)   BECAUSE S22;
h(o,p) => IsOrdinal(p)   BECAUSE TI;
IsOrdinal(o) /\ IsOrdinal(p) => IsOrdinal(o)   BECAUSE S12;
h(o,p) => IsOrdinal(o)   BECAUSE TI;
h(o,p) => (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])   BECAUSE S23;
(\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE CHOOSE cf(o,p);
h(o,p) => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE TI;
(cf(o,p) \in Bijections(o,p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => cf(o,p) \in Bijections(o,p)   BECAUSE S12;
h(o,p) => cf(o,p) \in Bijections(o,p)   BECAUSE TI;
(cf(o,p) \in Bijections(o,p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]   BECAUSE S22;
h(o,p) => \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]   BECAUSE TI;

\* Proof that h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z
\* (z is below the minimum cm(o,p), so doesn't have its defining property)
h(o,p) => cm(o,p) \in o   BECAUSE TI;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(o) /\ cm(o,p) \in o => IsOrdinal(cm(o,p))   BECAUSE \A(o <- o, x <- cm(o,p));
h(o,p) => IsOrdinal(o) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => IsOrdinal(cm(o,p))   BECAUSE TI;
bijApply   BECAUSE THEOREM;
(cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in o) => cf(o,p)[cm(o,p)] \in p
   BECAUSE \A(f <- cf(o,p), a <- o, b <- p, x <- cm(o,p));
h(o,p) => cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => cf(o,p)[cm(o,p)] \in p   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => \A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)   BECAUSE S22;
h(o,p) => \A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)   BECAUSE TI;
(\A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)) => (z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z))
   BECAUSE \A(b <- z);
h(o,p) => (z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z))   BECAUSE TI;
h(o,p) /\ z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE HypoImplToAnd;
~(z = cm(o,p) \/ cm(o,p) \in z) => ~(h(o,p) /\ z \in cb(o,p))   BECAUSE Contraposition;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) /\ z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z   BECAUSE \A(o <- z, p <- cm(o,p));
IsOrdinal(cm(o,p)) => (z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z)   BECAUSE HypoAndToImpl;
h(o,p) => (z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z)   BECAUSE TI;
z # cm(o,p) /\ cm(o,p) \notin z => ~(z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE FactorNotOr;
h(o,p) /\ z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z   BECAUSE HypoImplToAnd;
h(o,p) /\ z \in cm(o,p) => ~(z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => ~(h(o,p) /\ z \in cb(o,p))   BECAUSE TI;
killCase(a,b,c) == (a /\ b => ~(a /\ c)) => (a /\ b => ~c)   PROPO_TAUTO;
h(o,p) /\ z \in cm(o,p) => z \notin cb(o,p)   BECAUSE killCase;
z \in cb(o,p) <=> z \in o /\ cf(o,p)[z] # z   BECAUSE \A(x <- z);
z \in o /\ cf(o,p)[z] # z => z \in cb(o,p)   BECAUSE EquivToImplReverse;
z \notin cb(o,p) => ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE Contraposition;
h(o,p) /\ z \in cm(o,p) => ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE TI;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
IsTransitiveSet(o) => (cm(o,p) \in o => cm(o,p) \subseteq o)   BECAUSE \A(a <- cm(o,p));
IsTransitiveSet(o) /\ cm(o,p) \in o => cm(o,p) \subseteq o   BECAUSE HypoImplToAnd;
h(o,p) => IsTransitiveSet(o)   BECAUSE TI;
h(o,p) => IsTransitiveSet(o) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => cm(o,p) \subseteq o   BECAUSE TI;
cm(o,p) \subseteq o => (z \in cm(o,p) => z \in o)   BECAUSE \A(z <- z);
h(o,p) => (z \in cm(o,p) => z \in o)   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => z \in o   BECAUSE HypoImplToAnd;
h(o,p) /\ z \in cm(o,p) => z \in o /\ ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE CIA;
killCaseB(a,b) == a /\ ~(a /\ ~b) => b   PROPO_TAUTO;
z \in o /\ ~(z \in o /\ cf(o,p)[z] # z) => cf(o,p)[z] = z   BECAUSE killCaseB;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z   BECAUSE TI;

\* Proof that cm(o,p) \subseteq cf(o,p)[cm(o,p)]
(\A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])
   => (z \in cm(o,p) /\ cm(o,p) \in o => cf(o,p)[z] \in cf(o,p)[cm(o,p)])   BECAUSE \A(x <- z, y <- cm(o,p));
h(o,p) => (z \in cm(o,p) /\ cm(o,p) \in o => cf(o,p)[z] \in cf(o,p)[cm(o,p)])   BECAUSE TI;
h(o,p) /\ (z \in cm(o,p) /\ cm(o,p) \in o) => cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE HypoImplToAnd;
pushHypo(a,b,c) == (a => c) => (a /\ b => a /\ (b /\ c))   PROPO_TAUTO;
h(o,p) /\ z \in cm(o,p) => h(o,p) /\ (z \in cm(o,p) /\ cm(o,p) \in o)   BECAUSE pushHypo;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z /\ cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE CIA;
\A y : \A z : y = z => (y \in cf(o,p)[cm(o,p)] <=> z \in cf(o,p)[cm(o,p)])   BECAUSE E_SCHEME;
cf(o,p)[z] = z => (cf(o,p)[z] \in cf(o,p)[cm(o,p)] <=> z \in cf(o,p)[cm(o,p)])   BECAUSE \A(y <- cf(o,p)[z], z <- z);
cf(o,p)[z] = z /\ cf(o,p)[z] \in cf(o,p)[cm(o,p)] => z \in cf(o,p)[cm(o,p)]   BECAUSE HypoEquivToAnd;
h(o,p) /\ z \in cm(o,p) => z \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) => (z \in cm(o,p) => z \in cf(o,p)[cm(o,p)])   BECAUSE HypoAndToImpl;
\A z : h(o,p) => (z \in cm(o,p) => z \in cf(o,p)[cm(o,p)])   BECAUSE GENERALIZATION;
h(o,p) => cm(o,p) \subseteq cf(o,p)[cm(o,p)]   BECAUSE Q_SCHEME;

\* Proof that h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)] \in p. By ordinal comparison,
\* cm(o,p) \subseteq cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)] \/ cm(o,p) \in cf(o,p)[cm(o,p)],
\* and since f[m] # m we have the other case.
includedOrdinals   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)]) /\ cm(o,p) \subseteq cf(o,p)[cm(o,p)]
   => cm(o,p) \in cf(o,p)[cm(o,p)] \/ cm(o,p) = cf(o,p)[cm(o,p)]
   BECAUSE \A(o <- cm(o,p), p <- cf(o,p)[cm(o,p)]);
IsOrdinal(p) /\ cf(o,p)[cm(o,p)] \in p => IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE \A(o <- p, x <- cf(o,p)[cm(o,p)]);
h(o,p) => IsOrdinal(p) /\ cf(o,p)[cm(o,p)] \in p   BECAUSE CIA;
h(o,p) => IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE TI;
h(o,p) => IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE CIA;
h(o,p) => IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)]) /\ cm(o,p) \subseteq cf(o,p)[cm(o,p)]   BECAUSE CIA;
h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)] \/ cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE TI;
cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE S22;
cm(o,p) \in cb(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
h(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
cm(o,p) = cf(o,p)[cm(o,p)] => cf(o,p)[cm(o,p)] = cm(o,p)   BECAUSE E_SCHEME;
cf(o,p)[cm(o,p)] # cm(o,p) => cm(o,p) # cf(o,p)[cm(o,p)]   BECAUSE Contraposition;
h(o,p) => cm(o,p) # cf(o,p)[cm(o,p)]   BECAUSE TI;
killCaseC(a,b,c) == (a => ~b) => ((a => (c \/ b)) => (a => c))   PROPO_TAUTO;
h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE killCaseC;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
IsTransitiveSet(p) => (cf(o,p)[cm(o,p)] \in p => cf(o,p)[cm(o,p)] \subseteq p)   BECAUSE \A(a <- cf(o,p)[cm(o,p)]);
IsTransitiveSet(p) /\ cf(o,p)[cm(o,p)] \in p => cf(o,p)[cm(o,p)] \subseteq p   BECAUSE HypoImplToAnd;
h(o,p) => IsTransitiveSet(p)   BECAUSE TI;
h(o,p) => IsTransitiveSet(p) /\ cf(o,p)[cm(o,p)] \in p   BECAUSE CIA;
h(o,p) => cf(o,p)[cm(o,p)] \subseteq p   BECAUSE TI;
cf(o,p)[cm(o,p)] \subseteq p => (cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p)   BECAUSE \A(z <- cm(o,p));
h(o,p) => (cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p   BECAUSE HypoImplToAnd;
h(o,p) => h(o,p) /\ cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE CIA;
h(o,p) => cm(o,p) \in p   BECAUSE TI;

\* Proof that f doesn't reach m, which contradicts that
\* f is a bijection. There are 3 cases :
\*    - z \in m => f[z] = z # m
\*    - f[m] # m
\*    - m \in z => m \in f[m] \in f[z]
bijPreApply   BECAUSE THEOREM;
(cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in p) => pre(cf(o,p),cm(o,p)) \in o
   BECAUSE \A(f <- cf(o,p), a <- o, b <- p, y <- cm(o,p));
h(o,p) => (cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in p)   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \in o   BECAUSE TI;
ordinalIsTotalOrder   BECAUSE THEOREM;
IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o /\ cm(o,p) \in o
   => pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))
   BECAUSE \A(o <- o, x <- pre(cf(o,p),cm(o,p)), y <- cm(o,p));
h(o,p) => IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o   BECAUSE CIA;
h(o,p) => IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))
   BECAUSE TI;
funcInversePre   BECAUSE THEOREM;
IsFunction(cf(o,p)) /\ cm(o,p) \in Image(cf(o,p)) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)
   BECAUSE \A(f <- cf(o,p), y <- cm(o,p));
bijectionsExists   BECAUSE THEOREM;
cf(o,p) \in Bijections(o,p) <=> IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p   BECAUSE \A(d <- o, i <- p, f <- cf(o,p));
cf(o,p) \in Bijections(o,p) => IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p   BECAUSE EquivToImpl;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => IsInjection(cf(o,p))   BECAUSE S13;
cf(o,p) \in Bijections(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) => IsFunction(cf(o,p))   BECAUSE S12;
h(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
h(o,p) => IsFunction(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Image(cf(o,p)) = p   BECAUSE S22;
cf(o,p) \in Bijections(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
h(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
\A x : \A y : x = y => (cm(o,p) \in x <=> cm(o,p) \in y)   BECAUSE E_SCHEME;
Image(cf(o,p)) = p => (cm(o,p) \in Image(cf(o,p)) <=> cm(o,p) \in p)   BECAUSE \A(x <- Image(cf(o,p)), y <- p);
h(o,p) => (cm(o,p) \in Image(cf(o,p)) <=> cm(o,p) \in p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in p => cm(o,p) \in Image(cf(o,p))   BECAUSE HypoEquivToAndReverse;
h(o,p) => h(o,p) /\ cm(o,p) \in p   BECAUSE CIA;
h(o,p) => cm(o,p) \in Image(cf(o,p))   BECAUSE TI;
h(o,p) => IsFunction(cf(o,p)) /\ cm(o,p) \in Image(cf(o,p))   BECAUSE CIA;
h(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)   BECAUSE TI;
\* First case
\A z : h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z   BECAUSE GENERALIZATION;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)
   => cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))   BECAUSE \A(z <- pre(cf(o,p),cm(o,p)));
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => h(o,p)   BECAUSE S12;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)   BECAUSE TI;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)
   => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))   BECAUSE CIA;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))
   => cm(o,p) = pre(cf(o,p),cm(o,p))   BECAUSE E_SCHEME;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) = pre(cf(o,p),cm(o,p))   BECAUSE TI;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => pre(cf(o,p),cm(o,p)) \in cm(o,p)   BECAUSE S22;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) = pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)   BECAUSE CIA;
\A x : \A y : x = y => (x \in cm(o,p) <=> y \in cm(o,p))   BECAUSE E_SCHEME;
cm(o,p) = pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cm(o,p) <=> pre(cf(o,p),cm(o,p)) \in cm(o,p))   BECAUSE \A(x <- cm(o,p), y <- pre(cf(o,p),cm(o,p)));
cm(o,p) = pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) \in cm(o,p)   BECAUSE HypoEquivToAndReverse;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) \in cm(o,p)   BECAUSE TI;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) => cm(o,p) \notin cm(o,p)   BECAUSE \A(o <- cm(o,p));
h(o,p) => cm(o,p) \notin cm(o,p)   BECAUSE TI;
killCaseD(h,a,b) == (h => ~a) => ((h /\ b => a) => (h => ~b))   PROPO_TAUTO;
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p)   BECAUSE killCaseD;
\* Second case
\A x : \A y : x = y => (cf(o,p)[x] = cf(o,p)[y])   BECAUSE E_SCHEME;
pre(cf(o,p),cm(o,p)) = cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)]   BECAUSE \A(x <- pre(cf(o,p),cm(o,p)), y <- cm(o,p));
h(o,p) /\ pre(cf(o,p),cm(o,p)) = cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)]   BECAUSE MergeImplicationsAnd;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE E_SCHEME;
h(o,p) /\ pre(cf(o,p),cm(o,p)) = cm(o,p) => cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) => pre(cf(o,p),cm(o,p)) # cm(o,p)   BECAUSE killCaseD;
\* Third case
(\A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])
   => (cm(o,p) \in pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in o => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))])   BECAUSE \A(x <- cm(o,p), y <- pre(cf(o,p),cm(o,p)));
h(o,p) => (cm(o,p) \in pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in o => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))])   BECAUSE TI;
killCaseE(h,a,b,c) == (h => b) => ((h => (a /\ b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))]   BECAUSE killCaseE;
\A x : \A y : x = y => (cf(o,p)[cm(o,p)] \in x <=> cf(o,p)[cm(o,p)] \in y)   BECAUSE E_SCHEME;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) => (cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] <=> cf(o,p)[cm(o,p)] \in cm(o,p))   BECAUSE \A(x <- cf(o,p)[pre(cf(o,p),cm(o,p))], y <- cm(o,p));
h(o,p) => (cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] <=> cf(o,p)[cm(o,p)] \in cm(o,p))   BECAUSE TI;
h(o,p) /\ cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] => cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE HypoEquivToAnd;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => h(o,p)   BECAUSE S12;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => h(o,p) /\ cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))]   BECAUSE CIA;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE CIA;
IsOrdinal(cm(o,p)) => IsTransitiveSet(cm(o,p))   BECAUSE S12;
IsTransitiveSet(cm(o,p)) => (a \in cm(o,p) => a \subseteq cm(o,p))   BECAUSE \A(a <- a);
h(o,p) => IsTransitiveSet(cm(o,p))   BECAUSE TI;
h(o,p) => (a \in cm(o,p) => a \subseteq cm(o,p))   BECAUSE TI;
h(o,p) /\ a \in cm(o,p) => a \subseteq cm(o,p)   BECAUSE HypoImplToAnd;
a \subseteq cm(o,p) => (cm(o,p) \in a => cm(o,p) \in cm(o,p))   BECAUSE \A(z <- cm(o,p));
h(o,p) /\ a \in cm(o,p) => (cm(o,p) \in a => cm(o,p) \in cm(o,p))   BECAUSE TI;
switchImpl(a,b,c,h) == (h /\ a => (b => c)) => (h => (b /\ a => c))   PROPO_TAUTO;
h(o,p) => (cm(o,p) \in a /\ a \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE switchImpl;
\A a : h(o,p) => (cm(o,p) \in a /\ a \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE GENERALIZATION;
h(o,p) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE \A(a <- cf(o,p)[cm(o,p)]);
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)) /\ (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE CIA;
andMP(a,b) == (a /\ (a => b)) => b   PROPO_TAUTO;
(cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)) /\ (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p)) => cm(o,p) \in cm(o,p)   BECAUSE andMP;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cm(o,p)   BECAUSE TI;
h(o,p) => cm(o,p) \notin pre(cf(o,p),cm(o,p))   BECAUSE killCaseD;

\* Conclusion that h(o,p) is false
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p)   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p) /\ cm(o,p) \notin pre(cf(o,p),cm(o,p))   BECAUSE CIA;
FactorNotOr3(a,b,c) == (~a /\ ~b /\ ~c) => ~(a \/ b \/ c)   PROPO_TAUTO;
pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p) /\ cm(o,p) \notin pre(cf(o,p),cm(o,p))
   => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE FactorNotOr3;
h(o,p) => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE TI;
h(o,p) => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))) /\ (pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE CIA;
absurd(a,h) == h => (~a /\ a) => ~h   PROPO_TAUTO;
~h(o,p)   BECAUSE absurd;
killCaseF(a,b) == ~(a /\ b) => (a => ~b)   PROPO_TAUTO;
\* The correct hypothesis
hh(o,p) == IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y]);
hh(o,p) => ~IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE killCaseF;
(\E m : IsMinimumForIn(m, cb(o,p))) => IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE CHOOSE cm(o,p);
~IsMinimumForIn(cm(o,p), cb(o,p)) => ~(\E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE Contraposition;
hh(o,p) => ~(\E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE TI;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))
   => (cb(o,p) \subseteq o => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE \A(p <- cb(o,p));
IsWellOrderedByIn(o) => (cb(o,p) \subseteq o => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE TI;
z \in cb(o,p) <=> z \in o /\ cf(o,p)[z] # z   BECAUSE \A(x <- z);
z \in cb(o,p) => z \in o /\ cf(o,p)[z] # z   BECAUSE EquivToImpl;
z \in o /\ cf(o,p)[z] # z => z \in o   BECAUSE S12;
z \in cb(o,p) => z \in o   BECAUSE TI;
cb(o,p) \subseteq o   BECAUSE GENERALIZATION;
cb(o,p) \subseteq o => (IsWellOrderedByIn(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE SwitchHypos;
IsWellOrderedByIn(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE MODUS_PONENS;
IsOrdinal(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE TI;
hh(o,p) => IsOrdinal(o)   BECAUSE S13;
hh(o,p) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE TI;
killCaseG(h,a,b) == (h => ~a) => ((h => b \/ a) => (h => b))   PROPO_TAUTO;
hh(o,p) => cb(o,p) = {}   BECAUSE killCaseG;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
cb(o,p) = {} => (a \in cb(o,p) <=> a \in {})   BECAUSE \A(x <- cb(o,p), y <- {});
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
implyEquivFalse(a,b,f) == ~f => ((a => (b <=> f)) => (a => ~b))   PROPO_TAUTO;
cb(o,p) = {} => a \notin cb(o,p)   BECAUSE implyEquivFalse;
a \in cb(o,p) <=> a \in o /\ cf(o,p)[a] # a   BECAUSE \A(x <- a);
a \in o /\ cf(o,p)[a] # a => a \in cb(o,p)   BECAUSE EquivToImplReverse;
a \notin cb(o,p) => ~(a \in o /\ cf(o,p)[a] # a)   BECAUSE Contraposition;
cb(o,p) = {} => ~(a \in o /\ cf(o,p)[a] # a)   BECAUSE TI;
distribImpl(a,b) == ~(a /\ ~b) => (a => b)   PROPO_TAUTO;
~(a \in o /\ cf(o,p)[a] # a) => (a \in o => cf(o,p)[a] = a)   BECAUSE distribImpl;
cb(o,p) = {} => (a \in o => cf(o,p)[a] = a)   BECAUSE TI;
hh(o,p) => (a \in o => cf(o,p)[a] = a)   BECAUSE TI;
\* Prove hh(o,p) => cf(o,p) = identity(o) by funcEqual,
\* then its domain and image are the same, o = p.
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Domain(cf(o,p)) = o   BECAUSE S23;
cf(o,p) \in Bijections(o,p) => Domain(cf(o,p)) = o   BECAUSE TI;
hh(o,p) => (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])   BECAUSE S22;
hh(o,p) => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE TI;
(cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => cf(o,p) \in Bijections(o, p)   BECAUSE S12;
hh(o,p) => cf(o,p) \in Bijections(o, p)   BECAUSE TI;
hh(o,p) => Domain(cf(o,p)) = o   BECAUSE TI;
identityBiject   BECAUSE THEOREM;
identity(o) \in Bijections(o,o)   BECAUSE \A(d <- o);
identity(o) \in Bijections(o,o) <=> IsInjection(identity(o)) /\ Domain(identity(o)) = o /\ Image(identity(o)) = o
   BECAUSE \A(d <- o, i <- o, f <- identity(o));
IsInjection(identity(o)) /\ Domain(identity(o)) = o /\ Image(identity(o)) = o   BECAUSE MODUS_PONENS;
IsInjection(identity(o))   BECAUSE S13;
IsFunction(identity(o))   BECAUSE S12;
Domain(identity(o)) = o   BECAUSE S23;
funcEqual   BECAUSE THEOREM;
IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))
   /\ (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])
   => cf(o,p) = identity(o)   BECAUSE \A(f <- cf(o,p), g <- identity(o));
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => IsInjection(cf(o,p))   BECAUSE S13;
cf(o,p) \in Bijections(o, p) => IsInjection(cf(o,p))   BECAUSE TI;
hh(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) => IsFunction(cf(o,p))   BECAUSE S12;
hh(o,p) => IsFunction(cf(o,p))   BECAUSE TI;
hh(o,p) => IsFunction(identity(o))   BECAUSE PT1;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o))  BECAUSE CIA;
hh(o,p) => Domain(identity(o)) = o   BECAUSE PT1;
hh(o,p) => Domain(cf(o,p)) = o /\ Domain(identity(o)) = o   BECAUSE CIA;
Domain(cf(o,p)) = o /\ Domain(identity(o)) = o => Domain(cf(o,p)) = Domain(identity(o))   BECAUSE E_SCHEME;
hh(o,p) => Domain(cf(o,p)) = Domain(identity(o))   BECAUSE TI;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o))   BECAUSE CIA;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))   BECAUSE CIA;
identityVal   BECAUSE THEOREM;
a \in o => (identity(o)[a] = a /\ pre(identity(o),a) = a)   BECAUSE \A(d <- o, x <- a);
(identity(o)[a] = a /\ pre(identity(o),a) = a) => identity(o)[a] = a   BECAUSE S12;
a \in o => identity(o)[a] = a   BECAUSE TI;
hh(o,p) => (a \in o => identity(o)[a] = a)   BECAUSE PT1;
hh(o,p) /\ a \in o => identity(o)[a] = a   BECAUSE HypoImplToAnd;
hh(o,p) /\ a \in o => cf(o,p)[a] = a   BECAUSE HypoImplToAnd;
hh(o,p) /\ a \in o => cf(o,p)[a] = a /\ identity(o)[a] = a   BECAUSE CIA;
cf(o,p)[a] = a /\ identity(o)[a] = a => cf(o,p)[a] = identity(o)[a]   BECAUSE E_SCHEME;
hh(o,p) /\ a \in o => cf(o,p)[a] = a /\ identity(o)[a] = a   BECAUSE CIA;
hh(o,p) /\ a \in o => cf(o,p)[a] = identity(o)[a]   BECAUSE TI;
hh(o,p) => (a \in o => cf(o,p)[a] = identity(o)[a])   BECAUSE HypoAndToImpl;
\A x : \A y : x = y => ((a \in x => cf(o,p)[a] = identity(o)[a]) <=> (a \in y => cf(o,p)[a] = identity(o)[a]))
   BECAUSE E_SCHEME;
Domain(cf(o,p)) = o => ((a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a]) <=> (a \in o => cf(o,p)[a] = identity(o)[a]))   BECAUSE \A(x <- Domain(cf(o,p)), y <- o);
hh(o,p) => ((a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a]) <=> (a \in o => cf(o,p)[a] = identity(o)[a]))   BECAUSE TI;
hh(o,p) /\ (a \in o => cf(o,p)[a] = identity(o)[a]) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE HypoEquivToAndReverse;
hh(o,p) => hh(o,p)   BECAUSE ImplySelf;
hh(o,p) => hh(o,p) /\ (a \in o => cf(o,p)[a] = identity(o)[a])   BECAUSE CIA;
hh(o,p) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE TI;
\A a : hh(o,p) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE GENERALIZATION;
hh(o,p) => (x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE \A(a <- x);
\A x : hh(o,p) => (x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE GENERALIZATION;
hh(o,p) => (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE Q_SCHEME;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))
   /\ (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE CIA;
hh(o,p) => cf(o,p) = identity(o)   BECAUSE TI;
\A x : \A y : x = y => Image(x) = Image(y)   BECAUSE E_SCHEME;
cf(o,p) = identity(o) => Image(cf(o,p)) = Image(identity(o))   BECAUSE \A(x <- cf(o,p), y <- identity(o));
hh(o,p) => Image(cf(o,p)) = Image(identity(o))   BECAUSE TI;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Image(cf(o,p)) = p   BECAUSE S22;
hh(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
hh(o,p) => Image(cf(o,p)) = p /\ Image(cf(o,p)) = Image(identity(o))   BECAUSE CIA;
Image(cf(o,p)) = p /\ Image(cf(o,p)) = Image(identity(o)) => p = Image(identity(o))  BECAUSE E_SCHEME;
hh(o,p) => p = Image(identity(o))  BECAUSE TI;
Image(identity(o)) = o   BECAUSE S22;
Image(identity(o)) = o => o = Image(identity(o))   BECAUSE E_SCHEME;
o = Image(identity(o))   BECAUSE MODUS_PONENS;
hh(o,p) => o = Image(identity(o))   BECAUSE PT1;
hh(o,p) => o = Image(identity(o)) /\ p = Image(identity(o))   BECAUSE CIA;
o = Image(identity(o)) /\ p = Image(identity(o)) => o = p   BECAUSE E_SCHEME;
hh(o,p) => o = p   BECAUSE TI;
bijectOrdinalsEqual   BECAUSE GENERALIZATION;
QED

(*
   This is the link between a well-order and an ordinal :
   when there is an increasing bijection between them.
*)
IsOrdinalOfWellOrder(o, w) == IsOrdinal(o) /\ IsWellOrder(w)
 /\ (\E f : f \in Bijections(Domain(w), o) /\ \A x : \A y : <<x,y>> \in w => f[x] \subseteq f[y])

uniqueOrdinalOfWellOrder == \A w : \A o : \A p :
   IsOrdinalOfWellOrder(o, w) /\ IsOrdinalOfWellOrder(p, w) => o = p
\* THEOREM uniqueOrdinalOfWellOrder
\* To prove this, compose the two functions to make an increasing bijection
\* between o and p, then conclude by the previous theorem.

(*
   With this unicity of a well-order's ordinal, we can now prove
   its existence. By the replacement axiom scheme, each element x
   of a well-order w is sent to the unique ordinal of the initial
   segment [min(w), x[.

   This forms a set of ordinals, which will be shown to be an ordinal.
   The final step is to prove that this ordinal is isomorphic to w.
*)
OrdinalOfWellOrder(w) == CHOOSE o : IsOrdinalOfWellOrder(o, w)
ordinalOfWellOrderExists == \A w : IsWellOrder(w)
   => IsOrdinalOfWellOrder(OrdinalOfWellOrder(w), w)
\* THEOREM ordinalOfWellOrderExists
\* By induction. Suppose by contradiction that there exists a well-order w
\* without an ordinal. Then we first show that there exists a well-order wmin
\* without an ordinal and such that all its initial segments has an ordinal.
\* If w is already in this case, take wmin = w. Otherwise there is an initial
\* segment x- of w without an ordinal. By well-ordering, take the smallest m \in w
\* such that m- is without an ordinal. Then take wmin = m-.
\* wmin is not empty, because the empty set is its own ordinal.
\* wmin has no maximum, because its ordinal would be the successor of its
\* maximum's ordinal.
\* But then the union of the ordinals of the initial segments of wmin is
\* the ordinal of wmin. Contradiction.

\* The +1 operation on ordinals
successor(o) == o \union { o }

inSuccessor == \A o : o \in successor(o)
THEOREM inSuccessor
PROOF
VARIABLES a,o,x,y,z;
singletonExists   BECAUSE THEOREM;
o \in { o } <=> o = o   BECAUSE \A(a <- o, x <- o);
equalSelf   BECAUSE THEOREM;
o = o   BECAUSE \A(a <- o);
o \in { o }   BECAUSE MODUS_PONENS;
unionInc   BECAUSE THEOREM;
o \in (o \union {o}) <=> (o \in o \/ o \in {o})   BECAUSE \A(x <- o, y <- {o}, z <- o);
o \in o \/ o \in {o}   BECAUSE IntroOrRight;
o \in successor(o)   BECAUSE MODUS_PONENS;
inSuccessor   BECAUSE GENERALIZATION;
QED

IsLimitOrdinal(o) == IsOrdinal(o) /\ o # {} /\ \A x : x \in o => o # successor(x)
IsFiniteOrdinal(o) == IsOrdinal(o) /\ ~IsLimitOrdinal(o)
   /\ \A x : x \in o => ~IsLimitOrdinal(x)

finiteInFinite == \A o : \A x : IsFiniteOrdinal(o) /\ x \in o => IsFiniteOrdinal(x)
THEOREM finiteInFinite
PROOF
VARIABLES a,o,x,y,z;
h(o,y) == IsFiniteOrdinal(o) /\ y \in o;
h(o,y) => IsFiniteOrdinal(o)   BECAUSE S12;
h(o,y) => y \in o   BECAUSE S22;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(o) /\ y \in o => IsOrdinal(y)   BECAUSE \A(o <- o, x <- y);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
h(o,y) => IsOrdinal(o)   BECAUSE TI;
h(o,y) => IsOrdinal(o) /\ y \in o   BECAUSE CIA;
h(o,y) => IsOrdinal(y)   BECAUSE TI;
IsFiniteOrdinal(o) => \A x : x \in o => ~IsLimitOrdinal(x)   BECAUSE S22;
(\A x : x \in o => ~IsLimitOrdinal(x)) => (y \in o => ~IsLimitOrdinal(y))   BECAUSE \A(x <- y);
h(o,y) => (y \in o => ~IsLimitOrdinal(y))   BECAUSE TI2;
h(o,y) => ~IsLimitOrdinal(y)   BECAUSE KillMiddleHypo;

(\A x : x \in o => ~IsLimitOrdinal(x)) => (x \in o => ~IsLimitOrdinal(x))   BECAUSE \A(x <- x);
h(o,y) => (x \in o => ~IsLimitOrdinal(x))   BECAUSE TI2;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
IsTransitiveSet(o) => (y \in o => y \subseteq o)   BECAUSE \A(a <- y);
h(o,y) => (y \in o => y \subseteq o)   BECAUSE TI2;
h(o,y) => y \subseteq o   BECAUSE KillMiddleHypo;
y \subseteq o => (x \in y => x \in o)   BECAUSE \A(z <- x);
h(o,y) => (x \in y => x \in o)   BECAUSE TI;
mergeHypos(h,a,b,c) == (h => (a => b)) => ((h => (c => a)) => (h => (c => b)))   PROPO_TAUTO;
h(o,y) => (x \in y => ~IsLimitOrdinal(x))   BECAUSE mergeHypos;
\A x : h(o,y) => (x \in y => ~IsLimitOrdinal(x))   BECAUSE GENERALIZATION;
h(o,y) => (\A x : x \in y => ~IsLimitOrdinal(x))   BECAUSE Q_SCHEME;

h(o,y) => IsOrdinal(y) /\ ~IsLimitOrdinal(y)   BECAUSE CIA;
h(o,y) => IsFiniteOrdinal(y)   BECAUSE CIA;
\A y : h(o,y) => IsFiniteOrdinal(y)   BECAUSE GENERALIZATION;
h(o,x) => IsFiniteOrdinal(x)   BECAUSE \A(y <- x);
finiteInFinite   BECAUSE GENERALIZATION;
QED

\* The empty set is the smallest ordinal, called "zero" as an ordinal
ordinalZero == IsFiniteOrdinal( {} )
THEOREM ordinalZero
PROOF
\* Just check implications starting with the false formula x \in {}
VARIABLES a,b,c,p,x;
\* Proof of TransitiveSet( {} )
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
a \in {} => a \subseteq {}   BECAUSE Explosion;
IsTransitiveSet( {} )   BECAUSE GENERALIZATION;
\* Proof of irreflexive
a \in {} => a \notin a   BECAUSE Explosion;
\A a : a \in {} => a \notin a   BECAUSE GENERALIZATION;
\* Proof of transitive order
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c)
   => (a \in {} /\ b \in {} /\ c \in {})   BECAUSE S13;
(a \in {} /\ b \in {} /\ c \in {}) => a \in {}   BECAUSE S13;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in {}   BECAUSE TI;
a \in {} => a \in c   BECAUSE Explosion;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE TI;
IsTransitiveIn( {} )  BECAUSE GENERALIZATION;
\* Proof of minimums
includedInEmpty   BECAUSE THEOREM;
p \subseteq {} => p = {}   BECAUSE \A(x <- p);
p = {} => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE IntroOrLeft;
p \subseteq {} => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE TI;
\A p : p \subseteq {} => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE GENERALIZATION;
(\A a : a \in {} => a \notin a) /\ IsTransitiveIn( {} )   BECAUSE IntroAndRight;
IsWellOrderedByIn( {} )   BECAUSE IntroAndRight;
IsOrdinal({})   BECAUSE IntroAndRight;
\* Proof of finiteness
IsLimitOrdinal({}) => {} # {}   BECAUSE S23;
contraposNeg(a,b) == (a => ~b) => (b => ~a)   PROPO_TAUTO;
{} = {} => ~IsLimitOrdinal({})   BECAUSE contraposNeg;
equalSelf   BECAUSE THEOREM;
{} = {}   BECAUSE \A(a <- {});
~IsLimitOrdinal({})   BECAUSE MODUS_PONENS;
IsOrdinal({}) /\ ~IsLimitOrdinal({})   BECAUSE IntroAndRight;
a \in {} => ~IsLimitOrdinal(a)   BECAUSE Explosion;
\A a : a \in {} => ~IsLimitOrdinal(a)   BECAUSE GENERALIZATION;
x \in {} => ~IsLimitOrdinal(x)   BECAUSE \A(a <- x);
\A x : x \in {} => ~IsLimitOrdinal(x)   BECAUSE GENERALIZATION;
ordinalZero   BECAUSE IntroAndRight;
QED

minInSingleton == \A a : IsMinimumForIn(a, {a})
THEOREM minInSingleton
PROOF
VARIABLES a,b,x;
singletonExists   BECAUSE THEOREM;
a \in { a } <=> a = a   BECAUSE \A(a <- a, x <- a);
a = a => a \in { a }   BECAUSE EquivToImplReverse;
equalSelf   BECAUSE THEOREM;
a = a   BECAUSE \A(a <- a);
a \in { a }   BECAUSE MODUS_PONENS;
b \in { a } <=> b = a   BECAUSE \A(a <- a, x <- b);
b \in { a } => b = a   BECAUSE EquivToImpl;
b = a => b = a \/ a \in b   BECAUSE IntroOrLeft;
b \in { a } => b = a \/ a \in b   BECAUSE TI;
\A b : b \in { a } => b = a \/ a \in b   BECAUSE GENERALIZATION;
IsMinimumForIn(a, {a})   BECAUSE IntroAndRight;
minInSingleton   BECAUSE GENERALIZATION;
QED

ordinalSuccessorStable == \A o : IsOrdinal(o) => IsOrdinal( successor(o) )
THEOREM ordinalSuccessorStable
PROOF
VARIABLES a,b,c,m,o,p,u,v,x,y,z;
\* Proof that IsOrdinal(o) => IsTransitiveSet(successor(o))
ht(o,a) == IsOrdinal(o) /\ a \in successor(o);
ht(o,a) => IsOrdinal(o)   BECAUSE S12;
ht(o,a) => a \in successor(o)   BECAUSE S22;
unionInc   BECAUSE THEOREM;
a \in successor(o) <=> a \in o \/ a \in {o}   BECAUSE \A(x <- o, y <- {o}, z <- a);
a \in successor(o) => a \in o \/ a \in {o}   BECAUSE EquivToImpl;
ht(o,a) => a \in o \/ a \in {o}   BECAUSE TI;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
IsTransitiveSet(o) => (a \in o => a \subseteq o)   BECAUSE \A(a <- a);
ht(o,a) => (a \in o => a \subseteq o)   BECAUSE TI2;
z \in successor(o) <=> z \in o \/ z \in {o}   BECAUSE \A(x <- o, y <- {o}, z <- z);
z \in o \/ z \in {o} => z \in successor(o)   BECAUSE EquivToImplReverse;
z \in o => z \in o \/ z \in {o}   BECAUSE IntroOrLeft;
z \in o => z \in successor(o)   BECAUSE TI;
o \subseteq successor(o)   BECAUSE GENERALIZATION;
transitInclusion   BECAUSE THEOREM;
(a \subseteq o) /\ (o \subseteq successor(o)) => a \subseteq successor(o)
   BECAUSE \A(a <- a, b <- o, c <- successor(o));
a \subseteq o => (o \subseteq successor(o) => a \subseteq successor(o))   BECAUSE HypoAndToImpl;
a \subseteq o => o \subseteq successor(o)   BECAUSE PT1;
a \subseteq o => a \subseteq successor(o)   BECAUSE KillMiddleHypo;
hti(h,a,b,c) == (h => (a => b)) => ((b => c) => (h => (a => c)))   PROPO_TAUTO;
ht(o,a) => (a \in o => a \subseteq successor(o))   BECAUSE hti;
\A a : \A b : a = b => (a \subseteq successor(o) <=> b \subseteq successor(o))   BECAUSE E_SCHEME;
a = o => (a \subseteq successor(o) <=> o \subseteq successor(o))   BECAUSE \A(a <- a, b <- o);
a = o => a \subseteq successor(o)   BECAUSE ImplyEquivTrue;
singletonExists   BECAUSE THEOREM;
a \in { o } <=> a = o   BECAUSE \A(a <- o, x <- a);
a \in { o } => a = o   BECAUSE EquivToImpl;
a \in {o} => a \subseteq successor(o)   BECAUSE TI;
mergeImpl(h,a,b,c) == (h => (a => c)) => ((b => c) => (h => (a \/ b => c)))   PROPO_TAUTO;
ht(o,a) => (a \in o \/ a \in {o} => a \subseteq successor(o))   BECAUSE mergeImpl;
ht(o,a) => a \subseteq successor(o)   BECAUSE KillMiddleHypo;
IsOrdinal(o) => (a \in successor(o) => a \subseteq successor(o))   BECAUSE HypoAndToImpl;
\A a : IsOrdinal(o) => (a \in successor(o) => a \subseteq successor(o))   BECAUSE GENERALIZATION;
IsOrdinal(o) => IsTransitiveSet(successor(o))   BECAUSE Q_SCHEME;

\* Prove that successor(o) is irreflexive
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => \A a : a \in o => a \notin a   BECAUSE S13;
(\A a : a \in o => a \notin a) => (a \in o => a \notin a)   BECAUSE \A(a <- a);
IsOrdinal(o) => (a \in o => a \notin a)   BECAUSE TI2;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(o) => o \notin o   BECAUSE \A(o <- o);
\A a : \A b : a = b => (a \notin a <=> b \notin b)   BECAUSE E_SCHEME;
a = o => (a \notin a <=> o \notin o)   BECAUSE \A(a <- a, b <- o);
a \in {o} => (a \notin a <=> o \notin o)   BECAUSE TI;
implyEquivTrue(a,b,h,t) == (h => t) => ((b => (a <=> t)) => (h => (b => a)))   PROPO_TAUTO;
IsOrdinal(o) => (a \in {o} => a \notin a)   BECAUSE implyEquivTrue;
mergeImplB(h,a,b,c) == (h => (a => c)) => ((h => (b => c)) => (h => (a \/ b => c)))   PROPO_TAUTO;
IsOrdinal(o) => (a \in o \/ a \in {o} => a \notin a)   BECAUSE mergeImplB;
IsOrdinal(o) /\ a \in successor(o) => (a \in o \/ a \in {o} => a \notin a)   BECAUSE TI;
IsOrdinal(o) /\ a \in successor(o) => a \notin a   BECAUSE KillMiddleHypo;
IsOrdinal(o) => (a \in successor(o) => a \notin a)   BECAUSE HypoAndToImpl;
\A a : IsOrdinal(o) => (a \in successor(o) => a \notin a)   BECAUSE GENERALIZATION;
IsOrdinal(o) => (\A a : a \in successor(o) => a \notin a)   BECAUSE Q_SCHEME;

\* Prove that successor(o) is transitive for \in.
\* Let a \in b \in c \in successor(o). If c = o then a \in b \in o and
\* a \in o by transitivity of the ordinal o. Otherwise a \in c by
\* transitity of \in in the ordinal o.
htt(o,a,b,c) == IsOrdinal(o) /\ (a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c);
htt(o,a,b,c) => IsOrdinal(o)   BECAUSE S12;
htt(o,a,b,c) => (a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c)   BECAUSE S22;
(a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c) => c \in successor(o)   BECAUSE S24;
(a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c) => a \in b   BECAUSE S23;
(a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c) => b \in c   BECAUSE S22;
\A c : \A o : c = o => (IsTransitiveSet(c) <=> IsTransitiveSet(o))   BECAUSE E_SCHEME;
c = o => (IsTransitiveSet(c) <=> IsTransitiveSet(o))   BECAUSE \A(c <- c, o <- o);
c \in { o } <=> c = o   BECAUSE \A(a <- o, x <- c);
c \in { o } => c = o   BECAUSE EquivToImpl;
htt(o,a,b,c) /\ c \in {o} => htt(o,a,b,c)   BECAUSE S12;
htt(o,a,b,c) /\ c \in {o} => c \in {o}   BECAUSE S22;
htt(o,a,b,c) /\ c \in {o} => c = o   BECAUSE TI;
htt(o,a,b,c) /\ c \in {o} => (IsTransitiveSet(c) <=> IsTransitiveSet(o))   BECAUSE TI;
htt(o,a,b,c) /\ c \in {o} => IsTransitiveSet(o)   BECAUSE TI2;
implyEquivTrueB(h,a,t) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
htt(o,a,b,c) /\ c \in {o} => IsTransitiveSet(c)   BECAUSE implyEquivTrueB;
IsTransitiveSet(c) => (b \in c => b \subseteq c)   BECAUSE \A(a <- b);
htt(o,a,b,c) /\ c \in {o} => (b \in c => b \subseteq c)   BECAUSE TI;
htt(o,a,b,c) /\ c \in {o} => b \in c   BECAUSE TI2;
htt(o,a,b,c) /\ c \in {o} => b \subseteq c   BECAUSE KillMiddleHypo;
b \subseteq c => (a \in b => a \in c)   BECAUSE \A(z <- a);
htt(o,a,b,c) /\ c \in {o} => (a \in b => a \in c)   BECAUSE TI;
htt(o,a,b,c) /\ c \in {o} => a \in b   BECAUSE TI2;
htt(o,a,b,c) /\ c \in {o} => a \in c   BECAUSE KillMiddleHypo;
\* Now when c \in o
IsTransitiveSet(o) => (c \in o => c \subseteq o)   BECAUSE \A(a <- c);
htt(o,a,b,c) => (c \in o => c \subseteq o)   BECAUSE TI2;
htt(o,a,b,c) /\ c \in o => c \subseteq o   BECAUSE HypoImplToAnd;
c \subseteq o => (b \in c => b \in o)   BECAUSE \A(z <- b);
htt(o,a,b,c) /\ c \in o => (b \in c => b \in o)   BECAUSE TI;
htt(o,a,b,c) /\ c \in o => htt(o,a,b,c)   BECAUSE S12;
htt(o,a,b,c) /\ c \in o => b \in c   BECAUSE TI2;
htt(o,a,b,c) /\ c \in o => b \in o   BECAUSE KillMiddleHypo;
IsTransitiveSet(o) => (b \in o => b \subseteq o)   BECAUSE \A(a <- b);
htt(o,a,b,c) /\ c \in o => IsOrdinal(o)   BECAUSE TI;
htt(o,a,b,c) /\ c \in o => (b \in o => b \subseteq o)   BECAUSE TI2;
htt(o,a,b,c) /\ c \in o => b \subseteq o   BECAUSE KillMiddleHypo;
b \subseteq o => (a \in b => a \in o)   BECAUSE \A(z <- a);
htt(o,a,b,c) /\ c \in o => (a \in b => a \in o)   BECAUSE TI;
htt(o,a,b,c) /\ c \in o => a \in b   BECAUSE TI2;
htt(o,a,b,c) /\ c \in o => a \in o   BECAUSE KillMiddleHypo;
IsWellOrderedByIn(o) => IsTransitiveIn(o)   BECAUSE S23;
htt(o,a,b,c) /\ c \in o => IsTransitiveIn(o)   BECAUSE TI2;
IsTransitiveIn(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE \A(a <- a, b <- b, c <- c);
htt(o,a,b,c) /\ c \in o => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
htt(o,a,b,c) /\ c \in o => a \in o /\ b \in o   BECAUSE CIA;
htt(o,a,b,c) /\ c \in o => c \in o   BECAUSE S22;
htt(o,a,b,c) /\ c \in o => a \in o /\ b \in o /\ c \in o  BECAUSE CIA;
htt(o,a,b,c) /\ c \in o => a \in o /\ b \in o /\ c \in o /\ a \in b BECAUSE CIA;
htt(o,a,b,c) /\ c \in o => a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c BECAUSE CIA;
htt(o,a,b,c) /\ c \in o => a \in c   BECAUSE KillMiddleHypo;
mergeImplC(h,a,b,c) == (h /\ a => c) => ((h /\ b => c) => (h => (a \/ b => c)))   PROPO_TAUTO;
htt(o,a,b,c) => (c \in o \/ c \in {o} => a \in c)   BECAUSE mergeImplC;
c \in successor(o) <=> c \in o \/ c \in {o}   BECAUSE \A(x <- o, y <- {o}, z <- c);
c \in successor(o) => c \in o \/ c \in {o}   BECAUSE EquivToImpl;
injectHypo(i,a,b,c) == (i => b) => ((a => (b => c)) => (a => (i => c)))   PROPO_TAUTO;
htt(o,a,b,c) => (c \in successor(o) => a \in c)   BECAUSE injectHypo;
htt(o,a,b,c) => c \in successor(o)   BECAUSE TI;
htt(o,a,b,c) => a \in c   BECAUSE KillMiddleHypo;
IsOrdinal(o) => (a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c => a \in c)   BECAUSE HypoAndToImpl;
\A c : IsOrdinal(o) => (a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
IsOrdinal(o) => (\A c : a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A b : IsOrdinal(o) => (\A c : a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
IsOrdinal(o) => (\A b : \A c : a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A a : IsOrdinal(o) => (\A b : \A c : a \in successor(o) /\ b \in successor(o) /\ c \in successor(o) /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
IsOrdinal(o) => IsTransitiveIn(successor(o))   BECAUSE Q_SCHEME;

\* Prove successor(o) has all minimums.
\* Let p \subseteq successor(o). If p = {o} then its minimum is o.
\* Otherwise p touches o and has a minimum because o is an ordinal.
hmin(o,p) == IsOrdinal(o) /\ p \subseteq successor(o);
hmin(o,p) => IsOrdinal(o)   BECAUSE S12;
hmin(o,p) => p \subseteq successor(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p)) => ((p \intersect o) \subseteq o => (p \intersect o) = {} \/ \E m : IsMinimumForIn(m, p \intersect o))   BECAUSE \A(p <- p \intersect o);
hmin(o,p) => IsWellOrderedByIn(o)   BECAUSE TI;
hmin(o,p) => ((p \intersect o) \subseteq o => (p \intersect o) = {} \/ \E m : IsMinimumForIn(m, p \intersect o))   BECAUSE TI2;
intersectIncludes   BECAUSE THEOREM;
(p \intersect o) \subseteq o   BECAUSE \A(a <- p, b <- o);
hmin(o,p) => (p \intersect o) \subseteq o   BECAUSE PT1;
\* Those are the 2 cases :
hmin(o,p) => (p \intersect o) = {} \/ \E m : IsMinimumForIn(m, p \intersect o)   BECAUSE KillMiddleHypo;
hminm(o,p,m) == hmin(o,p) /\ IsMinimumForIn(m, p \intersect o);
hminm(o,p,m) => hmin(o,p)   BECAUSE S12;
hminm(o,p,m) => IsMinimumForIn(m, p \intersect o)   BECAUSE S22;
IsMinimumForIn(m, p \intersect o) => m \in (p \intersect o)   BECAUSE S12;
hminm(o,p,m) => m \in (p \intersect o)   BECAUSE TI;
intersectionExists   BECAUSE THEOREM;
m \in (p \intersect o) <=> (m \in p /\ m \in o)   BECAUSE \A(u <- p, v <- o, x <- m);
m \in (p \intersect o) => (m \in p /\ m \in o)   BECAUSE EquivToImpl;
(m \in p /\ m \in o) => m \in o   BECAUSE S22;
hminm(o,p,m) => m \in o   BECAUSE TI2; \* means m lower than o
p \subseteq successor(o) => (b \in p => b \in successor(o))   BECAUSE \A(z <- b);
hminm(o,p,m) => (b \in p => b \in successor(o))   BECAUSE TI2;
hminm(o,p,m) /\ b \in p => b \in successor(o)   BECAUSE HypoImplToAnd;
b \in successor(o) <=> b \in o \/ b \in {o}   BECAUSE \A(x <- o, y <- {o}, z <- b);
b \in successor(o) => b \in o \/ b \in {o}   BECAUSE EquivToImpl;
hminm(o,p,m) /\ b \in p => b \in o \/ b \in {o}   BECAUSE TI;
b \in { o } <=> b = o   BECAUSE \A(a <- o, x <- b);
b \in { o } => b = o   BECAUSE EquivToImpl;
hminm(o,p,m) /\ b \in p /\ b \in {o} => hminm(o,p,m)   BECAUSE S13;
hminm(o,p,m) /\ b \in p /\ b \in {o} => b \in {o}   BECAUSE S22;
\A b : \A o : b = o => (m \in b <=> m \in o)   BECAUSE E_SCHEME;
b = o => (m \in b <=> m \in o)   BECAUSE \A(b <- b, o <- o);
hminm(o,p,m) /\ b \in p /\ b \in {o} => (m \in b <=> m \in o)   BECAUSE TI2;
hminm(o,p,m) /\ b \in p /\ b \in {o} => m \in o   BECAUSE TI;
hminm(o,p,m) /\ b \in p /\ b \in {o} => m \in b   BECAUSE implyEquivTrueB;
m \in b => b = m \/ m \in b   BECAUSE IntroOrRight;
hminm(o,p,m) /\ b \in p /\ b \in {o} => b = m \/ m \in b   BECAUSE TI;
b \in (p \intersect o) <=> (b \in p /\ b \in o)   BECAUSE \A(u <- p, v <- o, x <- b);
(b \in p /\ b \in o) => b \in (p \intersect o)   BECAUSE EquivToImplReverse;
hminm(o,p,m) /\ b \in p /\ b \in o => hminm(o,p,m)   BECAUSE S13;
hminm(o,p,m) /\ b \in p /\ b \in o => b \in p   BECAUSE S23;
hminm(o,p,m) /\ b \in p /\ b \in o => b \in o   BECAUSE S22;
hminm(o,p,m) /\ b \in p /\ b \in o => b \in p /\ b \in o  BECAUSE CIA;
hminm(o,p,m) /\ b \in p /\ b \in o => b \in (p \intersect o)  BECAUSE TI;
IsMinimumForIn(m, p \intersect o) => \A b : b \in (p \intersect o) => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in (p \intersect o) => (b = m \/ m \in b)) => (b \in (p \intersect o) => (b = m \/ m \in b))   BECAUSE \A(b <- b);
hminm(o,p,m) => (b \in (p \intersect o) => (b = m \/ m \in b))   BECAUSE TI2;
hminm(o,p,m) /\ b \in p /\ b \in o => (b \in (p \intersect o) => (b = m \/ m \in b))   BECAUSE TI;
hminm(o,p,m) /\ b \in p /\ b \in o => (b = m \/ m \in b)   BECAUSE KillMiddleHypo;
hminm(o,p,m) /\ b \in p => ((b \in o \/ b \in {o}) => (b = m \/ m \in b))   BECAUSE mergeImplC;
hminm(o,p,m) /\ b \in p => (b = m \/ m \in b)   BECAUSE KillMiddleHypo;
hminm(o,p,m) => (b \in p => b = m \/ m \in b)   BECAUSE HypoAndToImpl;
\A b : hminm(o,p,m) => (b \in p => b = m \/ m \in b)   BECAUSE GENERALIZATION;
hminm(o,p,m) => (\A b : b \in p => b = m \/ m \in b)   BECAUSE Q_SCHEME;
(m \in p /\ m \in o) => m \in p   BECAUSE S12;
hminm(o,p,m) => m \in p   BECAUSE TI2;
hminm(o,p,m) => IsMinimumForIn(m, p)   BECAUSE CIA;
hmin(o,p) => (IsMinimumForIn(m, p \intersect o) => IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
\A m : hmin(o,p) => (IsMinimumForIn(m, p \intersect o) => IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
hmin(o,p) => (\A m : IsMinimumForIn(m, p \intersect o) => IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
(\A m : IsMinimumForIn(m, p \intersect o) => IsMinimumForIn(m, p)) => ((\E m : IsMinimumForIn(m, p \intersect o)) => \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
hmin(o,p) => ((\E m : IsMinimumForIn(m, p \intersect o)) => \E m : IsMinimumForIn(m, p))   BECAUSE TI;
hmin(o,p) /\ (\E m : IsMinimumForIn(m, p \intersect o)) => \E m : IsMinimumForIn(m, p)   BECAUSE HypoImplToAnd;
(\E m : IsMinimumForIn(m, p)) => (p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE IntroOrRight;
hmin(o,p) /\ (\E m : IsMinimumForIn(m, p \intersect o)) => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE TI;

\* Other case : p \intersect o = {}
emptySetExistsUniquely   BECAUSE THEOREM;
p \intersect o = {} <=> \A x : x \notin (p \intersect o)   BECAUSE \A(c <- p \intersect o);
p \intersect o = {} => \A x : x \notin (p \intersect o)   BECAUSE EquivToImpl;
(\A x : x \notin (p \intersect o)) => z \notin (p \intersect o)   BECAUSE \A(x <- z);
p \subseteq successor(o) => (z \in p => z \in successor(o))   BECAUSE \A(z <- z);
hmin(o,p) /\ (p \intersect o) = {} => hmin(o,p)   BECAUSE S12;
hmin(o,p) /\ (p \intersect o) = {} => (p \intersect o) = {}   BECAUSE S22;
hmin(o,p) /\ (p \intersect o) = {} => z \notin (p \intersect o)   BECAUSE TI2;
z \in (p \intersect o) <=> (z \in p /\ z \in o)   BECAUSE \A(u <- p, v <- o, x <- z);
(z \in p /\ z \in o) => z \in (p \intersect o)   BECAUSE EquivToImplReverse;
z \notin (p \intersect o) => ~(z \in p /\ z \in o)   BECAUSE Contraposition;
~(z \in p /\ z \in o) => z \notin p \/ z \notin o   BECAUSE DistribNotAnd;
hmin(o,p) /\ (p \intersect o) = {} => z \notin p \/ z \notin o   BECAUSE TI2;
hmin(o,p) /\ (p \intersect o) = {} => (z \in p => z \in successor(o))   BECAUSE TI2;
z \in successor(o) <=> z \in o \/ z \in {o}   BECAUSE \A(x <- o, y <- {o}, z <- z);
z \in successor(o) => z \in o \/ z \in {o}   BECAUSE EquivToImpl;
mergeImplD(a,o,p,h,s) == (h => ~p \/ ~o) => ((h => (p => s)) => (((s => o \/ a) => (h => (p => a)))))   PROPO_TAUTO;
hmin(o,p) /\ (p \intersect o) = {} => (z \in p => z \in {o})   BECAUSE mergeImplD;
\A z : hmin(o,p) /\ (p \intersect o) = {} => (z \in p => z \in {o})   BECAUSE GENERALIZATION;
hmin(o,p) /\ (p \intersect o) = {} => p \subseteq {o}   BECAUSE Q_SCHEME;
subsetSingleton   BECAUSE THEOREM;
p \subseteq {o} => p = {} \/ p = {o}   BECAUSE \A(a <- o, p <- p);
hmin(o,p) /\ (p \intersect o) = {} => p = {} \/ p = {o}   BECAUSE TI;
minInSingleton   BECAUSE THEOREM;
IsMinimumForIn(o, {o})   BECAUSE \A(a <- o);
\E m : IsMinimumForIn(m, {o})   BECAUSE \E(m <- o);
\A p : \A o : p = o => ((\E m : IsMinimumForIn(m, p)) <=> (\E m : IsMinimumForIn(m, o)))   BECAUSE E_SCHEME;
p = {o} => ((\E m : IsMinimumForIn(m, p)) <=> (\E m : IsMinimumForIn(m, {o})))   BECAUSE \A(p <- p, o <- {o});
p = {o} => (\E m : IsMinimumForIn(m, p))   BECAUSE ImplyEquivTrue;
p = {} => p = {}   BECAUSE ImplySelf;
p = {} \/ p = {o} => p = {} \/ (\E m : IsMinimumForIn(m, p))   BECAUSE MergeImplicationsOr;
hmin(o,p) /\ (p \intersect o) = {} => p = {} \/ (\E m : IsMinimumForIn(m, p))   BECAUSE TI;

hmin(o,p) => ((p \intersect o) = {} \/ (\E m : IsMinimumForIn(m, p \intersect o)) => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE mergeImplC;
hmin(o,p) => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE KillMiddleHypo;
IsOrdinal(o) => (p \subseteq successor(o) => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
\A p : IsOrdinal(o) => (p \subseteq successor(o) => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
IsOrdinal(o) => (\A p : p \subseteq successor(o) => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;
IsOrdinal(o) => (\A a : a \in successor(o) => a \notin a) /\ IsTransitiveIn(successor(o))   BECAUSE CIA;
IsOrdinal(o) => IsWellOrderedByIn(successor(o))   BECAUSE CIA;
IsOrdinal(o) => IsOrdinal(successor(o))   BECAUSE CIA;
ordinalSuccessorStable   BECAUSE GENERALIZATION;
QED

successorIncreasing == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p) /\ o \in p
   => successor(o) \in successor(p)
THEOREM successorIncreasing
PROOF
VARIABLES a,o,p,x,y,z;
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p) /\ o \in p;
h(o,p) => IsOrdinal(o)   BECAUSE S13;
h(o,p) => IsOrdinal(p)   BECAUSE S23;
h(o,p) => o \in p   BECAUSE S22;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(o) => IsOrdinal( successor(o) )   BECAUSE \A(o <- o);
IsOrdinal(p) => IsOrdinal( successor(p) )   BECAUSE \A(o <- p);
h(o,p) => IsOrdinal( successor(o) )   BECAUSE TI;
h(o,p) => IsOrdinal( successor(p) )   BECAUSE TI;
\* Prove successor(o) \subseteq p
unionInc   BECAUSE THEOREM;
z \in successor(o) <=> (z \in o \/ z \in {o})   BECAUSE \A(x <- o, y <- {o}, z <- z);
z \in successor(o) => (z \in o \/ z \in {o})   BECAUSE EquivToImpl;
singletonExists   BECAUSE THEOREM;
z \in { o } <=> z = o   BECAUSE \A(a <- o, x <- z);
\A z : \A o : z = o => (z \in p <=> o \in p)   BECAUSE E_SCHEME;
z = o => (z \in p <=> o \in p)   BECAUSE \A(z <- z, o <- o);
cycleHypos(a,b,c,d) == (d <=> a) => ((a => (b <=> c)) => (c => (d => b)))   PROPO_TAUTO;
o \in p => (z \in {o} => z \in p)   BECAUSE cycleHypos;
h(o,p) => (z \in {o} => z \in p)   BECAUSE TI;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
IsTransitiveSet(p) => (o \in p => o \subseteq p)   BECAUSE \A(a <- o);
h(o,p) => (o \in p => o \subseteq p)   BECAUSE TI2;
h(o,p) => o \subseteq p   BECAUSE KillMiddleHypo;
o \subseteq p => (z \in o => z \in p)   BECAUSE \A(z <- z);
h(o,p) => (z \in o => z \in p)   BECAUSE TI;
mergeImpl(a,b,c,d,h) == (d => a \/ b) => ((h => (a => c)) => (((h => (b => c)) => (h => (d => c)))))   PROPO_TAUTO;
h(o,p) => (z \in successor(o) => z \in p)   BECAUSE mergeImpl;
\A z : h(o,p) => (z \in successor(o) => z \in p)   BECAUSE GENERALIZATION;
h(o,p) => successor(o) \subseteq p   BECAUSE Q_SCHEME;
\* Conclude successor(o) \in succesor(p)
includedOrdinals   BECAUSE THEOREM;
IsOrdinal(successor(o)) /\ IsOrdinal(p) /\ successor(o) \subseteq p
   => successor(o) \in p \/ successor(o) = p   BECAUSE \A(o <- successor(o), p <- p);
h(o,p) => IsOrdinal(successor(o)) /\ IsOrdinal(p)   BECAUSE CIA;
h(o,p) => IsOrdinal(successor(o)) /\ IsOrdinal(p) /\ successor(o) \subseteq p   BECAUSE CIA;
h(o,p) => successor(o) \in p \/ successor(o) = p   BECAUSE TI;
successor(o) \in successor(p) <=> (successor(o) \in p \/ successor(o) \in {p})   BECAUSE \A(x <- p, y <- {p}, z <- successor(o));
successor(o) \in p \/ successor(o) \in {p} => successor(o) \in successor(p)   BECAUSE EquivToImplReverse;
successor(o) \in {p} <=> successor(o) = p   BECAUSE \A(a <- p, x <- successor(o));
successor(o) = p => successor(o) \in {p}   BECAUSE EquivToImplReverse;
successor(o) \in p => successor(o) \in p   BECAUSE ImplySelf;
successor(o) \in p \/ successor(o) = p =>  successor(o) \in p \/ successor(o) \in {p}   BECAUSE MergeImplicationsOr;
h(o,p) => successor(o) \in successor(p)   BECAUSE TI2;
successorIncreasing   BECAUSE GENERALIZATION;
QED

ordinalSuccessorRegular == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p) /\ successor(o) = successor(p)
   => o = p
THEOREM ordinalSuccessorRegular
PROOF
VARIABLES a,o,p,x,y,z;
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p) /\ successor(o) = successor(p);
unionInc   BECAUSE THEOREM;
o \in successor(o) <=> o \in o \/ o \in {o}   BECAUSE \A(x <- o, y <- {o}, z <- o);
o \in o \/ o \in {o} => o \in successor(o)   BECAUSE EquivToImplReverse;
o \in {o} => o \in o \/ o \in {o}   BECAUSE IntroOrRight;
singletonExists   BECAUSE THEOREM;
o \in {o} <=> o = o   BECAUSE \A(a <- o, x <- o);
o = o => o \in {o}   BECAUSE EquivToImplReverse;
o = o => o \in successor(o)   BECAUSE TI2;
equalSelf   BECAUSE THEOREM;
o = o   BECAUSE \A(a <- o);
o \in successor(o)   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (o \in x <=> o \in y)   BECAUSE E_SCHEME;
successor(o) = successor(p) => (o \in successor(o) <=> o \in successor(p))   BECAUSE \A(x <- successor(o), y <- successor(p));
h(o,p) => successor(o) = successor(p)   BECAUSE S22;
h(o,p) => (o \in successor(o) <=> o \in successor(p))   BECAUSE TI;
implyTrueEquiv(t,h,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
h(o,p) => o \in successor(p)   BECAUSE implyTrueEquiv;
o \in successor(p) <=> o \in p \/ o \in {p}   BECAUSE \A(x <- p, y <- {p}, z <- o);
o \in successor(p) => o \in p \/ o \in {p}   BECAUSE EquivToImpl;
h(o,p) => o \in p \/ o \in {p}   BECAUSE TI;
\* Prove o \in p is impossible by successorIncreasing
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(o) /\ IsOrdinal(p) /\ o \in p => successor(o) \in successor(p)   BECAUSE \A(o <- o, p <- p);
h(o,p) => IsOrdinal(o) /\ IsOrdinal(p)   BECAUSE S12;
h(o,p) => IsOrdinal(p)   BECAUSE S23;
o \in p => o \in p   BECAUSE ImplySelf;
h(o,p) /\ o \in p => IsOrdinal(o) /\ IsOrdinal(p) /\ o \in p   BECAUSE MergeImplicationsAnd;
h(o,p) /\ o \in p => successor(o) \in successor(p)   BECAUSE TI;
\A x : \A y : x = y => (x \in successor(p) <=> y \in successor(p))   BECAUSE E_SCHEME;
successor(o) = successor(p) => (successor(o) \in successor(p) <=> successor(p) \in successor(p))   BECAUSE \A(x <- successor(o), y <- successor(p));
h(o,p) /\ o \in p => h(o,p)   BECAUSE S12;
h(o,p) /\ o \in p => (successor(o) \in successor(p) <=> successor(p) \in successor(p))   BECAUSE TI2;
implyTrueEquivB(t,h,a) == (h => t) => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
h(o,p) /\ o \in p => successor(p) \in successor(p)   BECAUSE implyTrueEquivB;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(p) => IsOrdinal( successor(p) )   BECAUSE \A(o <- p);
h(o,p) /\ o \in p => IsOrdinal( successor(p) )   BECAUSE TI2;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(successor(p)) => successor(p) \notin successor(p)   BECAUSE \A(o <- successor(p));
h(o,p) /\ o \in p => successor(p) \notin successor(p)   BECAUSE TI;
h(o,p) /\ o \in p => successor(p) \in successor(p) /\ successor(p) \notin successor(p)   BECAUSE CIA;
absurd(h,a,b) == ((h /\ b) => (a /\ ~a)) => (h => ~b)   PROPO_TAUTO;
h(o,p) => o \notin p   BECAUSE absurd;
killCase(h,a,b) == (h => ~a) => ((h => a \/ b) => (h => b))   PROPO_TAUTO;
h(o,p) => o \in {p}   BECAUSE killCase;
o \in {p} <=> o = p   BECAUSE \A(a <- p, x <- o);
o \in {p} => o = p   BECAUSE EquivToImpl;
h(o,p) => o = p   BECAUSE TI;
ordinalSuccessorRegular   BECAUSE GENERALIZATION;
QED

finiteOrdinalSuccessorStable == \A o : IsFiniteOrdinal(o) => IsFiniteOrdinal( successor(o) )
THEOREM finiteOrdinalSuccessorStable
PROOF
VARIABLES a,o,x,y,z;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(o) => IsOrdinal( successor(o) )   BECAUSE \A(o <- o);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
IsFiniteOrdinal(o) => IsOrdinal(successor(o))   BECAUSE TI;
IsLimitOrdinal(successor(o)) => \A x : x \in successor(o) => successor(o) # successor(x)   BECAUSE S22;
(\A x : x \in successor(o) => successor(o) # successor(x)) => (o \in successor(o) => successor(o) # successor(o))   BECAUSE \A(x <- o);
IsLimitOrdinal(successor(o)) => (o \in successor(o) => successor(o) # successor(o))   BECAUSE TI;
inSuccessor   BECAUSE THEOREM;
o \in successor(o)   BECAUSE \A(o <- o);
IsLimitOrdinal(successor(o)) => o \in successor(o)   BECAUSE PT1;
IsLimitOrdinal(successor(o)) => successor(o) # successor(o)   BECAUSE KillMiddleHypo;
~(successor(o) # successor(o)) => ~IsLimitOrdinal(successor(o))   BECAUSE Contraposition;
equalSelf   BECAUSE THEOREM;
successor(o) = successor(o)   BECAUSE \A(a <- successor(o));
~(successor(o) # successor(o))   BECAUSE IntroNotNot;
~IsLimitOrdinal(successor(o))   BECAUSE MODUS_PONENS;
IsFiniteOrdinal(o) => ~IsLimitOrdinal(successor(o))   BECAUSE PT1;

unionInc   BECAUSE THEOREM;
x \in (o \union {o}) <=> (x \in o \/ x \in {o})   BECAUSE \A(x <- o, y <- {o}, z <- x);
x \in successor(o) => x \in o \/ x \in {o}   BECAUSE EquivToImpl;
IsFiniteOrdinal(o) => (\A x : x \in o => ~IsLimitOrdinal(x))   BECAUSE S22;
(\A x : x \in o => ~IsLimitOrdinal(x)) => (x \in o => ~IsLimitOrdinal(x))   BECAUSE \A(x <- x);
IsFiniteOrdinal(o) => (x \in o => ~IsLimitOrdinal(x))   BECAUSE TI;
IsFiniteOrdinal(o) /\ x \in successor(o) => (x \in o => ~IsLimitOrdinal(x)) /\ (x \in o \/ x \in {o})   BECAUSE MergeImplicationsAnd;
mp(a,b,c) == (a => b) /\ (a \/ c) => b \/ c   PROPO_TAUTO;
(x \in o => ~IsLimitOrdinal(x)) /\ (x \in o \/ x \in {o}) => ~IsLimitOrdinal(x) \/ x \in {o}   BECAUSE mp;
IsFiniteOrdinal(o) /\ x \in successor(o) => ~IsLimitOrdinal(x) \/ x \in {o}   BECAUSE TI;
singletonExists   BECAUSE THEOREM;
x \in { o } <=> x = o   BECAUSE \A(a <- o, x <- x);
x \in { o } => x = o   BECAUSE EquivToImpl;
IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE S23;
IsFiniteOrdinal(o) /\ x \in successor(o) => IsFiniteOrdinal(o)   BECAUSE S12;
IsFiniteOrdinal(o) /\ x \in successor(o) => ~IsLimitOrdinal(o)   BECAUSE TI;
\A x : \A o : x = o => (~IsLimitOrdinal(x) <=> ~IsLimitOrdinal(o))   BECAUSE E_SCHEME;
x = o => (~IsLimitOrdinal(x) <=> ~IsLimitOrdinal(o))   BECAUSE \A(x <- x, o <- o);
x \in {o} => (~IsLimitOrdinal(x) <=> ~IsLimitOrdinal(o))   BECAUSE TI;
mergeImpl(h,a,b,c) == (h => a \/ b) => ((h => c) => ((b => (a <=> c)) => (h => a)))   PROPO_TAUTO;
IsFiniteOrdinal(o) /\ x \in successor(o) => ~IsLimitOrdinal(x)   BECAUSE mergeImpl;
IsFiniteOrdinal(o) => (x \in successor(o) => ~IsLimitOrdinal(x))   BECAUSE HypoAndToImpl;
\A x : IsFiniteOrdinal(o) => (x \in successor(o) => ~IsLimitOrdinal(x))   BECAUSE GENERALIZATION;
IsFiniteOrdinal(o) => (\A x : x \in successor(o) => ~IsLimitOrdinal(x))   BECAUSE Q_SCHEME;

IsFiniteOrdinal(o) => IsOrdinal(successor(o)) /\ ~IsLimitOrdinal(successor(o))   BECAUSE CIA;
IsFiniteOrdinal(o) => IsFiniteOrdinal(successor(o))   BECAUSE CIA;
finiteOrdinalSuccessorStable   BECAUSE GENERALIZATION;
QED
