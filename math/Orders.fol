EXTENDS ZFC

(*
   The class of orders : graphs that are reflexive, anti-symmetric and transitive.
*)
IsOrder(o) == IsGraph(o)
   \* reflexivity
   /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   \* transitivity
   /\ (\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)
   \* anti-symmetry
   /\ (\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)

domainOrderReflex == \A o : \A x : (IsOrder(o) /\ IsDefinedOn(o,x)) => <<x,x>> \in o
THEOREM domainOrderReflex
PROOF
VARIABLES m,n,o,x,y;
IsOrder(o) => (IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))
   BECAUSE DropAndRight2;
(IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndLeft;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TransitImplication;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => <<m,n>> \in o => (<<m,m>> \in o /\ <<n,n>> \in o)   BECAUSE \A(x <- m, y <- n);
IsOrder(o) => (<<m,n>> \in o => (<<m,m>> \in o /\ <<n,n>> \in o))   BECAUSE TransitImplication;
(IsOrder(o) /\ <<m,n>> \in o) => (<<m,m>> \in o /\ <<n,n>> \in o)   BECAUSE HypoImplToAnd;
QED

\* An injection f transports an order o
injectOrder(o,f) == CHOOSE b : \A x : x \in b <=> (IsCouple(x) /\
   \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)

injectOrderExists == \A o : \A f : \A x : x \in injectOrder(o,f) <=> (IsCouple(x) /\
   \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
THEOREM injectOrderExists
PROOF
VARIABLES a,b,c,f,g,m,n,o,x,y;
\* By separation in Image(f) \X Image(f)
(\A x : x \in injectOrder(o,f) <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   <=> (\E b : \A x : x \in b <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   BECAUSE CHOOSE;
\A a : \E b : \A x : x \in b <=> ( x \in a /\ (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o) )   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> ( (x \in (Image(f) \X Image(f)))
   /\ (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o) )
   BECAUSE \A(a <- Image(f) \X Image(f));

cartesianProductInc   BECAUSE THEOREM;
(fst(x) \in Image(f) /\ snd(x) \in Image(f)) => <<fst(x),snd(x)>> \in (Image(f) \X Image(f))
   BECAUSE \A(x <- Image(f), y <- Image(f), a <- fst(x), b <- snd(x));
imageInc   BECAUSE THEOREM;
<<m,fst(x)>> \in f => fst(x) \in Image(f)   BECAUSE \A(g <- f, x <- fst(x), y <- m);
<<n,snd(x)>> \in f => snd(x) \in Image(f)   BECAUSE \A(g <- f, x <- snd(x), y <- n);
(<<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f) => (fst(x) \in Image(f) /\ snd(x) \in Image(f))   BECAUSE MergeImplicationsAnd;
(<<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f) => <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE TransitImplication;
(<<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   => (<<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f)   BECAUSE DropAndRight;
(<<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o) => <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE TransitImplication;
(\E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   => \E n : <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE Q_SCHEME;
(\E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   => \E m : \E n : <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE Q_SCHEME;
(\E m : \E n : <<fst(x),snd(x)>> \in (Image(f) \X Image(f)))
   => \E n : <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE Q_SCHEME;
(\E n : <<fst(x),snd(x)>> \in (Image(f) \X Image(f)))
   => <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE Q_SCHEME;
(\E m : \E n : <<fst(x),snd(x)>> \in (Image(f) \X Image(f)))
   => <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE TransitImplication;
(\E m :\E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   => <<fst(x),snd(x)>> \in (Image(f) \X Image(f))   BECAUSE TransitImplication;

tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x),snd(x)>>   BECAUSE \A(c <- x);
x = <<fst(x),snd(x)>> => (x \in (Image(f) \X Image(f)) <=> <<fst(x),snd(x)>> \in (Image(f) \X Image(f)))   BECAUSE E_SCHEME;
IsCouple(x) => (x \in (Image(f) \X Image(f)) <=> <<fst(x),snd(x)>> \in (Image(f) \X Image(f)))   BECAUSE TransitImplication;
(IsCouple(x) /\ <<fst(x),snd(x)>> \in (Image(f) \X Image(f))) => x \in (Image(f) \X Image(f))   BECAUSE HypoEquivToAndReverse;
(<<fst(x),snd(x)>> \in (Image(f) \X Image(f)) /\ IsCouple(x))
   => (IsCouple(x) /\ <<fst(x),snd(x)>> \in (Image(f) \X Image(f)))   BECAUSE AndSymmetry;
(<<fst(x),snd(x)>> \in (Image(f) \X Image(f)) /\ IsCouple(x))
   => x \in (Image(f) \X Image(f))   BECAUSE TransitImplication;
<<fst(x),snd(x)>> \in (Image(f) \X Image(f))
   => (IsCouple(x) => x \in (Image(f) \X Image(f)))   BECAUSE HypoAndToImpl;
(\E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   => (IsCouple(x) => x \in (Image(f) \X Image(f)))   BECAUSE TransitImplication;
((\E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o) /\ IsCouple(x))
   => x \in (Image(f) \X Image(f))   BECAUSE HypoImplToAnd;
(IsCouple(x) /\ (\E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   => ((\E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o) /\ IsCouple(x))   BECAUSE AndSymmetry;
(IsCouple(x) /\ (\E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   => x \in (Image(f) \X Image(f))   BECAUSE TransitImplication;

(x \in b <=> ( (x \in (Image(f) \X Image(f))) /\ (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)))
   => (x \in b <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   BECAUSE SeparationTauto;
(\A x : x \in b <=> ( (x \in (Image(f) \X Image(f))) /\ (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)))
   => (\A x : x \in b <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> ( (x \in (Image(f) \X Image(f))) /\ (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)))
   => (\E b : \A x : x \in b <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o))
   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   BECAUSE MODUS_PONENS;
\A x : x \in injectOrder(o,f) <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   BECAUSE MODUS_PONENS;
injectOrderExists   BECAUSE GENERALIZATION;
QED

equivTrueAnd(a,b,t) == t => ((a <=> (t /\ b)) => (a <=> b))
PROPO_TAUTO equivTrueAnd

injectOrderInc == \A o : \A f : \A a : \A b : <<a,b>> \in injectOrder(o,f)
   <=> (\E m : \E n : <<m,a>> \in f /\ <<n,b>> \in f /\ <<m,n>> \in o)
THEOREM injectOrderInc
PROOF
VARIABLES a,b,c,d,f,m,n,o,x,y;
injectOrderExists   BECAUSE THEOREM;
<<a,b>> \in injectOrder(o,f) <=> (IsCouple(<<a,b>>) /\ \E m : \E n : <<m,fst(<<a,b>>)>> \in f /\ <<n,snd(<<a,b>>)>> \in f /\ <<m,n>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- <<a,b>>);
<<a,b>> = <<a,b>> => \E x : \E y : <<a,b>> = <<x,y>>   BECAUSE \E(x <- a, y <- b);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
IsCouple(<<a,b>>)   BECAUSE MODUS_PONENS;
<<a,b>> \in injectOrder(o,f)
   <=> (\E m : \E n : <<m,fst(<<a,b>>)>> \in f /\ <<n,snd(<<a,b>>)>> \in f /\ <<m,n>> \in o)
   BECAUSE equivTrueAnd;

fstExists   BECAUSE THEOREM;
a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
sndExists   BECAUSE THEOREM;
b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE IntroAndRight;
(a = x /\ b = y) => ((\E m : \E n : <<m,a>> \in f /\ <<n,b>> \in f /\ <<m,n>> \in o)
                      <=> (\E m : \E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o))   BECAUSE E_SCHEME;
\A x : \A y : (a = x /\ b = y) => ((\E m : \E n : <<m,a>> \in f /\ <<n,b>> \in f /\ <<m,n>> \in o)
        <=> (\E m : \E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o))   BECAUSE GENERALIZATION;
(a = fst(<<a,b>>) /\ b = snd(<<a,b>>)) => ((\E m : \E n : <<m,a>> \in f /\ <<n,b>> \in f /\ <<m,n>> \in o)
        <=> (\E m : \E n : <<m,fst(<<a,b>>)>> \in f /\ <<n,snd(<<a,b>>)>> \in f /\ <<m,n>> \in o))
	BECAUSE \A(x <- fst(<<a,b>>), y <- snd(<<a,b>>));
(\E m : \E n : <<m,a>> \in f /\ <<n,b>> \in f /\ <<m,n>> \in o)
   <=> (\E m : \E n : <<m,fst(<<a,b>>)>> \in f /\ <<n,snd(<<a,b>>)>> \in f /\ <<m,n>> \in o)
   BECAUSE MODUS_PONENS;
<<a,b>> \in injectOrder(o,f)
   <=> (\E m : \E n : <<m,a>> \in f /\ <<n,b>> \in f /\ <<m,n>> \in o)
   BECAUSE TransitEquiv2;
injectOrderInc   BECAUSE GENERALIZATION;
QED

injectOrderIsOrder == \A o : \A f : (IsOrder(o) /\ IsInjection(f))
   => IsOrder(injectOrder(o,f))
THEOREM injectOrderIsOrder
PROOF
VARIABLES a,b,f,m,n,o,x,y;
\* Proof that injectOrder(o,f) is a graph
injectOrderExists   BECAUSE THEOREM;
x \in injectOrder(o,f) <=> (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x);
x \in injectOrder(o,f) => (IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o)
   BECAUSE EquivToImpl;
(IsCouple(x) /\ \E m : \E n : <<m,fst(x)>> \in f /\ <<n,snd(x)>> \in f /\ <<m,n>> \in o) => IsCouple(x)   BECAUSE DropAndRight;
x \in injectOrder(o,f) => IsCouple(x)   BECAUSE TransitImplication;
IsGraph(injectOrder(o,f))   BECAUSE GENERALIZATION;

\* Proof that injectOrder(o,f) is reflexive
injectOrderInc   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> (\E m : \E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   BECAUSE \A(o <- o, f <- f, a <- x, b <- y);
<<x,x>> \in injectOrder(o,f) <=> (\E m : \E n : <<m,x>> \in f /\ <<n,x>> \in f /\ <<m,n>> \in o)
   BECAUSE \A(o <- o, f <- f, a <- x, b <- x);
<<y,y>> \in injectOrder(o,f) <=> (\E m : \E n : <<m,y>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   BECAUSE \A(o <- o, f <- f, a <- y, b <- y);
<<x,y>> \in injectOrder(o,f) => (\E m : \E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   BECAUSE EquivToImpl;
(\E m : \E n : <<m,x>> \in f /\ <<n,x>> \in f /\ <<m,n>> \in o) => <<x,x>> \in injectOrder(o,f)
   BECAUSE EquivToImplReverse;
(<<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o) => <<m,x>> \in f   BECAUSE DropAndRight2;
(<<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o) => <<m,n>> \in o   BECAUSE DropAndLeft;
<<m,n>> \in o => \E y : <<m,y>> \in o   BECAUSE \E(y <- n);
(<<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o) => IsDefinedOn(o,m)   BECAUSE TransitImplication;
(<<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   => (<<m,x>> \in f /\ IsDefinedOn(o,m))   BECAUSE CombineImplicationsEnd;
(\E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   => \E n : <<m,x>> \in f /\ IsDefinedOn(o,m)  BECAUSE Q_SCHEME;
(\E n : <<m,x>> \in f /\ IsDefinedOn(o,m)) => (<<m,x>> \in f /\ IsDefinedOn(o,m))   BECAUSE Q_SCHEME;
(\E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   => (<<m,x>> \in f /\ IsDefinedOn(o,m))   BECAUSE TransitImplication;
(\E m : \E n : <<m,x>> \in f /\ <<n,y>> \in f /\ <<m,n>> \in o)
   => \E m : <<m,x>> \in f /\ IsDefinedOn(o,m)   BECAUSE Q_SCHEME;
<<x,y>> \in injectOrder(o,f) => \E m : <<m,x>> \in f /\ IsDefinedOn(o,m)   BECAUSE TransitImplication;

(<<m,x>> \in f /\ <<m,x>> \in f /\ <<m,m>> \in o)
   => \E n : <<m,x>> \in f /\ <<n,x>> \in f /\ <<m,n>> \in o   BECAUSE \E(n <- m);
\* TODO
QED

disjointOrders == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ (u \intersect v = {}))
   => IsOrder(u \union v)
THEOREM disjointOrders

(*
   The class of well-orders, orders where each nonempty subset has a minimum.
   They allow to count :
      - in the well-order, take the minimum and call it zero
      - in the nonzero elements of the well-order, take the minimum and call it one
      - in the elements of the well-order that are neither zero nor one,
        take the minimum and call it two
      - iterate
   
   For this reason, some well-orders (the finite ones) define the natural numbers.
   The well-orders are stable under disjoint unions, which they call addition.
   They are also stable under cartesian products, which they call multiplication.
*)
IsWellOrder(w) == IsOrder(w)
   /\ (\A part : (part # {} /\ (\A x : x \in part => IsDefinedOn(w,x)))
         => \E min : min \in part /\ \A b : b \in part => <<min,b>> \in w)

\* TODO rewrite it as funcProd(identity(dom), const(dom, tag))
pasteTags(dom, tag) == CHOOSE f : IsInjection(f)
   /\ Domain(f) = dom
   /\ \A x : x \in dom => <<x, <<x,tag>> >> \in f

\* Define a well-order on the disjoint union of two well-orders.
\* This order simply pastes v after u.
wellOrderAddition(u,v) == injectOrder(u, pasteTags(Domain(u),{}))
   \union injectOrder(v, pasteTags(Domain(v),ordinalOne))
   \union ((Domain(u)\X{{}}) \X (Domain(v)\X{ordinalOne})) \* this puts v after u

woAddIsWo == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v)) => IsWellOrder(wellOrderAddition(u,v))
THEOREM woAddIsWo
PROOF
VARIABLES a,b,g,m,n,u,v,x,y,z;
\* Proof that wellOrderAddition(u,v) is a graph
(m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>) => x = << <<m,{}>>, <<n,ordinalOne>> >>   BECAUSE DropAndLeft;
x = << <<m,{}>>, <<n,ordinalOne>> >> => ((\E a : \E b : x = <<a,b>>) <=> (\E a : \E b : << <<m,{}>>, <<n,ordinalOne>> >> = <<a,b>>))   BECAUSE E_SCHEME;
(<< <<m,{}>>, <<n,ordinalOne>> >> = << <<m,{}>>, <<n,ordinalOne>> >>
   => \E a : \E b : << <<m,{}>>, <<n,ordinalOne>> >> = <<a,b>>)   BECAUSE \E(a <- <<m,{}>>, b <- <<n,ordinalOne>>);
<< <<m,{}>>, <<n,ordinalOne>> >> = << <<m,{}>>, <<n,ordinalOne>> >>   BECAUSE E_SCHEME;
\E a : \E b : << <<m,{}>>, <<n,ordinalOne>> >> = <<a,b>>   BECAUSE MODUS_PONENS;
x = << <<m,{}>>, <<n,ordinalOne>> >> => (\E a : \E b : x = <<a,b>>)   BECAUSE ImplyEquivTrue;
(m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>) => (\E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
   => (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >>)   BECAUSE DropAndRight;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >>) => x = << <<m,{}>>, <<n,{}>> >> BECAUSE DropAndLeft;
x = << <<m,{}>>, <<n,{}>> >> => ((\E a : \E b : x = <<a,b>>) <=> (\E a : \E b : << <<m,{}>>, <<n,{}>> >> = <<a,b>>))   BECAUSE E_SCHEME;
(<< <<m,{}>>, <<n,{}>> >> = << <<m,{}>>, <<n,{}>> >>
   => \E a : \E b : << <<m,{}>>, <<n,{}>> >> = <<a,b>>)   BECAUSE \E(a <- <<m,{}>>, b <- <<n,{}>>);
<< <<m,{}>>, <<n,{}>> >> = << <<m,{}>>, <<n,{}>> >>   BECAUSE E_SCHEME;
\E a : \E b : << <<m,{}>>, <<n,{}>> >> = <<a,b>>   BECAUSE MODUS_PONENS;
x = << <<m,{}>>, <<n,{}>> >> => (\E a : \E b : x = <<a,b>>)   BECAUSE ImplyEquivTrue;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >>) => (\E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u) => (\E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v)
   => (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)   BECAUSE DropAndRight;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>) => x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> BECAUSE DropAndLeft;
x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> => ((\E a : \E b : x = <<a,b>>) <=> (\E a : \E b : << <<m,ordinalOne>>, <<n,ordinalOne>> >> = <<a,b>>))   BECAUSE E_SCHEME;
(<< <<m,ordinalOne>>, <<n,ordinalOne>> >> = << <<m,ordinalOne>>, <<n,ordinalOne>> >>
   => \E a : \E b : << <<m,ordinalOne>>, <<n,ordinalOne>> >> = <<a,b>>)   BECAUSE \E(a <- <<m,ordinalOne>>, b <- <<n,ordinalOne>>);
<< <<m,ordinalOne>>, <<n,ordinalOne>> >> = << <<m,ordinalOne>>, <<n,ordinalOne>> >>   BECAUSE E_SCHEME;
\E a : \E b : << <<m,ordinalOne>>, <<n,ordinalOne>> >> = <<a,b>>   BECAUSE MODUS_PONENS;
x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> => (\E a : \E b : x = <<a,b>>)   BECAUSE ImplyEquivTrue;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>) => (\E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v) => (\E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
((m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
     \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u))
  => (\E a : \E b : x = <<a,b>>)   BECAUSE CombineImplicationsStart;
((m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
     \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
     \/ (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v))
  => (\E a : \E b : x = <<a,b>>)   BECAUSE CombineImplicationsStart;
(\E n : (m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
     \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
     \/ (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v))
  => (\E n : \E a : \E b : x = <<a,b>>)   BECAUSE Q_SCHEME;
\* IsInWellOrderAddition(x,u,v) => (\E m : \E n : \E a : \E b : x = <<a,b>>)   BECAUSE Q_SCHEME;
\* wellOrderAdditionExists   BECAUSE THEOREM;
\* x \in wellOrderAddition(u,v) <=> IsInWellOrderAddition(x,u,v)   BECAUSE \A(u <- u, v <- v, x <- x);
\* x \in wellOrderAddition(u,v) => IsInWellOrderAddition(x,u,v)   BECAUSE EquivToImpl;
\* x \in wellOrderAddition(u,v) => (\E m : \E n : \E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
(\E m : \E n : \E a : \E b : x = <<a,b>>) => (\E n : \E a : \E b : x = <<a,b>>)   BECAUSE Q_SCHEME;
(\E n : \E a : \E b : x = <<a,b>>) => (\E a : \E b : x = <<a,b>>)   BECAUSE Q_SCHEME;
\* x \in wellOrderAddition(u,v) => (\E n : \E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
\* x \in wellOrderAddition(u,v) => (\E a : \E b : x = <<a,b>>)   BECAUSE TransitImplication;
IsGraph(wellOrderAddition(u,v))   BECAUSE GENERALIZATION;

\* Proof that wellOrderAddition is reflexive
   \* Proof that (IsOrder(u) /\ m \in Domain(u) /\ x = << <<m,{}>>, <<m,{}>> >>) => IsInWellOrderAddition(x,u,v)
domainExists   BECAUSE THEOREM;
m \in Domain(u) <=> IsDefinedOn(u,m)   BECAUSE \A(g <- u, x <- m);
QED


(*
   At the moment, the addition and multiplication of well-orders are not commutative,
   even for finite ones. wellOrderAddition(u,v) and wellOrderAddition(v,u) are
   isomorphic as well-orders, but not equal.

   It would be convenient to fix one representative in each well-order isomorphy
   class, so that addition and multiplication get their usual properties. The
   ordinals achieve that, they find canonical elements for the well-orders' domains.
*)
TransitiveSet(x) == \A a : a \in x => a \subseteq x

(*
   Predicate asserting that the set x is strictly well-ordered by the membership
   relation \in. In those sets, \in behaves like < on the natural numbers. Actually,
   those sets start with the natural numbers and \in will be the definition of <.
*)
WellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ (\A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c) \* transitive
   /\ (\A p : (p # {} /\ p \subseteq x) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)) \* existence of minimums

(*
   The class of ordinals, which starts with the natural numbers. This predicate
   rigorously defines what could be naively stated as
      0 = {}
      n = { 0, ..., n-1 }
*)
IsOrdinal(o) == TransitiveSet(o) /\ WellOrderedByIn(o)

\* The empty set is the smallest ordinal, called "zero" as an ordinal
ordinalZero == IsOrdinal( {} )
THEOREM ordinalZero
PROOF
\* Just check implications starting with the false formula x \in {}
VARIABLES a,b,c,p,x;
\* Proof of TransitiveSet( {} )
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
a \in {} => a \subseteq {}   BECAUSE Explosion;
TransitiveSet( {} )   BECAUSE GENERALIZATION;

\* Proof of irreflexive
a \in {} => a \notin a   BECAUSE Explosion;
\A a : a \in {} => a \notin a   BECAUSE GENERALIZATION;

\* Proof of transitive order
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c)
   => (a \in {} /\ b \in {} /\ c \in {})   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {}) => a \in {}   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in {}   BECAUSE TransitImplication;
a \in {} => a \in c   BECAUSE Explosion;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE TransitImplication;
\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE GENERALIZATION;

\* Proof of minimums
includedInEmpty   BECAUSE THEOREM;
p \subseteq {} => p = {}   BECAUSE \A(x <- p);
(p \subseteq {} => p = {}) <=> (~(p \subseteq {}) \/ p = {})   BECAUSE BooleanImplication;
~(p \subseteq {}) \/ p = {}   BECAUSE MODUS_PONENS;
p = {} \/ ~(p \subseteq {})   BECAUSE OrSymmetry;
~~(p = {} \/ ~(p \subseteq {}))   BECAUSE IntroNotNot;
~(p = {} \/ ~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE Explosion;
~(p = {} \/ ~(p \subseteq {})) <=> (p # {} /\ ~~(p \subseteq {}))   BECAUSE DistribNotOr;
(p # {} /\ ~~(p \subseteq {})) => ~(p = {} \/ ~(p \subseteq {}))   BECAUSE EquivToImplReverse;
(p # {} /\ ~~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TransitImplication;
p \subseteq {} => ~~(p \subseteq {})   BECAUSE IntroNotNot;
p # {} => p # {}   BECAUSE ImplyOneself;
(p # {} /\ p \subseteq {}) => (p # {} /\ ~~(p \subseteq {}))   BECAUSE MergeImplicationsAnd;
(p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TransitImplication;
\A p : (p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE GENERALIZATION;

\* Conclude with PT6
(\A a : a \in {} => a \notin a)
   /\ (\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c)   BECAUSE IntroAndRight;
WellOrderedByIn( {} )   BECAUSE IntroAndRight;
ordinalZero   BECAUSE IntroAndRight;
QED

\* The +1 operation on ordinals
successor(o) == o \union { o }

ordinalSuccessorStable == \A o : IsOrdinal(o) => IsOrdinal( successor(o) )
THEOREM ordinalSuccessorStable

IsLimitOrdinal(o) == IsOrdinal(o) /\ o # {} /\ \A x : x \in o => o # successor(x)

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE o : IsLimitOrdinal(o) /\ \A x : x \in o => ~IsLimitOrdinal(x)
naturalNumbersExist == IsLimitOrdinal(Nat) /\ \A x : x \in Nat => ~IsLimitOrdinal(x)
THEOREM naturalNumbersExist

(*
   The addition function on natural numbers. It could be declared as an operator
   natAddition(x,y) = CHOOSE z : ...
   however it would be recursive (or use well-orders). Keep it a simple function here.
*)
natAddition == CHOOSE f : IsFunction(f)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in f) \* f : Nat \X Nat -> Nat
   /\ (\A x : x \in Nat => << <<x,{}>>, x >> \in f) \* f(x,0) = x
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : << <<x,y>>, u >> \in f /\ << <<x,successor(y)>>, successor(u) >> \in f) \* f(x,y+1) = f(x,y)+1

natAdditionExists == IsFunction(natAddition)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in natAddition)
   /\ (\A x : x \in Nat => << <<x,{}>>, x >> \in natAddition)
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : << <<x,y>>, u >> \in natAddition /\ << <<x,successor(y)>>, successor(u) >> \in natAddition)

THEOREM natAdditionExists

(*
   The multiplication function on natural numbers.
*)
natMultiplication == CHOOSE f : IsFunction(f)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in f) \* f : Nat \X Nat -> Nat
   /\ (\A x : x \in Nat => << <<x,{}>>, {} >> \in f) \* f(x,0) = 0
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : \E v : << <<x,y>>, u >> \in f /\ << <<x,successor(y)>>, v>> \in f
	                  /\ << <<u,x>>, v >> \in natAddition) \* u=f(x,y) and v=f(x,y+1) and v=u+x, ie f(x,y+1) = f(x,y)+x

natMultiplicationExists == IsFunction(natMultiplication)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in natMultiplication)
   /\ (\A x : x \in Nat => << <<x,{}>>, {} >> \in natMultiplication)
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : \E v : << <<x,y>>, u >> \in natMultiplication /\ << <<x,successor(y)>>, v>> \in natMultiplication /\ << <<u,x>>, v >> \in natAddition)

THEOREM natMultiplicationExists