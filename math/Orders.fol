(*
   The elements of a ZFC set are not ordered. There is only one set
   with elements x and y : { x, y } = { y, x }. Likewise with any
   number of elements, by the axiom of extensionality the set is
   the same, independently of the order in which its elements were
   listed.

   Couples introduce an order between two elements, because <<x,y>>
   and <<y,x>> are different. Here we discuss the more general
   structure of order, that applies to a set with any number of
   elements.

   Order is fundamental for numbers. When we measure things with
   numbers, we're often only interested in the order the numbers
   place on the things : which are bigger, faster, stronger, ...
   The geometry of the real numbers comes from their order, which
   tells when a point on a line lies between two other points.
   Deeper still, orders are the very definition of natural numbers :
   they are the finite well-orders. We will see that addition and
   multiplication, often introduced at school for natural numbers,
   are actually operations on orders.

   Orders also serve for optimization. In the dictionary, the
   alphabetical order allows to find any word among more than
   100 000 words in a few seconds. This is true for any collection
   of objects, in a book, house, factory or even human society :
   when ordered, the objects are much faster to find and easier
   to manipulate.
*)

EXTENDS Functions

IsOrder(o) == IsGraph(o)
   \* Reflexivity
   /\ (\A x : \A y : (<<x,y>> \in o) => (<<x,x>> \in o /\ <<y,y>> \in o))
   \* transitivity
   /\ (\A x : \A y : \A z : ((<<x,y>> \in o) /\ (<<y,z>> \in o)) => (<<x,z>> \in o))
   \* anti-symmetry
   /\ (\A x : \A y : ((<<x,y>> \in o) /\ (<<y,x>> \in o)) => x = y)

\* Because f[x] is a CHOOSE, this only allows functions which domains
\* contain Domain(u)
IsIncreasing(f, u, v) == \A x : \A y : (<<x,y>> \in u) => (<<f[x], f[y]>> \in v)

IsMinimum(m, part, order) == (m \in part) /\ \A x : (x \in part) => <<m,x>> \in order

\* Usually reflexivity is rather stated in terms of the domain :
orderDomainReflexive == \A o : \A x : IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o
THEOREM orderDomainReflexive
PROOF
VARIABLES g,o,x,y;
domainExists   BECAUSE THEOREM;
x \in Domain(o) <=> IsDefinedOn(o,x)   BECAUSE \A(g <- o, x <- x);
x \in Domain(o) => \E y : <<x,y>> \in o   BECAUSE EquivToImpl;
IsOrder(o) => IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndRight2;
IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndLeft;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE \A(x <- x, y <- y);
IsOrder(o) => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
<<x,y>> \in o => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE SwitchHypos;
IsDefinedOn(o,x) => (\E y : IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE Q_SCHEME;
(\E y : IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE Q_SCHEME;
IsDefinedOn(o,x) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE TI;
x \in Domain(o) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE TI;
IsOrder(o) => (x \in Domain(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE SwitchHypos;
IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o /\ <<y,y>> \in o   BECAUSE HypoImplToAnd;
<<x,x>> \in o /\ <<y,y>> \in o => <<x,x>> \in o   BECAUSE DropAndRight;
IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o   BECAUSE TI;
orderDomainReflexive   BECAUSE GENERALIZATION;
QED

\* An injection f transports an order o
IsInInjectOrder(o,f,x) == x \in (Image(f) \X Image(f)) /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o
injectOrder(o,f) == CHOOSE b : \A x : x \in b <=> IsInInjectOrder(o,f,x)

injectOrderExists == \A o : \A f : \A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)
THEOREM injectOrderExists
PROOF
\* By separation in Image(f) \X Image(f)
VARIABLES a,b,c,f,o,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> IsInInjectOrder(o,f,x)   BECAUSE \A(a <- Image(f) \X Image(f));
\A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE CHOOSE injectOrder(o,f);
injectOrderExists   BECAUSE GENERALIZATION;
QED

doubleEquiv(a,b,c,d) == (a <=> b) => ((c <=> d) => ((a /\ c) <=> (b /\ d)))   PROPO_TAUTO doubleEquiv

injectOrderCouples == \A o : \A f : \A x : \A y : <<x,y>> \in injectOrder(o,f) <=>
   (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
THEOREM injectOrderCouples
PROOF
VARIABLES a,b,f,o,x,y;
injectOrderExists   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE \A(o <- o, f <- f, x <- <<x,y>>);
cartesianProductCouples   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f)) <=> <<x,y>> \in (Image(f) \X Image(f))
   BECAUSE \A(x <- Image(f), y <- Image(f), a <- x, b <- y);
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
\A x : \A a : \A y : \A b : (x = a /\ y = b)
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,a), pre(f,b)>> \in o)   BECAUSE E_SCHEME;
(x = fst(<<x,y>>) /\ y = snd(<<x,y>>))
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o)
   BECAUSE \A(x <- x, a <- fst(<<x,y>>), y <- y, b <- snd(<<x,y>>));
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o   BECAUSE MODUS_PONENS;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE doubleEquiv;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> <<x,y>> \in injectOrder(o,f)   BECAUSE TransitEquiv2;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivSymmetry;
injectOrderCouples   BECAUSE GENERALIZATION;
QED

injectOrderIsOrder == \A o : \A f : (IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))
THEOREM injectOrderIsOrder
PROOF
VARIABLES a,b,d,f,g,i,j,o,x,y,z;
\* Proof that injectOrder(o,f) is a graph
injectOrderExists   BECAUSE THEOREM;
x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE \A(o <- o, f <- f, x <- x);
x \in injectOrder(o,f) => IsInInjectOrder(o,f,x)   BECAUSE EquivToImpl;
IsInInjectOrder(o,f,x) => x \in (Image(f) \X Image(f))   BECAUSE DropAndRight;
cartesianProductExists   BECAUSE THEOREM;
x \in (Image(f) \X Image(f)) <=> (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))
   BECAUSE \A(i <- Image(f), j <- Image(f), x <- x);
x \in (Image(f) \X Image(f)) => (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f)) => IsCouple(x)   BECAUSE DropAndRight2;
x \in (Image(f) \X Image(f)) => IsCouple(x)   BECAUSE TI;
IsInInjectOrder(o,f,x) => IsCouple(x)   BECAUSE TI;
x \in injectOrder(o,f) => IsCouple(x)   BECAUSE TI;
IsGraph(injectOrder(o,f))   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => IsGraph(injectOrder(o,f))   BECAUSE PT1;

\* Proof that injectOrder(o,f) is reflexive
IsOrder(o) => (IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))   BECAUSE DropAndRight2;
(IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE DropAndLeft;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))   BECAUSE TI;
(IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE HypoImplToAnd;
injectOrderCouples   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- y);
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivToImpl;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE DropAndLeft;
<<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE TI;
IsOrder(o) => IsOrder(o)   BECAUSE ImplySelf;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE MergeImplicationsAnd;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE TI;

   \* Lemma : \A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>>) \in o => <<d,d>> \in injectOrder
<<d,d>> \in injectOrder(o,f) <=> (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- d, y <- d);
d \in Image(f) => (d \in Image(f) /\ d \in Image(f))   BECAUSE AndSelf;
<<pre(f,d), pre(f,d)>> \in o => <<pre(f,d), pre(f,d)>> \in o   BECAUSE ImplySelf;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE MergeImplicationsAnd;
(d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE TI;
\A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;

   \* <<x, x>>
(x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o) => <<x,x>> \in injectOrder(o,f)
   BECAUSE \A(d <- x);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => x \in Image(f)   BECAUSE DropAndRight2;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE DropAndRight;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE DropAndLeft;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => x \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o)
   BECAUSE CIA;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,x>> \in injectOrder(o,f)   BECAUSE TI;

   \* <<y, y>>
(y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o) => <<y,y>> \in injectOrder(o,f)
   BECAUSE \A(d <- y);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => y \in Image(f)   BECAUSE DropAndBoth;
<<x,y>> \in injectOrder(o,f) => y \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE DropAndLeft;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE DropAndLeft;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => y \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o)
   BECAUSE CIA;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<y,y>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))
   BECAUSE CIA;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE HypoAndToImpl;
\A y : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(o)   BECAUSE DropAndRight;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;

\* Proof that injectOrder(o,f) is anti-symmetric
\A x : \A y: <<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE GENERALIZATION;
<<y,x>> \in injectOrder(o,f) => <<pre(f,y), pre(f,x)>> \in o   BECAUSE \A(x <- y, y <- x);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)   BECAUSE DropAndLeft;
(\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => pre(f,x) = pre(f,y)   BECAUSE HypoImplToAnd;

(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,y>> \in injectOrder(o,f)   BECAUSE DropAndRight2;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => (x \in Image(f) /\ y \in Image(f))   BECAUSE DropAndRight;
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))   BECAUSE CIA;
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))   BECAUSE MergeImplicationsAnd;
funcUniqueImage   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE \A(f <- f, x <- x, y <- y);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f)) => x = y   BECAUSE TI;
massageHypos(a,b,c,d) == ((c /\ d) /\ (a /\ b)) => (a /\ b /\ c /\ d)   PROPO_TAUTO;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)))
   => (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))   BECAUSE massageHypos;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))) => x = y   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE HypoAndToImpl;
\A y: (IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that injectOrder(o,f) is transitive
<<y,z>> \in injectOrder(o,f) => <<pre(f,y), pre(f,z)>> \in o   BECAUSE \A(x <- y, y <- z);
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)   BECAUSE DropAndBoth;
(\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE \A(x <- pre(f,x), y <- pre(f,y), z <- pre(f,z));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<pre(f,x), pre(f,z)>> \in o
   BECAUSE HypoImplToAnd;
\A x : \A y : <<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE GENERALIZATION;
<<y,z>> \in injectOrder(o,f) => (y \in Image(f) /\ z \in Image(f))   BECAUSE \A(x <- y, y <- z);
(y \in Image(f) /\ z \in Image(f)) => z \in Image(f)   BECAUSE DropAndLeft;
<<y,z>> \in injectOrder(o,f) => z \in Image(f)   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f)) => x \in Image(f)   BECAUSE DropAndRight;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE MergeImplicationsAnd;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))   BECAUSE DropAndRight;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)   BECAUSE CIA;
<<x,z>> \in injectOrder(o,f) <=> (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- z);
(x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o) => <<x,z>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<x,z>> \in injectOrder(o,f))   BECAUSE HypoAndToImpl;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE SwitchHypos;
\A z : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE GENERALIZATION;
IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A y : IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))))   BECAUSE CIA;
(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))) /\ (\A x : \A y : \A z : (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => <<x,z>> \in injectOrder(o,f)))   BECAUSE CIA;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))   BECAUSE CIA;
injectOrderIsOrder   BECAUSE GENERALIZATION;
QED

\* When two orders have disjoint domains, their union is an order
disjointOrders == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v)
THEOREM disjointOrders
PROOF
\* Proof that disjointOrders is a graph
VARIABLES g,u,v,x,y,z;
unionInc   BECAUSE THEOREM;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
x \in (u \union v) => (x \in u \/ x \in v)   BECAUSE EquivToImpl;
IsOrder(u) => IsGraph(u)   BECAUSE DropAndRight3;
IsGraph(u) => (x \in u => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u) => (x \in u => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE DropAndRight;
(IsOrder(u) /\ IsOrder(v)) => (x \in u => IsCouple(x))   BECAUSE TI;
x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
\A u : x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(v) => IsGraph(v)   BECAUSE DropAndRight3;
IsGraph(v) => (x \in v => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(v) => (x \in v => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE DropAndLeft;
(IsOrder(u) /\ IsOrder(v)) => (x \in v => IsCouple(x))   BECAUSE TI;
x \in v => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
(x \in u \/ x \in v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE CombineImplicationsStart;
x \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : (IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => IsGraph(u \union v)   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE DropAndRight;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsGraph(u \union v)   BECAUSE TI;

\* Proof that u \union v is reflexive.
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
selectSecond(a,b,c,d) == (a /\ b /\ c /\ d) => b   PROPO_TAUTO;
IsOrder(u) => (\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE selectSecond;
(\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE DropAndRight;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)   BECAUSE HypoImplToAnd;
unionFirstInc   BECAUSE THEOREM;
<<x,x>> \in u => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in u => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in u /\ <<y,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
\A u : IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(u <- v);
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE DropAndLeft;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
unionSecondInc   BECAUSE THEOREM;
<<x,x>> \in v => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in v => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in v /\ <<y,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE CombineImplicationsStart;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => ((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   BECAUSE DistribAndOrLeft;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE HypoAndToImpl;
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in u \/ <<x,y>> \in v)
   => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE SwitchHypos;
<<x,y>> \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE SwitchHypos;
\A y : (IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;

\* Proof that u \union v is anti-symmetric
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
implyNotAnd(a,b,c) == (a => ~(b /\ c)) => ((a /\ b) => ~c)   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => <<y,y>> \notin v   BECAUSE implyNotAnd;

(<<x,x>> \in v /\ <<y,y>> \in v) => <<y,y>> \in v   BECAUSE DropAndLeft;
(IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<x,y>> \in v) => <<y,y>> \in v   BECAUSE TI;
andContrapos(a,b,c) == ((a /\ b) => c) => (~c => (a => ~b))   PROPO_TAUTO;
<<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;

\A x : \A y : IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<y,x>> \in v => (<<y,y>> \in v /\ <<x,x>> \in v))   BECAUSE \A(x <- y, y <- x);
(<<y,y>> \in v /\ <<x,x>> \in v) => <<y,y>> \in v   BECAUSE DropAndRight;
(IsOrder(v) /\ <<y,x>> \in v) => (<<y,y>> \in v /\ <<x,x>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<y,x>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,x>> \notin v   BECAUSE HypoImplToAnd;

<<y,x>> \in (u \union v) <=> (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in (u \union v) => (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v)   BECAUSE CIA;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCases(a,b,c,d) == (~a /\ ~b /\ ((c \/ a) /\ (d \/ b))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE TI;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE DropAndLeft;
(\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,x>> \in u) => (IsOrder(u) => x = y)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(u) => x = y)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(u))
   => x = y   BECAUSE HypoImplToAnd;
flipLast(a,b,c,d) == ((a /\ b /\ c) => d) => ((a /\ c) => (b => d))   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<x,y>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<x,y>> \notin u   BECAUSE HypoImplToAnd;
\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,x>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,x>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,x>> \notin u)   BECAUSE CIA;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCasesRight(a,b,c,d) == (~a /\ ~b /\ ((a \/ c) /\ (b \/ d))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE TI;
\A u : IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE GENERALIZATION;
IsOrder(v) => ((<<x,y>> \in v /\ <<y,x>> \in v) => x = y)   BECAUSE \A(u <- v);
(<<x,y>> \in v /\ <<y,x>> \in v) => (IsOrder(v) => x = y)   BECAUSE SwitchHypos;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(v) => x = y)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(v))
   => x = y   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)
   BECAUSE CombineImplicationsStart;
exclMid(a,b,c,d) == (a /\ b /\ c) => ((c /\ d /\ b /\ a) \/ (~d /\ a /\ b))   PROPO_TAUTO;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   BECAUSE exclMid;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE TI;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that u \union v is transitive.
\* If <<y,y>> \in u, because u and v are disjoint, <<y,y>> \notin v and then by reflexivity of v,
\* <<y,z>> \notin v and <<x,y>> \notin v. Else <<y,y>> \notin u, then by reflexivity of u,
\* <<y,z>> \notin u and <<x,y>> \notin u.
IsOrder(v) => (<<y,z>> \in v => (<<y,y>> \in v /\ <<z,z>> \in v))   BECAUSE \A(x <- y, y <- z);
(IsOrder(v) /\ <<y,z>> \in v) => (<<y,y>> \in v /\ <<z,z>> \in v)   BECAUSE HypoImplToAnd;
(<<y,y>> \in v /\ <<z,z>> \in v) => <<y,y>> \in v   BECAUSE DropAndRight;
(IsOrder(v) /\ <<y,z>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,z>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => (<<x,y>> \notin v /\ <<y,z>> \notin v)  BECAUSE CIA;

<<y,z>> \in (u \union v) <=> (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in (u \union v) => (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE TI;

IsOrder(u) => (\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE DropAndBoth;
(\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)
   => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(u) => <<x,z>> \in u)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in u   BECAUSE HypoImplToAnd;
<<x,z>> \in u => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,z>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,z>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,z>> \notin u)   BECAUSE CIA;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE TI;
\A u : (<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE GENERALIZATION;
(<<x,y>> \in v /\ <<y,z>> \in v) => (IsOrder(v) => <<x,z>> \in v)   BECAUSE \A(u <- v);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(v) => <<x,z>> \in v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in v   BECAUSE HypoImplToAnd;
<<x,z>> \in v => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE CombineImplicationsStart;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE TI;
\A z : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;

(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))))   BECAUSE CIA;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))) /\ (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v)))   BECAUSE CIA;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v)   BECAUSE CIA;
disjointOrders   BECAUSE GENERALIZATION;
QED

(*
   Not only can two disjoint orders be united, then can also be glued together,
   the second coming completely after then first, which defines their addition.

   On natural numbers (finite well-orders, see below), this is the usual addition.
*)
disjointOrderAddition == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointOrderAddition
PROOF
VARIABLES a,b,c,g,i,j,o,p,u,v,x,y,z,part;
\* Proof that u \union v \union (Domain(u) \X Domain(v)) is a graph : union of 3 graphs
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
h(u,v) == IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v); \* The hypothesis
unionInc   BECAUSE THEOREM;
x \in woAdd(u,v) <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
cartesianProductExists   BECAUSE THEOREM;
x \in woAdd(u,v)
   => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
x \in (Domain(u) \X Domain(v)) <=> (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))
   BECAUSE \A(i <- Domain(u), j <- Domain(v), x <- x);
x \in (Domain(u) \X Domain(v)) => (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v)) => IsCouple(x)   BECAUSE DropAndRight2;
x \in (Domain(u) \X Domain(v)) => IsCouple(x)   BECAUSE TI;
IsOrder(u \union v) => IsGraph(u \union v)   BECAUSE DropAndRight3;
(\A x : x \in (u \union v) => IsCouple(x)) => (x \in (u \union v) => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u \union v) => (x \in (u \union v) => IsCouple(x))   BECAUSE TI;
mergeWithHypo(a,b,c,d) == (a => b) => ((c => (d => b)) => ((d \/ a) => (c => b)))   PROPO_TAUTO;
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE mergeWithHypo;
x \in woAdd(u,v) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE TI;
IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(u \union v) => IsGraph(woAdd(u,v))   BECAUSE Q_SCHEME;
disjointOrders   BECAUSE THEOREM;
IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
h(u,v) => IsGraph(woAdd(u,v))   BECAUSE TI;

\* Proof that orderAddition is reflexive : <<x,y>> \in woAdd(u,v) => (x \in Domain(u) \/ x \in Domain(v))
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,y>>);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)
   BECAUSE EquivToImpl;
domainExists   BECAUSE THEOREM;
x \in Domain(u \union v) <=> IsDefinedOn(u \union v, x)   BECAUSE \A(g <- u \union v, x <- x);
(\E y : <<x,y>> \in u \union v) => x \in Domain(u \union v)   BECAUSE EquivToImplReverse;
<<x,y>> \in u \union v => (\E y : <<x,y>> \in u \union v)   BECAUSE \E(y <- y);
<<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE TI;
cartesianProductCouples   BECAUSE THEOREM;
x \in Domain(u) /\ y \in Domain(v) <=> <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u) /\ y \in Domain(v)   BECAUSE EquivToImplReverse;
x \in Domain(u) /\ y \in Domain(v) => x \in Domain(u)   BECAUSE DropAndRight;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
x \in Domain(u) => \E y : <<x,y>> \in u   BECAUSE EquivToImpl;
unionFirstInc   BECAUSE THEOREM;
<<x,y>> \in u => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in u) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(u) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(u) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in woAdd(u,v) => x \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) => IsOrder(u \union v)   BECAUSE ImplySelf;
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ x \in Domain(u \union v)   BECAUSE MergeImplicationsAnd;
orderDomainReflexive   BECAUSE THEOREM;
IsOrder(u \union v) /\ x \in Domain(u \union v) => <<x,x>> \in u \union v   BECAUSE \A(o <- u \union v, x <- x);
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
disjointOrders   BECAUSE THEOREM;
h(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in woAdd(u,v)   BECAUSE ImplySelf;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v)   BECAUSE MergeImplicationsAnd;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
<<x,x>> \in (u \union v) => <<x,x>> \in woAdd(u,v)   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,x>>);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v)   BECAUSE TI;

IsOrder(u \union v) => IsGraph(u \union v) /\ (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE DropAndRight2;
IsGraph(u \union v) /\ (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v)) => (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE DropAndLeft;
IsOrder(u \union v) => (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))
   => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE \A(x <- x, y <- y);
IsOrder(u \union v) => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
h(u,v) => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v) => <<x,x>> \in u \union v /\ <<y,y>> \in u \union v   BECAUSE HypoImplToAnd;
<<x,x>> \in u \union v /\ <<y,y>> \in u \union v => <<y,y>> \in u \union v   BECAUSE DropAndLeft;
h(u,v) /\ (<<x,y>> \in u \union v) => <<y,y>> \in u \union v   BECAUSE TI;
\A x : <<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE GENERALIZATION;
<<y,y>> \in u \union v => y \in Domain(u \union v)   BECAUSE \A(x <- y);
h(u,v) /\ <<x,y>> \in u \union v => y \in Domain(u \union v)   BECAUSE TI;
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE DropAndLeft;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
x \in Domain(v) <=> IsDefinedOn(v, x)   BECAUSE \A(g <- v, x <- x);
x \in Domain(v) => \E y : <<x,y>> \in v   BECAUSE EquivToImpl;
unionSecondInc   BECAUSE THEOREM;
<<x,y>> \in v => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in v) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(v) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
\A x : x \in Domain(v) => x \in Domain(u \union v)   BECAUSE GENERALIZATION;
y \in Domain(v) => y \in Domain(u \union v)   BECAUSE \A(x <- y);
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(u \union v)   BECAUSE TI;
(h(u,v) /\ <<x,y>> \in u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
semiDistrib(a,b,c) == a /\ (b \/ c) => (a /\ b) \/ c   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v))
   => (h(u,v) /\ <<x,y>> \in u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE semiDistrib;
h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)) => y \in Domain(u \union v)   BECAUSE TI;
h(u,v) => h(u,v)   BECAUSE ImplySelf;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v))   BECAUSE MergeImplicationsAnd;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => y \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) /\ y \in Domain(u \union v) => <<y,y>> \in u \union v   BECAUSE \A(o <- u \union v, x <- y);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => h(u,v)   BECAUSE DropAndRight;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v)   BECAUSE TI;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ y \in Domain(u \union v)   BECAUSE CIA;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<y,y>> \in u \union v   BECAUSE TI;
<<y,y>> \in (u \union v) => <<y,y>> \in woAdd(u,v)   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,y>>);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<y,y>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v)   BECAUSE CIA;
h(u,v) => (<<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A y : h(u,v) => (<<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE Q_SCHEME;


\* Proof that orderAddition is transitive : if <<x,y>> and <<y,z>> are in the addition,
\*    - <<x,y>> and <<y,z>> are is u \union v then <<x,z>> too be it's an order
\*    - else either <<x,y>> or <<y,z>> are in the product glue
<<y,z>> \in woAdd(u,v) <=> (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,z>>);
<<y,z>> \in woAdd(u,v) => (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)
   => ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
        /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
\* Kill the double-glue case
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE DropAndLeft;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(v) => IsOrder(v)   BECAUSE ImplySelf;
IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v) => IsOrder(v) /\ y \in Domain(v)
   BECAUSE MergeImplicationsAnd;
IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v) => <<y,y>> \in v   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE GENERALIZATION;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE \A(x <- y, y <- z);
IsOrder(u) /\ y \in Domain(u) => <<y,y>> \in u   BECAUSE \A(o <- u, x <- y);
IsOrder(u) => IsOrder(u)   BECAUSE ImplySelf;
IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v) => IsOrder(u) /\ y \in Domain(u)
   BECAUSE MergeImplicationsAnd;
IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v) => <<y,y>> \in u   BECAUSE TI;
(IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v))
   => <<y,y>> \in u /\ <<y,y>> \in v  BECAUSE MergeImplicationsAnd; \* Impossible, u and v are disjoint
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
~(<<y,y>> \in u /\ <<y,y>> \in v)
   => ~((IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v)))   BECAUSE Contraposition;
AreDisjoint(u,v)
   => ~((IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v)))   BECAUSE TI;
pullHypos(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => ((b /\ d /\ a) => ~(c /\ e))   PROPO_TAUTO;
h(u,v) => ~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v))   BECAUSE pullHypos;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => ~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v))
      /\ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
        /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
killCase(a,b,c,d) == (~(a /\ b) /\ ((c \/ b) /\ (d \/ a))) => (c /\ d) \/ (b /\ d) \/ (c /\ a)   PROPO_TAUTO;
~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v)) /\ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE killCase;

h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE TI;
pushHypo(a,b,c) == ((a /\ b) => c) => ((a /\ b) => (a /\ c))   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => h(u,v) /\ ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))
   BECAUSE pushHypo;

IsOrder(u \union v) => (\A x : \A y : \A z : ((<<x,y>> \in u \union v) /\ (<<y,z>> \in u \union v)) => (<<x,z>> \in u \union v))
   BECAUSE DropAndBoth;
(\A x : \A y : \A z : ((<<x,y>> \in u \union v) /\ (<<y,z>> \in u \union v)) => (<<x,z>> \in u \union v))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u \union v)
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE TI;
h(u,v) => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) => <<x,z>> \in u \union v   BECAUSE HypoImplToAnd;
<<x,z>> \in woAdd(u,v) <=> (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,z>>);
(<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v))) => <<x,z>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,z>> \in u \union v => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
<<x,z>> \in u \union v => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

<<y,z>> \in u \union v <=> <<y,z>> \in u \/ <<y,z>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in u \union v => <<y,z>> \in u \/ <<y,z>> \in v   BECAUSE EquivToImpl;
<<x,y>> \in Domain(u) \X Domain(v) => <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE ImplySelf;
(<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => y \in Domain(v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE MergeImplicationsAnd;
y \in Domain(v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)
   => (y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v   BECAUSE semiDistrib;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v
   => (y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v   BECAUSE TI;
\* Proof first case is impossible
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(u) => IsGraph(u) /\ (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE DropAndRight2;
IsGraph(u) /\ (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE DropAndLeft;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)) => ((<<y,z>> \in u) => (<<y,y>> \in u /\ <<z,z>> \in u))   BECAUSE \A(x <- y, y <- z);
IsOrder(u) => ((<<y,z>> \in u) => (<<y,y>> \in u /\ <<z,z>> \in u))   BECAUSE TI;
IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE HypoImplToAnd;
<<y,y>> \in u /\ <<z,z>> \in u => <<y,y>> \in u   BECAUSE DropAndRight;
IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u   BECAUSE TI;
(IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)) => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE MergeImplicationsAnd;
~(<<y,y>> \in u /\ <<y,y>> \in v) => ~((IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)))   BECAUSE Contraposition;
AreDisjoint(u,v) => ~((IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)))   BECAUSE TI;
shuffleNot(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => (b /\ d /\ a => ~(e /\ c))   PROPO_TAUTO;
h(u,v) => ~(y \in Domain(v) /\ <<y,z>> \in u)   BECAUSE shuffleNot;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => ~(y \in Domain(v) /\ <<y,z>> \in u) /\ ((y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v)   BECAUSE MergeImplicationsAnd;
distribNot(a,b) == ~a /\ (a \/ b) => b   PROPO_TAUTO;
~(y \in Domain(v) /\ <<y,z>> \in u) /\ ((y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v)
   => <<y,z>> \in v   BECAUSE distribNot;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => <<y,z>> \in v   BECAUSE TI;
selectHypo(a,b,c,d) == (a => b) => (c /\ (a /\ d) => b)   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => x \in Domain(u)   BECAUSE selectHypo;
\A u : IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE GENERALIZATION;
IsOrder(v) /\ <<y,z>> \in v => <<y,y>> \in v /\ <<z,z>> \in v   BECAUSE \A(u <- v);
<<y,y>> \in v /\ <<z,z>> \in v => <<z,z>> \in v   BECAUSE DropAndLeft;
IsOrder(v) /\ <<y,z>> \in v => <<z,z>> \in v   BECAUSE TI;
z \in Domain(v) <=> IsDefinedOn(v, z)   BECAUSE \A(g <- v, x <- z);
(\E y : <<z,y>> \in v) => z \in Domain(v)   BECAUSE EquivToImplReverse;
<<z,z>> \in v => (\E y : <<z,y>> \in v)   BECAUSE \E(y <- z);
<<z,z>> \in v => z \in Domain(v)   BECAUSE TI;
IsOrder(v) /\ <<y,z>> \in v => z \in Domain(v)   BECAUSE TI;
IsOrder(v) => (<<y,z>> \in v => z \in Domain(v))   BECAUSE HypoAndToImpl;
<<y,z>> \in v => (IsOrder(v) => z \in Domain(v))   BECAUSE SwitchHypos;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => (IsOrder(v) => z \in Domain(v))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) /\ IsOrder(v) => z \in Domain(v)   BECAUSE HypoImplToAnd;
repeatHypo(a,b,c,d) == a /\ b /\ c /\ d => a /\ b /\ c /\ d /\ b   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) /\ IsOrder(v)   BECAUSE repeatHypo;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => z \in Domain(v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => x \in Domain(u) /\ z \in Domain(v)   BECAUSE CIA;
x \in Domain(u) /\ z \in Domain(v) <=> <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- z);
x \in Domain(u) /\ z \in Domain(v) => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE EquivToImpl;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE TI;
<<x,z>> \in (Domain(u) \X Domain(v)) => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,z>> \in (Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

\* (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
<<x,y>> \in u \union v <=> <<x,y>> \in u \/ <<x,y>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in u \union v => <<x,y>> \in u \/ <<x,y>> \in v   BECAUSE EquivToImpl;
<<y,z>> \in Domain(u) \X Domain(v) => <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE ImplySelf;
y \in Domain(u) /\ z \in Domain(v) <=> <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- y, b <- z);
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u) /\ z \in Domain(v)   BECAUSE EquivToImplReverse;
y \in Domain(u) /\ z \in Domain(v) => y \in Domain(u)   BECAUSE DropAndRight;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE TI;
<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)
   => (<<x,y>> \in u \/ <<x,y>> \in v) /\ y \in Domain(u)   BECAUSE MergeImplicationsAnd;
semiDistribRight(a,b,c) == (b \/ c) /\ a => (b \/ (c /\ a))   PROPO_TAUTO;
(<<x,y>> \in u \/ <<x,y>> \in v) /\ y \in Domain(u)
   => <<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u))   BECAUSE semiDistribRight;
<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)
   => <<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u))   BECAUSE TI; \* second case is impossible
IsOrder(u) /\ y \in Domain(u) => <<y,y>> \in u   BECAUSE \A(o <- u, x <- y);
IsOrder(v) => IsGraph(v) /\ (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE DropAndRight2;
IsGraph(v) /\ (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))
   => (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE DropAndLeft;
IsOrder(v) => (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)) => ((<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(x <- x, y <- y);
IsOrder(v) => ((<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
IsOrder(v) /\ <<x,y>> \in v => <<x,x>> \in v /\ <<y,y>> \in v   BECAUSE HypoImplToAnd;
<<x,x>> \in v /\ <<y,y>> \in v => <<y,y>> \in v   BECAUSE DropAndLeft;
IsOrder(v) /\ <<x,y>> \in v => <<y,y>> \in v   BECAUSE TI;
(IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)) => <<y,y>> \in v /\ <<y,y>> \in u   BECAUSE MergeImplicationsAnd;
<<y,y>> \in v /\ <<y,y>> \in u => <<y,y>> \in u /\ <<y,y>> \in v  BECAUSE AndSymmetry;
(IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)) => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE TI;
~(<<y,y>> \in u /\ <<y,y>> \in v) => ~((IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)))   BECAUSE Contraposition;
AreDisjoint(u,v) => ~((IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)))   BECAUSE TI;
shuffleNotBis(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => (d /\ b /\ a => ~(c /\ e))   PROPO_TAUTO;
h(u,v) => ~(<<x,y>> \in v /\ y \in Domain(u))   BECAUSE shuffleNotBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => ~(<<x,y>> \in v /\ y \in Domain(u)) /\ (<<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u)))   BECAUSE MergeImplicationsAnd;
distribNotBis(a,b) == ~a /\ (b \/ a) => b   PROPO_TAUTO;
~(<<x,y>> \in v /\ y \in Domain(u)) /\ (<<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u)))
   => <<x,y>> \in u   BECAUSE distribNotBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => <<x,y>> \in u   BECAUSE TI;
y \in Domain(u) /\ z \in Domain(v) <=> <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- y, b <- z);
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u) /\ z \in Domain(v)   BECAUSE EquivToImplReverse;
y \in Domain(u) /\ z \in Domain(v) => z \in Domain(v)   BECAUSE DropAndLeft;
<<y,z>> \in Domain(u) \X Domain(v) => z \in Domain(v)   BECAUSE TI;
selectHypoBis(a,b,c,d) == (d => b) => (c /\ (a /\ d) => b)   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => z \in Domain(v)   BECAUSE selectHypoBis;
\A y : \A z : IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE GENERALIZATION;
IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u /\ <<y,y>> \in u   BECAUSE \A(y <- x, z <- y);
<<x,x>> \in u /\ <<y,y>> \in u => <<x,x>> \in u   BECAUSE DropAndRight;
IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
(\E y : <<x,y>> \in u) => x \in Domain(u)   BECAUSE EquivToImplReverse;
<<x,x>> \in u => (\E y : <<x,y>> \in u)   BECAUSE \E(y <- x);
<<x,x>> \in u => x \in Domain(u)   BECAUSE TI;
IsOrder(u) /\ <<x,y>> \in u => x \in Domain(u)   BECAUSE TI;
IsOrder(u) => (<<x,y>> \in u => x \in Domain(u))   BECAUSE HypoAndToImpl;
<<x,y>> \in u => (IsOrder(u) => x \in Domain(u))   BECAUSE SwitchHypos;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => (IsOrder(u) => x \in Domain(u))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ IsOrder(u) => x \in Domain(u)   BECAUSE HypoImplToAnd;
repeatHypoBis(a,b,c,d) == a /\ b /\ c /\ d => a /\ b /\ c /\ d /\ a   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ IsOrder(u)   BECAUSE repeatHypoBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => x \in Domain(u)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => x \in Domain(u) /\ z \in Domain(v)   BECAUSE CIA;
x \in Domain(u) /\ z \in Domain(v) <=> <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- z);
x \in Domain(u) /\ z \in Domain(v) => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE EquivToImpl;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE TI;
<<x,z>> \in (Domain(u) \X Domain(v)) => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,z>> \in (Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

(h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)) => <<x,z>> \in woAdd(u,v)   BECAUSE CombineImplicationsStart;
(h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))) => <<x,z>> \in woAdd(u,v)   BECAUSE CombineImplicationsStart;
DistribAndOrLeft4(a,b,c,d) == (a /\ (b \/ c \/ d)) => ((a /\ b) \/ (a /\ c) \/ (a /\ d))   PROPO_TAUTO;
h(u,v) /\ ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))
   => ((h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v))
        \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v))
	\/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))))   BECAUSE DistribAndOrLeft4;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)) => ((h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v))
        \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v))
	\/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A z : h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A y : h(u,v) => (\A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;

\* Proof that orderAddition is anti-symmetric
\A z : h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE GENERALIZATION;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v))
   => ((<<x,y>> \in u \union v /\ <<y,x>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v)))   BECAUSE \A(z <- x);
\* Prove the second case is impossible : ~(<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
\* The third case is the same as the second, by generalizing then swapping x and y
<<y,x>> \in u \union v <=> <<y,x>> \in u \/ <<y,x>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in u \union v => <<y,x>> \in u \/ <<y,x>> \in v   BECAUSE EquivToImpl;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v
   => x \in Domain(u) /\ y \in Domain(v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE MergeImplicationsAnd;
multiDistrib(a,b,c,d) == a /\ b /\ (c \/ d) => (b /\ c) \/ (a /\ d)   PROPO_TAUTO;
x \in Domain(u) /\ y \in Domain(v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)
   => (y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v)   BECAUSE multiDistrib;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v
   => (y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v)   BECAUSE TI;

\A u : \A x : \A y : IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u   BECAUSE GENERALIZATION;
IsOrder(u) /\ <<y,x>> \in u => <<y,y>> \in u   BECAUSE \A(u <- u, x <- y, y <- x);
IsOrder(u) => (<<y,x>> \in u => <<y,y>> \in u)   BECAUSE HypoAndToImpl;
<<y,x>> \in u => (IsOrder(u) => <<y,y>> \in u)   BECAUSE SwitchHypos;
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(v) => (y \in Domain(v) => <<y,y>> \in v)   BECAUSE HypoAndToImpl;
y \in Domain(v) => (IsOrder(v) => <<y,y>> \in v)   BECAUSE SwitchHypos;
y \in Domain(v) /\ <<y,x>> \in u => (IsOrder(v) => <<y,y>> \in v) /\ (IsOrder(u) => <<y,y>> \in u)
   BECAUSE MergeImplicationsAnd;
factorTwoHypos(a,b,c,d) == ((a => b) /\ (c => d)) => ((a /\ c) => (b /\ d))   PROPO_TAUTO;
(IsOrder(v) => <<y,y>> \in v) /\ (IsOrder(u) => <<y,y>> \in u)
   => (IsOrder(v) /\ IsOrder(u) => <<y,y>> \in v /\ <<y,y>> \in u)   BECAUSE factorTwoHypos;
y \in Domain(v) /\ <<y,x>> \in u => (IsOrder(v) /\ IsOrder(u) => <<y,y>> \in v /\ <<y,y>> \in u)
   BECAUSE TI;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => <<y,y>> \in v /\ <<y,y>> \in u
   BECAUSE HypoImplToAnd;
<<y,y>> \in v /\ <<y,y>> \in u => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE AndSymmetry;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => <<y,y>> \in u /\ <<y,y>> \in v
   BECAUSE TI;
~~(<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE Contraposition;
(<<y,y>> \in u /\ <<y,y>> \in v) => ~~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE IntroNotNot;
(<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE TI;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => ~AreDisjoint(u,v)   BECAUSE TI;
pullH(a,b,c,d) == (a /\ (b /\ c) => ~d) => (a => ~(c /\ b /\ d))   PROPO_TAUTO;
(y \in Domain(v) /\ <<y,x>> \in u) => ~h(u,v)   BECAUSE pullH;

<<x,x>> \in u /\ <<y,y>> \in u => <<y,y>> \in u   BECAUSE DropAndLeft;
IsOrder(u) /\ <<x,y>> \in u => <<y,y>> \in u   BECAUSE TI;
\A u : \A x : \A y : IsOrder(u) /\ <<x,y>> \in u => <<y,y>> \in u   BECAUSE GENERALIZATION;
IsOrder(v) /\ <<y,x>> \in v => <<x,x>> \in v   BECAUSE \A(u <- v, x <- y, y <- x);
IsOrder(v) => (<<y,x>> \in v => <<x,x>> \in v)   BECAUSE HypoAndToImpl;
<<y,x>> \in v => (IsOrder(v) => <<x,x>> \in v)   BECAUSE SwitchHypos;
IsOrder(u) /\ x \in Domain(u) => <<x,x>> \in u   BECAUSE \A(o <- u, x <- x);
IsOrder(u) => (x \in Domain(u) => <<x,x>> \in u)   BECAUSE HypoAndToImpl;
x \in Domain(u) => (IsOrder(u) => <<x,x>> \in u)   BECAUSE SwitchHypos;
x \in Domain(u) /\ <<y,x>> \in v => (IsOrder(u) => <<x,x>> \in u) /\ (IsOrder(v) => <<x,x>> \in v)
   BECAUSE MergeImplicationsAnd;
(IsOrder(u) => <<x,x>> \in u) /\ (IsOrder(v) => <<x,x>> \in v)
   => (IsOrder(u) /\ IsOrder(v) => <<x,x>> \in u /\ <<x,x>> \in v)   BECAUSE factorTwoHypos;
x \in Domain(u) /\ <<y,x>> \in v => (IsOrder(u) /\ IsOrder(v) => <<x,x>> \in u /\ <<x,x>> \in v)
   BECAUSE TI;
x \in Domain(u) /\ <<y,x>> \in v /\ (IsOrder(u) /\ IsOrder(v)) => <<x,x>> \in u /\ <<x,x>> \in v
   BECAUSE HypoImplToAnd;
\A y : (<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE GENERALIZATION;
(<<x,x>> \in u /\ <<x,x>> \in v) => ~AreDisjoint(u,v)   BECAUSE \A(y <- x);
x \in Domain(u) /\ <<y,x>> \in v /\ (IsOrder(u) /\ IsOrder(v)) => ~AreDisjoint(u,v)   BECAUSE TI;
pullHbis(a,b,c,d) == (a /\ (b /\ c) => ~d) => (a => ~(b /\ c /\ d))   PROPO_TAUTO;
(x \in Domain(u) /\ <<y,x>> \in v) => ~h(u,v)   BECAUSE pullHbis;

(y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v) => ~h(u,v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v => ~h(u,v)   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v => ~h(u,v)   BECAUSE GENERALIZATION;
<<y,x>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in u \union v => ~h(u,v)   BECAUSE \A(x <- y, y <- x);
<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v) => <<y,x>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in u \union v   BECAUSE AndSymmetry;
<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v) => ~h(u,v)   BECAUSE TI;

IsOrder(u \union v) => (\A x : \A y : ((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE DropAndLeft;
(\A x : \A y : ((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)
   => (((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u \union v) => (((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE TI;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => (IsOrder(u \union v) => x = y)   BECAUSE SwitchHypos;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v)   BECAUSE MergeImplicationsOr;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v))
   \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
   \/ (<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v))
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v) \/ ~h(u,v)  BECAUSE MergeImplicationsOr;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v))
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v) \/ ~h(u,v)  BECAUSE TI;
dropRedundantCases(a,b,c,d) == (a => c) => ((a /\ b => (c => d) \/ ~a \/ ~a) => (a /\ b => d))   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v)) => x = y   BECAUSE dropRedundantCases;
h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE HypoAndToImpl;
\A y : h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE GENERALIZATION;
h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE Q_SCHEME;

h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v)) /\ (\A x : \A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsOrder(woAdd(u,v))   BECAUSE CIA;
disjointOrderAddition   BECAUSE GENERALIZATION;
QED

(*
   Now the multiplication of orders, which is the usual multiplication on
   natural numbers.
*)
OrderMultiplication(u,v) == CHOOSE m : \A x : x \in m
   <=> IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
       /\ ((fst(fst(x)) # fst(snd(x)) /\ << fst(fst(x)), fst(snd(x))>> \in u)
             \/ (fst(fst(x)) = fst(snd(x)) /\ << snd(fst(x)), snd(snd(x))>> \in v))

orderMultiplicationIsOrder == \A u : \A v : (IsOrder(u) /\ IsOrder(v))
   => IsOrder(OrderMultiplication(u,v))
THEOREM orderMultiplicationIsOrder


EmptyOrHasMinimum(part, order) == (part = {}) \/ (\E m : IsMinimum(m, part, order))

minOfTwoParts == \A o : \A a : \A b :
      (EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o)
        /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)
THEOREM minOfTwoParts
PROOF
VARIABLES a,b,m,o,x,y,z;
\* If a is not empty, then it has a minimum
ma(a,o) == CHOOSE m : IsMinimum(m, a, o);
killCase(a,b) == ((a \/ b) /\ ~a) => b   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ a # {}) => \E m : IsMinimum(m, a, o)   BECAUSE killCase;
(\E m : IsMinimum(m, a, o)) => IsMinimum(ma(a,o), a, o)   BECAUSE CHOOSE ma(a,o);
(EmptyOrHasMinimum(a,o) /\ a # {}) => IsMinimum(ma(a,o), a, o)   BECAUSE TI;

   \* ma(a,o) is below b
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)
   => ((ma(a,o) \in a /\ x \in b) => <<ma(a,o), x>> \in o)   BECAUSE \A(x <- ma(a,o), y <- x);
pullHypo(a,b,c,d) == (a => ((b /\ c) => d)) => ((a /\ b) => (c => d))   PROPO_TAUTO;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE pullHypo;
IsMinimum(ma(a,o), a, o) => ma(a,o) \in a   BECAUSE DropAndRight;
(EmptyOrHasMinimum(a,o) /\ a # {}) => ma(a,o) \in a   BECAUSE TI;
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) => (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)   BECAUSE ImplySelf;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)   BECAUSE MergeImplicationsAnd;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;

   \* ma(a,o) is the minimum of (a \union b)
IsMinimum(ma(a,o), a, o) => \A x : x \in a => <<ma(a,o),x>> \in o   BECAUSE DropAndLeft;
(\A x : x \in a => <<ma(a,o),x>> \in o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE \A(x <- x);
IsMinimum(ma(a,o), a, o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)) => EmptyOrHasMinimum(a,o)   BECAUSE DropAndRight;
a # {} => a # {}   BECAUSE ImplySelf;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (EmptyOrHasMinimum(a,o) /\ a # {})   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a, o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
shuffleHypos(a,b,c) == (b /\ a /\ c) => (a /\ (b /\ c))   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))    BECAUSE shuffleHypos;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))   BECAUSE CIA;
((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE TI;
unionInc   BECAUSE THEOREM;
x \in (a \union b) <=> (x \in a \/ x \in b)   BECAUSE \A(x <- a, y <- b, z <- x);
x \in (a \union b) => (x \in a \/ x \in b)   BECAUSE EquivToImpl;
((x \in a \/ x \in b) => <<ma(a,o),x>> \in o) => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
\A x : (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE GENERALIZATION;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (\A x : (x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE Q_SCHEME;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in a   BECAUSE TI;
unionFirstInc   BECAUSE THEOREM;
ma(a,o) \in a => ma(a,o) \in (a \union b)   BECAUSE \A(x <- a, y <- b, z <- ma(a,o)); 
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in (a \union b)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a \union b, o) BECAUSE CIA;
IsMinimum(ma(a,o), a \union b, o) => \E m : IsMinimum(m, a \union b, o)   BECAUSE \E(m <- ma(a,o));
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => \E m : IsMinimum(m, a \union b, o) BECAUSE TI;
(\E m : IsMinimum(m, a \union b, o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE IntroOrRight;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => EmptyOrHasMinimum(a \union b, o) BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE HypoAndToImpl;
addHypo(a,b,c) == (a /\ b /\ c) => (a /\ c)   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))   BECAUSE addHypo;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE TI;

\* If a is empty
emptyUnion   BECAUSE THEOREM;
{} \union b = b   BECAUSE \A(a <- b);
\A x : \A y : x = y => (x \union b = b <=> y \union b = b)   BECAUSE E_SCHEME;
a = {} => (a \union b = b <=> {} \union b = b)   BECAUSE \A(x <- a, y <- {});
a = {} => a \union b = b   BECAUSE ImplyEquivTrue;
\A x : \A y : x = y => (EmptyOrHasMinimum(x,o) <=> EmptyOrHasMinimum(y,o))   BECAUSE E_SCHEME;
a \union b = b => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE \A(x <- a \union b, y <- b);
a = {} => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE TI;
(a = {} /\ EmptyOrHasMinimum(b,o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE HypoEquivToAndReverse;
(EmptyOrHasMinimum(b,o) /\ a = {}) => (a = {} /\ EmptyOrHasMinimum(b,o))   BECAUSE AndSymmetry;
(EmptyOrHasMinimum(b,o) /\ a = {}) => EmptyOrHasMinimum(a \union b, o)   BECAUSE TI;
EmptyOrHasMinimum(b,o) => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE HypoAndToImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(b,o)   BECAUSE DropAndBoth;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;

(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))   BECAUSE CIA;
((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;
a = {} \/ a # {}   BECAUSE ExcludedMiddle;
(a = {} \/ a # {}) => ((EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o))   BECAUSE SwitchHypos;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)   BECAUSE MODUS_PONENS;
minOfTwoParts   BECAUSE GENERALIZATION;
QED


(*
   The class of well-orders, orders where each nonempty subset has a minimum.
   They allow to count :
      - in the well-order, take the minimum and call it zero
      - in the nonzero elements of the well-order, take the minimum and call it one
      - in the elements of the well-order that are neither zero nor one,
        take the minimum and call it two
      - iterate

   For this reason, some well-orders (the finite ones) define the natural numbers.
   The well-orders are stable under addition and multiplication, as defined above.
*)
IsWellOrder(w) == IsOrder(w) /\ (\A p : (p \subseteq Domain(w)) => EmptyOrHasMinimum(p, w))

injectWOIsWO == \A o : \A f : (IsWellOrder(o) /\ IsFunction(f)) => IsWellOrder(injectOrder(o,f))
THEOREM injectWOIsWO

disjointWOAddition == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v))
   => IsWellOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointWOAddition
PROOF
VARIABLES a,b,c,g,i,j,m,o,p,u,v,x,y,z,part;
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
disjointOrderAddition   BECAUSE THEOREM;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v \union (Domain(u) \X Domain(v)))
   BECAUSE \A(u <- u, v <- v);
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(u)   BECAUSE DropAndRight2;
IsWellOrder(u) => IsOrder(u)   BECAUSE DropAndRight;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(v)   BECAUSE DropAndBoth;
IsWellOrder(v) => IsOrder(v)   BECAUSE DropAndRight;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(v)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => AreDisjoint(u,v)   BECAUSE DropAndLeft;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE CIA;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   BECAUSE CIA;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(woAdd(u,v))   BECAUSE TI;

\* Proof that wellOrderAddition has all minimums
\* Prove part \subseteq Domain(woAdd(u,v)) => part = (part \intersect Domain(u)) \union (part \intersect Domain(v))
\* and call theorem minOfTwoParts with those two parts
domainExists   BECAUSE THEOREM;
z \in Domain(woAdd(u,v))
   <=> IsDefinedOn(woAdd(u,v),z)   BECAUSE \A(g <- woAdd(u,v), x <- z);
z \in Domain(woAdd(u,v))
   => \E y : <<z,y>> \in woAdd(u,v)   BECAUSE EquivToImpl;
unionInc   BECAUSE THEOREM;
<<z,y>> \in woAdd(u,v)
   <=> (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<z,y>>);
<<z,y>> \in woAdd(u,v)
   => (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
cartesianProductCouples   BECAUSE THEOREM;
(z \in Domain(u) /\ y \in Domain(v)) <=> <<z,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- z, b <- y);
<<z,y>> \in (Domain(u) \X Domain(v)) => (z \in Domain(u) /\ y \in Domain(v))   BECAUSE EquivToImplReverse;
(z \in Domain(u) /\ y \in Domain(v)) => z \in Domain(u)   BECAUSE DropAndRight;
<<z,y>> \in (Domain(u) \X Domain(v)) => z \in Domain(u)   BECAUSE TI;
<<z,y>> \in (u \union v) <=> (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<z,y>>);
<<z,y>> \in (u \union v) => (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE EquivToImpl;
domainInc   BECAUSE THEOREM;
<<z,y>> \in u => z \in Domain(u)   BECAUSE \A(g <- u, x <- z, y <- y);
<<z,y>> \in v => z \in Domain(v)   BECAUSE \A(g <- v, x <- z, y <- y);
(<<z,y>> \in u \/ <<z,y>> \in v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE MergeImplicationsOr;
<<z,y>> \in (u \union v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE MergeImplicationsOr;
<<z,y>> \in woAdd(u,v)
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE TI;
dropRedOr(a,z) == ((a \/ z) \/ a) => (a \/ z)   PROPO_TAUTO;
((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE dropRedOr;
<<z,y>> \in woAdd(u,v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(\E y : <<z,y>> \in woAdd(u,v)) => (\E y : z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : z \in Domain(u) \/ z \in Domain(v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : <<z,y>> \in woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in Domain(woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in (Domain(u) \union Domain(v)) <=> (z \in Domain(u) \/ z \in Domain(v))
   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- z);
(z \in Domain(u) \/ z \in Domain(v)) => z \in (Domain(u) \union Domain(v))   BECAUSE EquivToImplReverse;
z \in Domain(woAdd(u,v)) => z \in (Domain(u) \union Domain(v))   BECAUSE TI;
Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v))   BECAUSE GENERALIZATION;
transitInclusion   BECAUSE THEOREM;
(part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))
   => part \subseteq (Domain(u) \union Domain(v))   BECAUSE \A(a <- part, b <- Domain(woAdd(u,v)), c <- (Domain(u) \union Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))   BECAUSE IntroAndLeft;
part \subseteq Domain(woAdd(u,v)) => part \subseteq (Domain(u) \union Domain(v))   BECAUSE TI;
distribIntersectUnion   BECAUSE THEOREM;
(part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   BECAUSE \A(a <- part, b <- Domain(u), c <- Domain(v));
intersectSuper   BECAUSE THEOREM;
part \subseteq (Domain(u) \union Domain(v)) => (part \intersect (Domain(u) \union Domain(v))) = part
   BECAUSE \A(a <- part, b <- Domain(u) \union Domain(v));
part \subseteq Domain(woAdd(u,v)) => (part \intersect (Domain(u) \union Domain(v))) = part   BECAUSE TI;
((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE E_SCHEME;
(part \intersect (Domain(u) \union Domain(v))) = part => ((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v))))   BECAUSE IntroAndLeft;
(part \intersect (Domain(u) \union Domain(v))) = part => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq (Domain(u) \union Domain(v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq Domain(woAdd(u,v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;

IsWellOrder(u) => (\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))   BECAUSE DropAndLeft;
(\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE \A(p <- part \intersect Domain(u));
IsWellOrder(u)
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)
   => (IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE SwitchHypos;
intersectionExists   BECAUSE THEOREM;
z \in (part \intersect Domain(u)) <=> (z \in part /\ z \in Domain(u))   BECAUSE \A(u <- part, v <- Domain(u), x <- z);
z \in (part \intersect Domain(u)) => (z \in part /\ z \in Domain(u))   BECAUSE EquivToImpl;
(z \in part /\ z \in Domain(u)) => z \in Domain(u)   BECAUSE DropAndLeft;
z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)   BECAUSE GENERALIZATION;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE MODUS_PONENS;
\A u : IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE GENERALIZATION;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), v)   BECAUSE \A(u <- v);

\* Proof of EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))
IsMinimum(m, part \intersect Domain(u), u)
   => \A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u   BECAUSE DropAndLeft;
(\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in u   BECAUSE HypoImplToAnd;
x \in woAdd(u,v)
   <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => x \in woAdd(u,v)   BECAUSE EquivToImplReverse;
x \in (u \union v) => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
x \in (u \union v) => x \in woAdd(u,v)   BECAUSE TI;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
(x \in u \/ x \in v) => x \in (u \union v)   BECAUSE EquivToImplReverse;
x \in u => (x \in u \/ x \in v)   BECAUSE IntroOrLeft;
x \in u => x \in (u \union v)   BECAUSE TI;
x \in u => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in u => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in u => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(u), u) => (\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(u), u) => m \in (part \intersect Domain(u))   BECAUSE DropAndRight;
IsMinimum(m, part \intersect Domain(u), u) => IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE CIA;
(\E m : IsMinimum(m, part \intersect Domain(u), u)) => \E m : IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(u) = {}) => (part \intersect Domain(u) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE TI;

IsMinimum(m, part \intersect Domain(v), v)
   => \A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v   BECAUSE DropAndLeft;
(\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in v   BECAUSE HypoImplToAnd;
x \in v => (x \in u \/ x \in v)   BECAUSE IntroOrRight;
x \in v => x \in (u \union v)   BECAUSE TI;
x \in v => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in v => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in v => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(v), v) => (\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(v), v) => m \in (part \intersect Domain(v))   BECAUSE DropAndRight;
IsMinimum(m, part \intersect Domain(v), v) => IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE CIA;
(\E m : IsMinimum(m, part \intersect Domain(v), v)) => \E m : IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(v) = {}) => (part \intersect Domain(v) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(v), v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE TI;

\* Domination of first part by second part
\A u : \A z : z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE GENERALIZATION;
x \in (part \intersect Domain(u)) => x \in Domain(u)   BECAUSE \A(u <- u, z <- x);
y \in (part \intersect Domain(v)) => y \in Domain(v)   BECAUSE \A(u <- v, z <- y);
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => (x \in Domain(u) /\ y \in Domain(v))   BECAUSE MergeImplicationsAnd;
(x \in Domain(u) /\ y \in Domain(v)) <=> <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
(x \in Domain(u) /\ y \in Domain(v)) => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE TI;
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,y>>);
(<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v))) => <<x,y>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,y>> \in (Domain(u) \X Domain(v)) => (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,y>> \in (Domain(u) \X Domain(v)) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE GENERALIZATION;

minOfTwoParts   BECAUSE THEOREM;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))
    /\ (\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)))
   => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))
   BECAUSE \A(o <- woAdd(u,v), a <- part \intersect Domain(u), b <- part \intersect Domain(v));
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE IntroAndLeft;
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))   BECAUSE TI;
\A a : \A b : a = b => (EmptyOrHasMinimum(a, woAdd(u,v)) <=> EmptyOrHasMinimum(b, woAdd(u,v)))   BECAUSE E_SCHEME;
part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))
   BECAUSE \A(a <- part, b <- (part \intersect Domain(u)) \union (part \intersect Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE TI;
(part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE HypoEquivToAndReverse;
part \subseteq Domain(woAdd(u,v)) => part \subseteq Domain(woAdd(u,v))   BECAUSE ImplySelf;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => (part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => (part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v)))   BECAUSE AndSymmetry;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE HypoAndToImpl;
\A part : (IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE \A(part <- p);
\A p : (IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE Q_SCHEME;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsWellOrder(u) /\ IsWellOrder(v))   BECAUSE DropAndRight;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(woAdd(u,v))   BECAUSE CIA;
disjointWOAddition   BECAUSE GENERALIZATION;
QED

pasteTags(dom, tag) == productFunc(identity(dom), const(dom, tag))

\* Define a well-order on the disjoint union of two well-orders.
\* This order simply pastes v after u.
wellOrderAddition(u,v) == injectOrder(u, pasteTags(Domain(u),{}))
   \union injectOrder(v, pasteTags(Domain(v),ordinalOne))
   \union ((Domain(u)\X{{}}) \X (Domain(v)\X{ordinalOne})) \* this puts v after u

woAddIsWo == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v)) => IsWellOrder(wellOrderAddition(u,v))
THEOREM woAddIsWo
PROOF
VARIABLES a,b,c,d,f,i,j,g,o,u,v,x,y,z,tag;
\* Give shorter names
Ione(u) == injectOrder(u, pasteTags(Domain(u),{}));
Itwo(v) == injectOrder(v, pasteTags(Domain(v),ordinalOne));
DO(u,v) == Ione(u) \union Itwo(v);

\* Proof that DO is an order
productFuncIsFunc   BECAUSE THEOREM;
(IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y)))
   => IsFunction(pasteTags(Domain(u),y))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),y));
identityBiject   BECAUSE THEOREM;
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))   BECAUSE \A(d <- Domain(u));
bijectionsExists   BECAUSE THEOREM;
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))
   <=> IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE \A(d <- Domain(u), i <- Domain(u), f <- identity(Domain(u)));
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))
   => IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE EquivToImpl;
IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE MODUS_PONENS;
IsInjection(identity(Domain(u)))   BECAUSE DropAndRight2;
IsFunction(identity(Domain(u)))   BECAUSE DropAndRight;
constFunc   BECAUSE THEOREM;
IsFunction(const(Domain(u),y))   BECAUSE \A(d <- Domain(u), c <- y);
IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y))   BECAUSE IntroAndRight;
IsFunction(pasteTags(Domain(u),y))   BECAUSE MODUS_PONENS;
injectOrderIsOrder   BECAUSE THEOREM;
(IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))
   => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),y));
IsOrder(u) => (IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))   BECAUSE IntroAndLeft;
IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE TI;
\A u : \A y : IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE GENERALIZATION;
IsOrder(u) => IsOrder(Ione(u))   BECAUSE \A(u <- u, y <- {});
IsOrder(v) => IsOrder(Itwo(v))   BECAUSE \A(u <- v, y <- ordinalOne);
	   \* Proof that AreDisjoint(Ione(u),Itwo(v))
disjointOrders   BECAUSE THEOREM;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u),Itwo(v)))
   => IsOrder(Ione(u) \union Itwo(v))   BECAUSE \A(u <- Ione(u), v <- Itwo(v));
noCommonElements   BECAUSE THEOREM;
AreDisjoint(Ione(u),Itwo(v)) <=> \A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE \A(x <- Ione(u), y <- Itwo(v));
(\A z : ~(z \in Ione(u) /\ z \in Itwo(v))) => AreDisjoint(Ione(u),Itwo(v))   BECAUSE EquivToImplReverse;
injectOrderExists   BECAUSE THEOREM;
z \in Ione(u) <=> IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),{}), x <- z);
z \in Itwo(v) <=> IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE \A(o <- v, f <- pasteTags(Domain(v),ordinalOne), x <- z);
IsInInjectOrder(u,pasteTags(Domain(u),tag),z)
   => z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag)))   BECAUSE DropAndRight;
cartesianProductExists   BECAUSE THEOREM;
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) <=> (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))
   BECAUSE \A(i <- Image(pasteTags(Domain(u),tag)), j <- Image(pasteTags(Domain(u),tag)), x <- z);
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE EquivToImpl;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE TI;
(IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag))) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE DropAndLeft;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE TI;
productFuncVal   BECAUSE THEOREM;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => (IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),tag), x <- x, y <- snd(z));
(IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag)) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE DropAndLeft;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
imageExists   BECAUSE THEOREM;
snd(z) \in Image(pasteTags(Domain(u),tag)) <=> Reaches(pasteTags(Domain(u),tag),snd(z))   BECAUSE \A(g <- pasteTags(Domain(u),tag), y <- snd(z));
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)   BECAUSE EquivToImpl;
(\E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE Q_SCHEME;
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
constExists   BECAUSE THEOREM;
<<x,snd(snd(z))>> \in const(Domain(u),tag) <=> (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE \A(d <- Domain(u), c <- tag, x <- <<x,snd(snd(z))>>);
<<x,snd(snd(z))>> \in const(Domain(u),tag) => (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE EquivToImpl;
(IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)
   => snd(<<x,snd(snd(z))>>) = tag   BECAUSE DropAndLeft;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => snd(<<x,snd(snd(z))>>) = tag   BECAUSE TI;
sndExists   BECAUSE THEOREM;
snd(snd(z)) = snd(<<x,snd(snd(z))>>)   BECAUSE \A(a <- x, b <- snd(snd(z)));
snd(<<x,snd(snd(z))>>) = tag => tag = snd(<<x,snd(snd(z))>>)   BECAUSE E_SCHEME;
(tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>)) => tag = snd(snd(z))  BECAUSE E_SCHEME;
tag = snd(<<x,snd(snd(z))>>) => (tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>))   BECAUSE IntroAndLeft;
tag = snd(<<x,snd(snd(z))>>) => tag = snd(snd(z))  BECAUSE TI;
snd(<<x,snd(snd(z))>>) = tag => tag = snd(snd(z))  BECAUSE TI;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => tag = snd(snd(z))  BECAUSE TI;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => \E x : tag = snd(snd(z))  BECAUSE Q_SCHEME;
(\E x : tag = snd(snd(z))) => tag = snd(snd(z))   BECAUSE Q_SCHEME;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => tag = snd(snd(z))   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE TI;
\A u : \A tag : IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE GENERALIZATION;
IsInInjectOrder(u,pasteTags(Domain(u),{}),z) => {} = snd(snd(z))   BECAUSE \A(u <- u, tag <- {});
IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z) => ordinalOne = snd(snd(z))   BECAUSE \A(u <- v, tag <- ordinalOne);
z \in Ione(u) => IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE EquivToImpl;
z \in Ione(u) => {} = snd(snd(z))   BECAUSE TI;
z \in Itwo(v) => IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE EquivToImpl;
z \in Itwo(v) => ordinalOne = snd(snd(z))   BECAUSE TI;

(z \in Ione(u) /\ z \in Itwo(v)) => ({} = snd(snd(z)) /\ ordinalOne = snd(snd(z)))   BECAUSE MergeImplicationsAnd;
({} = snd(snd(z)) /\ ordinalOne = snd(snd(z))) => {} = ordinalOne   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => {} = ordinalOne   BECAUSE TI;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => ordinalOne = {}   BECAUSE TI;
ordinalOne # {} => ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE Contraposition;
oneIsNotZero   BECAUSE THEOREM;
~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE MODUS_PONENS;
\A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE GENERALIZATION;
AreDisjoint(Ione(u),Itwo(v))   BECAUSE MODUS_PONENS;
(IsOrder(u) /\ IsOrder(v)) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)))   BECAUSE MergeImplicationsAnd;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u), Itwo(v)))   BECAUSE IntroAndLeft;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => IsOrder(Ione(u) \union Itwo(v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(DO(u,v))   BECAUSE TI;

QED


(*
   At the moment, the addition and multiplication of well-orders are not commutative,
   even for finite ones. wellOrderAddition(u,v) and wellOrderAddition(v,u) are
   isomorphic as well-orders, but not equal.

   It would be convenient to fix one representative in each well-order isomorphy
   class, so that addition and multiplication get their usual properties. The
   ordinals achieve that, they find canonical elements for the well-orders' domains.
*)
IsTransitiveSet(x) == \A a : a \in x => a \subseteq x

(*
   Predicate asserting that the set x is strictly well-ordered by the membership
   relation \in. In those sets, \in behaves like < on the natural numbers. Actually,
   those sets start with the natural numbers and \in will be the definition of <.
*)
IsMinimumForIn(m, part) == m \in part /\ \A b : b \in part => (b = m \/ m \in b)
IsWellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ (\A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c) \* transitive
   /\ (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))

(*
   The class of ordinals, which starts with the natural numbers. This predicate
   rigorously defines what could be naively stated as
      0 = {}
      n = { 0, ..., n-1 }
*)
IsOrdinal(o) == IsTransitiveSet(o) /\ IsWellOrderedByIn(o)

ordinalTrichotomy == \A o : \A x : \A y : IsOrdinal(o) /\ x \in o /\ y \in o
   => x \in y \/ x = y \/ y \in x
THEOREM ordinalTrichotomy
PROOF
ordinalTrichotomy   BECAUSE GENERALIZATION;
QED

ordinalsWellFounded == \A o : IsOrdinal(o) => o \notin o
THEOREM ordinalsWellFounded
PROOF
VARIABLES a,o;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE DropAndLeft;
IsWellOrderedByIn(o) => (\A a : a \in o => a \notin a)   BECAUSE DropAndRight2;
IsOrdinal(o) => (\A a : a \in o => a \notin a)   BECAUSE TI;
(\A a : a \in o => a \notin a) => (o \in o => o \notin o)   BECAUSE \A(a <- o);
IsOrdinal(o) => (o \in o => o \notin o)   BECAUSE TI;
absurd(a,b) == (a => (b => ~b)) => (a => ~b)   PROPO_TAUTO;
IsOrdinal(o) => o \notin o   BECAUSE absurd;
ordinalsWellFounded   BECAUSE GENERALIZATION;
QED

(*
   The strict order \in between the elements of an ordinal p
   extends to p itself, ie p \union {p} is an ordinal and p
   is its maximum.
*)
ordinalComparesWithOwnElements == \A o : \A p : IsOrdinal(p) /\ o \in p
   => o # p /\ p \notin o
THEOREM ordinalComparesWithOwnElements
PROOF
VARIABLES a,o,p,x,z;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(p) => p \notin p   BECAUSE \A(o <- p);
\A o : \A p : o = p => (o \in x <=> p \in x)   BECAUSE E_SCHEME;
o = p => (o \in x <=> p \in x)   BECAUSE \A(o <- o, p <- p);
\A x : o = p => (o \in x <=> p \in x)   BECAUSE GENERALIZATION;
o = p => (o \in p <=> p \in p)   BECAUSE \A(x <- p);
IsOrdinal(p) /\ o = p => p \notin p /\ (o \in p <=> p \in p)   BECAUSE MergeImplicationsAnd;
absurd(a,b,c,d) == (a /\ b => ~c /\ (d <=> c)) => (a /\ d => ~b)   PROPO_TAUTO;
IsOrdinal(p) /\ o \in p => o # p   BECAUSE absurd;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE DropAndRight;
IsTransitiveSet(p) => (o \in p => o \subseteq p)   BECAUSE \A(a <- o);
IsOrdinal(p) => (o \in p => o \subseteq p)   BECAUSE TI;
IsOrdinal(p) /\ o \in p => o \subseteq p   BECAUSE HypoImplToAnd;
o \subseteq p => (p \in o => p \in p)   BECAUSE \A(z <- p);
IsOrdinal(p) /\ o \in p => (p \in o => p \in p)   BECAUSE TI;
absurdAgain(a,b,c,d) == (a => ~b) => ((a /\ c => (d => b)) => (a /\ c => ~d))   PROPO_TAUTO;
IsOrdinal(p) /\ o \in p => p \notin o   BECAUSE absurdAgain;
IsOrdinal(p) /\ o \in p => o # p /\ p \notin o   BECAUSE CIA;
ordinalComparesWithOwnElements   BECAUSE GENERALIZATION;
QED

includedOrdinal == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p) /\ o \subseteq p
   => o = p \/ o \in p
THEOREM includedOrdinal
PROOF
includedOrdinal   BECAUSE GENERALIZATION;
QED

elemOfOrdinalIsOrdinal == \A o : \A x : IsOrdinal(o) /\ x \in o => IsOrdinal(x)
THEOREM elemOfOrdinalIsOrdinal
PROOF
VARIABLES a,b,c,o,x,z;
h(o,x) == IsOrdinal(o) /\ x \in o;
\* Proof that h(o,x) => IsTransitiveSet(x)
h(o,x) => IsOrdinal(o)   BECAUSE DropAndRight;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE DropAndRight;
h(o,x) => IsTransitiveSet(o)   BECAUSE TI;
IsTransitiveSet(o) => (x \in o => x \subseteq o)   BECAUSE \A(a <- x);
h(o,x) => (x \in o => x \subseteq o)   BECAUSE TI;
h(o,x) => x \in o   BECAUSE DropAndLeft;
h(o,x) => x \subseteq o   BECAUSE KillMiddleHypo;
x \subseteq o => (a \in x => a \in o)   BECAUSE \A(z <- a);
h(o,x) => (a \in x => a \in o)   BECAUSE TI;
hh(a,o,x) == h(o,x) /\ a \in x;
hh(a,o,x) => a \in o   BECAUSE HypoImplToAnd;
IsTransitiveSet(o) => (a \in o => a \subseteq o)   BECAUSE \A(a <- a);
h(o,x) => (a \in o => a \subseteq o)   BECAUSE TI;
hh(a,o,x) => h(o,x)   BECAUSE DropAndRight;
hh(a,o,x) => (a \in o => a \subseteq o)   BECAUSE TI;
hh(a,o,x) => a \subseteq o   BECAUSE KillMiddleHypo;
a \subseteq o => (z \in a => z \in o)   BECAUSE \A(z <- z);
hh(a,o,x) => (z \in a => z \in o)   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o   BECAUSE HypoImplToAnd;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE DropAndLeft;
IsWellOrderedByIn(o) => (\A a : \A b : \A c : (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c) => a \in c)   BECAUSE DropAndBoth;
(\A a : \A b : \A c : (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c) => a \in c)
   => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE \A(a <- z, b <- a, c <- x);
IsWellOrderedByIn(o) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
IsOrdinal(o) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
h(o,x) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) /\ z \in a => hh(a,o,x)   BECAUSE DropAndRight;
hh(a,o,x) /\ z \in a => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) /\ z \in a => a \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o   BECAUSE CIA;
hh(a,o,x) => x \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => x \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o   BECAUSE CIA;
hh(a,o,x) /\ z \in a => z \in a   BECAUSE DropAndLeft;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o /\ z \in a   BECAUSE CIA;
hh(a,o,x) => a \in x   BECAUSE DropAndLeft;
hh(a,o,x) /\ z \in a => a \in x   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x   BECAUSE CIA;
hh(a,o,x) /\ z \in a => z \in x   BECAUSE KillMiddleHypo;
hh(a,o,x) => (z \in a => z \in x)   BECAUSE HypoAndToImpl;
\A z : hh(a,o,x) => (z \in a => z \in x)   BECAUSE GENERALIZATION;
hh(a,o,x) => a \subseteq x   BECAUSE Q_SCHEME;
h(o,x) => (a \in x => a \subseteq x)   BECAUSE HypoAndToImpl;
\A a : h(o,x) => (a \in x => a \subseteq x)   BECAUSE GENERALIZATION;
h(o,x) => IsTransitiveSet(x)   BECAUSE Q_SCHEME;

\* Proof of h(o,x) => IsWellOrderedByIn(x)
IsWellOrderedByIn(o) => \A a : a \in o => a \notin a   BECAUSE DropAndRight2;
(\A a : a \in o => a \notin a) => (a \in o => a \notin a)   BECAUSE \A(a <- a);
IsWellOrderedByIn(o) => (a \in o => a \notin a)   BECAUSE TI;
IsOrdinal(o) => (a \in o => a \notin a)   BECAUSE TI;
h(o,x) => (a \in o => a \notin a)   BECAUSE TI;
hh(a,o,x) => (a \in o => a \notin a)   BECAUSE TI;
hh(a,o,x) => a \notin a   BECAUSE KillMiddleHypo;
h(o,x) => (a \in x => a \notin a)   BECAUSE HypoAndToImpl;
\A a : h(o,x) => (a \in x => a \notin a)   BECAUSE GENERALIZATION;
h(o,x) => (\A a : a \in x => a \notin a)   BECAUSE Q_SCHEME;
(*
IsWellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ (\A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c) \* transitive
   /\ (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))
*)

elemOfOrdinalIsOrdinal   BECAUSE GENERALIZATION;
QED

\* The only increasing bijection between two ordinals is the identity function.
\* Which means two ordinals in increasing bijection are equal.
bijectOrdinalsEqual == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p)
        /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   => o = p
THEOREM bijectOrdinalsEqual
PROOF
VARIABLES a,b,d,f,g,i,o,p,x,y,z;
\* If f is not the identity, there is a minimum element m(o,p) such that
\* f[m(o,p)] # m(o,p). But then we will show that m(o,p) \in p and
\* f doesn't reach it, contradicting f is bijection.
cf(o,p) == CHOOSE f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y];
\* By separation, take the subset of o where cf[x] # x
\A a : \E b : \A x : x \in b <=> x \in a /\ cf(o,p)[x] # x   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in o /\ cf(o,p)[x] # x   BECAUSE \A(a <- o);
cb(o,p) == CHOOSE b : \A x : x \in b <=> x \in o /\ cf(o,p)[x] # x;
\A x : x \in cb(o,p) <=> x \in o /\ cf(o,p)[x] # x   BECAUSE CHOOSE cb(o,p);
cm(o,p) == CHOOSE m : IsMinimumForIn(m, cb(o,p)); \* we will show that m does not exist
IsMinimumForIn(cm(o,p), cb(o,p)) => cm(o,p) \in cb(o,p)   BECAUSE DropAndRight;
cm(o,p) \in cb(o,p) <=> cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE \A(x <- cm(o,p));
cm(o,p) \in cb(o,p) => cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE EquivToImpl;
cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p) => cm(o,p) \in o   BECAUSE DropAndRight;
cm(o,p) \in cb(o,p) => cm(o,p) \in o   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => cm(o,p) \in o   BECAUSE TI;
\* The hypotheses and all their implications. Prove that h(o,p) is false,
\* in other words ~IsMinimumForIn(cm(o,p), cb(o,p)).
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p)
        /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   /\ IsMinimumForIn(cm(o,p), cb(o,p));
h(o,p) => h(o,p)   BECAUSE ImplySelf;
h(o,p) => IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE DropAndLeft;
h(o,p) => IsOrdinal(o) /\ IsOrdinal(p)   BECAUSE DropAndRight2;
IsOrdinal(o) /\ IsOrdinal(p) => IsOrdinal(p)   BECAUSE DropAndLeft;
h(o,p) => IsOrdinal(p)   BECAUSE TI;
IsOrdinal(o) /\ IsOrdinal(p) => IsOrdinal(o)   BECAUSE DropAndRight;
h(o,p) => IsOrdinal(o)   BECAUSE TI;
h(o,p) => (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])   BECAUSE DropAndBoth;
(\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE CHOOSE cf(o,p);
h(o,p) => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE TI;
(cf(o,p) \in Bijections(o,p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => cf(o,p) \in Bijections(o,p)   BECAUSE DropAndRight;
h(o,p) => cf(o,p) \in Bijections(o,p)   BECAUSE TI;
(cf(o,p) \in Bijections(o,p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]   BECAUSE DropAndLeft;
h(o,p) => \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]   BECAUSE TI;

\* Proof that h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z
\* (z is below the minimum cm(o,p), so doesn't have its defining property)
h(o,p) => cm(o,p) \in o   BECAUSE TI;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(o) /\ cm(o,p) \in o => IsOrdinal(cm(o,p))   BECAUSE \A(o <- o, x <- cm(o,p));
h(o,p) => IsOrdinal(o) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => IsOrdinal(cm(o,p))   BECAUSE TI;
bijApply   BECAUSE THEOREM;
(cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in o) => cf(o,p)[cm(o,p)] \in p
   BECAUSE \A(f <- cf(o,p), a <- o, b <- p, x <- cm(o,p));
h(o,p) => cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => cf(o,p)[cm(o,p)] \in p   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => \A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)   BECAUSE DropAndLeft;
h(o,p) => \A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)   BECAUSE TI;
(\A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)) => (z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z))
   BECAUSE \A(b <- z);
h(o,p) => (z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z))   BECAUSE TI;
h(o,p) /\ z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE HypoImplToAnd;
~(z = cm(o,p) \/ cm(o,p) \in z) => ~(h(o,p) /\ z \in cb(o,p))   BECAUSE Contraposition;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) /\ z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z   BECAUSE \A(o <- z, p <- cm(o,p));
IsOrdinal(cm(o,p)) => (z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z)   BECAUSE HypoAndToImpl;
h(o,p) => (z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z)   BECAUSE TI;
z # cm(o,p) /\ cm(o,p) \notin z => ~(z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE FactorNotOr;
h(o,p) /\ z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z   BECAUSE HypoImplToAnd;
h(o,p) /\ z \in cm(o,p) => ~(z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => ~(h(o,p) /\ z \in cb(o,p))   BECAUSE TI;
killCase(a,b,c) == (a /\ b => ~(a /\ c)) => (a /\ b => ~c)   PROPO_TAUTO;
h(o,p) /\ z \in cm(o,p) => z \notin cb(o,p)   BECAUSE killCase;
z \in cb(o,p) <=> z \in o /\ cf(o,p)[z] # z   BECAUSE \A(x <- z);
z \in o /\ cf(o,p)[z] # z => z \in cb(o,p)   BECAUSE EquivToImplReverse;
z \notin cb(o,p) => ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE Contraposition;
h(o,p) /\ z \in cm(o,p) => ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE TI;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE DropAndRight;
IsTransitiveSet(o) => (cm(o,p) \in o => cm(o,p) \subseteq o)   BECAUSE \A(a <- cm(o,p));
IsTransitiveSet(o) /\ cm(o,p) \in o => cm(o,p) \subseteq o   BECAUSE HypoImplToAnd;
h(o,p) => IsTransitiveSet(o)   BECAUSE TI;
h(o,p) => IsTransitiveSet(o) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => cm(o,p) \subseteq o   BECAUSE TI;
cm(o,p) \subseteq o => (z \in cm(o,p) => z \in o)   BECAUSE \A(z <- z);
h(o,p) => (z \in cm(o,p) => z \in o)   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => z \in o   BECAUSE HypoImplToAnd;
h(o,p) /\ z \in cm(o,p) => z \in o /\ ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE CIA;
killCaseB(a,b) == a /\ ~(a /\ ~b) => b   PROPO_TAUTO;
z \in o /\ ~(z \in o /\ cf(o,p)[z] # z) => cf(o,p)[z] = z   BECAUSE killCaseB;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z   BECAUSE TI;

\* Proof that cm(o,p) \subseteq cf(o,p)[cm(o,p)]
(\A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])
   => (z \in cm(o,p) /\ cm(o,p) \in o => cf(o,p)[z] \in cf(o,p)[cm(o,p)])   BECAUSE \A(x <- z, y <- cm(o,p));
h(o,p) => (z \in cm(o,p) /\ cm(o,p) \in o => cf(o,p)[z] \in cf(o,p)[cm(o,p)])   BECAUSE TI;
h(o,p) /\ (z \in cm(o,p) /\ cm(o,p) \in o) => cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE HypoImplToAnd;
pushHypo(a,b,c) == (a => c) => (a /\ b => a /\ (b /\ c))   PROPO_TAUTO;
h(o,p) /\ z \in cm(o,p) => h(o,p) /\ (z \in cm(o,p) /\ cm(o,p) \in o)   BECAUSE pushHypo;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z /\ cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE CIA;
\A y : \A z : y = z => (y \in cf(o,p)[cm(o,p)] <=> z \in cf(o,p)[cm(o,p)])   BECAUSE E_SCHEME;
cf(o,p)[z] = z => (cf(o,p)[z] \in cf(o,p)[cm(o,p)] <=> z \in cf(o,p)[cm(o,p)])   BECAUSE \A(y <- cf(o,p)[z], z <- z);
cf(o,p)[z] = z /\ cf(o,p)[z] \in cf(o,p)[cm(o,p)] => z \in cf(o,p)[cm(o,p)]   BECAUSE HypoEquivToAnd;
h(o,p) /\ z \in cm(o,p) => z \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) => (z \in cm(o,p) => z \in cf(o,p)[cm(o,p)])   BECAUSE HypoAndToImpl;
\A z : h(o,p) => (z \in cm(o,p) => z \in cf(o,p)[cm(o,p)])   BECAUSE GENERALIZATION;
h(o,p) => cm(o,p) \subseteq cf(o,p)[cm(o,p)]   BECAUSE Q_SCHEME;

\* Proof that h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)] \in p. By ordinal comparison,
\* cm(o,p) \subseteq cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)] \/ cm(o,p) \in cf(o,p)[cm(o,p)],
\* and since f[m] # m we have the other case.
includedOrdinal   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)]) /\ cm(o,p) \subseteq cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)] \/ cm(o,p) \in cf(o,p)[cm(o,p)]
   BECAUSE \A(o <- cm(o,p), p <- cf(o,p)[cm(o,p)]);
IsOrdinal(p) /\ cf(o,p)[cm(o,p)] \in p => IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE \A(o <- p, x <- cf(o,p)[cm(o,p)]);
h(o,p) => IsOrdinal(p) /\ cf(o,p)[cm(o,p)] \in p   BECAUSE CIA;
h(o,p) => IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE TI;
h(o,p) => IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE CIA;
h(o,p) => IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)]) /\ cm(o,p) \subseteq cf(o,p)[cm(o,p)]   BECAUSE CIA;
h(o,p) => cm(o,p) = cf(o,p)[cm(o,p)] \/ cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE TI;
cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE DropAndLeft;
cm(o,p) \in cb(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
h(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
cm(o,p) = cf(o,p)[cm(o,p)] => cf(o,p)[cm(o,p)] = cm(o,p)   BECAUSE E_SCHEME;
cf(o,p)[cm(o,p)] # cm(o,p) => cm(o,p) # cf(o,p)[cm(o,p)]   BECAUSE Contraposition;
h(o,p) => cm(o,p) # cf(o,p)[cm(o,p)]   BECAUSE TI;
killCaseC(a,b,c) == (a => ~b) => ((a => (b \/ c)) => (a => c))   PROPO_TAUTO;
h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE killCaseC;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE DropAndRight;
IsTransitiveSet(p) => (cf(o,p)[cm(o,p)] \in p => cf(o,p)[cm(o,p)] \subseteq p)   BECAUSE \A(a <- cf(o,p)[cm(o,p)]);
IsTransitiveSet(p) /\ cf(o,p)[cm(o,p)] \in p => cf(o,p)[cm(o,p)] \subseteq p   BECAUSE HypoImplToAnd;
h(o,p) => IsTransitiveSet(p)   BECAUSE TI;
h(o,p) => IsTransitiveSet(p) /\ cf(o,p)[cm(o,p)] \in p   BECAUSE CIA;
h(o,p) => cf(o,p)[cm(o,p)] \subseteq p   BECAUSE TI;
cf(o,p)[cm(o,p)] \subseteq p => (cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p)   BECAUSE \A(z <- cm(o,p));
h(o,p) => (cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p   BECAUSE HypoImplToAnd;
h(o,p) => h(o,p) /\ cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE CIA;
h(o,p) => cm(o,p) \in p   BECAUSE TI;

\* Proof that f doesn't reach m, which contradicts that
\* f is a bijection. There are 3 cases :
\*    - z \in m => f[z] = z # m
\*    - f[m] # m
\*    - m \in z => m \in f[m] \in f[z]
bijPreApply   BECAUSE THEOREM;
(cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in p) => pre(cf(o,p),cm(o,p)) \in o
   BECAUSE \A(f <- cf(o,p), a <- o, b <- p, y <- cm(o,p));
h(o,p) => (cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in p)   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \in o   BECAUSE TI;
ordinalTrichotomy   BECAUSE THEOREM;
IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o /\ cm(o,p) \in o
   => pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))
   BECAUSE \A(o <- o, x <- pre(cf(o,p),cm(o,p)), y <- cm(o,p));
h(o,p) => IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o   BECAUSE CIA;
h(o,p) => IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))
   BECAUSE TI;
funcInversePre   BECAUSE THEOREM;
IsFunction(cf(o,p)) /\ cm(o,p) \in Image(cf(o,p)) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)
   BECAUSE \A(f <- cf(o,p), y <- cm(o,p));
bijectionsExists   BECAUSE THEOREM;
cf(o,p) \in Bijections(o,p) <=> IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p   BECAUSE \A(d <- o, i <- p, f <- cf(o,p));
cf(o,p) \in Bijections(o,p) => IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p   BECAUSE EquivToImpl;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => IsInjection(cf(o,p))   BECAUSE DropAndRight2;
cf(o,p) \in Bijections(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) => IsFunction(cf(o,p))   BECAUSE DropAndRight;
h(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
h(o,p) => IsFunction(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Image(cf(o,p)) = p   BECAUSE DropAndLeft;
cf(o,p) \in Bijections(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
h(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
\A x : \A y : x = y => (cm(o,p) \in x <=> cm(o,p) \in y)   BECAUSE E_SCHEME;
Image(cf(o,p)) = p => (cm(o,p) \in Image(cf(o,p)) <=> cm(o,p) \in p)   BECAUSE \A(x <- Image(cf(o,p)), y <- p);
h(o,p) => (cm(o,p) \in Image(cf(o,p)) <=> cm(o,p) \in p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in p => cm(o,p) \in Image(cf(o,p))   BECAUSE HypoEquivToAndReverse;
h(o,p) => h(o,p) /\ cm(o,p) \in p   BECAUSE CIA;
h(o,p) => cm(o,p) \in Image(cf(o,p))   BECAUSE TI;
h(o,p) => IsFunction(cf(o,p)) /\ cm(o,p) \in Image(cf(o,p))   BECAUSE CIA;
h(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)   BECAUSE TI;
\* First case
\A z : h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z   BECAUSE GENERALIZATION;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)
   => cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))   BECAUSE \A(z <- pre(cf(o,p),cm(o,p)));
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => h(o,p)   BECAUSE DropAndRight;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)   BECAUSE TI;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)
   => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))   BECAUSE CIA;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))
   => cm(o,p) = pre(cf(o,p),cm(o,p))   BECAUSE E_SCHEME;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) = pre(cf(o,p),cm(o,p))   BECAUSE TI;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => pre(cf(o,p),cm(o,p)) \in cm(o,p)   BECAUSE DropAndLeft;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) = pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)   BECAUSE CIA;
\A x : \A y : x = y => (x \in cm(o,p) <=> y \in cm(o,p))   BECAUSE E_SCHEME;
cm(o,p) = pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cm(o,p) <=> pre(cf(o,p),cm(o,p)) \in cm(o,p))   BECAUSE \A(x <- cm(o,p), y <- pre(cf(o,p),cm(o,p)));
cm(o,p) = pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) \in cm(o,p)   BECAUSE HypoEquivToAndReverse;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) \in cm(o,p)   BECAUSE TI;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) => cm(o,p) \notin cm(o,p)   BECAUSE \A(o <- cm(o,p));
h(o,p) => cm(o,p) \notin cm(o,p)   BECAUSE TI;
killCaseD(h,a,b) == (h => ~a) => ((h /\ b => a) => (h => ~b))   PROPO_TAUTO;
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p)   BECAUSE killCaseD;
\* Second case
\A x : \A y : x = y => (cf(o,p)[x] = cf(o,p)[y])   BECAUSE E_SCHEME;
pre(cf(o,p),cm(o,p)) = cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)]   BECAUSE \A(x <- pre(cf(o,p),cm(o,p)), y <- cm(o,p));
h(o,p) /\ pre(cf(o,p),cm(o,p)) = cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)]   BECAUSE MergeImplicationsAnd;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE E_SCHEME;
h(o,p) /\ pre(cf(o,p),cm(o,p)) = cm(o,p) => cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) => pre(cf(o,p),cm(o,p)) # cm(o,p)   BECAUSE killCaseD;
\* Third case
(\A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])
   => (cm(o,p) \in pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in o => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))])   BECAUSE \A(x <- cm(o,p), y <- pre(cf(o,p),cm(o,p)));
h(o,p) => (cm(o,p) \in pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in o => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))])   BECAUSE TI;
killCaseE(h,a,b,c) == (h => b) => ((h => (a /\ b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))]   BECAUSE killCaseE;
\A x : \A y : x = y => (cf(o,p)[cm(o,p)] \in x <=> cf(o,p)[cm(o,p)] \in y)   BECAUSE E_SCHEME;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) => (cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] <=> cf(o,p)[cm(o,p)] \in cm(o,p))   BECAUSE \A(x <- cf(o,p)[pre(cf(o,p),cm(o,p))], y <- cm(o,p));
h(o,p) => (cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] <=> cf(o,p)[cm(o,p)] \in cm(o,p))   BECAUSE TI;
h(o,p) /\ cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] => cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE HypoEquivToAnd;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => h(o,p)   BECAUSE DropAndRight;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => h(o,p) /\ cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))]   BECAUSE CIA;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE CIA;
IsOrdinal(cm(o,p)) => IsTransitiveSet(cm(o,p))   BECAUSE DropAndRight;
IsTransitiveSet(cm(o,p)) => (a \in cm(o,p) => a \subseteq cm(o,p))   BECAUSE \A(a <- a);
h(o,p) => IsTransitiveSet(cm(o,p))   BECAUSE TI;
h(o,p) => (a \in cm(o,p) => a \subseteq cm(o,p))   BECAUSE TI;
h(o,p) /\ a \in cm(o,p) => a \subseteq cm(o,p)   BECAUSE HypoImplToAnd;
a \subseteq cm(o,p) => (cm(o,p) \in a => cm(o,p) \in cm(o,p))   BECAUSE \A(z <- cm(o,p));
h(o,p) /\ a \in cm(o,p) => (cm(o,p) \in a => cm(o,p) \in cm(o,p))   BECAUSE TI;
switchImpl(a,b,c,h) == (h /\ a => (b => c)) => (h => (b /\ a => c))   PROPO_TAUTO;
h(o,p) => (cm(o,p) \in a /\ a \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE switchImpl;
\A a : h(o,p) => (cm(o,p) \in a /\ a \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE GENERALIZATION;
h(o,p) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE \A(a <- cf(o,p)[cm(o,p)]);
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)) /\ (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE CIA;
andMP(a,b) == (a /\ (a => b)) => b   PROPO_TAUTO;
(cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)) /\ (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p)) => cm(o,p) \in cm(o,p)   BECAUSE andMP;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cm(o,p)   BECAUSE TI;
h(o,p) => cm(o,p) \notin pre(cf(o,p),cm(o,p))   BECAUSE killCaseD;

\* Conclusion that h(o,p) is false
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p)   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p) /\ cm(o,p) \notin pre(cf(o,p),cm(o,p))   BECAUSE CIA;
FactorNotOr3(a,b,c) == (~a /\ ~b /\ ~c) => ~(a \/ b \/ c)   PROPO_TAUTO;
pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p) /\ cm(o,p) \notin pre(cf(o,p),cm(o,p))
   => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE FactorNotOr3;
h(o,p) => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE TI;
h(o,p) => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))) /\ (pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE CIA;
absurd(a,h) == h => (~a /\ a) => ~h   PROPO_TAUTO;
~h(o,p)   BECAUSE absurd;
killCaseF(a,b) == ~(a /\ b) => (a => ~b)   PROPO_TAUTO;
\* The correct hypothesis
hh(o,p) == IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y]);
hh(o,p) => ~IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE killCaseF;
(\E m : IsMinimumForIn(m, cb(o,p))) => IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE CHOOSE cm(o,p);
~IsMinimumForIn(cm(o,p), cb(o,p)) => ~(\E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE Contraposition;
hh(o,p) => ~(\E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE TI;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE DropAndLeft;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE DropAndLeft;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))
   => (cb(o,p) \subseteq o => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE \A(p <- cb(o,p));
IsWellOrderedByIn(o) => (cb(o,p) \subseteq o => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE TI;
z \in cb(o,p) <=> z \in o /\ cf(o,p)[z] # z   BECAUSE \A(x <- z);
z \in cb(o,p) => z \in o /\ cf(o,p)[z] # z   BECAUSE EquivToImpl;
z \in o /\ cf(o,p)[z] # z => z \in o   BECAUSE DropAndRight;
z \in cb(o,p) => z \in o   BECAUSE TI;
cb(o,p) \subseteq o   BECAUSE GENERALIZATION;
cb(o,p) \subseteq o => (IsWellOrderedByIn(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE SwitchHypos;
IsWellOrderedByIn(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE MODUS_PONENS;
IsOrdinal(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE TI;
hh(o,p) => IsOrdinal(o)   BECAUSE DropAndRight2;
hh(o,p) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE TI;
killCaseG(h,a,b) == (h => ~a) => ((h => b \/ a) => (h => b))   PROPO_TAUTO;
hh(o,p) => cb(o,p) = {}   BECAUSE killCaseG;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
cb(o,p) = {} => (a \in cb(o,p) <=> a \in {})   BECAUSE \A(x <- cb(o,p), y <- {});
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
implyEquivFalse(a,b,f) == ~f => ((a => (b <=> f)) => (a => ~b))   PROPO_TAUTO;
cb(o,p) = {} => a \notin cb(o,p)   BECAUSE implyEquivFalse;
a \in cb(o,p) <=> a \in o /\ cf(o,p)[a] # a   BECAUSE \A(x <- a);
a \in o /\ cf(o,p)[a] # a => a \in cb(o,p)   BECAUSE EquivToImplReverse;
a \notin cb(o,p) => ~(a \in o /\ cf(o,p)[a] # a)   BECAUSE Contraposition;
cb(o,p) = {} => ~(a \in o /\ cf(o,p)[a] # a)   BECAUSE TI;
distribImpl(a,b) == ~(a /\ ~b) => (a => b)   PROPO_TAUTO;
~(a \in o /\ cf(o,p)[a] # a) => (a \in o => cf(o,p)[a] = a)   BECAUSE distribImpl;
cb(o,p) = {} => (a \in o => cf(o,p)[a] = a)   BECAUSE TI;
hh(o,p) => (a \in o => cf(o,p)[a] = a)   BECAUSE TI;
\* Prove hh(o,p) => cf(o,p) = identity(o) by funcEqual,
\* then its domain and image are the same, o = p.
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Domain(cf(o,p)) = o   BECAUSE DropAndBoth;
cf(o,p) \in Bijections(o,p) => Domain(cf(o,p)) = o   BECAUSE TI;
hh(o,p) => (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])   BECAUSE DropAndLeft;
hh(o,p) => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE TI;
(cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => cf(o,p) \in Bijections(o, p)   BECAUSE DropAndRight;
hh(o,p) => cf(o,p) \in Bijections(o, p)   BECAUSE TI;
hh(o,p) => Domain(cf(o,p)) = o   BECAUSE TI;
identityBiject   BECAUSE THEOREM;
identity(o) \in Bijections(o,o)   BECAUSE \A(d <- o);
identity(o) \in Bijections(o,o) <=> IsInjection(identity(o)) /\ Domain(identity(o)) = o /\ Image(identity(o)) = o
   BECAUSE \A(d <- o, i <- o, f <- identity(o));
IsInjection(identity(o)) /\ Domain(identity(o)) = o /\ Image(identity(o)) = o   BECAUSE MODUS_PONENS;
IsInjection(identity(o))   BECAUSE DropAndRight2;
IsFunction(identity(o))   BECAUSE DropAndRight;
Domain(identity(o)) = o   BECAUSE DropAndBoth;
funcEqual   BECAUSE THEOREM;
IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))
   /\ (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])
   => cf(o,p) = identity(o)   BECAUSE \A(f <- cf(o,p), g <- identity(o));
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => IsInjection(cf(o,p))   BECAUSE DropAndRight2;
cf(o,p) \in Bijections(o, p) => IsInjection(cf(o,p))   BECAUSE TI;
hh(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) => IsFunction(cf(o,p))   BECAUSE DropAndRight;
hh(o,p) => IsFunction(cf(o,p))   BECAUSE TI;
hh(o,p) => IsFunction(identity(o))   BECAUSE PT1;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o))  BECAUSE CIA;
hh(o,p) => Domain(identity(o)) = o   BECAUSE PT1;
hh(o,p) => Domain(cf(o,p)) = o /\ Domain(identity(o)) = o   BECAUSE CIA;
Domain(cf(o,p)) = o /\ Domain(identity(o)) = o => Domain(cf(o,p)) = Domain(identity(o))   BECAUSE E_SCHEME;
hh(o,p) => Domain(cf(o,p)) = Domain(identity(o))   BECAUSE TI;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o))   BECAUSE CIA;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))   BECAUSE CIA;
identityVal   BECAUSE THEOREM;
a \in o => (identity(o)[a] = a /\ pre(identity(o),a) = a)   BECAUSE \A(d <- o, x <- a);
(identity(o)[a] = a /\ pre(identity(o),a) = a) => identity(o)[a] = a   BECAUSE DropAndRight;
a \in o => identity(o)[a] = a   BECAUSE TI;
hh(o,p) => (a \in o => identity(o)[a] = a)   BECAUSE PT1;
hh(o,p) /\ a \in o => identity(o)[a] = a   BECAUSE HypoImplToAnd;
hh(o,p) /\ a \in o => cf(o,p)[a] = a   BECAUSE HypoImplToAnd;
hh(o,p) /\ a \in o => cf(o,p)[a] = a /\ identity(o)[a] = a   BECAUSE CIA;
cf(o,p)[a] = a /\ identity(o)[a] = a => cf(o,p)[a] = identity(o)[a]   BECAUSE E_SCHEME;
hh(o,p) /\ a \in o => cf(o,p)[a] = a /\ identity(o)[a] = a   BECAUSE CIA;
hh(o,p) /\ a \in o => cf(o,p)[a] = identity(o)[a]   BECAUSE TI;
hh(o,p) => (a \in o => cf(o,p)[a] = identity(o)[a])   BECAUSE HypoAndToImpl;
\A x : \A y : x = y => ((a \in x => cf(o,p)[a] = identity(o)[a]) <=> (a \in y => cf(o,p)[a] = identity(o)[a]))
   BECAUSE E_SCHEME;
Domain(cf(o,p)) = o => ((a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a]) <=> (a \in o => cf(o,p)[a] = identity(o)[a]))   BECAUSE \A(x <- Domain(cf(o,p)), y <- o);
hh(o,p) => ((a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a]) <=> (a \in o => cf(o,p)[a] = identity(o)[a]))   BECAUSE TI;
hh(o,p) /\ (a \in o => cf(o,p)[a] = identity(o)[a]) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE HypoEquivToAndReverse;
hh(o,p) => hh(o,p)   BECAUSE ImplySelf;
hh(o,p) => hh(o,p) /\ (a \in o => cf(o,p)[a] = identity(o)[a])   BECAUSE CIA;
hh(o,p) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE TI;
\A a : hh(o,p) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE GENERALIZATION;
hh(o,p) => (x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE \A(a <- x);
\A x : hh(o,p) => (x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE GENERALIZATION;
hh(o,p) => (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE Q_SCHEME;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))
   /\ (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE CIA;
hh(o,p) => cf(o,p) = identity(o)   BECAUSE TI;
\A x : \A y : x = y => Image(x) = Image(y)   BECAUSE E_SCHEME;
cf(o,p) = identity(o) => Image(cf(o,p)) = Image(identity(o))   BECAUSE \A(x <- cf(o,p), y <- identity(o));
hh(o,p) => Image(cf(o,p)) = Image(identity(o))   BECAUSE TI;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Image(cf(o,p)) = p   BECAUSE DropAndLeft;
hh(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
hh(o,p) => Image(cf(o,p)) = p /\ Image(cf(o,p)) = Image(identity(o))   BECAUSE CIA;
Image(cf(o,p)) = p /\ Image(cf(o,p)) = Image(identity(o)) => p = Image(identity(o))  BECAUSE E_SCHEME;
hh(o,p) => p = Image(identity(o))  BECAUSE TI;
Image(identity(o)) = o   BECAUSE DropAndLeft;
Image(identity(o)) = o => o = Image(identity(o))   BECAUSE E_SCHEME;
o = Image(identity(o))   BECAUSE MODUS_PONENS;
hh(o,p) => o = Image(identity(o))   BECAUSE PT1;
hh(o,p) => o = Image(identity(o)) /\ p = Image(identity(o))   BECAUSE CIA;
o = Image(identity(o)) /\ p = Image(identity(o)) => o = p   BECAUSE E_SCHEME;
hh(o,p) => o = p   BECAUSE TI;
bijectOrdinalsEqual   BECAUSE GENERALIZATION;
QED

(*
   This is the link between a well-order and an ordinal :
   when there is an increasing bijection between them.
*)
IsOrdinalOfWellOrder(o, w) == IsOrdinal(o) /\ IsWellOrder(w)
 /\ (\E f : f \in Bijections(Domain(w), o) /\ \A x : \A y : <<x,y>> \in w => f[x] \subseteq f[y])

uniqueOrdinalOfWellOrder == \A w : \A o : \A p :
   IsOrdinalOfWellOrder(o, w) /\ IsOrdinalOfWellOrder(p, w) => o = p
THEOREM uniqueOrdinalOfWellOrder
\* To prove this, compose the two functions to make an increasing bijection
\* between o and p, then conclude by the previous theorem.

(*
   With this unicity of a well-order's ordinal, we can now prove
   its existence. By the replacement axiom scheme, each element x
   of a well-order w is sent to the unique ordinal of the initial
   segment [min(w), x[.

   This forms a set of ordinals, which will be shown to be an ordinal.
   The final step is to prove that this ordinal is isomorphic to w.
*)
OrdinalOfWellOrder(w) == CHOOSE o : IsOrdinalOfWellOrder(o, w)
ordinalOfWellOrderExists == \A w : IsWellOrder(w)
   => IsOrdinalOfWellOrder(OrdinalOfWellOrder(w), w)
THEOREM ordinalOfWellOrderExists

\* The empty set is the smallest ordinal, called "zero" as an ordinal
ordinalZero == IsOrdinal( {} )
THEOREM ordinalZero
PROOF
\* Just check implications starting with the false formula x \in {}
VARIABLES a,b,c,p,x;
\* Proof of TransitiveSet( {} )
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
a \in {} => a \subseteq {}   BECAUSE Explosion;
IsTransitiveSet( {} )   BECAUSE GENERALIZATION;

\* Proof of irreflexive
a \in {} => a \notin a   BECAUSE Explosion;
\A a : a \in {} => a \notin a   BECAUSE GENERALIZATION;

\* Proof of transitive order
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c)
   => (a \in {} /\ b \in {} /\ c \in {})   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {}) => a \in {}   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in {}   BECAUSE TI;
a \in {} => a \in c   BECAUSE Explosion;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE TI;
\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE GENERALIZATION;

\* Proof of minimums
includedInEmpty   BECAUSE THEOREM;
p \subseteq {} => p = {}   BECAUSE \A(x <- p);
(p \subseteq {} => p = {}) <=> (~(p \subseteq {}) \/ p = {})   BECAUSE BooleanImplication;
~(p \subseteq {}) \/ p = {}   BECAUSE MODUS_PONENS;
p = {} \/ ~(p \subseteq {})   BECAUSE OrSymmetry;
~~(p = {} \/ ~(p \subseteq {}))   BECAUSE IntroNotNot;
~(p = {} \/ ~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE Explosion;
(p # {} /\ ~~(p \subseteq {})) => ~(p = {} \/ ~(p \subseteq {}))   BECAUSE FactorNotOr;
(p # {} /\ ~~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TI;
p \subseteq {} => ~~(p \subseteq {})   BECAUSE IntroNotNot;
p # {} => p # {}   BECAUSE ImplySelf;
(p # {} /\ p \subseteq {}) => (p # {} /\ ~~(p \subseteq {}))   BECAUSE MergeImplicationsAnd;
(p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TI;
\A p : (p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE GENERALIZATION;

\* Conclude with PT6
(\A a : a \in {} => a \notin a)
   /\ (\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c)   BECAUSE IntroAndRight;
IsWellOrderedByIn( {} )   BECAUSE IntroAndRight;
ordinalZero   BECAUSE IntroAndRight;
QED

\* The +1 operation on ordinals
successor(o) == o \union { o }

ordinalSuccessorStable == \A o : IsOrdinal(o) => IsOrdinal( successor(o) )
THEOREM ordinalSuccessorStable

IsLimitOrdinal(o) == IsOrdinal(o) /\ o # {} /\ \A x : x \in o => o # successor(x)
IsFiniteOrdinal(o) == IsOrdinal(o) /\ ~IsLimitOrdinal(o)
   /\ \A x : x \in o => ~IsLimitOrdinal(x)

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE o : \A x : x \in o <=> IsFiniteOrdinal(x)
NatExists == \A x : x \in Nat <=> IsFiniteOrdinal(x)
THEOREM NatExists
PROOF
\* By separation in a set given by the axiom of infinity
VARIABLES a;
Infinity   BECAUSE AXIOM;
ca == CHOOSE a : {} \in a /\ \A x : x \in a => successor(x) \in a;
{} \in ca /\ \A x : x \in ca => successor(x) \in ca   BECAUSE CHOOSE ca;
\A a : \E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in ca /\ IsFiniteOrdinal(x)   BECAUSE \A(a <- ca);
cb == CHOOSE b : \A x : x \in b <=> x \in ca /\ IsFiniteOrdinal(x);
\A x : x \in cb <=> x \in ca /\ IsFiniteOrdinal(x)   BECAUSE CHOOSE cb;
\* Prove cb is Nat, ie IsFiniteOrdinal(x) => x \in cb.
\* UNION cb is an ordinal as a union of ordinals. UNION cb
\* is a limit ordinal. Any finite ordinal is either in or
\* contains UNION cb by ordinal comparison. But a finite
\* ordinal cannot contain a limit ordinal so it is in UNION cb.
\* This means the finite ordinal is in one of the elements of cb
\* so in cb by ordinal transitivity.
QED
