(*
   The elements of a ZFC set are not ordered. There is only one set
   with elements x and y : { x, y } = { y, x }. Likewise with any
   number of elements, by the axiom of extensionality the set is
   the same, independently of the order in which its elements were
   listed.

   Couples introduce an order between two elements, because <<x,y>>
   and <<y,x>> are different. Here we discuss the more general
   structure of order, that applies to a set with any number of
   elements.

   Order is fundamental for numbers. When we measure things with
   numbers, we're often only interested in the order the numbers
   place on the things : which are bigger, faster, stronger, ...
   The geometry of the real numbers comes from their order, which
   tells when a point on a line lies between two other points.
   Deeper still, orders are the very definition of natural numbers :
   they are the finite well-orders. We will see that addition and
   multiplication, often introduced at school for natural numbers,
   are actually operations on orders.

   Orders also serve for optimization. In the dictionary, the
   alphabetical order allows to find any word among more than
   100 000 words in a few seconds. This is true for any collection
   of objects, in a book, house, factory or even human society :
   when ordered, the objects are much faster to find and easier
   to manipulate.
*)

EXTENDS Functions

IsOrder(o) == IsGraph(o)
   \* Reflexivity
   /\ (\A x : \A y : (<<x,y>> \in o) => (<<x,x>> \in o /\ <<y,y>> \in o))
   \* transitivity
   /\ (\A x : \A y : \A z : ((<<x,y>> \in o) /\ (<<y,z>> \in o)) => (<<x,z>> \in o))
   \* anti-symmetry
   /\ (\A x : \A y : ((<<x,y>> \in o) /\ (<<y,x>> \in o)) => x = y)

\* Because f[x] is a CHOOSE, this only allows functions which domains
\* contain Domain(u)
IsIncreasing(f, u, v) == \A x : \A y : (<<x,y>> \in u) => (<<f[x], f[y]>> \in v)

IsMinimum(m, part, order) == (m \in part) /\ \A x : (x \in part) => <<m,x>> \in order

\* Usually reflexivity is rather stated in terms of the domain :
orderDomainReflexive == \A o : \A x : IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o
THEOREM orderDomainReflexive
PROOF
VARIABLES g,o,x,y;
domainExists   BECAUSE THEOREM;
x \in Domain(o) <=> IsDefinedOn(o,x)   BECAUSE \A(g <- o, x <- x);
x \in Domain(o) => \E y : <<x,y>> \in o   BECAUSE EquivToImpl;
IsOrder(o) => IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE S13;
IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE S22;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE \A(x <- x, y <- y);
IsOrder(o) => (<<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
<<x,y>> \in o => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE SwitchHypos;
IsDefinedOn(o,x) => (\E y : IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE Q_SCHEME;
(\E y : IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE Q_SCHEME;
IsDefinedOn(o,x) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE TI;
x \in Domain(o) => (IsOrder(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE TI;
IsOrder(o) => (x \in Domain(o) => <<x,x>> \in o /\ <<y,y>> \in o)   BECAUSE SwitchHypos;
IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o /\ <<y,y>> \in o   BECAUSE HypoImplToAnd;
<<x,x>> \in o /\ <<y,y>> \in o => <<x,x>> \in o   BECAUSE S12;
IsOrder(o) /\ x \in Domain(o) => <<x,x>> \in o   BECAUSE TI;
orderDomainReflexive   BECAUSE GENERALIZATION;
QED

\* An injection f transports an order o
IsInInjectOrder(o,f,x) == x \in (Image(f) \X Image(f)) /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o
injectOrder(o,f) == CHOOSE b : \A x : x \in b <=> IsInInjectOrder(o,f,x)

injectOrderExists == \A o : \A f : \A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)
THEOREM injectOrderExists
PROOF
\* By separation in Image(f) \X Image(f)
VARIABLES a,b,c,f,o,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ <<pre(f,fst(x)), pre(f,snd(x))>> \in o)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> IsInInjectOrder(o,f,x)   BECAUSE \A(a <- Image(f) \X Image(f));
\A x : x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE CHOOSE injectOrder(o,f);
injectOrderExists   BECAUSE GENERALIZATION;
QED

doubleEquiv(a,b,c,d) == (a <=> b) => ((c <=> d) => ((a /\ c) <=> (b /\ d)))   PROPO_TAUTO doubleEquiv

injectOrderCouples == \A o : \A f : \A x : \A y : <<x,y>> \in injectOrder(o,f) <=>
   (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
THEOREM injectOrderCouples
PROOF
VARIABLES a,b,f,o,x,y;
injectOrderExists   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE \A(o <- o, f <- f, x <- <<x,y>>);
cartesianProductCouples   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f)) <=> <<x,y>> \in (Image(f) \X Image(f))
   BECAUSE \A(x <- Image(f), y <- Image(f), a <- x, b <- y);
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
\A x : \A a : \A y : \A b : (x = a /\ y = b)
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,a), pre(f,b)>> \in o)   BECAUSE E_SCHEME;
(x = fst(<<x,y>>) /\ y = snd(<<x,y>>))
   => (<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o)
   BECAUSE \A(x <- x, a <- fst(<<x,y>>), y <- y, b <- snd(<<x,y>>));
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
<<pre(f,x), pre(f,y)>> \in o <=> <<pre(f,fst(<<x,y>>)), pre(f,snd(<<x,y>>))>> \in o   BECAUSE MODUS_PONENS;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> IsInInjectOrder(o,f,<<x,y>>)   BECAUSE doubleEquiv;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) <=> <<x,y>> \in injectOrder(o,f)   BECAUSE TransitEquiv2;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivSymmetry;
injectOrderCouples   BECAUSE GENERALIZATION;
QED

injectOrderIsOrder == \A o : \A f : (IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))
THEOREM injectOrderIsOrder
PROOF
VARIABLES a,b,d,f,g,i,j,o,x,y,z;
\* Proof that injectOrder(o,f) is a graph
injectOrderExists   BECAUSE THEOREM;
x \in injectOrder(o,f) <=> IsInInjectOrder(o,f,x)   BECAUSE \A(o <- o, f <- f, x <- x);
x \in injectOrder(o,f) => IsInInjectOrder(o,f,x)   BECAUSE EquivToImpl;
IsInInjectOrder(o,f,x) => x \in (Image(f) \X Image(f))   BECAUSE S12;
cartesianProductExists   BECAUSE THEOREM;
x \in (Image(f) \X Image(f)) <=> (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))
   BECAUSE \A(i <- Image(f), j <- Image(f), x <- x);
x \in (Image(f) \X Image(f)) => (IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Image(f) /\ snd(x) \in Image(f)) => IsCouple(x)   BECAUSE S13;
x \in (Image(f) \X Image(f)) => IsCouple(x)   BECAUSE TI;
IsInInjectOrder(o,f,x) => IsCouple(x)   BECAUSE TI;
x \in injectOrder(o,f) => IsCouple(x)   BECAUSE TI;
IsGraph(injectOrder(o,f))   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => IsGraph(injectOrder(o,f))   BECAUSE PT1;

\* Proof that injectOrder(o,f) is reflexive
IsOrder(o) => (IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))   BECAUSE S13;
(IsGraph(o) /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o)))
   => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE S22;
IsOrder(o) => (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))   BECAUSE TI;
(\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => (<<pre(f,x), pre(f,y)>> \in o => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o))   BECAUSE TI;
(IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE HypoImplToAnd;
injectOrderCouples   BECAUSE THEOREM;
<<x,y>> \in injectOrder(o,f) <=> (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- y);
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE EquivToImpl;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE S22;
<<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE TI;
IsOrder(o) => IsOrder(o)   BECAUSE ImplySelf;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (IsOrder(o) /\ <<pre(f,x), pre(f,y)>> \in o)   BECAUSE MergeImplicationsAnd;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o)   BECAUSE TI;

   \* Lemma : \A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>>) \in o => <<d,d>> \in injectOrder
<<d,d>> \in injectOrder(o,f) <=> (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- d, y <- d);
d \in Image(f) => (d \in Image(f) /\ d \in Image(f))   BECAUSE AndSelf;
<<pre(f,d), pre(f,d)>> \in o => <<pre(f,d), pre(f,d)>> \in o   BECAUSE ImplySelf;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => (d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o)
   BECAUSE MergeImplicationsAnd;
(d \in Image(f) /\ d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE TI;
\A d : (d \in Image(f) /\ <<pre(f,d), pre(f,d)>> \in o) => <<d,d>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;

   \* <<x, x>>
(x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o) => <<x,x>> \in injectOrder(o,f)
   BECAUSE \A(d <- x);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => x \in Image(f)   BECAUSE S13;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE S12;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,x), pre(f,x)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE S22;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => x \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (x \in Image(f) /\ <<pre(f,x), pre(f,x)>> \in o)
   BECAUSE CIA;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,x>> \in injectOrder(o,f)   BECAUSE TI;

   \* <<y, y>>
(y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o) => <<y,y>> \in injectOrder(o,f)
   BECAUSE \A(d <- y);
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => y \in Image(f)   BECAUSE S23;
<<x,y>> \in injectOrder(o,f) => y \in Image(f)   BECAUSE TI;
(<<pre(f,x), pre(f,x)>> \in o /\ <<pre(f,y), pre(f,y)>> \in o) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE S22;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<pre(f,y), pre(f,y)>> \in o   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<x,y>> \in injectOrder(o,f)   BECAUSE S22;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => y \in Image(f)   BECAUSE TI;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (y \in Image(f) /\ <<pre(f,y), pre(f,y)>> \in o)
   BECAUSE CIA;
(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => <<y,y>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ <<x,y>> \in injectOrder(o,f)) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))
   BECAUSE CIA;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE HypoAndToImpl;
\A y : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => (\A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE GENERALIZATION;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))
   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(o)   BECAUSE S12;
IsOrder(o) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f)))   BECAUSE TI;

\* Proof that injectOrder(o,f) is anti-symmetric
\A x : \A y: <<x,y>> \in injectOrder(o,f) => <<pre(f,x), pre(f,y)>> \in o   BECAUSE GENERALIZATION;
<<y,x>> \in injectOrder(o,f) => <<pre(f,y), pre(f,x)>> \in o   BECAUSE \A(x <- y, y <- x);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)   BECAUSE S22;
(\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))
   BECAUSE \A(x <- pre(f,x), y <- pre(f,y));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,x)>> \in o) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => (IsOrder(o) => pre(f,x) = pre(f,y))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => pre(f,x) = pre(f,y)   BECAUSE HypoImplToAnd;

(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,y>> \in injectOrder(o,f)   BECAUSE S13;
(x \in Image(f) /\ y \in Image(f) /\ <<pre(f,x), pre(f,y)>> \in o) => (x \in Image(f) /\ y \in Image(f))   BECAUSE S12;
<<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ y \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))   BECAUSE CIA;
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))
   => (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))   BECAUSE MergeImplicationsAnd;
funcUniqueImage   BECAUSE THEOREM;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE \A(f <- f, x <- x, y <- y);
(<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f)) => x = y   BECAUSE TI;
massageHypos(a,b,c,d) == ((c /\ d) /\ (a /\ b)) => (a /\ b /\ c /\ d)   PROPO_TAUTO;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)))
   => (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f) /\ IsOrder(o) /\ IsFunction(f))   BECAUSE massageHypos;
(IsOrder(o) /\ IsFunction(f) /\ (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f))) => x = y   BECAUSE TI;
(IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE HypoAndToImpl;
\A y: (IsOrder(o) /\ IsFunction(f)) => ((<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(o) /\ IsFunction(f)) => (\A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(o) /\ IsFunction(f)) => (\A x : \A y : (<<x,y>> \in injectOrder(o,f) /\ <<y,x>> \in injectOrder(o,f)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that injectOrder(o,f) is transitive
<<y,z>> \in injectOrder(o,f) => <<pre(f,y), pre(f,z)>> \in o   BECAUSE \A(x <- y, y <- z);
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))
   => (<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o)   BECAUSE MergeImplicationsAnd;
IsOrder(o) => (\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)   BECAUSE S23;
(\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)
   => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE \A(x <- pre(f,x), y <- pre(f,y), z <- pre(f,z));
IsOrder(o) => ((<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<pre(f,x), pre(f,y)>> \in o /\ <<pre(f,y), pre(f,z)>> \in o) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE SwitchHypos;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<pre(f,x), pre(f,z)>> \in o)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<pre(f,x), pre(f,z)>> \in o
   BECAUSE HypoImplToAnd;
\A x : \A y : <<x,y>> \in injectOrder(o,f) => (x \in Image(f) /\ y \in Image(f))   BECAUSE GENERALIZATION;
<<y,z>> \in injectOrder(o,f) => (y \in Image(f) /\ z \in Image(f))   BECAUSE \A(x <- y, y <- z);
(y \in Image(f) /\ z \in Image(f)) => z \in Image(f)   BECAUSE S22;
<<y,z>> \in injectOrder(o,f) => z \in Image(f)   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f)) => x \in Image(f)   BECAUSE S12;
<<x,y>> \in injectOrder(o,f) => x \in Image(f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE MergeImplicationsAnd;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f))   BECAUSE S12;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => (x \in Image(f) /\ z \in Image(f))   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o))
   => (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)   BECAUSE CIA;
<<x,z>> \in injectOrder(o,f) <=> (x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o)
   BECAUSE \A(o <- o, f <- f, x <- x, y <- z);
(x \in Image(f) /\ z \in Image(f) /\ <<pre(f,x), pre(f,z)>> \in o) => <<x,z>> \in injectOrder(o,f)   BECAUSE EquivToImplReverse;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) /\ IsOrder(o)) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;
(<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => (IsOrder(o) => <<x,z>> \in injectOrder(o,f))   BECAUSE HypoAndToImpl;
IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE SwitchHypos;
\A z : IsOrder(o) => (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f))   BECAUSE GENERALIZATION;
IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A y : IsOrder(o) => \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
\A x : IsOrder(o) => \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE GENERALIZATION;
IsOrder(o) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE Q_SCHEME;
(IsOrder(o) /\ IsFunction(f)) => \A x : \A y : \A z : <<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f) => <<x,z>> \in injectOrder(o,f)   BECAUSE TI;

(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))))   BECAUSE CIA;
(IsOrder(o) /\ IsFunction(f)) => (IsGraph(injectOrder(o,f)) /\ (\A x : \A y : <<x,y>> \in injectOrder(o,f) => (<<x,x>> \in injectOrder(o,f) /\ <<y,y>> \in injectOrder(o,f))) /\ (\A x : \A y : \A z : (<<x,y>> \in injectOrder(o,f) /\ <<y,z>> \in injectOrder(o,f)) => <<x,z>> \in injectOrder(o,f)))   BECAUSE CIA;
(IsOrder(o) /\ IsFunction(f)) => IsOrder(injectOrder(o,f))   BECAUSE CIA;
injectOrderIsOrder   BECAUSE GENERALIZATION;
QED

\* When two orders have disjoint domains, their union is an order
disjointOrders == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v)
THEOREM disjointOrders
PROOF
\* Proof that disjointOrders is a graph
VARIABLES g,u,v,x,y,z;
unionInc   BECAUSE THEOREM;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
x \in (u \union v) => (x \in u \/ x \in v)   BECAUSE EquivToImpl;
IsOrder(u) => IsGraph(u)   BECAUSE S14;
IsGraph(u) => (x \in u => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u) => (x \in u => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE S12;
(IsOrder(u) /\ IsOrder(v)) => (x \in u => IsCouple(x))   BECAUSE TI;
x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
\A u : x \in u => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(v) => IsGraph(v)   BECAUSE S14;
IsGraph(v) => (x \in v => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(v) => (x \in v => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE S22;
(IsOrder(u) /\ IsOrder(v)) => (x \in v => IsCouple(x))   BECAUSE TI;
x \in v => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE SwitchHypos;
(x \in u \/ x \in v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE CombineImplicationsStart;
x \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => IsCouple(x))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : (IsOrder(u) /\ IsOrder(v)) => (x \in (u \union v) => IsCouple(x))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => IsGraph(u \union v)   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE S12;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsGraph(u \union v)   BECAUSE TI;

\* Proof that u \union v is reflexive.
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
selectSecond(a,b,c,d) == (a /\ b /\ c /\ d) => b   PROPO_TAUTO;
IsOrder(u) => (\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE selectSecond;
(\A x : \A y : <<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(u)   BECAUSE S12;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)   BECAUSE HypoImplToAnd;
unionFirstInc   BECAUSE THEOREM;
<<x,x>> \in u => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in u => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in u /\ <<y,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
\A u : IsOrder(u) => (<<x,y>> \in u => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(u <- v);
(IsOrder(u) /\ IsOrder(v)) => IsOrder(v)   BECAUSE S22;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
unionSecondInc   BECAUSE THEOREM;
<<x,x>> \in v => <<x,x>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,x>>);
<<y,y>> \in v => <<y,y>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<y,y>>);
(<<x,x>> \in v /\ <<y,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE MergeImplicationsAnd;
(IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE CombineImplicationsStart;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => ((IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in u) \/ (IsOrder(u) /\ IsOrder(v) /\ <<x,y>> \in v))
   BECAUSE DistribAndOrLeft;
((IsOrder(u) /\ IsOrder(v)) /\ (<<x,y>> \in u \/ <<x,y>> \in v))
   => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE HypoAndToImpl;
<<x,y>> \in (u \union v) <=> (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in (u \union v) => (<<x,y>> \in u \/ <<x,y>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in u \/ <<x,y>> \in v)
   => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))
   BECAUSE SwitchHypos;
<<x,y>> \in (u \union v) => ((IsOrder(u) /\ IsOrder(v)) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE SwitchHypos;
\A y : (IsOrder(u) /\ IsOrder(v)) => (<<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v)) => (\A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE Q_SCHEME;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v)))   BECAUSE TI;

\* Proof that u \union v is anti-symmetric
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
implyNotAnd(a,b,c) == (a => ~(b /\ c)) => ((a /\ b) => ~c)   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => <<y,y>> \notin v   BECAUSE implyNotAnd;

(<<x,x>> \in v /\ <<y,y>> \in v) => <<y,y>> \in v   BECAUSE S22;
(IsOrder(v) /\ <<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<x,y>> \in v) => <<y,y>> \in v   BECAUSE TI;
andContrapos(a,b,c) == ((a /\ b) => c) => (~c => (a => ~b))   PROPO_TAUTO;
<<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;

\A x : \A y : IsOrder(v) => (<<x,y>> \in v => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE GENERALIZATION;
IsOrder(v) => (<<y,x>> \in v => (<<y,y>> \in v /\ <<x,x>> \in v))   BECAUSE \A(x <- y, y <- x);
(<<y,y>> \in v /\ <<x,x>> \in v) => <<y,y>> \in v   BECAUSE S12;
(IsOrder(v) /\ <<y,x>> \in v) => (<<y,y>> \in v /\ <<x,x>> \in v)   BECAUSE HypoImplToAnd;
(IsOrder(v) /\ <<y,x>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,x>> \notin v   BECAUSE HypoImplToAnd;

<<y,x>> \in (u \union v) <=> (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in (u \union v) => (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v)   BECAUSE CIA;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCases(a,b,c,d) == (~a /\ ~b /\ ((c \/ a) /\ (d \/ b))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin v /\ <<y,x>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in u  /\ <<y,x>> \in u)   BECAUSE TI;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE S22;
(\A x : \A y : (<<x,y>> \in u /\ <<y,x>> \in u) => x = y) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,x>> \in u) => (IsOrder(u) => x = y)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(u) => x = y)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(u))
   => x = y   BECAUSE HypoImplToAnd;
flipLast(a,b,c,d) == ((a /\ b /\ c) => d) => ((a /\ c) => (b => d))   PROPO_TAUTO;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<x,y>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<x,y>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<x,y>> \notin u   BECAUSE HypoImplToAnd;
\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,x>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,x>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,x>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,x>> \notin u)   BECAUSE CIA;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   BECAUSE MergeImplicationsAnd;
killCasesRight(a,b,c,d) == (~a /\ ~b /\ ((a \/ c) /\ (b \/ d))) => (c /\ d)   PROPO_TAUTO;
(<<x,y>> \notin u /\ <<y,x>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,x>> \in v)   BECAUSE TI;
\A u : IsOrder(u) => ((<<x,y>> \in u /\ <<y,x>> \in u) => x = y)   BECAUSE GENERALIZATION;
IsOrder(v) => ((<<x,y>> \in v /\ <<y,x>> \in v) => x = y)   BECAUSE \A(u <- v);
(<<x,y>> \in v /\ <<y,x>> \in v) => (IsOrder(v) => x = y)   BECAUSE SwitchHypos;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)))
   => (IsOrder(v) => x = y)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) /\ IsOrder(v))
   => x = y   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)
   BECAUSE CombineImplicationsStart;
exclMid(a,b,c,d) == (a /\ b /\ c) => ((c /\ d /\ b /\ a) \/ (~d /\ a /\ b))   PROPO_TAUTO;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   BECAUSE exclMid;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE TI;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : (<<x,y>> \in (u \union v) /\ <<y,x>> \in (u \union v)) => x = y)   BECAUSE Q_SCHEME;

\* Proof that u \union v is transitive.
\* If <<y,y>> \in u, because u and v are disjoint, <<y,y>> \notin v and then by reflexivity of v,
\* <<y,z>> \notin v and <<x,y>> \notin v. Else <<y,y>> \notin u, then by reflexivity of u,
\* <<y,z>> \notin u and <<x,y>> \notin u.
IsOrder(v) => (<<y,z>> \in v => (<<y,y>> \in v /\ <<z,z>> \in v))   BECAUSE \A(x <- y, y <- z);
(IsOrder(v) /\ <<y,z>> \in v) => (<<y,y>> \in v /\ <<z,z>> \in v)   BECAUSE HypoImplToAnd;
(<<y,y>> \in v /\ <<z,z>> \in v) => <<y,y>> \in v   BECAUSE S12;
(IsOrder(v) /\ <<y,z>> \in v) => <<y,y>> \in v   BECAUSE TI;
<<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE andContrapos;
(AreDisjoint(u,v) /\ <<y,y>> \in u) => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<x,y>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => <<y,z>> \notin v   BECAUSE HypoImplToAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v)) => (<<x,y>> \notin v /\ <<y,z>> \notin v)  BECAUSE CIA;

<<y,z>> \in (u \union v) <=> (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in (u \union v) => (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE EquivToImpl;
(<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v))
   => ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v))   BECAUSE MergeImplicationsAnd;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin v /\ <<y,z>> \notin v /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE killCases;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in u /\ <<y,z>> \in u)   BECAUSE TI;

IsOrder(u) => (\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE S23;
(\A x : \A y : \A z : (<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)
   => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u) => ((<<x,y>> \in u /\ <<y,z>> \in u) => <<x,z>> \in u)   BECAUSE TI;
(<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE SwitchHypos;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(u) => <<x,z>> \in u)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in u   BECAUSE HypoImplToAnd;
<<x,z>> \in u => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(u))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;

\A v : <<y,y>> \notin v => (IsOrder(v) => <<y,z>> \notin v)   BECAUSE GENERALIZATION;
<<y,y>> \notin u => (IsOrder(u) => <<y,z>> \notin u)   BECAUSE \A(v <- u);
(<<y,y>> \notin u /\ IsOrder(u)) => <<y,z>> \notin u   BECAUSE HypoImplToAnd;
(<<y,y>> \notin u /\ IsOrder(u)) => (<<x,y>> \notin u /\ <<y,z>> \notin u)   BECAUSE CIA;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \notin u /\ <<y,z>> \notin u /\ ((<<x,y>> \in u \/ <<x,y>> \in v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE killCasesRight;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (<<x,y>> \in v /\ <<y,z>> \in v)   BECAUSE TI;
\A u : (<<x,y>> \in u /\ <<y,z>> \in u) => (IsOrder(u) => <<x,z>> \in u)   BECAUSE GENERALIZATION;
(<<x,y>> \in v /\ <<y,z>> \in v) => (IsOrder(v) => <<x,z>> \in v)   BECAUSE \A(u <- v);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)))
   => (IsOrder(v) => <<x,z>> \in v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in v   BECAUSE HypoImplToAnd;
<<x,z>> \in v => <<x,z>> \in (u \union v)   BECAUSE \A(x <- u, y <- v, z <- <<x,z>>);
(<<y,y>> \notin u /\ IsOrder(u) /\ (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) /\ IsOrder(v))
   => <<x,z>> \in (u \union v)   BECAUSE TI;
(<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE flipLast;
((AreDisjoint(u,v) /\ <<y,y>> \in u /\ IsOrder(v) /\ IsOrder(u)) \/ (<<y,y>> \notin u /\ IsOrder(u) /\ IsOrder(v)))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE CombineImplicationsStart;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE TI;
\A z : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => ((<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A y : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;
\A x : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE GENERALIZATION;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v))   BECAUSE Q_SCHEME;

(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))))   BECAUSE CIA;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => (IsGraph(u \union v) /\ (\A x : \A y : <<x,y>> \in (u \union v) => (<<x,x>> \in (u \union v) /\ <<y,y>> \in (u \union v))) /\ (\A x : \A y : \A z : (<<x,y>> \in (u \union v) /\ <<y,z>> \in (u \union v)) => <<x,z>> \in (u \union v)))   BECAUSE CIA;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v)   BECAUSE CIA;
disjointOrders   BECAUSE GENERALIZATION;
QED

(*
   Not only can two disjoint orders be united, then can also be glued together,
   the second coming completely after then first, which defines their addition.

   On natural numbers (finite well-orders, see below), this is the usual addition.
*)
disjointOrderAddition == \A u : \A v : (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   => IsOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointOrderAddition
PROOF
VARIABLES a,b,c,g,i,j,o,p,u,v,x,y,z,part;
\* Proof that u \union v \union (Domain(u) \X Domain(v)) is a graph : union of 3 graphs
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
h(u,v) == IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v); \* The hypothesis
unionInc   BECAUSE THEOREM;
x \in woAdd(u,v) <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
cartesianProductExists   BECAUSE THEOREM;
x \in woAdd(u,v)
   => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
x \in (Domain(u) \X Domain(v)) <=> (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))
   BECAUSE \A(i <- Domain(u), j <- Domain(v), x <- x);
x \in (Domain(u) \X Domain(v)) => (IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Domain(u) /\ snd(x) \in Domain(v)) => IsCouple(x)   BECAUSE S13;
x \in (Domain(u) \X Domain(v)) => IsCouple(x)   BECAUSE TI;
IsOrder(u \union v) => IsGraph(u \union v)   BECAUSE S14;
(\A x : x \in (u \union v) => IsCouple(x)) => (x \in (u \union v) => IsCouple(x))   BECAUSE \A(x <- x);
IsOrder(u \union v) => (x \in (u \union v) => IsCouple(x))   BECAUSE TI;
mergeWithHypo(a,b,c,d) == (a => b) => ((c => (d => b)) => ((d \/ a) => (c => b)))   PROPO_TAUTO;
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE mergeWithHypo;
x \in woAdd(u,v) => (IsOrder(u \union v) => IsCouple(x))   BECAUSE TI;
IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE SwitchHypos;
\A x : IsOrder(u \union v) => (x \in woAdd(u,v) => IsCouple(x))   BECAUSE GENERALIZATION;
IsOrder(u \union v) => IsGraph(woAdd(u,v))   BECAUSE Q_SCHEME;
disjointOrders   BECAUSE THEOREM;
IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
h(u,v) => IsGraph(woAdd(u,v))   BECAUSE TI;

\* Proof that orderAddition is reflexive : <<x,y>> \in woAdd(u,v) => (x \in Domain(u) \/ x \in Domain(v))
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,y>>);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)
   BECAUSE EquivToImpl;
domainExists   BECAUSE THEOREM;
x \in Domain(u \union v) <=> IsDefinedOn(u \union v, x)   BECAUSE \A(g <- u \union v, x <- x);
(\E y : <<x,y>> \in u \union v) => x \in Domain(u \union v)   BECAUSE EquivToImplReverse;
<<x,y>> \in u \union v => (\E y : <<x,y>> \in u \union v)   BECAUSE \E(y <- y);
<<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE TI;
cartesianProductCouples   BECAUSE THEOREM;
x \in Domain(u) /\ y \in Domain(v) <=> <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u) /\ y \in Domain(v)   BECAUSE EquivToImplReverse;
x \in Domain(u) /\ y \in Domain(v) => x \in Domain(u)   BECAUSE S12;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
x \in Domain(u) => \E y : <<x,y>> \in u   BECAUSE EquivToImpl;
unionFirstInc   BECAUSE THEOREM;
<<x,y>> \in u => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in u) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(u) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(u) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in woAdd(u,v) => x \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) => IsOrder(u \union v)   BECAUSE ImplySelf;
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ x \in Domain(u \union v)   BECAUSE MergeImplicationsAnd;
orderDomainReflexive   BECAUSE THEOREM;
IsOrder(u \union v) /\ x \in Domain(u \union v) => <<x,x>> \in u \union v   BECAUSE \A(o <- u \union v, x <- x);
IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
disjointOrders   BECAUSE THEOREM;
h(u,v) => IsOrder(u \union v)   BECAUSE \A(u <- u, v <- v);
<<x,y>> \in woAdd(u,v) => <<x,y>> \in woAdd(u,v)   BECAUSE ImplySelf;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ <<x,y>> \in woAdd(u,v)   BECAUSE MergeImplicationsAnd;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in u \union v   BECAUSE TI;
<<x,x>> \in (u \union v) => <<x,x>> \in woAdd(u,v)   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<x,x>>);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v)   BECAUSE TI;

IsOrder(u \union v) => IsGraph(u \union v) /\ (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE S13;
IsGraph(u \union v) /\ (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v)) => (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE S22;
IsOrder(u \union v) => (\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))
   => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE \A(x <- x, y <- y);
IsOrder(u \union v) => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
h(u,v) => ((<<x,y>> \in u \union v) => (<<x,x>> \in u \union v /\ <<y,y>> \in u \union v))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v) => <<x,x>> \in u \union v /\ <<y,y>> \in u \union v   BECAUSE HypoImplToAnd;
<<x,x>> \in u \union v /\ <<y,y>> \in u \union v => <<y,y>> \in u \union v   BECAUSE S22;
h(u,v) /\ (<<x,y>> \in u \union v) => <<y,y>> \in u \union v   BECAUSE TI;
\A x : <<x,y>> \in u \union v => x \in Domain(u \union v)   BECAUSE GENERALIZATION;
<<y,y>> \in u \union v => y \in Domain(u \union v)   BECAUSE \A(x <- y);
h(u,v) /\ <<x,y>> \in u \union v => y \in Domain(u \union v)   BECAUSE TI;
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE S22;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
x \in Domain(v) <=> IsDefinedOn(v, x)   BECAUSE \A(g <- v, x <- x);
x \in Domain(v) => \E y : <<x,y>> \in v   BECAUSE EquivToImpl;
unionSecondInc   BECAUSE THEOREM;
<<x,y>> \in v => <<x,y>> \in u \union v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
(\E y : <<x,y>> \in v) => \E y : <<x,y>> \in u \union v   BECAUSE Q_SCHEME;
x \in Domain(v) => \E y : <<x,y>> \in u \union v   BECAUSE TI;
x \in Domain(v) => x \in Domain(u \union v)   BECAUSE TI;
\A x : x \in Domain(v) => x \in Domain(u \union v)   BECAUSE GENERALIZATION;
y \in Domain(v) => y \in Domain(u \union v)   BECAUSE \A(x <- y);
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(u \union v)   BECAUSE TI;
(h(u,v) /\ <<x,y>> \in u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(u \union v)   BECAUSE CombineImplicationsStart;
semiDistrib(a,b,c) == a /\ (b \/ c) => (a /\ b) \/ c   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v))
   => (h(u,v) /\ <<x,y>> \in u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE semiDistrib;
h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v)) => y \in Domain(u \union v)   BECAUSE TI;
h(u,v) => h(u,v)   BECAUSE ImplySelf;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => h(u,v) /\ (<<x,y>> \in u \union v \/ <<x,y>> \in Domain(u) \X Domain(v))   BECAUSE MergeImplicationsAnd;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => y \in Domain(u \union v)   BECAUSE TI;
IsOrder(u \union v) /\ y \in Domain(u \union v) => <<y,y>> \in u \union v   BECAUSE \A(o <- u \union v, x <- y);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => h(u,v)   BECAUSE S12;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v)   BECAUSE TI;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => IsOrder(u \union v) /\ y \in Domain(u \union v)   BECAUSE CIA;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<y,y>> \in u \union v   BECAUSE TI;
<<y,y>> \in (u \union v) => <<y,y>> \in woAdd(u,v)   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,y>>);
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<y,y>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v)   BECAUSE CIA;
h(u,v) => (<<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A y : h(u,v) => (<<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE Q_SCHEME;


\* Proof that orderAddition is transitive : if <<x,y>> and <<y,z>> are in the addition,
\*    - <<x,y>> and <<y,z>> are is u \union v then <<x,z>> too be it's an order
\*    - else either <<x,y>> or <<y,z>> are in the product glue
<<y,z>> \in woAdd(u,v) <=> (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE \A(x <- u \union v, y <- Domain(u) \X Domain(v), z <- <<y,z>>);
<<y,z>> \in woAdd(u,v) => (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)
   => ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
        /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
\* Kill the double-glue case
x \in Domain(u) /\ y \in Domain(v) => y \in Domain(v)   BECAUSE S22;
<<x,y>> \in Domain(u) \X Domain(v) => y \in Domain(v)   BECAUSE TI;
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(v) => IsOrder(v)   BECAUSE ImplySelf;
IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v) => IsOrder(v) /\ y \in Domain(v)
   BECAUSE MergeImplicationsAnd;
IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v) => <<y,y>> \in v   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) => x \in Domain(u)   BECAUSE GENERALIZATION;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE \A(x <- y, y <- z);
IsOrder(u) /\ y \in Domain(u) => <<y,y>> \in u   BECAUSE \A(o <- u, x <- y);
IsOrder(u) => IsOrder(u)   BECAUSE ImplySelf;
IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v) => IsOrder(u) /\ y \in Domain(u)
   BECAUSE MergeImplicationsAnd;
IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v) => <<y,y>> \in u   BECAUSE TI;
(IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v))
   => <<y,y>> \in u /\ <<y,y>> \in v  BECAUSE MergeImplicationsAnd; \* Impossible, u and v are disjoint
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
noCommonElements   BECAUSE THEOREM;
AreDisjoint(u,v) <=> \A z : ~(z \in u /\ z \in v)   BECAUSE \A(x <- u, y <- v);
AreDisjoint(u,v) => \A z : ~(z \in u /\ z \in v)   BECAUSE EquivToImpl;
(\A z : ~(z \in u /\ z \in v)) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE \A(z <- <<y,y>>);
AreDisjoint(u,v) => ~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE TI;
~(<<y,y>> \in u /\ <<y,y>> \in v)
   => ~((IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v)))   BECAUSE Contraposition;
AreDisjoint(u,v)
   => ~((IsOrder(u) /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ (IsOrder(v) /\ <<x,y>> \in Domain(u) \X Domain(v)))   BECAUSE TI;
pullHypos(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => ((b /\ d /\ a) => ~(c /\ e))   PROPO_TAUTO;
h(u,v) => ~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v))   BECAUSE pullHypos;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => ~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v))
      /\ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v))
        /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE MergeImplicationsAnd;
killCase(a,b,c,d) == (~(a /\ b) /\ ((c \/ b) /\ (d \/ a))) => (c /\ d) \/ (b /\ d) \/ (c /\ a)   PROPO_TAUTO;
~(<<y,z>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in Domain(u) \X Domain(v)) /\ ((<<x,y>> \in (u \union v) \/ <<x,y>> \in Domain(u) \X Domain(v)) /\ (<<y,z>> \in (u \union v) \/ <<y,z>> \in Domain(u) \X Domain(v)))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))   BECAUSE killCase;

h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   BECAUSE TI;
pushHypo(a,b,c) == ((a /\ b) => c) => ((a /\ b) => (a /\ c))   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => h(u,v) /\ ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))
   BECAUSE pushHypo;

IsOrder(u \union v) => (\A x : \A y : \A z : ((<<x,y>> \in u \union v) /\ (<<y,z>> \in u \union v)) => (<<x,z>> \in u \union v))
   BECAUSE S23;
(\A x : \A y : \A z : ((<<x,y>> \in u \union v) /\ (<<y,z>> \in u \union v)) => (<<x,z>> \in u \union v))
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE \A(x <- x, y <- y, z <- z);
IsOrder(u \union v)
   => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE TI;
h(u,v) => (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v => <<x,z>> \in u \union v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) => <<x,z>> \in u \union v   BECAUSE HypoImplToAnd;
<<x,z>> \in woAdd(u,v) <=> (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,z>>);
(<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v))) => <<x,z>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,z>> \in u \union v => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
<<x,z>> \in u \union v => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

<<y,z>> \in u \union v <=> <<y,z>> \in u \/ <<y,z>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<y,z>>);
<<y,z>> \in u \union v => <<y,z>> \in u \/ <<y,z>> \in v   BECAUSE EquivToImpl;
<<x,y>> \in Domain(u) \X Domain(v) => <<x,y>> \in Domain(u) \X Domain(v)   BECAUSE ImplySelf;
(<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => y \in Domain(v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)   BECAUSE MergeImplicationsAnd;
y \in Domain(v) /\ (<<y,z>> \in u \/ <<y,z>> \in v)
   => (y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v   BECAUSE semiDistrib;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v
   => (y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v   BECAUSE TI;
\* Proof first case is impossible
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(u) => IsGraph(u) /\ (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE S13;
IsGraph(u) /\ (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))
   => (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE S22;
IsOrder(u) => (\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in u) => (<<x,x>> \in u /\ <<y,y>> \in u)) => ((<<y,z>> \in u) => (<<y,y>> \in u /\ <<z,z>> \in u))   BECAUSE \A(x <- y, y <- z);
IsOrder(u) => ((<<y,z>> \in u) => (<<y,y>> \in u /\ <<z,z>> \in u))   BECAUSE TI;
IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE HypoImplToAnd;
<<y,y>> \in u /\ <<z,z>> \in u => <<y,y>> \in u   BECAUSE S12;
IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u   BECAUSE TI;
(IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)) => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE MergeImplicationsAnd;
~(<<y,y>> \in u /\ <<y,y>> \in v) => ~((IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)))   BECAUSE Contraposition;
AreDisjoint(u,v) => ~((IsOrder(u) /\ <<y,z>> \in u) /\ (IsOrder(v) /\ y \in Domain(v)))   BECAUSE TI;
shuffleNot(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => (b /\ d /\ a => ~(e /\ c))   PROPO_TAUTO;
h(u,v) => ~(y \in Domain(v) /\ <<y,z>> \in u)   BECAUSE shuffleNot;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => ~(y \in Domain(v) /\ <<y,z>> \in u) /\ ((y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v)   BECAUSE MergeImplicationsAnd;
distribNot(a,b) == ~a /\ (a \/ b) => b   PROPO_TAUTO;
~(y \in Domain(v) /\ <<y,z>> \in u) /\ ((y \in Domain(v) /\ <<y,z>> \in u) \/ <<y,z>> \in v)
   => <<y,z>> \in v   BECAUSE distribNot;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => <<y,z>> \in v   BECAUSE TI;
selectHypo(a,b,c,d) == (a => b) => (c /\ (a /\ d) => b)   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => x \in Domain(u)   BECAUSE selectHypo;
\A u : IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE GENERALIZATION;
IsOrder(v) /\ <<y,z>> \in v => <<y,y>> \in v /\ <<z,z>> \in v   BECAUSE \A(u <- v);
<<y,y>> \in v /\ <<z,z>> \in v => <<z,z>> \in v   BECAUSE S22;
IsOrder(v) /\ <<y,z>> \in v => <<z,z>> \in v   BECAUSE TI;
z \in Domain(v) <=> IsDefinedOn(v, z)   BECAUSE \A(g <- v, x <- z);
(\E y : <<z,y>> \in v) => z \in Domain(v)   BECAUSE EquivToImplReverse;
<<z,z>> \in v => (\E y : <<z,y>> \in v)   BECAUSE \E(y <- z);
<<z,z>> \in v => z \in Domain(v)   BECAUSE TI;
IsOrder(v) /\ <<y,z>> \in v => z \in Domain(v)   BECAUSE TI;
IsOrder(v) => (<<y,z>> \in v => z \in Domain(v))   BECAUSE HypoAndToImpl;
<<y,z>> \in v => (IsOrder(v) => z \in Domain(v))   BECAUSE SwitchHypos;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => (IsOrder(v) => z \in Domain(v))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) /\ IsOrder(v) => z \in Domain(v)   BECAUSE HypoImplToAnd;
repeatHypo(a,b,c,d) == a /\ b /\ c /\ d => a /\ b /\ c /\ d /\ b   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) /\ IsOrder(v)   BECAUSE repeatHypo;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => z \in Domain(v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => x \in Domain(u) /\ z \in Domain(v)   BECAUSE CIA;
x \in Domain(u) /\ z \in Domain(v) <=> <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- z);
x \in Domain(u) /\ z \in Domain(v) => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE EquivToImpl;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
   => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE TI;
<<x,z>> \in (Domain(u) \X Domain(v)) => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,z>> \in (Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

\* (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
<<x,y>> \in u \union v <=> <<x,y>> \in u \/ <<x,y>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<x,y>>);
<<x,y>> \in u \union v => <<x,y>> \in u \/ <<x,y>> \in v   BECAUSE EquivToImpl;
<<y,z>> \in Domain(u) \X Domain(v) => <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE ImplySelf;
y \in Domain(u) /\ z \in Domain(v) <=> <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- y, b <- z);
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u) /\ z \in Domain(v)   BECAUSE EquivToImplReverse;
y \in Domain(u) /\ z \in Domain(v) => y \in Domain(u)   BECAUSE S12;
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u)   BECAUSE TI;
<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)
   => (<<x,y>> \in u \/ <<x,y>> \in v) /\ y \in Domain(u)   BECAUSE MergeImplicationsAnd;
semiDistribRight(a,b,c) == (b \/ c) /\ a => (b \/ (c /\ a))   PROPO_TAUTO;
(<<x,y>> \in u \/ <<x,y>> \in v) /\ y \in Domain(u)
   => <<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u))   BECAUSE semiDistribRight;
<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)
   => <<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u))   BECAUSE TI; \* second case is impossible
IsOrder(u) /\ y \in Domain(u) => <<y,y>> \in u   BECAUSE \A(o <- u, x <- y);
IsOrder(v) => IsGraph(v) /\ (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE S13;
IsGraph(v) /\ (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))
   => (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE S22;
IsOrder(v) => (\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
(\A x : \A y : (<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v)) => ((<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE \A(x <- x, y <- y);
IsOrder(v) => ((<<x,y>> \in v) => (<<x,x>> \in v /\ <<y,y>> \in v))   BECAUSE TI;
IsOrder(v) /\ <<x,y>> \in v => <<x,x>> \in v /\ <<y,y>> \in v   BECAUSE HypoImplToAnd;
<<x,x>> \in v /\ <<y,y>> \in v => <<y,y>> \in v   BECAUSE S22;
IsOrder(v) /\ <<x,y>> \in v => <<y,y>> \in v   BECAUSE TI;
(IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)) => <<y,y>> \in v /\ <<y,y>> \in u   BECAUSE MergeImplicationsAnd;
<<y,y>> \in v /\ <<y,y>> \in u => <<y,y>> \in u /\ <<y,y>> \in v  BECAUSE AndSymmetry;
(IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)) => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE TI;
~(<<y,y>> \in u /\ <<y,y>> \in v) => ~((IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)))   BECAUSE Contraposition;
AreDisjoint(u,v) => ~((IsOrder(v) /\ <<x,y>> \in v) /\ (IsOrder(u) /\ y \in Domain(u)))   BECAUSE TI;
shuffleNotBis(a,b,c,d,e) == (a => ~((b /\ c) /\ (d /\ e))) => (d /\ b /\ a => ~(c /\ e))   PROPO_TAUTO;
h(u,v) => ~(<<x,y>> \in v /\ y \in Domain(u))   BECAUSE shuffleNotBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => ~(<<x,y>> \in v /\ y \in Domain(u)) /\ (<<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u)))   BECAUSE MergeImplicationsAnd;
distribNotBis(a,b) == ~a /\ (b \/ a) => b   PROPO_TAUTO;
~(<<x,y>> \in v /\ y \in Domain(u)) /\ (<<x,y>> \in u \/ (<<x,y>> \in v /\ y \in Domain(u)))
   => <<x,y>> \in u   BECAUSE distribNotBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => <<x,y>> \in u   BECAUSE TI;
y \in Domain(u) /\ z \in Domain(v) <=> <<y,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- y, b <- z);
<<y,z>> \in Domain(u) \X Domain(v) => y \in Domain(u) /\ z \in Domain(v)   BECAUSE EquivToImplReverse;
y \in Domain(u) /\ z \in Domain(v) => z \in Domain(v)   BECAUSE S22;
<<y,z>> \in Domain(u) \X Domain(v) => z \in Domain(v)   BECAUSE TI;
selectHypoBis(a,b,c,d) == (d => b) => (c /\ (a /\ d) => b)   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => z \in Domain(v)   BECAUSE selectHypoBis;
\A y : \A z : IsOrder(u) /\ <<y,z>> \in u => <<y,y>> \in u /\ <<z,z>> \in u   BECAUSE GENERALIZATION;
IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u /\ <<y,y>> \in u   BECAUSE \A(y <- x, z <- y);
<<x,x>> \in u /\ <<y,y>> \in u => <<x,x>> \in u   BECAUSE S12;
IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u   BECAUSE TI;
x \in Domain(u) <=> IsDefinedOn(u, x)   BECAUSE \A(g <- u, x <- x);
(\E y : <<x,y>> \in u) => x \in Domain(u)   BECAUSE EquivToImplReverse;
<<x,x>> \in u => (\E y : <<x,y>> \in u)   BECAUSE \E(y <- x);
<<x,x>> \in u => x \in Domain(u)   BECAUSE TI;
IsOrder(u) /\ <<x,y>> \in u => x \in Domain(u)   BECAUSE TI;
IsOrder(u) => (<<x,y>> \in u => x \in Domain(u))   BECAUSE HypoAndToImpl;
<<x,y>> \in u => (IsOrder(u) => x \in Domain(u))   BECAUSE SwitchHypos;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => (IsOrder(u) => x \in Domain(u))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ IsOrder(u) => x \in Domain(u)   BECAUSE HypoImplToAnd;
repeatHypoBis(a,b,c,d) == a /\ b /\ c /\ d => a /\ b /\ c /\ d /\ a   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) /\ IsOrder(u)   BECAUSE repeatHypoBis;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => x \in Domain(u)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => x \in Domain(u) /\ z \in Domain(v)   BECAUSE CIA;
x \in Domain(u) /\ z \in Domain(v) <=> <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- z);
x \in Domain(u) /\ z \in Domain(v) => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE EquivToImpl;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))
   => <<x,z>> \in Domain(u) \X Domain(v)   BECAUSE TI;
<<x,z>> \in (Domain(u) \X Domain(v)) => (<<x,z>> \in (u \union v) \/ <<x,z>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,z>> \in (Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;

(h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)) => <<x,z>> \in woAdd(u,v)   BECAUSE CombineImplicationsStart;
(h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)) \/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))) => <<x,z>> \in woAdd(u,v)   BECAUSE CombineImplicationsStart;
DistribAndOrLeft4(a,b,c,d) == (a /\ (b \/ c \/ d)) => ((a /\ b) \/ (a /\ c) \/ (a /\ d))   PROPO_TAUTO;
h(u,v) /\ ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))
   => ((h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v))
        \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v))
	\/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))))   BECAUSE DistribAndOrLeft4;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)) => ((h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in u \union v))
        \/ (h(u,v) /\ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v))
	\/ (h(u,v) /\ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v))))   BECAUSE TI;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v)) => <<x,z>> \in woAdd(u,v)   BECAUSE TI;
h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A z : h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A y : h(u,v) => (\A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE Q_SCHEME;

\* Proof that orderAddition is anti-symmetric
\A z : h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v))
   => ((<<x,y>> \in u \union v /\ <<y,z>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,z>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,z>> \in Domain(u) \X Domain(v)))   BECAUSE GENERALIZATION;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v))
   => ((<<x,y>> \in u \union v /\ <<y,x>> \in u \union v) \* Solved because u \union v is an order
        \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
        \/ (<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v)))   BECAUSE \A(z <- x);
\* Prove the second case is impossible : ~(<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
\* The third case is the same as the second, by generalizing then swapping x and y
<<y,x>> \in u \union v <=> <<y,x>> \in u \/ <<y,x>> \in v   BECAUSE \A(x <- u, y <- v, z <- <<y,x>>);
<<y,x>> \in u \union v => <<y,x>> \in u \/ <<y,x>> \in v   BECAUSE EquivToImpl;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v
   => x \in Domain(u) /\ y \in Domain(v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)   BECAUSE MergeImplicationsAnd;
multiDistrib(a,b,c,d) == a /\ b /\ (c \/ d) => (b /\ c) \/ (a /\ d)   PROPO_TAUTO;
x \in Domain(u) /\ y \in Domain(v) /\ (<<y,x>> \in u \/ <<y,x>> \in v)
   => (y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v)   BECAUSE multiDistrib;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v
   => (y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v)   BECAUSE TI;

\A u : \A x : \A y : IsOrder(u) /\ <<x,y>> \in u => <<x,x>> \in u   BECAUSE GENERALIZATION;
IsOrder(u) /\ <<y,x>> \in u => <<y,y>> \in u   BECAUSE \A(u <- u, x <- y, y <- x);
IsOrder(u) => (<<y,x>> \in u => <<y,y>> \in u)   BECAUSE HypoAndToImpl;
<<y,x>> \in u => (IsOrder(u) => <<y,y>> \in u)   BECAUSE SwitchHypos;
IsOrder(v) /\ y \in Domain(v) => <<y,y>> \in v   BECAUSE \A(o <- v, x <- y);
IsOrder(v) => (y \in Domain(v) => <<y,y>> \in v)   BECAUSE HypoAndToImpl;
y \in Domain(v) => (IsOrder(v) => <<y,y>> \in v)   BECAUSE SwitchHypos;
y \in Domain(v) /\ <<y,x>> \in u => (IsOrder(v) => <<y,y>> \in v) /\ (IsOrder(u) => <<y,y>> \in u)
   BECAUSE MergeImplicationsAnd;
factorTwoHypos(a,b,c,d) == ((a => b) /\ (c => d)) => ((a /\ c) => (b /\ d))   PROPO_TAUTO;
(IsOrder(v) => <<y,y>> \in v) /\ (IsOrder(u) => <<y,y>> \in u)
   => (IsOrder(v) /\ IsOrder(u) => <<y,y>> \in v /\ <<y,y>> \in u)   BECAUSE factorTwoHypos;
y \in Domain(v) /\ <<y,x>> \in u => (IsOrder(v) /\ IsOrder(u) => <<y,y>> \in v /\ <<y,y>> \in u)
   BECAUSE TI;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => <<y,y>> \in v /\ <<y,y>> \in u
   BECAUSE HypoImplToAnd;
<<y,y>> \in v /\ <<y,y>> \in u => <<y,y>> \in u /\ <<y,y>> \in v   BECAUSE AndSymmetry;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => <<y,y>> \in u /\ <<y,y>> \in v
   BECAUSE TI;
~~(<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE Contraposition;
(<<y,y>> \in u /\ <<y,y>> \in v) => ~~(<<y,y>> \in u /\ <<y,y>> \in v)   BECAUSE IntroNotNot;
(<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE TI;
y \in Domain(v) /\ <<y,x>> \in u /\ (IsOrder(v) /\ IsOrder(u)) => ~AreDisjoint(u,v)   BECAUSE TI;
pullH(a,b,c,d) == (a /\ (b /\ c) => ~d) => (a => ~(c /\ b /\ d))   PROPO_TAUTO;
(y \in Domain(v) /\ <<y,x>> \in u) => ~h(u,v)   BECAUSE pullH;

<<x,x>> \in u /\ <<y,y>> \in u => <<y,y>> \in u   BECAUSE S22;
IsOrder(u) /\ <<x,y>> \in u => <<y,y>> \in u   BECAUSE TI;
\A u : \A x : \A y : IsOrder(u) /\ <<x,y>> \in u => <<y,y>> \in u   BECAUSE GENERALIZATION;
IsOrder(v) /\ <<y,x>> \in v => <<x,x>> \in v   BECAUSE \A(u <- v, x <- y, y <- x);
IsOrder(v) => (<<y,x>> \in v => <<x,x>> \in v)   BECAUSE HypoAndToImpl;
<<y,x>> \in v => (IsOrder(v) => <<x,x>> \in v)   BECAUSE SwitchHypos;
IsOrder(u) /\ x \in Domain(u) => <<x,x>> \in u   BECAUSE \A(o <- u, x <- x);
IsOrder(u) => (x \in Domain(u) => <<x,x>> \in u)   BECAUSE HypoAndToImpl;
x \in Domain(u) => (IsOrder(u) => <<x,x>> \in u)   BECAUSE SwitchHypos;
x \in Domain(u) /\ <<y,x>> \in v => (IsOrder(u) => <<x,x>> \in u) /\ (IsOrder(v) => <<x,x>> \in v)
   BECAUSE MergeImplicationsAnd;
(IsOrder(u) => <<x,x>> \in u) /\ (IsOrder(v) => <<x,x>> \in v)
   => (IsOrder(u) /\ IsOrder(v) => <<x,x>> \in u /\ <<x,x>> \in v)   BECAUSE factorTwoHypos;
x \in Domain(u) /\ <<y,x>> \in v => (IsOrder(u) /\ IsOrder(v) => <<x,x>> \in u /\ <<x,x>> \in v)
   BECAUSE TI;
x \in Domain(u) /\ <<y,x>> \in v /\ (IsOrder(u) /\ IsOrder(v)) => <<x,x>> \in u /\ <<x,x>> \in v
   BECAUSE HypoImplToAnd;
\A y : (<<y,y>> \in u /\ <<y,y>> \in v) => ~AreDisjoint(u,v)   BECAUSE GENERALIZATION;
(<<x,x>> \in u /\ <<x,x>> \in v) => ~AreDisjoint(u,v)   BECAUSE \A(y <- x);
x \in Domain(u) /\ <<y,x>> \in v /\ (IsOrder(u) /\ IsOrder(v)) => ~AreDisjoint(u,v)   BECAUSE TI;
pullHbis(a,b,c,d) == (a /\ (b /\ c) => ~d) => (a => ~(b /\ c /\ d))   PROPO_TAUTO;
(x \in Domain(u) /\ <<y,x>> \in v) => ~h(u,v)   BECAUSE pullHbis;

(y \in Domain(v) /\ <<y,x>> \in u) \/ (x \in Domain(u) /\ <<y,x>> \in v) => ~h(u,v)   BECAUSE CombineImplicationsStart;
<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v => ~h(u,v)   BECAUSE TI;
\A x : \A y : <<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v => ~h(u,v)   BECAUSE GENERALIZATION;
<<y,x>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in u \union v => ~h(u,v)   BECAUSE \A(x <- y, y <- x);
<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v) => <<y,x>> \in Domain(u) \X Domain(v) /\ <<x,y>> \in u \union v   BECAUSE AndSymmetry;
<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v) => ~h(u,v)   BECAUSE TI;

IsOrder(u \union v) => (\A x : \A y : ((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE S22;
(\A x : \A y : ((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)
   => (((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE \A(x <- x, y <- y);
IsOrder(u \union v) => (((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => x = y)   BECAUSE TI;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) => (IsOrder(u \union v) => x = y)   BECAUSE SwitchHypos;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v)) \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v)   BECAUSE MergeImplicationsOr;
((<<x,y>> \in u \union v) /\ (<<y,x>> \in u \union v))
   \/ (<<x,y>> \in Domain(u) \X Domain(v) /\ <<y,x>> \in u \union v)
   \/ (<<x,y>> \in u \union v /\ <<y,x>> \in Domain(u) \X Domain(v))
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v) \/ ~h(u,v)  BECAUSE MergeImplicationsOr;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v))
   => (IsOrder(u \union v) => x = y) \/ ~h(u,v) \/ ~h(u,v)  BECAUSE TI;
dropRedundantCases(a,b,c,d) == (a => c) => ((a /\ b => (c => d) \/ ~a \/ ~a) => (a /\ b => d))   PROPO_TAUTO;
h(u,v) /\ (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v)) => x = y   BECAUSE dropRedundantCases;
h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE HypoAndToImpl;
\A y : h(u,v) => (<<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE GENERALIZATION;
h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE Q_SCHEME;
\A x : h(u,v) => (\A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE GENERALIZATION;
h(u,v) => (\A x : \A y : <<x,y>> \in woAdd(u,v) /\ <<y,x>> \in woAdd(u,v) => x = y)   BECAUSE Q_SCHEME;

h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsGraph(woAdd(u,v)) /\ (\A x : \A y : <<x,y>> \in woAdd(u,v) => <<x,x>> \in woAdd(u,v) /\ <<y,y>> \in woAdd(u,v)) /\ (\A x : \A y : \A z : <<x,y>> \in woAdd(u,v) /\ <<y,z>> \in woAdd(u,v) => <<x,z>> \in woAdd(u,v))   BECAUSE CIA;
h(u,v) => IsOrder(woAdd(u,v))   BECAUSE CIA;
disjointOrderAddition   BECAUSE GENERALIZATION;
QED

(*
   Now the multiplication of orders, which is the usual multiplication on
   natural numbers.
*)
OrderMultiplication(u,v) == CHOOSE m : \A x : x \in m
   <=> IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
       /\ ((fst(fst(x)) # fst(snd(x)) /\ << fst(fst(x)), fst(snd(x))>> \in u)
             \/ (fst(fst(x)) = fst(snd(x)) /\ << snd(fst(x)), snd(snd(x))>> \in v))

orderMultiplicationIsOrder == \A u : \A v : (IsOrder(u) /\ IsOrder(v))
   => IsOrder(OrderMultiplication(u,v))
THEOREM orderMultiplicationIsOrder


EmptyOrHasMinimum(part, order) == (part = {}) \/ (\E m : IsMinimum(m, part, order))

minOfTwoParts == \A o : \A a : \A b :
      (EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o)
        /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)
THEOREM minOfTwoParts
PROOF
VARIABLES a,b,m,o,x,y,z;
\* If a is not empty, then it has a minimum
ma(a,o) == CHOOSE m : IsMinimum(m, a, o);
killCase(a,b) == ((a \/ b) /\ ~a) => b   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ a # {}) => \E m : IsMinimum(m, a, o)   BECAUSE killCase;
(\E m : IsMinimum(m, a, o)) => IsMinimum(ma(a,o), a, o)   BECAUSE CHOOSE ma(a,o);
(EmptyOrHasMinimum(a,o) /\ a # {}) => IsMinimum(ma(a,o), a, o)   BECAUSE TI;

   \* ma(a,o) is below b
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)
   => ((ma(a,o) \in a /\ x \in b) => <<ma(a,o), x>> \in o)   BECAUSE \A(x <- ma(a,o), y <- x);
pullHypo(a,b,c,d) == (a => ((b /\ c) => d)) => ((a /\ b) => (c => d))   PROPO_TAUTO;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE pullHypo;
IsMinimum(ma(a,o), a, o) => ma(a,o) \in a   BECAUSE S12;
(EmptyOrHasMinimum(a,o) /\ a # {}) => ma(a,o) \in a   BECAUSE TI;
(\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) => (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)   BECAUSE ImplySelf;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ ma(a,o) \in a)   BECAUSE MergeImplicationsAnd;
((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;

   \* ma(a,o) is the minimum of (a \union b)
IsMinimum(ma(a,o), a, o) => \A x : x \in a => <<ma(a,o),x>> \in o   BECAUSE S22;
(\A x : x \in a => <<ma(a,o),x>> \in o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE \A(x <- x);
IsMinimum(ma(a,o), a, o) => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o)) => EmptyOrHasMinimum(a,o)   BECAUSE S12;
a # {} => a # {}   BECAUSE ImplySelf;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (EmptyOrHasMinimum(a,o) /\ a # {})   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a, o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in a => <<ma(a,o),x>> \in o)   BECAUSE TI;
shuffleHypos(a,b,c) == (b /\ a /\ c) => (a /\ (b /\ c))   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ (EmptyOrHasMinimum(a,o) /\ a # {}))    BECAUSE shuffleHypos;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (x \in b => <<ma(a,o), x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))   BECAUSE CIA;
((x \in a => <<ma(a,o),x>> \in o) /\ (x \in b => <<ma(a,o), x>> \in o))
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in a \/ x \in b) => <<ma(a,o),x>> \in o)   BECAUSE TI;
unionInc   BECAUSE THEOREM;
x \in (a \union b) <=> (x \in a \/ x \in b)   BECAUSE \A(x <- a, y <- b, z <- x);
x \in (a \union b) => (x \in a \/ x \in b)   BECAUSE EquivToImpl;
((x \in a \/ x \in b) => <<ma(a,o),x>> \in o) => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE TI;
\A x : (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ((x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE GENERALIZATION;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => (\A x : (x \in (a \union b)) => <<ma(a,o),x>> \in o)   BECAUSE Q_SCHEME;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in a   BECAUSE TI;
unionFirstInc   BECAUSE THEOREM;
ma(a,o) \in a => ma(a,o) \in (a \union b)   BECAUSE \A(x <- a, y <- b, z <- ma(a,o)); 
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => ma(a,o) \in (a \union b)   BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => IsMinimum(ma(a,o), a \union b, o) BECAUSE CIA;
IsMinimum(ma(a,o), a \union b, o) => \E m : IsMinimum(m, a \union b, o)   BECAUSE \E(m <- ma(a,o));
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => \E m : IsMinimum(m, a \union b, o) BECAUSE TI;
(\E m : IsMinimum(m, a \union b, o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE IntroOrRight;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o) /\ a # {})
   => EmptyOrHasMinimum(a \union b, o) BECAUSE TI;
(EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE HypoAndToImpl;
addHypo(a,b,c) == (a /\ b /\ c) => (a /\ c)   PROPO_TAUTO;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (EmptyOrHasMinimum(a,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))   BECAUSE addHypo;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a # {} => EmptyOrHasMinimum(a \union b, o)) BECAUSE TI;

\* If a is empty
emptyUnion   BECAUSE THEOREM;
{} \union b = b   BECAUSE \A(a <- b);
\A x : \A y : x = y => (x \union b = b <=> y \union b = b)   BECAUSE E_SCHEME;
a = {} => (a \union b = b <=> {} \union b = b)   BECAUSE \A(x <- a, y <- {});
a = {} => a \union b = b   BECAUSE ImplyEquivTrue;
\A x : \A y : x = y => (EmptyOrHasMinimum(x,o) <=> EmptyOrHasMinimum(y,o))   BECAUSE E_SCHEME;
a \union b = b => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE \A(x <- a \union b, y <- b);
a = {} => (EmptyOrHasMinimum(a \union b,o) <=> EmptyOrHasMinimum(b,o))   BECAUSE TI;
(a = {} /\ EmptyOrHasMinimum(b,o)) => EmptyOrHasMinimum(a \union b, o)   BECAUSE HypoEquivToAndReverse;
(EmptyOrHasMinimum(b,o) /\ a = {}) => (a = {} /\ EmptyOrHasMinimum(b,o))   BECAUSE AndSymmetry;
(EmptyOrHasMinimum(b,o) /\ a = {}) => EmptyOrHasMinimum(a \union b, o)   BECAUSE TI;
EmptyOrHasMinimum(b,o) => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE HypoAndToImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(b,o)   BECAUSE S23;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => (a = {} => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;

(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))   BECAUSE CIA;
((a = {} => EmptyOrHasMinimum(a \union b, o)) /\ (a # {} => EmptyOrHasMinimum(a \union b, o)))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE FactorAndImpl;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => ((a = {} \/ a # {}) => EmptyOrHasMinimum(a \union b, o))   BECAUSE TI;
a = {} \/ a # {}   BECAUSE ExcludedMiddle;
(a = {} \/ a # {}) => ((EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o))   BECAUSE SwitchHypos;
(EmptyOrHasMinimum(a,o) /\ EmptyOrHasMinimum(b,o) /\ (\A x : \A y : (x \in a /\ y \in b) => <<x,y>> \in o))
   => EmptyOrHasMinimum(a \union b, o)   BECAUSE MODUS_PONENS;
minOfTwoParts   BECAUSE GENERALIZATION;
QED


(*
   The class of well-orders, orders where each nonempty subset has a minimum.
   They allow to count :
      - in the well-order, take the minimum and call it zero
      - in the nonzero elements of the well-order, take the minimum and call it one
      - in the elements of the well-order that are neither zero nor one,
        take the minimum and call it two
      - iterate

   For this reason, some well-orders (the finite ones) define the natural numbers.
   The well-orders are stable under addition and multiplication, as defined above.
*)
IsWellOrder(w) == IsOrder(w) /\ (\A p : (p \subseteq Domain(w)) => EmptyOrHasMinimum(p, w))

injectWOIsWO == \A o : \A f : (IsWellOrder(o) /\ IsFunction(f)) => IsWellOrder(injectOrder(o,f))
THEOREM injectWOIsWO

disjointWOAddition == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v))
   => IsWellOrder(u \union v \union (Domain(u) \X Domain(v))) \* this puts v after u
THEOREM disjointWOAddition
PROOF
VARIABLES a,b,c,g,i,j,m,o,p,u,v,x,y,z,part;
woAdd(u,v) == u \union v \union (Domain(u) \X Domain(v)); \* Shorter name
disjointOrderAddition   BECAUSE THEOREM;
(IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u \union v \union (Domain(u) \X Domain(v)))
   BECAUSE \A(u <- u, v <- v);
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(u)   BECAUSE S13;
IsWellOrder(u) => IsOrder(u)   BECAUSE S12;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(u)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(v)   BECAUSE S23;
IsWellOrder(v) => IsOrder(v)   BECAUSE S12;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(v)   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => AreDisjoint(u,v)   BECAUSE S22;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v))   BECAUSE CIA;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsOrder(u) /\ IsOrder(v) /\ AreDisjoint(u,v))
   BECAUSE CIA;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsOrder(woAdd(u,v))   BECAUSE TI;

\* Proof that wellOrderAddition has all minimums
\* Prove part \subseteq Domain(woAdd(u,v)) => part = (part \intersect Domain(u)) \union (part \intersect Domain(v))
\* and call theorem minOfTwoParts with those two parts
domainExists   BECAUSE THEOREM;
z \in Domain(woAdd(u,v))
   <=> IsDefinedOn(woAdd(u,v),z)   BECAUSE \A(g <- woAdd(u,v), x <- z);
z \in Domain(woAdd(u,v))
   => \E y : <<z,y>> \in woAdd(u,v)   BECAUSE EquivToImpl;
unionInc   BECAUSE THEOREM;
<<z,y>> \in woAdd(u,v)
   <=> (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<z,y>>);
<<z,y>> \in woAdd(u,v)
   => (<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))   BECAUSE EquivToImpl;
cartesianProductCouples   BECAUSE THEOREM;
(z \in Domain(u) /\ y \in Domain(v)) <=> <<z,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- z, b <- y);
<<z,y>> \in (Domain(u) \X Domain(v)) => (z \in Domain(u) /\ y \in Domain(v))   BECAUSE EquivToImplReverse;
(z \in Domain(u) /\ y \in Domain(v)) => z \in Domain(u)   BECAUSE S12;
<<z,y>> \in (Domain(u) \X Domain(v)) => z \in Domain(u)   BECAUSE TI;
<<z,y>> \in (u \union v) <=> (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE \A(x <- u, y <- v, z <- <<z,y>>);
<<z,y>> \in (u \union v) => (<<z,y>> \in u \/ <<z,y>> \in v)   BECAUSE EquivToImpl;
domainInc   BECAUSE THEOREM;
<<z,y>> \in u => z \in Domain(u)   BECAUSE \A(g <- u, x <- z, y <- y);
<<z,y>> \in v => z \in Domain(v)   BECAUSE \A(g <- v, x <- z, y <- y);
(<<z,y>> \in u \/ <<z,y>> \in v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE MergeImplicationsOr;
<<z,y>> \in (u \union v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(<<z,y>> \in (u \union v) \/ <<z,y>> \in (Domain(u) \X Domain(v)))
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE MergeImplicationsOr;
<<z,y>> \in woAdd(u,v)
   => ((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u))   BECAUSE TI;
dropRedOr(a,z) == ((a \/ z) \/ a) => (a \/ z)   PROPO_TAUTO;
((z \in Domain(u) \/ z \in Domain(v)) \/ z \in Domain(u)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE dropRedOr;
<<z,y>> \in woAdd(u,v) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
(\E y : <<z,y>> \in woAdd(u,v)) => (\E y : z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : z \in Domain(u) \/ z \in Domain(v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE Q_SCHEME;
(\E y : <<z,y>> \in woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in Domain(woAdd(u,v)) => (z \in Domain(u) \/ z \in Domain(v))   BECAUSE TI;
z \in (Domain(u) \union Domain(v)) <=> (z \in Domain(u) \/ z \in Domain(v))
   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- z);
(z \in Domain(u) \/ z \in Domain(v)) => z \in (Domain(u) \union Domain(v))   BECAUSE EquivToImplReverse;
z \in Domain(woAdd(u,v)) => z \in (Domain(u) \union Domain(v))   BECAUSE TI;
Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v))   BECAUSE GENERALIZATION;
transitInclusion   BECAUSE THEOREM;
(part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))
   => part \subseteq (Domain(u) \union Domain(v))   BECAUSE \A(a <- part, b <- Domain(woAdd(u,v)), c <- (Domain(u) \union Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (part \subseteq Domain(woAdd(u,v)) /\ Domain(woAdd(u,v)) \subseteq (Domain(u) \union Domain(v)))   BECAUSE IntroAndLeft;
part \subseteq Domain(woAdd(u,v)) => part \subseteq (Domain(u) \union Domain(v))   BECAUSE TI;
distribIntersectUnion   BECAUSE THEOREM;
(part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   BECAUSE \A(a <- part, b <- Domain(u), c <- Domain(v));
intersectSuper   BECAUSE THEOREM;
part \subseteq (Domain(u) \union Domain(v)) => (part \intersect (Domain(u) \union Domain(v))) = part
   BECAUSE \A(a <- part, b <- Domain(u) \union Domain(v));
part \subseteq Domain(woAdd(u,v)) => (part \intersect (Domain(u) \union Domain(v))) = part   BECAUSE TI;
((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE E_SCHEME;
(part \intersect (Domain(u) \union Domain(v))) = part => ((part \intersect (Domain(u) \union Domain(v))) = part /\ (part \intersect (Domain(u) \union Domain(v))) = ((part \intersect Domain(u)) \union (part \intersect Domain(v))))   BECAUSE IntroAndLeft;
(part \intersect (Domain(u) \union Domain(v))) = part => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq (Domain(u) \union Domain(v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;
part \subseteq Domain(woAdd(u,v)) => part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))   BECAUSE TI;

IsWellOrder(u) => (\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))   BECAUSE S22;
(\A p : p \subseteq Domain(u) => EmptyOrHasMinimum(p, u))
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE \A(p <- part \intersect Domain(u));
IsWellOrder(u)
   => ((part \intersect Domain(u)) \subseteq Domain(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)
   => (IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u))   BECAUSE SwitchHypos;
intersectionExists   BECAUSE THEOREM;
z \in (part \intersect Domain(u)) <=> (z \in part /\ z \in Domain(u))   BECAUSE \A(u <- part, v <- Domain(u), x <- z);
z \in (part \intersect Domain(u)) => (z \in part /\ z \in Domain(u))   BECAUSE EquivToImpl;
(z \in part /\ z \in Domain(u)) => z \in Domain(u)   BECAUSE S22;
z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE TI;
(part \intersect Domain(u)) \subseteq Domain(u)   BECAUSE GENERALIZATION;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE MODUS_PONENS;
\A u : IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), u)   BECAUSE GENERALIZATION;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), v)   BECAUSE \A(u <- v);

\* Proof of EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))
IsMinimum(m, part \intersect Domain(u), u)
   => \A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u   BECAUSE S22;
(\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in u)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in u   BECAUSE HypoImplToAnd;
x \in woAdd(u,v)
   <=> (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- x);
(x \in (u \union v) \/ x \in (Domain(u) \X Domain(v))) => x \in woAdd(u,v)   BECAUSE EquivToImplReverse;
x \in (u \union v) => (x \in (u \union v) \/ x \in (Domain(u) \X Domain(v)))   BECAUSE IntroOrLeft;
x \in (u \union v) => x \in woAdd(u,v)   BECAUSE TI;
x \in (u \union v) <=> (x \in u \/ x \in v)   BECAUSE \A(x <- u, y <- v, z <- x);
(x \in u \/ x \in v) => x \in (u \union v)   BECAUSE EquivToImplReverse;
x \in u => (x \in u \/ x \in v)   BECAUSE IntroOrLeft;
x \in u => x \in (u \union v)   BECAUSE TI;
x \in u => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in u => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in u => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(u), u) /\ x \in (part \intersect Domain(u))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(u), u) => (x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(u), u) => (\A x : x \in (part \intersect Domain(u)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(u), u) => m \in (part \intersect Domain(u))   BECAUSE S12;
IsMinimum(m, part \intersect Domain(u), u) => IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE CIA;
(\E m : IsMinimum(m, part \intersect Domain(u), u)) => \E m : IsMinimum(m, part \intersect Domain(u), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(u) = {}) => (part \intersect Domain(u) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(u), u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(u) => EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v))   BECAUSE TI;

IsMinimum(m, part \intersect Domain(v), v)
   => \A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v   BECAUSE S22;
(\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE \A(x <- x);
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in v)   BECAUSE TI;
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in v   BECAUSE HypoImplToAnd;
x \in v => (x \in u \/ x \in v)   BECAUSE IntroOrRight;
x \in v => x \in (u \union v)   BECAUSE TI;
x \in v => x \in woAdd(u,v)   BECAUSE TI;
\A x : x \in v => x \in woAdd(u,v)   BECAUSE GENERALIZATION;
<<m,x>> \in v => <<m,x>> \in woAdd(u,v)   BECAUSE \A(x <- <<m,x>>);
(IsMinimum(m, part \intersect Domain(v), v) /\ x \in (part \intersect Domain(v))) => <<m,x>> \in woAdd(u,v)   BECAUSE TI;
IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE HypoAndToImpl;
\A x : IsMinimum(m, part \intersect Domain(v), v) => (x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE GENERALIZATION;
IsMinimum(m, part \intersect Domain(v), v) => (\A x : x \in (part \intersect Domain(v)) => <<m,x>> \in woAdd(u,v))   BECAUSE Q_SCHEME;
IsMinimum(m, part \intersect Domain(v), v) => m \in (part \intersect Domain(v))   BECAUSE S12;
IsMinimum(m, part \intersect Domain(v), v) => IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE CIA;
(\E m : IsMinimum(m, part \intersect Domain(v), v)) => \E m : IsMinimum(m, part \intersect Domain(v), woAdd(u,v))
   BECAUSE Q_SCHEME;
(part \intersect Domain(v) = {}) => (part \intersect Domain(v) = {})   BECAUSE ImplySelf;
EmptyOrHasMinimum(part \intersect Domain(v), v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE MergeImplicationsOr;
IsWellOrder(v) => EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))   BECAUSE TI;

\* Domination of first part by second part
\A u : \A z : z \in (part \intersect Domain(u)) => z \in Domain(u)   BECAUSE GENERALIZATION;
x \in (part \intersect Domain(u)) => x \in Domain(u)   BECAUSE \A(u <- u, z <- x);
y \in (part \intersect Domain(v)) => y \in Domain(v)   BECAUSE \A(u <- v, z <- y);
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => (x \in Domain(u) /\ y \in Domain(v))   BECAUSE MergeImplicationsAnd;
(x \in Domain(u) /\ y \in Domain(v)) <=> <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE \A(x <- Domain(u), y <- Domain(v), a <- x, b <- y);
(x \in Domain(u) /\ y \in Domain(v)) => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE EquivToImpl;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v)))
   => <<x,y>> \in (Domain(u) \X Domain(v))   BECAUSE TI;
<<x,y>> \in woAdd(u,v) <=> (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE \A(x <- (u \union v), y <- (Domain(u) \X Domain(v)), z <- <<x,y>>);
(<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v))) => <<x,y>> \in woAdd(u,v)
   BECAUSE EquivToImplReverse;
<<x,y>> \in (Domain(u) \X Domain(v)) => (<<x,y>> \in (u \union v) \/ <<x,y>> \in (Domain(u) \X Domain(v)))
   BECAUSE IntroOrRight;
<<x,y>> \in (Domain(u) \X Domain(v)) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
(x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE TI;
\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)   BECAUSE GENERALIZATION;

minOfTwoParts   BECAUSE THEOREM;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))
    /\ (\A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v)))
   => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))
   BECAUSE \A(o <- woAdd(u,v), a <- part \intersect Domain(u), b <- part \intersect Domain(v));
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v))) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE IntroAndLeft;
(IsWellOrder(u) /\ IsWellOrder(v)) => (EmptyOrHasMinimum(part \intersect Domain(u), woAdd(u,v)) /\ EmptyOrHasMinimum(part \intersect Domain(v), woAdd(u,v)) /\ \A x : \A y : (x \in (part \intersect Domain(u)) /\ y \in (part \intersect Domain(v))) => <<x,y>> \in woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => EmptyOrHasMinimum((part \intersect Domain(u)) \union (part \intersect Domain(v)), woAdd(u,v))   BECAUSE TI;
\A a : \A b : a = b => (EmptyOrHasMinimum(a, woAdd(u,v)) <=> EmptyOrHasMinimum(b, woAdd(u,v)))   BECAUSE E_SCHEME;
part = ((part \intersect Domain(u)) \union (part \intersect Domain(v)))
   => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))
   BECAUSE \A(a <- part, b <- (part \intersect Domain(u)) \union (part \intersect Domain(v)));
part \subseteq Domain(woAdd(u,v)) => (EmptyOrHasMinimum(part, woAdd(u,v)) <=> EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE TI;
(part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE HypoEquivToAndReverse;
part \subseteq Domain(woAdd(u,v)) => part \subseteq Domain(woAdd(u,v))   BECAUSE ImplySelf;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => (part \subseteq Domain(woAdd(u,v)) /\ EmptyOrHasMinimum(((part \intersect Domain(u)) \union (part \intersect Domain(v))), woAdd(u,v)))   BECAUSE MergeImplicationsAnd;
(part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => (part \subseteq Domain(woAdd(u,v)) /\ (IsWellOrder(u) /\ IsWellOrder(v)))   BECAUSE AndSymmetry;
(IsWellOrder(u) /\ IsWellOrder(v) /\ part \subseteq Domain(woAdd(u,v))) => EmptyOrHasMinimum(part, woAdd(u,v))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE HypoAndToImpl;
\A part : (IsWellOrder(u) /\ IsWellOrder(v)) => (part \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(part, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE \A(part <- p);
\A p : (IsWellOrder(u) /\ IsWellOrder(v)) => (p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE GENERALIZATION;
(IsWellOrder(u) /\ IsWellOrder(v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE Q_SCHEME;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (IsWellOrder(u) /\ IsWellOrder(v))   BECAUSE S12;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => (\A p : p \subseteq Domain(woAdd(u,v)) => EmptyOrHasMinimum(p, woAdd(u,v)))   BECAUSE TI;
(IsWellOrder(u) /\ IsWellOrder(v) /\ AreDisjoint(u,v)) => IsWellOrder(woAdd(u,v))   BECAUSE CIA;
disjointWOAddition   BECAUSE GENERALIZATION;
QED

pasteTags(dom, tag) == productFunc(identity(dom), const(dom, tag))

\* Define a well-order on the disjoint union of two well-orders.
\* This order simply pastes v after u.
wellOrderAddition(u,v) == injectOrder(u, pasteTags(Domain(u),{}))
   \union injectOrder(v, pasteTags(Domain(v),ordinalOne))
   \union ((Domain(u)\X{{}}) \X (Domain(v)\X{ordinalOne})) \* this puts v after u

woAddIsWo == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v)) => IsWellOrder(wellOrderAddition(u,v))
THEOREM woAddIsWo
PROOF
VARIABLES a,b,c,d,f,i,j,g,o,u,v,x,y,z,tag;
\* Give shorter names
Ione(u) == injectOrder(u, pasteTags(Domain(u),{}));
Itwo(v) == injectOrder(v, pasteTags(Domain(v),ordinalOne));
DO(u,v) == Ione(u) \union Itwo(v);

\* Proof that DO is an order
productFuncIsFunc   BECAUSE THEOREM;
(IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y)))
   => IsFunction(pasteTags(Domain(u),y))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),y));
identityBiject   BECAUSE THEOREM;
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))   BECAUSE \A(d <- Domain(u));
bijectionsExists   BECAUSE THEOREM;
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))
   <=> IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE \A(d <- Domain(u), i <- Domain(u), f <- identity(Domain(u)));
identity(Domain(u)) \in Bijections(Domain(u),Domain(u))
   => IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE EquivToImpl;
IsInjection(identity(Domain(u))) /\ Domain(identity(Domain(u))) = Domain(u) /\ Image(identity(Domain(u))) = Domain(u)
   BECAUSE MODUS_PONENS;
IsInjection(identity(Domain(u)))   BECAUSE S13;
IsFunction(identity(Domain(u)))   BECAUSE S12;
constFunc   BECAUSE THEOREM;
IsFunction(const(Domain(u),y))   BECAUSE \A(d <- Domain(u), c <- y);
IsFunction(identity(Domain(u))) /\ IsFunction(const(Domain(u),y))   BECAUSE IntroAndRight;
IsFunction(pasteTags(Domain(u),y))   BECAUSE MODUS_PONENS;
injectOrderIsOrder   BECAUSE THEOREM;
(IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))
   => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),y));
IsOrder(u) => (IsOrder(u) /\ IsFunction(pasteTags(Domain(u),y)))   BECAUSE IntroAndLeft;
IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE TI;
\A u : \A y : IsOrder(u) => IsOrder(injectOrder(u,pasteTags(Domain(u),y)))   BECAUSE GENERALIZATION;
IsOrder(u) => IsOrder(Ione(u))   BECAUSE \A(u <- u, y <- {});
IsOrder(v) => IsOrder(Itwo(v))   BECAUSE \A(u <- v, y <- ordinalOne);
	   \* Proof that AreDisjoint(Ione(u),Itwo(v))
disjointOrders   BECAUSE THEOREM;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u),Itwo(v)))
   => IsOrder(Ione(u) \union Itwo(v))   BECAUSE \A(u <- Ione(u), v <- Itwo(v));
noCommonElements   BECAUSE THEOREM;
AreDisjoint(Ione(u),Itwo(v)) <=> \A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE \A(x <- Ione(u), y <- Itwo(v));
(\A z : ~(z \in Ione(u) /\ z \in Itwo(v))) => AreDisjoint(Ione(u),Itwo(v))   BECAUSE EquivToImplReverse;
injectOrderExists   BECAUSE THEOREM;
z \in Ione(u) <=> IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE \A(o <- u, f <- pasteTags(Domain(u),{}), x <- z);
z \in Itwo(v) <=> IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE \A(o <- v, f <- pasteTags(Domain(v),ordinalOne), x <- z);
IsInInjectOrder(u,pasteTags(Domain(u),tag),z)
   => z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag)))   BECAUSE S12;
cartesianProductExists   BECAUSE THEOREM;
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) <=> (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))
   BECAUSE \A(i <- Image(pasteTags(Domain(u),tag)), j <- Image(pasteTags(Domain(u),tag)), x <- z);
z \in (Image(pasteTags(Domain(u),tag)) \X Image(pasteTags(Domain(u),tag))) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE EquivToImpl;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => (IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag)))   BECAUSE TI;
(IsCouple(z) /\ fst(z) \in Image(pasteTags(Domain(u),tag)) /\ snd(z) \in Image(pasteTags(Domain(u),tag))) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE S22;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => snd(z) \in Image(pasteTags(Domain(u),tag))   BECAUSE TI;
productFuncVal   BECAUSE THEOREM;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => (IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag))
   BECAUSE \A(f <- identity(Domain(u)), g <- const(Domain(u),tag), x <- x, y <- snd(z));
(IsCouple(snd(z)) /\ <<x,fst(snd(z))>> \in identity(Domain(u)) /\ <<x,snd(snd(z))>> \in const(Domain(u),tag)) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE S22;
<<x,snd(z)>> \in pasteTags(Domain(u),tag) => <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
imageExists   BECAUSE THEOREM;
snd(z) \in Image(pasteTags(Domain(u),tag)) <=> Reaches(pasteTags(Domain(u),tag),snd(z))   BECAUSE \A(g <- pasteTags(Domain(u),tag), y <- snd(z));
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)   BECAUSE EquivToImpl;
(\E x : <<x,snd(z)>> \in pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE Q_SCHEME;
snd(z) \in Image(pasteTags(Domain(u),tag)) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => \E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)   BECAUSE TI;
constExists   BECAUSE THEOREM;
<<x,snd(snd(z))>> \in const(Domain(u),tag) <=> (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE \A(d <- Domain(u), c <- tag, x <- <<x,snd(snd(z))>>);
<<x,snd(snd(z))>> \in const(Domain(u),tag) => (IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)   BECAUSE EquivToImpl;
(IsCouple(<<x,snd(snd(z))>>) /\ fst(<<x,snd(snd(z))>>) \in Domain(u) /\ snd(<<x,snd(snd(z))>>) = tag)
   => snd(<<x,snd(snd(z))>>) = tag   BECAUSE S22;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => snd(<<x,snd(snd(z))>>) = tag   BECAUSE TI;
sndExists   BECAUSE THEOREM;
snd(snd(z)) = snd(<<x,snd(snd(z))>>)   BECAUSE \A(a <- x, b <- snd(snd(z)));
snd(<<x,snd(snd(z))>>) = tag => tag = snd(<<x,snd(snd(z))>>)   BECAUSE E_SCHEME;
(tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>)) => tag = snd(snd(z))  BECAUSE E_SCHEME;
tag = snd(<<x,snd(snd(z))>>) => (tag = snd(<<x,snd(snd(z))>>) /\ snd(snd(z)) = snd(<<x,snd(snd(z))>>))   BECAUSE IntroAndLeft;
tag = snd(<<x,snd(snd(z))>>) => tag = snd(snd(z))  BECAUSE TI;
snd(<<x,snd(snd(z))>>) = tag => tag = snd(snd(z))  BECAUSE TI;
<<x,snd(snd(z))>> \in const(Domain(u),tag) => tag = snd(snd(z))  BECAUSE TI;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => \E x : tag = snd(snd(z))  BECAUSE Q_SCHEME;
(\E x : tag = snd(snd(z))) => tag = snd(snd(z))   BECAUSE Q_SCHEME;
(\E x : <<x,snd(snd(z))>> \in const(Domain(u),tag)) => tag = snd(snd(z))   BECAUSE TI;
IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE TI;
\A u : \A tag : IsInInjectOrder(u,pasteTags(Domain(u),tag),z) => tag = snd(snd(z))   BECAUSE GENERALIZATION;
IsInInjectOrder(u,pasteTags(Domain(u),{}),z) => {} = snd(snd(z))   BECAUSE \A(u <- u, tag <- {});
IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z) => ordinalOne = snd(snd(z))   BECAUSE \A(u <- v, tag <- ordinalOne);
z \in Ione(u) => IsInInjectOrder(u,pasteTags(Domain(u),{}),z)   BECAUSE EquivToImpl;
z \in Ione(u) => {} = snd(snd(z))   BECAUSE TI;
z \in Itwo(v) => IsInInjectOrder(v,pasteTags(Domain(v),ordinalOne),z)   BECAUSE EquivToImpl;
z \in Itwo(v) => ordinalOne = snd(snd(z))   BECAUSE TI;

(z \in Ione(u) /\ z \in Itwo(v)) => ({} = snd(snd(z)) /\ ordinalOne = snd(snd(z)))   BECAUSE MergeImplicationsAnd;
({} = snd(snd(z)) /\ ordinalOne = snd(snd(z))) => {} = ordinalOne   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => {} = ordinalOne   BECAUSE TI;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
(z \in Ione(u) /\ z \in Itwo(v)) => ordinalOne = {}   BECAUSE TI;
ordinalOne # {} => ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE Contraposition;
oneIsNotZero   BECAUSE THEOREM;
~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE MODUS_PONENS;
\A z : ~(z \in Ione(u) /\ z \in Itwo(v))   BECAUSE GENERALIZATION;
AreDisjoint(Ione(u),Itwo(v))   BECAUSE MODUS_PONENS;
(IsOrder(u) /\ IsOrder(v)) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)))   BECAUSE MergeImplicationsAnd;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => (IsOrder(Ione(u)) /\ IsOrder(Itwo(v)) /\ AreDisjoint(Ione(u), Itwo(v)))   BECAUSE IntroAndLeft;
(IsOrder(Ione(u)) /\ IsOrder(Itwo(v))) => IsOrder(Ione(u) \union Itwo(v))   BECAUSE TI;
(IsOrder(u) /\ IsOrder(v)) => IsOrder(DO(u,v))   BECAUSE TI;
QED


(*
   At the moment, the addition and multiplication of well-orders are not commutative,
   even for finite ones. wellOrderAddition(u,v) and wellOrderAddition(v,u) are
   isomorphic as well-orders, but not equal.

   It would be convenient to fix one representative in each well-order isomorphy
   class, so that addition and multiplication get their usual properties. The
   ordinals achieve that, they find canonical elements for the well-orders' domains.
*)
IsTransitiveSet(x) == \A a : a \in x => a \subseteq x

(*
   Predicate asserting that the set x is strictly well-ordered by the membership
   relation \in. In those sets, \in behaves like < on the natural numbers. Actually,
   those sets start with the natural numbers and \in will be the definition of <.
*)
IsMinimumForIn(m, part) == m \in part /\ \A b : b \in part => (b = m \/ m \in b)
IsTransitiveIn(x) == \A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c
IsWellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ IsTransitiveIn(x)
   /\ (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))

(*
   The class of ordinals, which starts with the natural numbers. This predicate
   rigorously defines what could be naively stated as
      0 = {}
      n = { 0, ..., n-1 }
*)
IsOrdinal(o) == IsTransitiveSet(o) /\ IsWellOrderedByIn(o)

ordinalsWellFounded == \A o : IsOrdinal(o) => o \notin o
THEOREM ordinalsWellFounded
PROOF
VARIABLES a,o;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A a : a \in o => a \notin a)   BECAUSE S13;
IsOrdinal(o) => (\A a : a \in o => a \notin a)   BECAUSE TI;
(\A a : a \in o => a \notin a) => (o \in o => o \notin o)   BECAUSE \A(a <- o);
IsOrdinal(o) => (o \in o => o \notin o)   BECAUSE TI;
absurd(a,b) == (a => (b => ~b)) => (a => ~b)   PROPO_TAUTO;
IsOrdinal(o) => o \notin o   BECAUSE absurd;
ordinalsWellFounded   BECAUSE GENERALIZATION;
QED

ordinalIsTotalOrder == \A o : \A x : \A y : IsOrdinal(o) /\ x \in o /\ y \in o
   => x \in y \/ x = y \/ y \in x
THEOREM ordinalIsTotalOrder
PROOF
ordinalIsTotalOrder   BECAUSE GENERALIZATION;
QED

(*
   The strict order \in between the elements of an ordinal p
   extends to p itself, ie p \union {p} is an ordinal and p
   is its maximum.
*)
ordinalComparesWithOwnElements == \A o : \A p : IsOrdinal(p) /\ o \in p
   => o # p /\ p \notin o
THEOREM ordinalComparesWithOwnElements
PROOF
VARIABLES a,o,p,x,z;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(p) => p \notin p   BECAUSE \A(o <- p);
\A o : \A p : o = p => (o \in x <=> p \in x)   BECAUSE E_SCHEME;
o = p => (o \in x <=> p \in x)   BECAUSE \A(o <- o, p <- p);
\A x : o = p => (o \in x <=> p \in x)   BECAUSE GENERALIZATION;
o = p => (o \in p <=> p \in p)   BECAUSE \A(x <- p);
IsOrdinal(p) /\ o = p => p \notin p /\ (o \in p <=> p \in p)   BECAUSE MergeImplicationsAnd;
absurd(a,b,c,d) == (a /\ b => ~c /\ (d <=> c)) => (a /\ d => ~b)   PROPO_TAUTO;
IsOrdinal(p) /\ o \in p => o # p   BECAUSE absurd;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
IsTransitiveSet(p) => (o \in p => o \subseteq p)   BECAUSE \A(a <- o);
IsOrdinal(p) => (o \in p => o \subseteq p)   BECAUSE TI;
IsOrdinal(p) /\ o \in p => o \subseteq p   BECAUSE HypoImplToAnd;
o \subseteq p => (p \in o => p \in p)   BECAUSE \A(z <- p);
IsOrdinal(p) /\ o \in p => (p \in o => p \in p)   BECAUSE TI;
absurdAgain(a,b,c,d) == (a => ~b) => ((a /\ c => (d => b)) => (a /\ c => ~d))   PROPO_TAUTO;
IsOrdinal(p) /\ o \in p => p \notin o   BECAUSE absurdAgain;
IsOrdinal(p) /\ o \in p => o # p /\ p \notin o   BECAUSE CIA;
ordinalComparesWithOwnElements   BECAUSE GENERALIZATION;
QED

elemOfOrdinalIsOrdinal == \A o : \A x : IsOrdinal(o) /\ x \in o => IsOrdinal(x)
THEOREM elemOfOrdinalIsOrdinal
PROOF
VARIABLES a,b,c,o,p,x,z;
h(o,x) == IsOrdinal(o) /\ x \in o;
\* Proof that h(o,x) => IsTransitiveSet(x)
h(o,x) => IsOrdinal(o)   BECAUSE S12;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
h(o,x) => IsTransitiveSet(o)   BECAUSE TI;
IsTransitiveSet(o) => (x \in o => x \subseteq o)   BECAUSE \A(a <- x);
h(o,x) => (x \in o => x \subseteq o)   BECAUSE TI;
h(o,x) => x \in o   BECAUSE S22;
h(o,x) => x \subseteq o   BECAUSE KillMiddleHypo;
x \subseteq o => (a \in x => a \in o)   BECAUSE \A(z <- a);
h(o,x) => (a \in x => a \in o)   BECAUSE TI;
hh(a,o,x) == h(o,x) /\ a \in x;
hh(a,o,x) => a \in o   BECAUSE HypoImplToAnd;
IsTransitiveSet(o) => (a \in o => a \subseteq o)   BECAUSE \A(a <- a);
h(o,x) => (a \in o => a \subseteq o)   BECAUSE TI;
hh(a,o,x) => h(o,x)   BECAUSE S12;
hh(a,o,x) => (a \in o => a \subseteq o)   BECAUSE TI;
hh(a,o,x) => a \subseteq o   BECAUSE KillMiddleHypo;
a \subseteq o => (z \in a => z \in o)   BECAUSE \A(z <- z);
hh(a,o,x) => (z \in a => z \in o)   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o   BECAUSE HypoImplToAnd;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => IsTransitiveIn(o)   BECAUSE S23;
(\A a : \A b : \A c : (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c) => a \in c)
   => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE \A(a <- z, b <- a, c <- x);
IsWellOrderedByIn(o) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
IsOrdinal(o) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
h(o,x) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) /\ z \in a => hh(a,o,x)   BECAUSE S12;
hh(a,o,x) /\ z \in a => (z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x => z \in x)   BECAUSE TI;
hh(a,o,x) /\ z \in a => a \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o   BECAUSE CIA;
hh(a,o,x) => x \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => x \in o   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o   BECAUSE CIA;
hh(a,o,x) /\ z \in a => z \in a   BECAUSE S22;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o /\ z \in a   BECAUSE CIA;
hh(a,o,x) => a \in x   BECAUSE S22;
hh(a,o,x) /\ z \in a => a \in x   BECAUSE TI;
hh(a,o,x) /\ z \in a => z \in o /\ a \in o /\ x \in o /\ z \in a /\ a \in x   BECAUSE CIA;
hh(a,o,x) /\ z \in a => z \in x   BECAUSE KillMiddleHypo;
hh(a,o,x) => (z \in a => z \in x)   BECAUSE HypoAndToImpl;
\A z : hh(a,o,x) => (z \in a => z \in x)   BECAUSE GENERALIZATION;
hh(a,o,x) => a \subseteq x   BECAUSE Q_SCHEME;
h(o,x) => (a \in x => a \subseteq x)   BECAUSE HypoAndToImpl;
\A a : h(o,x) => (a \in x => a \subseteq x)   BECAUSE GENERALIZATION;
h(o,x) => IsTransitiveSet(x)   BECAUSE Q_SCHEME;

\* Proof of h(o,x) => IsWellOrderedByIn(x)
IsWellOrderedByIn(o) => \A a : a \in o => a \notin a   BECAUSE S13;
(\A a : a \in o => a \notin a) => (a \in o => a \notin a)   BECAUSE \A(a <- a);
IsWellOrderedByIn(o) => (a \in o => a \notin a)   BECAUSE TI;
IsOrdinal(o) => (a \in o => a \notin a)   BECAUSE TI;
h(o,x) => (a \in o => a \notin a)   BECAUSE TI;
hh(a,o,x) => (a \in o => a \notin a)   BECAUSE TI;
hh(a,o,x) => a \notin a   BECAUSE KillMiddleHypo;
h(o,x) => (a \in x => a \notin a)   BECAUSE HypoAndToImpl;
\A a : h(o,x) => (a \in x => a \notin a)   BECAUSE GENERALIZATION;
h(o,x) => (\A a : a \in x => a \notin a)   BECAUSE Q_SCHEME;

\* Proof of transitivity of the well-order
transitX(a,b,c,o,x) == h(o,x) /\ (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c);
transitX(a,b,c,o,x) => h(o,x)   BECAUSE S12;
transitX(a,b,c,o,x) => (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c)   BECAUSE S22;
(a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => (a \in x /\ b \in x /\ c \in x)   BECAUSE S13;
transitX(a,b,c,o,x) => (a \in x /\ b \in x /\ c \in x)   BECAUSE TI;
(a \in x /\ b \in x /\ c \in x) => a \in x   BECAUSE S13;
(a \in x /\ b \in x /\ c \in x) => b \in x   BECAUSE S23;
(a \in x /\ b \in x /\ c \in x) => c \in x   BECAUSE S22;
transitX(a,b,c,o,x) => a \in x   BECAUSE TI;
transitX(a,b,c,o,x) => b \in x   BECAUSE TI;
transitX(a,b,c,o,x) => c \in x   BECAUSE TI;
transitX(a,b,c,o,x) => h(o,x) /\ a \in x   BECAUSE CIA;
transitX(a,b,c,o,x) => h(o,x) /\ b \in x   BECAUSE CIA;
transitX(a,b,c,o,x) => h(o,x) /\ c \in x   BECAUSE CIA;
\A a : hh(a,o,x) => a \in o   BECAUSE GENERALIZATION;
hh(b,o,x) => b \in o   BECAUSE \A(a <- b);
hh(c,o,x) => c \in o   BECAUSE \A(a <- c);
transitX(a,b,c,o,x) => a \in o   BECAUSE TI;
transitX(a,b,c,o,x) => b \in o   BECAUSE TI;
transitX(a,b,c,o,x) => c \in o   BECAUSE TI;
(a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in b   BECAUSE S23;
(a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => b \in c   BECAUSE S22;
transitX(a,b,c,o,x) => a \in b   BECAUSE TI;
transitX(a,b,c,o,x) => b \in c   BECAUSE TI;
transitX(a,b,c,o,x) => a \in o /\ b \in o   BECAUSE CIA;
transitX(a,b,c,o,x) => a \in o /\ b \in o /\ c \in o   BECAUSE CIA;
transitX(a,b,c,o,x) => a \in o /\ b \in o /\ c \in o /\ a \in b   BECAUSE CIA;
transitX(a,b,c,o,x) => a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c   BECAUSE CIA;
IsTransitiveIn(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)
   BECAUSE \A(a <- a, b <- b, c <- c);
IsWellOrderedByIn(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
IsOrdinal(o) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
h(o,x) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
transitX(a,b,c,o,x) => (a \in o /\ b \in o /\ c \in o /\ a \in b /\ b \in c => a \in c)   BECAUSE TI;
transitX(a,b,c,o,x) => a \in c   BECAUSE KillMiddleHypo;
h(o,x) => ((a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE HypoAndToImpl;
h(o,x) => ((a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE HypoAndToImpl;
\A c : h(o,x) => ((a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,x) => (\A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE Q_SCHEME;
\A b : h(o,x) => (\A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,x) => (\A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE Q_SCHEME;
\A a : h(o,x) => (\A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c)   BECAUSE GENERALIZATION;
h(o,x) => IsTransitiveIn(x)   BECAUSE Q_SCHEME;

minPart(o,p,x) == h(o,x) /\ p \subseteq x;
minPart(o,p,x) => h(o,x)   BECAUSE S12;
minPart(o,p,x) => p \subseteq x   BECAUSE S22;
minPart(o,p,x) => x \subseteq o   BECAUSE TI;
transitInclusion   BECAUSE THEOREM;
p \subseteq x /\ x \subseteq o => p \subseteq o   BECAUSE \A(a <- p, b <- x, c <- o);
minPart(o,p,x) => p \subseteq x /\ x \subseteq o   BECAUSE CIA;
minPart(o,p,x) => p \subseteq o   BECAUSE TI;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p)) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE \A(p <- p);
IsWellOrderedByIn(o) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
IsOrdinal(o) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
h(o,x) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
minPart(o,p,x) => (p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE TI;
minPart(o,p,x) => (p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE KillMiddleHypo;
h(o,x) => (p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE HypoAndToImpl;
\A p : h(o,x) => (p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE GENERALIZATION;
h(o,x) => (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE Q_SCHEME;

h(o,x) => IsWellOrderedByIn(x)   BECAUSE CIA2;
h(o,x) => IsOrdinal(x)   BECAUSE CIA;
elemOfOrdinalIsOrdinal   BECAUSE GENERALIZATION;
QED

includedOrdinals == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p) /\ o \subseteq p
   => o \in p \/ o = p
THEOREM includedOrdinals
PROOF
VARIABLES a,b,c,o,m,p,u,v,x,y,z;
bothInclusions   BECAUSE THEOREM;
(o \subseteq p /\ p \subseteq o) => o = p   BECAUSE \A(a <- o, b <- p);
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p) /\ o \subseteq p;
h(o,p) => o \subseteq p   BECAUSE S22;
contraPos(a,b,c,h) == ((a /\ b) => c) => ((h => a) => (h /\ ~c => ~b))   PROPO_TAUTO;
h(o,p) /\ o # p => ~(p \subseteq o)   BECAUSE contraPos;

\* Proof that p \ o is not empty
setDifferenceExists   BECAUSE THEOREM;
z \in (p \ o) <=> (z \in p /\ z \notin o)   BECAUSE \A(u <- p, v <- o, x <- z);
(z \in p /\ z \notin o) => z \in (p \ o)   BECAUSE EquivToImplReverse;
z \notin (p \ o) => ~(z \in p /\ z \notin o)   BECAUSE Contraposition;
(\E z : z \in p \ o) <=> ~\A z : z \notin (p \ o)   BECAUSE Q_SCHEME;
~(\A z : z \notin p \ o) => (\E z : z \in p \ o)   BECAUSE EquivToImplReverse;
boolImpl(a,b) == ~(a /\ ~b) => (a => b)   PROPO_TAUTO;
~(z \in p /\ z \notin o) => (z \in p => z \in o)   BECAUSE boolImpl;
z \notin p \ o => (z \in p => z \in o)   BECAUSE TI;
(\A z : z \notin p \ o) => p \subseteq o   BECAUSE Q_SCHEME;
~(p \subseteq o) => ~\A z : z \notin p \ o   BECAUSE Contraposition;
h(o,p) /\ o # p => \E z : z \in (p \ o)   BECAUSE TI2;
emptySetExistsUniquely   BECAUSE THEOREM;
(p \ o) = {} <=> \A x : x \notin p \ o   BECAUSE \A(c <- p \ o);
(p \ o) = {} => \A x : x \notin p \ o   BECAUSE EquivToImpl;
~(\A x : x \notin p \ o) => (p \ o) # {}   BECAUSE Contraposition;
(\E x : x \in (p \ o)) <=> ~\A x : x \notin p \ o   BECAUSE Q_SCHEME;
(\E x : x \in (p \ o)) => ~\A x : x \notin p \ o   BECAUSE EquivToImpl;
z \in (p \ o) => \E x : x \in (p \ o)   BECAUSE \E(x <- z);
(\E z : z \in (p \ o)) => \E z : \E x : x \in (p \ o)   BECAUSE Q_SCHEME;
(\E z : \E x : x \in (p \ o)) => \E x : x \in (p \ o)   BECAUSE Q_SCHEME;
(\E z : z \in (p \ o)) => ~\A x : x \notin p \ o   BECAUSE TI2;
h(o,p) /\ o # p => (p \ o) # {}   BECAUSE TI2;

\* Take m the minimum of p \ o as a subset of ordinal p
h(o,p) => IsOrdinal(p)  BECAUSE S23;
IsWellOrderedByIn(x) => (\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq x => p = {} \/ \E m : IsMinimumForIn(m, p)) => (p \ o \subseteq x => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE \A(p <- p\o);
IsWellOrderedByIn(x) => (p \ o \subseteq x => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE TI;
\A x : IsWellOrderedByIn(x) => (p \ o \subseteq x => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE GENERALIZATION;
IsWellOrderedByIn(p) => (p \ o \subseteq p => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE \A(x <- p);
IsOrdinal(p) => IsWellOrderedByIn(p)   BECAUSE S22;
h(o,p) => (p \ o \subseteq p => p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE TI2;
z \in (p \ o) => (z \in p /\ z \notin o)   BECAUSE EquivToImpl;
(z \in p /\ z \notin o) => z \in p   BECAUSE S12;
z \in p \ o => z \in p   BECAUSE TI;
p \ o \subseteq p   BECAUSE GENERALIZATION;
h(o,p) => p \ o \subseteq p   BECAUSE PT1;
h(o,p) => (p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE KillMiddleHypo;
h(o,p) /\ o # p => h(o,p)   BECAUSE S12;
h(o,p) /\ o # p => (p\o = {} \/ \E m : IsMinimumForIn(m, p\o))   BECAUSE TI;
killCase(h,a,b) == (h => ~a) => ((h => a \/ b) => (h => b))   PROPO_TAUTO;
h(o,p) /\ o # p => \E m : IsMinimumForIn(m, p\o)   BECAUSE killCase;
hh(o,p,m) == h(o,p) /\ o # p /\ IsMinimumForIn(m, p\o);

\* Then show that m = o by double inclusion.
\* If x \in m, below minimum so x \in o.
hh(o,p,m) => IsMinimumForIn(m, p\o)   BECAUSE S22;
hh(o,p,m) => h(o,p)   BECAUSE S13;
IsMinimumForIn(m, p\o) => m \in p\o   BECAUSE S12;
IsMinimumForIn(m, p\o) => \A b : b \in p\o => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in p\o => (b = m \/ m \in b)) => (x \in p\o => (x = m \/ m \in x))   BECAUSE \A(b <- x);
hh(o,p,m) => (x \in p\o => (x = m \/ m \in x))   BECAUSE TI2;
hh(o,p,m) => m \in p\o   BECAUSE TI;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(p) /\ m \in p => IsOrdinal(m)   BECAUSE \A(o <- p, x <- m);
m \in (p \ o) <=> (m \in p /\ m \notin o)   BECAUSE \A(u <- p, v <- o, x <- m);
m \in (p \ o) => (m \in p /\ m \notin o)   BECAUSE EquivToImpl;
(m \in p /\ m \notin o) => m \in p   BECAUSE S12;
hh(o,p,m) => m \in p   BECAUSE TI2;
hh(o,p,m) => IsOrdinal(p)   BECAUSE TI;
hh(o,p,m) => IsOrdinal(p) /\ m \in p   BECAUSE CIA;
hh(o,p,m) => IsOrdinal(m)   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ x \in m => x # m /\ m \notin x   BECAUSE \A(o <- x, p <- m);
x \in m => x \in m   BECAUSE ImplySelf;
hh(o,p,m) /\ x \in m => IsOrdinal(m) /\ x \in m   BECAUSE MergeImplicationsAnd;
hh(o,p,m) /\ x \in m => x # m /\ m \notin x   BECAUSE TI;
x # m /\ m \notin x => ~(x = m \/ m \in x)   BECAUSE FactorNotOr;
hh(o,p,m) /\ x \in m => ~(x = m \/ m \in x)   BECAUSE TI;
hh(o,p,m) /\ x \in m => hh(o,p,m)   BECAUSE S12;
hh(o,p,m) /\ x \in m => (x \in p\o => (x = m \/ m \in x))   BECAUSE TI;
contrapos(h,a,b) == (h => ~a) => ((h => (b => a)) => (h => ~b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in m => x \notin p\o   BECAUSE contrapos;
x \in (p \ o) <=> (x \in p /\ x \notin o)   BECAUSE \A(u <- p, v <- o, x <- x);
(x \in p /\ x \notin o) => x \in (p \ o)   BECAUSE EquivToImplReverse;
x \notin (p \ o) => ~(x \in p /\ x \notin o)   BECAUSE Contraposition;
hh(o,p,m) /\ x \in m => ~(x \in p /\ x \notin o)   BECAUSE TI;
IsTransitiveSet(p) => (m \in p => m \subseteq p)   BECAUSE \A(a <- m);
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
hh(o,p,m) => (m \in p => m \subseteq p)   BECAUSE TI2;
hh(o,p,m) => m \subseteq p   BECAUSE KillMiddleHypo;
m \subseteq p => (x \in m => x \in p)   BECAUSE \A(z <- x);
hh(o,p,m) => (x \in m => x \in p)   BECAUSE TI;
hh(o,p,m) /\ x \in m => x \in p   BECAUSE HypoImplToAnd;
killCaseB(h,a,b) == (h => a) => ((h => ~(a /\ ~b)) => (h => b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in m => x \in o   BECAUSE killCaseB;

\* If x \in o, then by total order of p, x \in m.
ordinalIsTotalOrder   BECAUSE THEOREM;
IsOrdinal(p) /\ x \in p /\ m \in p => x \in m \/ x = m \/ m \in x   BECAUSE \A(o <- p, x <- x, y <- m);
hh(o,p,m) /\ x \in o => x \in o   BECAUSE S22;
o \subseteq p => (x \in o => x \in p)   BECAUSE \A(z <- x);
hh(o,p,m) => (x \in o => x \in p)   BECAUSE TI2;
hh(o,p,m) /\ x \in o => x \in p   BECAUSE HypoImplToAnd;
hh(o,p,m) /\ x \in o => hh(o,p,m)   BECAUSE S12;
hh(o,p,m) /\ x \in o => m \in p   BECAUSE TI;
hh(o,p,m) /\ x \in o => IsOrdinal(p)   BECAUSE TI;
hh(o,p,m) /\ x \in o => IsOrdinal(p) /\ x \in p   BECAUSE CIA;
hh(o,p,m) /\ x \in o => IsOrdinal(p) /\ x \in p /\ m \in p   BECAUSE CIA;
hh(o,p,m) /\ x \in o => x \in m \/ x = m \/ m \in x   BECAUSE TI;
(m \in p /\ m \notin o) => m \notin o   BECAUSE S22;
hh(o,p,m) => m \notin o   BECAUSE TI2;
\A x : \A m : x = m => (x \notin o <=> m \notin o)   BECAUSE E_SCHEME;
x = m => (x \notin o <=> m \notin o)   BECAUSE \A(x <- x, m <- m);
implyEquivTrue(a,b,h,t) == (h => t) => ((b => (~a <=> t)) => (h /\ a => ~b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in o => x # m   BECAUSE implyEquivTrue;
IsTransitiveSet(o) => (x \in o => x \subseteq o)   BECAUSE \A(a <- x);
h(o,p) => IsOrdinal(o)  BECAUSE S13;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
hh(o,p,m) => IsOrdinal(o)   BECAUSE TI;
hh(o,p,m) => (x \in o => x \subseteq o)   BECAUSE TI2;
hh(o,p,m) /\ x \in o => x \subseteq o   BECAUSE HypoImplToAnd;
x \subseteq o => (m \in x => m \in o)   BECAUSE \A(z <- m);
hh(o,p,m) /\ x \in o => (m \in x => m \in o)   BECAUSE TI;
hh(o,p,m) /\ x \in o => hh(o,p,m)   BECAUSE S12;
hh(o,p,m) /\ x \in o => m \notin o   BECAUSE TI;
killCaseC(h,a,b) == (h => ~a) => ((h => (b => a)) => (h => ~b))   PROPO_TAUTO;
hh(o,p,m) /\ x \in o => m \notin x   BECAUSE killCaseC;
killCaseD(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
hh(o,p,m) /\ x \in o => x \in m   BECAUSE killCaseD;

hIntroEquiv(h,a,b) == (h /\ a => b) => ((h /\ b => a) => (h => (a <=> b)))   PROPO_TAUTO;
hh(o,p,m) => (x \in o <=> x \in m)   BECAUSE hIntroEquiv;
\A x : hh(o,p,m) => (x \in o <=> x \in m)   BECAUSE GENERALIZATION;
hh(o,p,m) => (\A x : x \in o <=> x \in m)   BECAUSE Q_SCHEME;
extensionality   BECAUSE AXIOM;
(\A x : x \in o <=> x \in m) => o = m   BECAUSE \A(a <- o, b <- m);
hh(o,p,m) => o = m   BECAUSE TI;
\A o : \A m : o = m => (o \in p <=> m \in p)   BECAUSE E_SCHEME;
o = m => (o \in p <=> m \in p)   BECAUSE \A(o <- o, m <- m);
hh(o,p,m) => (o \in p <=> m \in p)   BECAUSE TI;
killCaseE(h,a,t) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hh(o,p,m) => o \in p   BECAUSE killCaseE;
h(o,p) /\ o # p => (IsMinimumForIn(m, p\o) => o \in p)   BECAUSE HypoAndToImpl;
\A m : h(o,p) /\ o # p => (IsMinimumForIn(m, p\o) => o \in p)   BECAUSE GENERALIZATION;
h(o,p) /\ o # p => (\A m : IsMinimumForIn(m, p\o) => o \in p)   BECAUSE Q_SCHEME;
(\A m : IsMinimumForIn(m, p\o) => o \in p) => ((\E m : IsMinimumForIn(m, p\o)) => \E m : o \in p)   BECAUSE Q_SCHEME;
h(o,p) /\ o # p => ((\E m : IsMinimumForIn(m, p\o)) => \E m : o \in p)   BECAUSE TI;
h(o,p) /\ o # p => \E m : o \in p   BECAUSE KillMiddleHypo;
(\E m : o \in p) => o \in p   BECAUSE Q_SCHEME;
h(o,p) /\ o # p => o \in p   BECAUSE TI;
boolImplB(h,a,b) == (h /\ ~a => b) => (h => b \/ a)   PROPO_TAUTO;
h(o,p) => o \in p \/ o = p   BECAUSE boolImplB;
includedOrdinals   BECAUSE GENERALIZATION;
QED

ordinalComparison == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p)
   => o \in p \/ o = p \/ p \in o
THEOREM ordinalComparison
PROOF
VARIABLES a,c,d,o,p,u,x,y;
includedOrdinals   BECAUSE THEOREM;
\* o \intersect p is an ordinal included in both o and p
\* By the previous theorem, either (o \intersect p) \in o or (o \intersect p) = o
\* Same (o \intersect p) \in p or (o \intersect p) = p
\* But both \in would yield (o \intersect p) \in (o \intersect p), absurd
QED

unionOrdinalsIsOrdinal == \A u : (\A x : x \in u => IsOrdinal(x)) => IsOrdinal(UNION u)
THEOREM unionOrdinalsIsOrdinal
PROOF
VARIABLES a,b,c,o,p,q,u,v,x,y,z;
h(u) == \A x : x \in u => IsOrdinal(x);
\* Proof that UNION u is transitive
unionExists   BECAUSE AXIOM;
(a \in UNION u <=> \E t : t \in u /\ a \in t)   BECAUSE \A(b <- u, z <- a);
a \in UNION u => \E t : t \in u /\ a \in t   BECAUSE EquivToImpl;
ct(a,u) == CHOOSE t : t \in u /\ a \in t;
(\E t : t \in u /\ a \in t) => ct(a,u) \in u /\ a \in ct(a,u)   BECAUSE CHOOSE ct(a,u);
a \in UNION u => ct(a,u) \in u /\ a \in ct(a,u)   BECAUSE TI;
ht(a,u) == h(u) /\ a \in UNION u;
ht(a,u) => h(u)   BECAUSE S12;
ht(a,u) => a \in UNION u   BECAUSE S22;
ct(a,u) \in u /\ a \in ct(a,u) => ct(a,u) \in u   BECAUSE S12;
ht(a,u) => ct(a,u) \in u   BECAUSE TI2;
h(u) => (ct(a,u) \in u => IsOrdinal(ct(a,u)))   BECAUSE \A(x <- ct(a,u));
ht(a,u) => (ct(a,u) \in u => IsOrdinal(ct(a,u)))   BECAUSE TI;
ht(a,u) => IsOrdinal(ct(a,u))   BECAUSE KillMiddleHypo;
IsOrdinal(ct(a,u)) => IsTransitiveSet(ct(a,u))   BECAUSE S12;
IsTransitiveSet(x) => (a \in x => a \subseteq x)  BECAUSE \A(a <- a);
\A x : IsTransitiveSet(x) => (a \in x => a \subseteq x)  BECAUSE GENERALIZATION;
IsTransitiveSet(ct(a,u)) => (a \in ct(a,u) => a \subseteq ct(a,u))  BECAUSE \A(x <- ct(a,u));
ht(a,u) => (a \in ct(a,u) => a \subseteq ct(a,u))   BECAUSE TI2;
ct(a,u) \in u /\ a \in ct(a,u) => a \in ct(a,u)   BECAUSE S22;
ht(a,u) => a \in ct(a,u)   BECAUSE TI2;
ht(a,u) => a \subseteq ct(a,u)   BECAUSE KillMiddleHypo;
a \subseteq ct(a,u) => (z \in a => z \in ct(a,u))   BECAUSE \A(z <- z);
ht(a,u) => (z \in a => z \in ct(a,u))   BECAUSE TI;
ht(a,u) /\ z \in a => z \in ct(a,u)   BECAUSE HypoImplToAnd;
inInUnion   BECAUSE THEOREM;
z \in ct(a,u) /\ ct(a,u) \in u => z \in UNION u   BECAUSE \A(a <- z, b <- ct(a,u), c <- u);
ht(a,u) /\ z \in a => ht(a,u)   BECAUSE S12;
ht(a,u) /\ z \in a => ct(a,u) \in u   BECAUSE TI;
ht(a,u) /\ z \in a => z \in ct(a,u) /\ ct(a,u) \in u   BECAUSE CIA;
ht(a,u) /\ z \in a => z \in UNION u   BECAUSE TI;
ht(a,u) => (z \in a => z \in UNION u)   BECAUSE HypoAndToImpl;
\A z : ht(a,u) => (z \in a => z \in UNION u)   BECAUSE GENERALIZATION;
ht(a,u) => a \subseteq UNION u   BECAUSE Q_SCHEME;
h(u) => (a \in UNION u => a \subseteq UNION u)   BECAUSE HypoAndToImpl;
\A a : h(u) => (a \in UNION u => a \subseteq UNION u)   BECAUSE GENERALIZATION;
h(u) => IsTransitiveSet(UNION u)   BECAUSE Q_SCHEME;

\* Proof that UNION u is irreflexive
IsWellOrderedByIn(x) => (\A a : a \in x => a \notin a)   BECAUSE S13;
(\A a : a \in x => a \notin a) => (a \in x => a \notin a)   BECAUSE \A(a <- a);
IsWellOrderedByIn(x) => (a \in x => a \notin a)   BECAUSE TI;
\A x : IsWellOrderedByIn(x) => (a \in x => a \notin a)   BECAUSE GENERALIZATION;
IsWellOrderedByIn(ct(a,u)) => (a \in ct(a,u) => a \notin a)   BECAUSE \A(x <- ct(a,u));
IsOrdinal(ct(a,u)) => IsWellOrderedByIn(ct(a,u))   BECAUSE S22;
ht(a,u) => (a \in ct(a,u) => a \notin a)   BECAUSE TI2;
ht(a,u) => a \notin a   BECAUSE KillMiddleHypo;
h(u) => (a \in UNION u => a \notin a)   BECAUSE HypoAndToImpl;
\A a : h(u) => (a \in UNION u => a \notin a)   BECAUSE GENERALIZATION;
h(u) => (\A a : a \in UNION u => a \notin a)   BECAUSE Q_SCHEME;

\* Proof that \in is transitive on UNION u
\A a : ht(a,u) => IsOrdinal(ct(a,u))   BECAUSE GENERALIZATION;
ht(c,u) => IsOrdinal(ct(c,u))   BECAUSE \A(a <- c);
\A a : ht(a,u) => a \in ct(a,u)   BECAUSE GENERALIZATION;
ht(c,u) => c \in ct(c,u)   BECAUSE \A(a <- c);
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(ct(c,u)) /\ c \in ct(c,u) => IsOrdinal(c)   BECAUSE \A(o <- ct(c,u), x <- c);
ht(c,u) => IsOrdinal(ct(c,u)) /\ c \in ct(c,u)   BECAUSE CIA;
ht(c,u) => IsOrdinal(c)   BECAUSE TI;
IsOrdinal(c) => IsTransitiveSet(c)   BECAUSE S12;
IsTransitiveSet(c) => (b \in c => b \subseteq c)   BECAUSE \A(a <- b);
ht(c,u) => (b \in c => b \subseteq c)   BECAUSE TI2;
ht(c,u) /\ b \in c => b \subseteq c   BECAUSE HypoImplToAnd;
b \subseteq c => (a \in b => a \in c)   BECAUSE \A(z <- a);
ht(c,u) /\ b \in c => (a \in b => a \in c)  BECAUSE TI;
ht(c,u) /\ b \in c /\ a \in b => a \in c  BECAUSE HypoImplToAnd;
shuffleHypos(a,c,d,e,h) == h /\ (a /\ c /\ d /\ e) => h /\ c /\ e /\ d   PROPO_TAUTO;
h(u) /\ (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c)
   => ht(c,u) /\ b \in c /\ a \in b   BECAUSE shuffleHypos;
h(u) /\ (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c)
   => a \in c   BECAUSE TI;
h(u) => (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE HypoAndToImpl;
\A c : h(u) => (a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(u) => (\A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A b : h(u) => (\A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(u) => (\A b : \A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE Q_SCHEME;
\A a : h(u) => (\A b : \A c : a \in UNION u /\ b \in UNION u /\ c \in UNION u /\ a \in b /\ b \in c => a \in c)   BECAUSE GENERALIZATION;
h(u) => IsTransitiveIn(UNION u)   BECAUSE Q_SCHEME;

\* Proof that \in is a total strict order on UNION u
htot(u,x,y) == h(u) /\ x \in UNION u /\ y \in UNION u;

htot(u,x,y) => x \in y \/ x = y \/ y \in x   BECAUSE TI;

\* Proof that minimums exist
hm(p,u) == h(u) /\ p \subseteq (UNION u) /\ p # {};
hm(p,u) => h(u)   BECAUSE S13;
hm(p,u) => p # {}   BECAUSE S22;
hm(p,u) => p \subseteq (UNION u)   BECAUSE S23;
notEmpty   BECAUSE THEOREM;
p # {} => \E z : z \in p   BECAUSE \A(x <- p);
cp(p) == CHOOSE z : z \in p; \* it is in one the ordinals of u, which minimum we will take
(\E z : z \in p) => cp(p) \in p   BECAUSE CHOOSE cp(p);
hm(p,u) => cp(p) \in p   BECAUSE TI2;
p \subseteq (UNION u) => (cp(p) \in p => cp(p) \in UNION u)   BECAUSE \A(z <- cp(p));
hm(p,u) => (cp(p) \in p => cp(p) \in UNION u)   BECAUSE TI;
hm(p,u) => cp(p) \in UNION u   BECAUSE KillMiddleHypo;
cp(p) \in UNION u <=> \E t : t \in u /\ cp(p) \in t   BECAUSE \A(b <- u, z <- cp(p));
cp(p) \in UNION u => \E t : t \in u /\ cp(p) \in t   BECAUSE EquivToImpl;
(\E t : t \in u /\ cp(p) \in t) => ct(cp(p),u) \in u /\ cp(p) \in ct(cp(p),u)   BECAUSE CHOOSE ct(cp(p),u);
hm(p,u) => ct(cp(p),u) \in u /\ cp(p) \in ct(cp(p),u)   BECAUSE TI2;
ct(cp(p),u) \in u /\ cp(p) \in ct(cp(p),u) => ct(cp(p),u) \in u   BECAUSE S12;
hm(p,u) => ct(cp(p),u) \in u   BECAUSE TI;
h(u) => (ct(cp(p),u) \in u => IsOrdinal(ct(cp(p),u)))   BECAUSE \A(x <- ct(cp(p),u));
hm(p,u) => (ct(cp(p),u) \in u => IsOrdinal(ct(cp(p),u)))   BECAUSE TI;
hm(p,u) => IsOrdinal(ct(cp(p),u))   BECAUSE KillMiddleHypo; \* Take the minimum of p in this ordinal
IsWellOrderedByIn(ct(cp(z),u)) => (\A p : p \subseteq ct(cp(z),u) => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq ct(cp(z),u) => p = {} \/ \E m : IsMinimumForIn(m, p)) => (q \subseteq ct(cp(z),u) => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE \A(p <- q);
IsWellOrderedByIn(ct(cp(z),u)) => (q \subseteq ct(cp(z),u) => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE TI;
\A z : IsWellOrderedByIn(ct(cp(z),u)) => (q \subseteq ct(cp(z),u) => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE GENERALIZATION;
IsWellOrderedByIn(ct(cp(p),u)) => (q \subseteq ct(cp(p),u) => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE \A(z <- p);
IsOrdinal(ct(cp(p),u)) => IsWellOrderedByIn(ct(cp(p),u))   BECAUSE S22;
hm(p,u) => (q \subseteq ct(cp(p),u) => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE TI2; \* take q = p \intersect ct(cp(p),u)
\A q : hm(p,u) => (q \subseteq ct(cp(p),u) => q = {} \/ \E m : IsMinimumForIn(m, q))   BECAUSE GENERALIZATION;
hm(p,u) => ((p \intersect ct(cp(p),u)) \subseteq ct(cp(p),u) => (p \intersect ct(cp(p),u)) = {} \/ \E m : IsMinimumForIn(m, p \intersect ct(cp(p),u)))   BECAUSE \A(q <- p \intersect ct(cp(p),u));
intersectIncludes   BECAUSE THEOREM;
(p \intersect ct(cp(p),u)) \subseteq ct(cp(p),u)   BECAUSE \A(a <- p, b <- ct(cp(p),u));
hm(p,u) => (p \intersect ct(cp(p),u)) \subseteq ct(cp(p),u)   BECAUSE PT1;
hm(p,u) => (p \intersect ct(cp(p),u)) = {} \/ \E m : IsMinimumForIn(m, p \intersect ct(cp(p),u))   BECAUSE KillMiddleHypo;
emptySetExistsUniquely   BECAUSE THEOREM;
(p \intersect ct(cp(p),u)) = {} <=> \A x : x \notin (p \intersect ct(cp(p),u))   BECAUSE \A(c <- p \intersect ct(cp(p),u));
(p \intersect ct(cp(p),u)) = {} => \A x : x \notin (p \intersect ct(cp(p),u))   BECAUSE EquivToImpl;
(\A x : x \notin (p \intersect ct(cp(p),u))) => cp(p) \notin (p \intersect ct(cp(p),u))   BECAUSE \A(x <- cp(p));
(p \intersect ct(cp(p),u)) = {} => cp(p) \notin (p \intersect ct(cp(p),u))   BECAUSE TI;
~(cp(p) \notin (p \intersect ct(cp(p),u))) => (p \intersect ct(cp(p),u)) # {}   BECAUSE Contraposition;
ct(cp(p),u) \in u /\ cp(p) \in ct(cp(p),u) => cp(p) \in ct(cp(p),u)   BECAUSE S22;
hm(p,u) => cp(p) \in ct(cp(p),u)   BECAUSE TI;
hm(p,u) => cp(p) \in p /\ cp(p) \in ct(cp(p),u)   BECAUSE CIA;
intersectionExists   BECAUSE THEOREM;
cp(p) \in (p \intersect ct(cp(p),u)) <=> (cp(p) \in p /\ cp(p) \in ct(cp(p),u))   BECAUSE \A(u <- p, v <- ct(cp(p),u), x <- cp(p));
(cp(p) \in p /\ cp(p) \in ct(cp(p),u)) => cp(p) \in (p \intersect ct(cp(p),u))   BECAUSE EquivToImplReverse;
cp(p) \in (p \intersect ct(cp(p),u)) => ~(cp(p) \notin (p \intersect ct(cp(p),u)))   BECAUSE IntroNotNot;
hm(p,u) => ~(cp(p) \notin (p \intersect ct(cp(p),u)))   BECAUSE TI2;
hm(p,u) => (p \intersect ct(cp(p),u)) # {}   BECAUSE TI;
killCase(a,b,h) == (h => ~a) => ((h => a \/ b) => (h => b))   PROPO_TAUTO;
hm(p,u) => \E m : IsMinimumForIn(m, p \intersect ct(cp(p),u))   BECAUSE killCase; \* Show that this minimum works for all UNION u
cm(p,u) == CHOOSE m : IsMinimumForIn(m, p \intersect ct(cp(p),u));
(\E m : IsMinimumForIn(m, p \intersect ct(cp(p),u))) => IsMinimumForIn(cm(p,u), p \intersect ct(cp(p),u))   BECAUSE CHOOSE cm(p,u);
IsMinimumForIn(cm(p,u), p \intersect ct(cp(p),u)) => cm(p,u) \in (p \intersect ct(cp(p),u))   BECAUSE S12;
hm(p,u) => cm(p,u) \in (p \intersect ct(cp(p),u))   BECAUSE TI2;
cm(p,u) \in (p \intersect ct(cp(p),u)) <=> (cm(p,u) \in p /\ cm(p,u) \in ct(cp(p),u))   BECAUSE \A(u <- p, v <- ct(cp(p),u), x <- cm(p,u));
cm(p,u) \in (p \intersect ct(cp(p),u)) => (cm(p,u) \in p /\ cm(p,u) \in ct(cp(p),u))   BECAUSE EquivToImpl;
(cm(p,u) \in p /\ cm(p,u) \in ct(cp(p),u)) => cm(p,u) \in ct(cp(p),u)   BECAUSE S22;
(cm(p,u) \in p /\ cm(p,u) \in ct(cp(p),u)) => cm(p,u) \in p   BECAUSE S12;
hm(p,u) => cm(p,u) \in p   BECAUSE TI2; \* First condition for IsMinimumForIn(cm(p,u), p)
hm(p,u) => cm(p,u) \in ct(cp(p),u)   BECAUSE TI2;

htot(u,x,cm(p,u)) => x \in cm(p,u) \/ x = cm(p,u) \/ cm(p,u) \in x   BECAUSE TI;
\* TODO first case impossible : if there was an x \in cm(p,u) and \in p,
\* then x \in ct(cp(p),u) by transitivity of ct(cp(p),u),
\* that x would be in p \intersect ct(cp(p),u), contradicting the minimality of cm(p,u)

\* IsMinimumForIn(m, p) == m \in p /\ \A b : b \in p => (b = m \/ m \in b)

h(u) => IsOrdinal(UNION u)   BECAUSE TI;
unionOrdinalsIsOrdinal   BECAUSE GENERALIZATION;
QED

\* The only increasing bijection between two ordinals is the identity function.
\* Which means two ordinals in increasing bijection are equal.
bijectOrdinalsEqual == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p)
        /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   => o = p
THEOREM bijectOrdinalsEqual
PROOF
VARIABLES a,b,d,f,g,i,o,p,x,y,z;
\* If f is not the identity, there is a minimum element m(o,p) such that
\* f[m(o,p)] # m(o,p). But then we will show that m(o,p) \in p and
\* f doesn't reach it, contradicting f is bijection.
cf(o,p) == CHOOSE f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y];
\* By separation, take the subset of o where cf[x] # x
\A a : \E b : \A x : x \in b <=> x \in a /\ cf(o,p)[x] # x   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in o /\ cf(o,p)[x] # x   BECAUSE \A(a <- o);
cb(o,p) == CHOOSE b : \A x : x \in b <=> x \in o /\ cf(o,p)[x] # x;
\A x : x \in cb(o,p) <=> x \in o /\ cf(o,p)[x] # x   BECAUSE CHOOSE cb(o,p);
cm(o,p) == CHOOSE m : IsMinimumForIn(m, cb(o,p)); \* we will show that m does not exist
IsMinimumForIn(cm(o,p), cb(o,p)) => cm(o,p) \in cb(o,p)   BECAUSE S12;
cm(o,p) \in cb(o,p) <=> cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE \A(x <- cm(o,p));
cm(o,p) \in cb(o,p) => cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE EquivToImpl;
cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p) => cm(o,p) \in o   BECAUSE S12;
cm(o,p) \in cb(o,p) => cm(o,p) \in o   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => cm(o,p) \in o   BECAUSE TI;
\* The hypotheses and all their implications. Prove that h(o,p) is false,
\* in other words ~IsMinimumForIn(cm(o,p), cb(o,p)).
h(o,p) == IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p)
        /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   /\ IsMinimumForIn(cm(o,p), cb(o,p));
h(o,p) => h(o,p)   BECAUSE ImplySelf;
h(o,p) => IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE S22;
h(o,p) => IsOrdinal(o) /\ IsOrdinal(p)   BECAUSE S13;
IsOrdinal(o) /\ IsOrdinal(p) => IsOrdinal(p)   BECAUSE S22;
h(o,p) => IsOrdinal(p)   BECAUSE TI;
IsOrdinal(o) /\ IsOrdinal(p) => IsOrdinal(o)   BECAUSE S12;
h(o,p) => IsOrdinal(o)   BECAUSE TI;
h(o,p) => (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])   BECAUSE S23;
(\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])
   => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE CHOOSE cf(o,p);
h(o,p) => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE TI;
(cf(o,p) \in Bijections(o,p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => cf(o,p) \in Bijections(o,p)   BECAUSE S12;
h(o,p) => cf(o,p) \in Bijections(o,p)   BECAUSE TI;
(cf(o,p) \in Bijections(o,p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]   BECAUSE S22;
h(o,p) => \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]   BECAUSE TI;

\* Proof that h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z
\* (z is below the minimum cm(o,p), so doesn't have its defining property)
h(o,p) => cm(o,p) \in o   BECAUSE TI;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(o) /\ cm(o,p) \in o => IsOrdinal(cm(o,p))   BECAUSE \A(o <- o, x <- cm(o,p));
h(o,p) => IsOrdinal(o) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => IsOrdinal(cm(o,p))   BECAUSE TI;
bijApply   BECAUSE THEOREM;
(cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in o) => cf(o,p)[cm(o,p)] \in p
   BECAUSE \A(f <- cf(o,p), a <- o, b <- p, x <- cm(o,p));
h(o,p) => cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => cf(o,p)[cm(o,p)] \in p   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => \A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)   BECAUSE S22;
h(o,p) => \A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)   BECAUSE TI;
(\A b : b \in cb(o,p) => (b = cm(o,p) \/ cm(o,p) \in b)) => (z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z))
   BECAUSE \A(b <- z);
h(o,p) => (z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z))   BECAUSE TI;
h(o,p) /\ z \in cb(o,p) => (z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE HypoImplToAnd;
~(z = cm(o,p) \/ cm(o,p) \in z) => ~(h(o,p) /\ z \in cb(o,p))   BECAUSE Contraposition;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) /\ z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z   BECAUSE \A(o <- z, p <- cm(o,p));
IsOrdinal(cm(o,p)) => (z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z)   BECAUSE HypoAndToImpl;
h(o,p) => (z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z)   BECAUSE TI;
z # cm(o,p) /\ cm(o,p) \notin z => ~(z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE FactorNotOr;
h(o,p) /\ z \in cm(o,p) => z # cm(o,p) /\ cm(o,p) \notin z   BECAUSE HypoImplToAnd;
h(o,p) /\ z \in cm(o,p) => ~(z = cm(o,p) \/ cm(o,p) \in z)   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => ~(h(o,p) /\ z \in cb(o,p))   BECAUSE TI;
killCase(a,b,c) == (a /\ b => ~(a /\ c)) => (a /\ b => ~c)   PROPO_TAUTO;
h(o,p) /\ z \in cm(o,p) => z \notin cb(o,p)   BECAUSE killCase;
z \in cb(o,p) <=> z \in o /\ cf(o,p)[z] # z   BECAUSE \A(x <- z);
z \in o /\ cf(o,p)[z] # z => z \in cb(o,p)   BECAUSE EquivToImplReverse;
z \notin cb(o,p) => ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE Contraposition;
h(o,p) /\ z \in cm(o,p) => ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE TI;
IsOrdinal(o) => IsTransitiveSet(o)   BECAUSE S12;
IsTransitiveSet(o) => (cm(o,p) \in o => cm(o,p) \subseteq o)   BECAUSE \A(a <- cm(o,p));
IsTransitiveSet(o) /\ cm(o,p) \in o => cm(o,p) \subseteq o   BECAUSE HypoImplToAnd;
h(o,p) => IsTransitiveSet(o)   BECAUSE TI;
h(o,p) => IsTransitiveSet(o) /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => cm(o,p) \subseteq o   BECAUSE TI;
cm(o,p) \subseteq o => (z \in cm(o,p) => z \in o)   BECAUSE \A(z <- z);
h(o,p) => (z \in cm(o,p) => z \in o)   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => z \in o   BECAUSE HypoImplToAnd;
h(o,p) /\ z \in cm(o,p) => z \in o /\ ~(z \in o /\ cf(o,p)[z] # z)   BECAUSE CIA;
killCaseB(a,b) == a /\ ~(a /\ ~b) => b   PROPO_TAUTO;
z \in o /\ ~(z \in o /\ cf(o,p)[z] # z) => cf(o,p)[z] = z   BECAUSE killCaseB;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z   BECAUSE TI;

\* Proof that cm(o,p) \subseteq cf(o,p)[cm(o,p)]
(\A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])
   => (z \in cm(o,p) /\ cm(o,p) \in o => cf(o,p)[z] \in cf(o,p)[cm(o,p)])   BECAUSE \A(x <- z, y <- cm(o,p));
h(o,p) => (z \in cm(o,p) /\ cm(o,p) \in o => cf(o,p)[z] \in cf(o,p)[cm(o,p)])   BECAUSE TI;
h(o,p) /\ (z \in cm(o,p) /\ cm(o,p) \in o) => cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE HypoImplToAnd;
pushHypo(a,b,c) == (a => c) => (a /\ b => a /\ (b /\ c))   PROPO_TAUTO;
h(o,p) /\ z \in cm(o,p) => h(o,p) /\ (z \in cm(o,p) /\ cm(o,p) \in o)   BECAUSE pushHypo;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z /\ cf(o,p)[z] \in cf(o,p)[cm(o,p)]   BECAUSE CIA;
\A y : \A z : y = z => (y \in cf(o,p)[cm(o,p)] <=> z \in cf(o,p)[cm(o,p)])   BECAUSE E_SCHEME;
cf(o,p)[z] = z => (cf(o,p)[z] \in cf(o,p)[cm(o,p)] <=> z \in cf(o,p)[cm(o,p)])   BECAUSE \A(y <- cf(o,p)[z], z <- z);
cf(o,p)[z] = z /\ cf(o,p)[z] \in cf(o,p)[cm(o,p)] => z \in cf(o,p)[cm(o,p)]   BECAUSE HypoEquivToAnd;
h(o,p) /\ z \in cm(o,p) => z \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) => (z \in cm(o,p) => z \in cf(o,p)[cm(o,p)])   BECAUSE HypoAndToImpl;
\A z : h(o,p) => (z \in cm(o,p) => z \in cf(o,p)[cm(o,p)])   BECAUSE GENERALIZATION;
h(o,p) => cm(o,p) \subseteq cf(o,p)[cm(o,p)]   BECAUSE Q_SCHEME;

\* Proof that h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)] \in p. By ordinal comparison,
\* cm(o,p) \subseteq cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)] \/ cm(o,p) \in cf(o,p)[cm(o,p)],
\* and since f[m] # m we have the other case.
includedOrdinals   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)]) /\ cm(o,p) \subseteq cf(o,p)[cm(o,p)]
   => cm(o,p) \in cf(o,p)[cm(o,p)] \/ cm(o,p) = cf(o,p)[cm(o,p)]
   BECAUSE \A(o <- cm(o,p), p <- cf(o,p)[cm(o,p)]);
IsOrdinal(p) /\ cf(o,p)[cm(o,p)] \in p => IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE \A(o <- p, x <- cf(o,p)[cm(o,p)]);
h(o,p) => IsOrdinal(p) /\ cf(o,p)[cm(o,p)] \in p   BECAUSE CIA;
h(o,p) => IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE TI;
h(o,p) => IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)])   BECAUSE CIA;
h(o,p) => IsOrdinal(cm(o,p)) /\ IsOrdinal(cf(o,p)[cm(o,p)]) /\ cm(o,p) \subseteq cf(o,p)[cm(o,p)]   BECAUSE CIA;
h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)] \/ cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE TI;
cm(o,p) \in o /\ cf(o,p)[cm(o,p)] # cm(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE S22;
cm(o,p) \in cb(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
IsMinimumForIn(cm(o,p), cb(o,p)) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
h(o,p) => cf(o,p)[cm(o,p)] # cm(o,p)   BECAUSE TI;
cm(o,p) = cf(o,p)[cm(o,p)] => cf(o,p)[cm(o,p)] = cm(o,p)   BECAUSE E_SCHEME;
cf(o,p)[cm(o,p)] # cm(o,p) => cm(o,p) # cf(o,p)[cm(o,p)]   BECAUSE Contraposition;
h(o,p) => cm(o,p) # cf(o,p)[cm(o,p)]   BECAUSE TI;
killCaseC(a,b,c) == (a => ~b) => ((a => (c \/ b)) => (a => c))   PROPO_TAUTO;
h(o,p) => cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE killCaseC;
IsOrdinal(p) => IsTransitiveSet(p)   BECAUSE S12;
IsTransitiveSet(p) => (cf(o,p)[cm(o,p)] \in p => cf(o,p)[cm(o,p)] \subseteq p)   BECAUSE \A(a <- cf(o,p)[cm(o,p)]);
IsTransitiveSet(p) /\ cf(o,p)[cm(o,p)] \in p => cf(o,p)[cm(o,p)] \subseteq p   BECAUSE HypoImplToAnd;
h(o,p) => IsTransitiveSet(p)   BECAUSE TI;
h(o,p) => IsTransitiveSet(p) /\ cf(o,p)[cm(o,p)] \in p   BECAUSE CIA;
h(o,p) => cf(o,p)[cm(o,p)] \subseteq p   BECAUSE TI;
cf(o,p)[cm(o,p)] \subseteq p => (cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p)   BECAUSE \A(z <- cm(o,p));
h(o,p) => (cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in cf(o,p)[cm(o,p)] => cm(o,p) \in p   BECAUSE HypoImplToAnd;
h(o,p) => h(o,p) /\ cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE CIA;
h(o,p) => cm(o,p) \in p   BECAUSE TI;

\* Proof that f doesn't reach m, which contradicts that
\* f is a bijection. There are 3 cases :
\*    - z \in m => f[z] = z # m
\*    - f[m] # m
\*    - m \in z => m \in f[m] \in f[z]
bijPreApply   BECAUSE THEOREM;
(cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in p) => pre(cf(o,p),cm(o,p)) \in o
   BECAUSE \A(f <- cf(o,p), a <- o, b <- p, y <- cm(o,p));
h(o,p) => (cf(o,p) \in Bijections(o,p) /\ cm(o,p) \in p)   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \in o   BECAUSE TI;
ordinalIsTotalOrder   BECAUSE THEOREM;
IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o /\ cm(o,p) \in o
   => pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))
   BECAUSE \A(o <- o, x <- pre(cf(o,p),cm(o,p)), y <- cm(o,p));
h(o,p) => IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o   BECAUSE CIA;
h(o,p) => IsOrdinal(o) /\ pre(cf(o,p),cm(o,p)) \in o /\ cm(o,p) \in o   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))
   BECAUSE TI;
funcInversePre   BECAUSE THEOREM;
IsFunction(cf(o,p)) /\ cm(o,p) \in Image(cf(o,p)) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)
   BECAUSE \A(f <- cf(o,p), y <- cm(o,p));
bijectionsExists   BECAUSE THEOREM;
cf(o,p) \in Bijections(o,p) <=> IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p   BECAUSE \A(d <- o, i <- p, f <- cf(o,p));
cf(o,p) \in Bijections(o,p) => IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p   BECAUSE EquivToImpl;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => IsInjection(cf(o,p))   BECAUSE S13;
cf(o,p) \in Bijections(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) => IsFunction(cf(o,p))   BECAUSE S12;
h(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
h(o,p) => IsFunction(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Image(cf(o,p)) = p   BECAUSE S22;
cf(o,p) \in Bijections(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
h(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
\A x : \A y : x = y => (cm(o,p) \in x <=> cm(o,p) \in y)   BECAUSE E_SCHEME;
Image(cf(o,p)) = p => (cm(o,p) \in Image(cf(o,p)) <=> cm(o,p) \in p)   BECAUSE \A(x <- Image(cf(o,p)), y <- p);
h(o,p) => (cm(o,p) \in Image(cf(o,p)) <=> cm(o,p) \in p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in p => cm(o,p) \in Image(cf(o,p))   BECAUSE HypoEquivToAndReverse;
h(o,p) => h(o,p) /\ cm(o,p) \in p   BECAUSE CIA;
h(o,p) => cm(o,p) \in Image(cf(o,p))   BECAUSE TI;
h(o,p) => IsFunction(cf(o,p)) /\ cm(o,p) \in Image(cf(o,p))   BECAUSE CIA;
h(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)   BECAUSE TI;
\* First case
\A z : h(o,p) /\ z \in cm(o,p) => cf(o,p)[z] = z   BECAUSE GENERALIZATION;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)
   => cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))   BECAUSE \A(z <- pre(cf(o,p),cm(o,p)));
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => h(o,p)   BECAUSE S12;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p)   BECAUSE TI;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)
   => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))   BECAUSE CIA;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = pre(cf(o,p),cm(o,p))
   => cm(o,p) = pre(cf(o,p),cm(o,p))   BECAUSE E_SCHEME;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) = pre(cf(o,p),cm(o,p))   BECAUSE TI;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => pre(cf(o,p),cm(o,p)) \in cm(o,p)   BECAUSE S22;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) = pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p)   BECAUSE CIA;
\A x : \A y : x = y => (x \in cm(o,p) <=> y \in cm(o,p))   BECAUSE E_SCHEME;
cm(o,p) = pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cm(o,p) <=> pre(cf(o,p),cm(o,p)) \in cm(o,p))   BECAUSE \A(x <- cm(o,p), y <- pre(cf(o,p),cm(o,p)));
cm(o,p) = pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) \in cm(o,p)   BECAUSE HypoEquivToAndReverse;
h(o,p) /\ pre(cf(o,p),cm(o,p)) \in cm(o,p) => cm(o,p) \in cm(o,p)   BECAUSE TI;
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(cm(o,p)) => cm(o,p) \notin cm(o,p)   BECAUSE \A(o <- cm(o,p));
h(o,p) => cm(o,p) \notin cm(o,p)   BECAUSE TI;
killCaseD(h,a,b) == (h => ~a) => ((h /\ b => a) => (h => ~b))   PROPO_TAUTO;
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p)   BECAUSE killCaseD;
\* Second case
\A x : \A y : x = y => (cf(o,p)[x] = cf(o,p)[y])   BECAUSE E_SCHEME;
pre(cf(o,p),cm(o,p)) = cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)]   BECAUSE \A(x <- pre(cf(o,p),cm(o,p)), y <- cm(o,p));
h(o,p) /\ pre(cf(o,p),cm(o,p)) = cm(o,p) => cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)]   BECAUSE MergeImplicationsAnd;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) /\ cf(o,p)[pre(cf(o,p),cm(o,p))] = cf(o,p)[cm(o,p)] => cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE E_SCHEME;
h(o,p) /\ pre(cf(o,p),cm(o,p)) = cm(o,p) => cm(o,p) = cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) => pre(cf(o,p),cm(o,p)) # cm(o,p)   BECAUSE killCaseD;
\* Third case
(\A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])
   => (cm(o,p) \in pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in o => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))])   BECAUSE \A(x <- cm(o,p), y <- pre(cf(o,p),cm(o,p)));
h(o,p) => (cm(o,p) \in pre(cf(o,p),cm(o,p)) /\ pre(cf(o,p),cm(o,p)) \in o => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))])   BECAUSE TI;
killCaseE(h,a,b,c) == (h => b) => ((h => (a /\ b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))]   BECAUSE killCaseE;
\A x : \A y : x = y => (cf(o,p)[cm(o,p)] \in x <=> cf(o,p)[cm(o,p)] \in y)   BECAUSE E_SCHEME;
cf(o,p)[pre(cf(o,p),cm(o,p))] = cm(o,p) => (cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] <=> cf(o,p)[cm(o,p)] \in cm(o,p))   BECAUSE \A(x <- cf(o,p)[pre(cf(o,p),cm(o,p))], y <- cm(o,p));
h(o,p) => (cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] <=> cf(o,p)[cm(o,p)] \in cm(o,p))   BECAUSE TI;
h(o,p) /\ cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))] => cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE HypoEquivToAnd;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => h(o,p)   BECAUSE S12;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => h(o,p) /\ cf(o,p)[cm(o,p)] \in cf(o,p)[pre(cf(o,p),cm(o,p))]   BECAUSE CIA;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cf(o,p)[cm(o,p)]   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)   BECAUSE CIA;
IsOrdinal(cm(o,p)) => IsTransitiveSet(cm(o,p))   BECAUSE S12;
IsTransitiveSet(cm(o,p)) => (a \in cm(o,p) => a \subseteq cm(o,p))   BECAUSE \A(a <- a);
h(o,p) => IsTransitiveSet(cm(o,p))   BECAUSE TI;
h(o,p) => (a \in cm(o,p) => a \subseteq cm(o,p))   BECAUSE TI;
h(o,p) /\ a \in cm(o,p) => a \subseteq cm(o,p)   BECAUSE HypoImplToAnd;
a \subseteq cm(o,p) => (cm(o,p) \in a => cm(o,p) \in cm(o,p))   BECAUSE \A(z <- cm(o,p));
h(o,p) /\ a \in cm(o,p) => (cm(o,p) \in a => cm(o,p) \in cm(o,p))   BECAUSE TI;
switchImpl(a,b,c,h) == (h /\ a => (b => c)) => (h => (b /\ a => c))   PROPO_TAUTO;
h(o,p) => (cm(o,p) \in a /\ a \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE switchImpl;
\A a : h(o,p) => (cm(o,p) \in a /\ a \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE GENERALIZATION;
h(o,p) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE \A(a <- cf(o,p)[cm(o,p)]);
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE TI;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)) /\ (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p))   BECAUSE CIA;
andMP(a,b) == (a /\ (a => b)) => b   PROPO_TAUTO;
(cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p)) /\ (cm(o,p) \in cf(o,p)[cm(o,p)] /\ cf(o,p)[cm(o,p)] \in cm(o,p) => cm(o,p) \in cm(o,p)) => cm(o,p) \in cm(o,p)   BECAUSE andMP;
h(o,p) /\ cm(o,p) \in pre(cf(o,p),cm(o,p)) => cm(o,p) \in cm(o,p)   BECAUSE TI;
h(o,p) => cm(o,p) \notin pre(cf(o,p),cm(o,p))   BECAUSE killCaseD;

\* Conclusion that h(o,p) is false
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p)   BECAUSE CIA;
h(o,p) => pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p) /\ cm(o,p) \notin pre(cf(o,p),cm(o,p))   BECAUSE CIA;
FactorNotOr3(a,b,c) == (~a /\ ~b /\ ~c) => ~(a \/ b \/ c)   PROPO_TAUTO;
pre(cf(o,p),cm(o,p)) \notin cm(o,p) /\ pre(cf(o,p),cm(o,p)) # cm(o,p) /\ cm(o,p) \notin pre(cf(o,p),cm(o,p))
   => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE FactorNotOr3;
h(o,p) => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE TI;
h(o,p) => ~(pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p))) /\ (pre(cf(o,p),cm(o,p)) \in cm(o,p) \/ pre(cf(o,p),cm(o,p)) = cm(o,p) \/ cm(o,p) \in pre(cf(o,p),cm(o,p)))   BECAUSE CIA;
absurd(a,h) == h => (~a /\ a) => ~h   PROPO_TAUTO;
~h(o,p)   BECAUSE absurd;
killCaseF(a,b) == ~(a /\ b) => (a => ~b)   PROPO_TAUTO;
\* The correct hypothesis
hh(o,p) == IsOrdinal(o) /\ IsOrdinal(p)
   /\ (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y]);
hh(o,p) => ~IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE killCaseF;
(\E m : IsMinimumForIn(m, cb(o,p))) => IsMinimumForIn(cm(o,p), cb(o,p))   BECAUSE CHOOSE cm(o,p);
~IsMinimumForIn(cm(o,p), cb(o,p)) => ~(\E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE Contraposition;
hh(o,p) => ~(\E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE TI;
IsOrdinal(o) => IsWellOrderedByIn(o)   BECAUSE S22;
IsWellOrderedByIn(o) => (\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))   BECAUSE S22;
(\A p : p \subseteq o => p = {} \/ \E m : IsMinimumForIn(m, p))
   => (cb(o,p) \subseteq o => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE \A(p <- cb(o,p));
IsWellOrderedByIn(o) => (cb(o,p) \subseteq o => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE TI;
z \in cb(o,p) <=> z \in o /\ cf(o,p)[z] # z   BECAUSE \A(x <- z);
z \in cb(o,p) => z \in o /\ cf(o,p)[z] # z   BECAUSE EquivToImpl;
z \in o /\ cf(o,p)[z] # z => z \in o   BECAUSE S12;
z \in cb(o,p) => z \in o   BECAUSE TI;
cb(o,p) \subseteq o   BECAUSE GENERALIZATION;
cb(o,p) \subseteq o => (IsWellOrderedByIn(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p)))   BECAUSE SwitchHypos;
IsWellOrderedByIn(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE MODUS_PONENS;
IsOrdinal(o) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE TI;
hh(o,p) => IsOrdinal(o)   BECAUSE S13;
hh(o,p) => cb(o,p) = {} \/ \E m : IsMinimumForIn(m, cb(o,p))   BECAUSE TI;
killCaseG(h,a,b) == (h => ~a) => ((h => b \/ a) => (h => b))   PROPO_TAUTO;
hh(o,p) => cb(o,p) = {}   BECAUSE killCaseG;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
cb(o,p) = {} => (a \in cb(o,p) <=> a \in {})   BECAUSE \A(x <- cb(o,p), y <- {});
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
implyEquivFalse(a,b,f) == ~f => ((a => (b <=> f)) => (a => ~b))   PROPO_TAUTO;
cb(o,p) = {} => a \notin cb(o,p)   BECAUSE implyEquivFalse;
a \in cb(o,p) <=> a \in o /\ cf(o,p)[a] # a   BECAUSE \A(x <- a);
a \in o /\ cf(o,p)[a] # a => a \in cb(o,p)   BECAUSE EquivToImplReverse;
a \notin cb(o,p) => ~(a \in o /\ cf(o,p)[a] # a)   BECAUSE Contraposition;
cb(o,p) = {} => ~(a \in o /\ cf(o,p)[a] # a)   BECAUSE TI;
distribImpl(a,b) == ~(a /\ ~b) => (a => b)   PROPO_TAUTO;
~(a \in o /\ cf(o,p)[a] # a) => (a \in o => cf(o,p)[a] = a)   BECAUSE distribImpl;
cb(o,p) = {} => (a \in o => cf(o,p)[a] = a)   BECAUSE TI;
hh(o,p) => (a \in o => cf(o,p)[a] = a)   BECAUSE TI;
\* Prove hh(o,p) => cf(o,p) = identity(o) by funcEqual,
\* then its domain and image are the same, o = p.
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Domain(cf(o,p)) = o   BECAUSE S23;
cf(o,p) \in Bijections(o,p) => Domain(cf(o,p)) = o   BECAUSE TI;
hh(o,p) => (\E f : f \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => f[x] \in f[y])   BECAUSE S22;
hh(o,p) => (cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y])   BECAUSE TI;
(cf(o,p) \in Bijections(o, p) /\ \A x : \A y : x \in y /\ y \in o => cf(o,p)[x] \in cf(o,p)[y]) => cf(o,p) \in Bijections(o, p)   BECAUSE S12;
hh(o,p) => cf(o,p) \in Bijections(o, p)   BECAUSE TI;
hh(o,p) => Domain(cf(o,p)) = o   BECAUSE TI;
identityBiject   BECAUSE THEOREM;
identity(o) \in Bijections(o,o)   BECAUSE \A(d <- o);
identity(o) \in Bijections(o,o) <=> IsInjection(identity(o)) /\ Domain(identity(o)) = o /\ Image(identity(o)) = o
   BECAUSE \A(d <- o, i <- o, f <- identity(o));
IsInjection(identity(o)) /\ Domain(identity(o)) = o /\ Image(identity(o)) = o   BECAUSE MODUS_PONENS;
IsInjection(identity(o))   BECAUSE S13;
IsFunction(identity(o))   BECAUSE S12;
Domain(identity(o)) = o   BECAUSE S23;
funcEqual   BECAUSE THEOREM;
IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))
   /\ (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])
   => cf(o,p) = identity(o)   BECAUSE \A(f <- cf(o,p), g <- identity(o));
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => IsInjection(cf(o,p))   BECAUSE S13;
cf(o,p) \in Bijections(o, p) => IsInjection(cf(o,p))   BECAUSE TI;
hh(o,p) => IsInjection(cf(o,p))   BECAUSE TI;
IsInjection(cf(o,p)) => IsFunction(cf(o,p))   BECAUSE S12;
hh(o,p) => IsFunction(cf(o,p))   BECAUSE TI;
hh(o,p) => IsFunction(identity(o))   BECAUSE PT1;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o))  BECAUSE CIA;
hh(o,p) => Domain(identity(o)) = o   BECAUSE PT1;
hh(o,p) => Domain(cf(o,p)) = o /\ Domain(identity(o)) = o   BECAUSE CIA;
Domain(cf(o,p)) = o /\ Domain(identity(o)) = o => Domain(cf(o,p)) = Domain(identity(o))   BECAUSE E_SCHEME;
hh(o,p) => Domain(cf(o,p)) = Domain(identity(o))   BECAUSE TI;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o))   BECAUSE CIA;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))   BECAUSE CIA;
identityVal   BECAUSE THEOREM;
a \in o => (identity(o)[a] = a /\ pre(identity(o),a) = a)   BECAUSE \A(d <- o, x <- a);
(identity(o)[a] = a /\ pre(identity(o),a) = a) => identity(o)[a] = a   BECAUSE S12;
a \in o => identity(o)[a] = a   BECAUSE TI;
hh(o,p) => (a \in o => identity(o)[a] = a)   BECAUSE PT1;
hh(o,p) /\ a \in o => identity(o)[a] = a   BECAUSE HypoImplToAnd;
hh(o,p) /\ a \in o => cf(o,p)[a] = a   BECAUSE HypoImplToAnd;
hh(o,p) /\ a \in o => cf(o,p)[a] = a /\ identity(o)[a] = a   BECAUSE CIA;
cf(o,p)[a] = a /\ identity(o)[a] = a => cf(o,p)[a] = identity(o)[a]   BECAUSE E_SCHEME;
hh(o,p) /\ a \in o => cf(o,p)[a] = a /\ identity(o)[a] = a   BECAUSE CIA;
hh(o,p) /\ a \in o => cf(o,p)[a] = identity(o)[a]   BECAUSE TI;
hh(o,p) => (a \in o => cf(o,p)[a] = identity(o)[a])   BECAUSE HypoAndToImpl;
\A x : \A y : x = y => ((a \in x => cf(o,p)[a] = identity(o)[a]) <=> (a \in y => cf(o,p)[a] = identity(o)[a]))
   BECAUSE E_SCHEME;
Domain(cf(o,p)) = o => ((a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a]) <=> (a \in o => cf(o,p)[a] = identity(o)[a]))   BECAUSE \A(x <- Domain(cf(o,p)), y <- o);
hh(o,p) => ((a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a]) <=> (a \in o => cf(o,p)[a] = identity(o)[a]))   BECAUSE TI;
hh(o,p) /\ (a \in o => cf(o,p)[a] = identity(o)[a]) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE HypoEquivToAndReverse;
hh(o,p) => hh(o,p)   BECAUSE ImplySelf;
hh(o,p) => hh(o,p) /\ (a \in o => cf(o,p)[a] = identity(o)[a])   BECAUSE CIA;
hh(o,p) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE TI;
\A a : hh(o,p) => (a \in Domain(cf(o,p)) => cf(o,p)[a] = identity(o)[a])   BECAUSE GENERALIZATION;
hh(o,p) => (x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE \A(a <- x);
\A x : hh(o,p) => (x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE GENERALIZATION;
hh(o,p) => (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE Q_SCHEME;
hh(o,p) => IsFunction(cf(o,p)) /\ IsFunction(identity(o)) /\ Domain(cf(o,p)) = Domain(identity(o))
   /\ (\A x : x \in Domain(cf(o,p)) => cf(o,p)[x] = identity(o)[x])   BECAUSE CIA;
hh(o,p) => cf(o,p) = identity(o)   BECAUSE TI;
\A x : \A y : x = y => Image(x) = Image(y)   BECAUSE E_SCHEME;
cf(o,p) = identity(o) => Image(cf(o,p)) = Image(identity(o))   BECAUSE \A(x <- cf(o,p), y <- identity(o));
hh(o,p) => Image(cf(o,p)) = Image(identity(o))   BECAUSE TI;
IsInjection(cf(o,p)) /\ Domain(cf(o,p)) = o /\ Image(cf(o,p)) = p => Image(cf(o,p)) = p   BECAUSE S22;
hh(o,p) => Image(cf(o,p)) = p   BECAUSE TI;
hh(o,p) => Image(cf(o,p)) = p /\ Image(cf(o,p)) = Image(identity(o))   BECAUSE CIA;
Image(cf(o,p)) = p /\ Image(cf(o,p)) = Image(identity(o)) => p = Image(identity(o))  BECAUSE E_SCHEME;
hh(o,p) => p = Image(identity(o))  BECAUSE TI;
Image(identity(o)) = o   BECAUSE S22;
Image(identity(o)) = o => o = Image(identity(o))   BECAUSE E_SCHEME;
o = Image(identity(o))   BECAUSE MODUS_PONENS;
hh(o,p) => o = Image(identity(o))   BECAUSE PT1;
hh(o,p) => o = Image(identity(o)) /\ p = Image(identity(o))   BECAUSE CIA;
o = Image(identity(o)) /\ p = Image(identity(o)) => o = p   BECAUSE E_SCHEME;
hh(o,p) => o = p   BECAUSE TI;
bijectOrdinalsEqual   BECAUSE GENERALIZATION;
QED

(*
   This is the link between a well-order and an ordinal :
   when there is an increasing bijection between them.
*)
IsOrdinalOfWellOrder(o, w) == IsOrdinal(o) /\ IsWellOrder(w)
 /\ (\E f : f \in Bijections(Domain(w), o) /\ \A x : \A y : <<x,y>> \in w => f[x] \subseteq f[y])

uniqueOrdinalOfWellOrder == \A w : \A o : \A p :
   IsOrdinalOfWellOrder(o, w) /\ IsOrdinalOfWellOrder(p, w) => o = p
THEOREM uniqueOrdinalOfWellOrder
\* To prove this, compose the two functions to make an increasing bijection
\* between o and p, then conclude by the previous theorem.

(*
   With this unicity of a well-order's ordinal, we can now prove
   its existence. By the replacement axiom scheme, each element x
   of a well-order w is sent to the unique ordinal of the initial
   segment [min(w), x[.

   This forms a set of ordinals, which will be shown to be an ordinal.
   The final step is to prove that this ordinal is isomorphic to w.
*)
OrdinalOfWellOrder(w) == CHOOSE o : IsOrdinalOfWellOrder(o, w)
ordinalOfWellOrderExists == \A w : IsWellOrder(w)
   => IsOrdinalOfWellOrder(OrdinalOfWellOrder(w), w)
THEOREM ordinalOfWellOrderExists

\* The +1 operation on ordinals
successor(o) == o \union { o }

inSuccessor == \A o : o \in successor(o)
THEOREM inSuccessor
PROOF
inSuccessor   BECAUSE GENERALIZATION;
QED

successorIncreasing == \A o : \A p : IsOrdinal(o) /\ IsOrdinal(p) /\ o \in p
   => successor(o) \in successor(p)
THEOREM successorIncreasing
PROOF
\* o \union { o } \subseteq p then \in succesor(p)
successorIncreasing   BECAUSE GENERALIZATION;
QED

IsLimitOrdinal(o) == IsOrdinal(o) /\ o # {} /\ \A x : x \in o => o # successor(x)
IsFiniteOrdinal(o) == IsOrdinal(o) /\ ~IsLimitOrdinal(o)
   /\ \A x : x \in o => ~IsLimitOrdinal(x)

finiteInFinite == \A o : \A x : IsFiniteOrdinal(o) /\ x \in o => IsFiniteOrdinal(x)
THEOREM finiteInFinite
PROOF
finiteInFinite   BECAUSE GENERALIZATION;
QED

\* The empty set is the smallest ordinal, called "zero" as an ordinal
ordinalZero == IsFiniteOrdinal( {} )
THEOREM ordinalZero
PROOF
\* Just check implications starting with the false formula x \in {}
VARIABLES a,b,c,p,x;
\* Proof of TransitiveSet( {} )
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
a \in {} => a \subseteq {}   BECAUSE Explosion;
IsTransitiveSet( {} )   BECAUSE GENERALIZATION;
\* Proof of irreflexive
a \in {} => a \notin a   BECAUSE Explosion;
\A a : a \in {} => a \notin a   BECAUSE GENERALIZATION;
\* Proof of transitive order
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c)
   => (a \in {} /\ b \in {} /\ c \in {})   BECAUSE S13;
(a \in {} /\ b \in {} /\ c \in {}) => a \in {}   BECAUSE S13;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in {}   BECAUSE TI;
a \in {} => a \in c   BECAUSE Explosion;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE TI;
IsTransitiveIn( {} )  BECAUSE GENERALIZATION;
\* Proof of minimums
includedInEmpty   BECAUSE THEOREM;
p \subseteq {} => p = {}   BECAUSE \A(x <- p);
p = {} => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE IntroOrLeft;
p \subseteq {} => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE TI;
\A p : p \subseteq {} => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE GENERALIZATION;
(\A a : a \in {} => a \notin a) /\ IsTransitiveIn( {} )   BECAUSE IntroAndRight;
IsWellOrderedByIn( {} )   BECAUSE IntroAndRight;
IsOrdinal({})   BECAUSE IntroAndRight;
\* Proof of finiteness
IsLimitOrdinal({}) => {} # {}   BECAUSE S23;
contraposNeg(a,b) == (a => ~b) => (b => ~a)   PROPO_TAUTO;
{} = {} => ~IsLimitOrdinal({})   BECAUSE contraposNeg;
equalSelf   BECAUSE THEOREM;
{} = {}   BECAUSE \A(a <- {});
~IsLimitOrdinal({})   BECAUSE MODUS_PONENS;
IsOrdinal({}) /\ ~IsLimitOrdinal({})   BECAUSE IntroAndRight;
a \in {} => ~IsLimitOrdinal(a)   BECAUSE Explosion;
\A a : a \in {} => ~IsLimitOrdinal(a)   BECAUSE GENERALIZATION;
x \in {} => ~IsLimitOrdinal(x)   BECAUSE \A(a <- x);
\A x : x \in {} => ~IsLimitOrdinal(x)   BECAUSE GENERALIZATION;
ordinalZero   BECAUSE IntroAndRight;
QED

ordinalSuccessorStable == \A o : IsOrdinal(o) => IsOrdinal( successor(o) )
THEOREM ordinalSuccessorStable

finiteOrdinalSuccessorStable == \A o : IsFiniteOrdinal(o) => IsFiniteOrdinal( successor(o) )
THEOREM finiteOrdinalSuccessorStable
PROOF
finiteOrdinalSuccessorStable   BECAUSE GENERALIZATION;
QED

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE_UNIQUE o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))

NatExists == (\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))
   /\ IsLimitOrdinal(Nat)
THEOREM NatExists
PROOF
\* By separation in a set given by the axiom of infinity
VARIABLES a,b,c,o,p,t,u,x,y,z,nat;
Infinity   BECAUSE AXIOM;
\A a : \E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE \A(a <- a);
\* Take a from the axiom of infinity and b from separation of finite ordinals
h(a,b) == {} \in a /\ (\A x : x \in a => successor(x) \in a)
   /\ \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x);
h(a,b) => \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE S22;

\* Prove UNION b is Nat, ie IsFiniteOrdinal(x) <=> x \in UNION b.
\* First prove that UNION b is an ordinal.
unionOrdinalsIsOrdinal   BECAUSE THEOREM;
(\A x : x \in b => IsOrdinal(x)) => IsOrdinal(UNION b)   BECAUSE \A(u <- b);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b <=> x \in a /\ IsFiniteOrdinal(x))
   BECAUSE \A(x <- x);
(x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE EquivToImpl;
h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE TI2;
IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE S13;
\A a : IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(a <- x);
extractProp(a,b,c,d) == (a => b) => ((c => d /\ a) => (c => b))   PROPO_TAUTO;
(x \in b => x \in a /\ IsFiniteOrdinal(x)) => (x \in b => IsOrdinal(x))   BECAUSE extractProp;
h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE TI;
\A x : h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in b => IsOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) => IsOrdinal(UNION b)   BECAUSE TI;

\* Proof that UNION b is a limit ordinal.
\* If o \in UNION b then successor(o) \in UNION b, so UNION b # successor o.
unionExists   BECAUSE AXIOM;
x \in UNION b <=> \E t : t \in b /\ x \in t   BECAUSE \A(b <- b, z <- x);
x \in UNION b => \E t : t \in b /\ x \in t   BECAUSE EquivToImpl;
\A x : h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => h(a,b)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => t \in b   BECAUSE S23;
h(a,b) /\ t \in b /\ x \in t => t \in a /\ IsFiniteOrdinal(t)   BECAUSE KillMiddleHypo;
h(a,b) => \A x : x \in a => successor(x) \in a   BECAUSE S23;
(\A x : x \in a => successor(x) \in a) => (t \in a => successor(t) \in a)   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => (t \in a => successor(t) \in a)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => t \in a   BECAUSE S12;
h(a,b) /\ t \in b /\ x \in t => t \in a   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a   BECAUSE KillMiddleHypo;
\* So successor(t) \in b.
\* Then successor(x) \in successor(t) \in b implies successor(x) \in UNION b.
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(t) => IsFiniteOrdinal( successor(t) )   BECAUSE \A(o <- t);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t)))   BECAUSE \A(x <- successor(t));
(successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t))) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE EquivToImplReverse;
h(a,b) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => IsFiniteOrdinal(t)   BECAUSE S22;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(successor(t))   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a /\ IsFiniteOrdinal(successor(t))   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in b   BECAUSE KillMiddleHypo;
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t => successor(x) \in successor(t)   BECAUSE \A(o <- x, p <- t);
IsFiniteOrdinal(t) => IsOrdinal(t)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t)   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => x \in t   BECAUSE S22;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(t) /\ x \in t => IsOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t)   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t)   BECAUSE TI;
inInUnion   BECAUSE THEOREM;
(successor(x) \in successor(t) /\ successor(t) \in b) => successor(x) \in UNION b   BECAUSE \A(a <- successor(x), b <- successor(t), c <- b);
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t) /\ successor(t) \in b   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in UNION b   BECAUSE TI;
pushHypos(h,a,b,c) == (h /\ a /\ b => c) => (h => (a /\ b => c))   PROPO_TAUTO;
h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => successor(x) \in UNION b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE Q_SCHEME;
h(a,b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE TI;
mergeHypos(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(a,b) /\ x \in UNION b => \E t : successor(x) \in UNION b   BECAUSE mergeHypos;
(\E t : successor(x) \in UNION b) => successor(x) \in UNION b   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => successor(x) \in UNION b   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(UNION b) /\ successor(x) \in UNION b => successor(x) # (UNION b) /\ (UNION b) \notin successor(x)   BECAUSE \A(o <- successor(x), p <- UNION b);
h(a,b) /\ x \in UNION b => h(a,b)   BECAUSE S12;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b)   BECAUSE TI2;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b) /\ successor(x) \in UNION b   BECAUSE CIA;
successor(x) # (UNION b) /\ (UNION b) \notin successor(x) => successor(x) # UNION b   BECAUSE S12;
h(a,b) /\ x \in UNION b => successor(x) # UNION b   BECAUSE TI2;
UNION b = successor(x) => successor(x) = UNION b   BECAUSE E_SCHEME;
successor(x) # UNION b => UNION b # successor(x)   BECAUSE Contraposition;
h(a,b) /\ x \in UNION b => UNION b # successor(x)   BECAUSE TI;
h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE HypoAndToImpl;
\A x : h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b => UNION b # successor(x))   BECAUSE Q_SCHEME;

\* {} \in successor({}) \in b, so {} \in UNION b
h(a,b) => {} \in a   BECAUSE S13;
(\A x : x \in a => successor(x) \in a) => ({} \in a => successor({}) \in a)   BECAUSE \A(x <- {});
h(a,b) => ({} \in a => successor({}) \in a)   BECAUSE TI;
h(a,b) => successor({}) \in a   BECAUSE KillMiddleHypo;
ordinalZero   BECAUSE THEOREM;
IsFiniteOrdinal({}) => IsFiniteOrdinal( successor({}) )   BECAUSE \A(o <- {});
IsFiniteOrdinal( successor({}) )   BECAUSE MODUS_PONENS;
successor({}) \in a => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE IntroAndLeft;
h(a,b) => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE TI;
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE \A(x <- successor({}));
h(a,b) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE TI;
killCase(h,a,b) == (h => a) => ((h => (b <=> a)) => (h => b))   PROPO_TAUTO;
h(a,b) => successor({}) \in b   BECAUSE killCase;
inSuccessor   BECAUSE THEOREM;
{} \in successor({})   BECAUSE \A(o <- {});
h(a,b) => {} \in successor({})   BECAUSE PT1;
h(a,b) => {} \in successor({}) /\ successor({}) \in b   BECAUSE CIA;
({} \in successor({}) /\ successor({}) \in b) => {} \in UNION b   BECAUSE \A(a <- {}, b <- successor({}), c <- b);
h(a,b) => {} \in UNION b   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
UNION b = {} <=> \A x : x \notin UNION b   BECAUSE \A(c <- UNION b);
(\E x : x \in UNION b) <=> ~\A x : x \notin UNION b   BECAUSE Q_SCHEME;
(\E x : x \in UNION b) => ~\A x : x \notin UNION b   BECAUSE EquivToImpl;
{} \in UNION b => \E x : x \in UNION b   BECAUSE \E(x <- {});
h(a,b) => ~\A x : x \notin UNION b   BECAUSE TI2;
UNION b = {} => \A x : x \notin UNION b   BECAUSE EquivToImpl;
~(\A x : x \notin UNION b) => UNION b # {}   BECAUSE Contraposition;
h(a,b) => UNION b # {}   BECAUSE TI;
h(a,b) => IsOrdinal(UNION b) /\ UNION b # {}   BECAUSE CIA;
h(a,b) => IsLimitOrdinal(UNION b)   BECAUSE CIA;

\* Proof that IsFiniteOrdinal(x) => x \in UNION b
ordinalComparison   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(UNION b) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE \A(o <- x, p <- UNION b);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => IsFiniteOrdinal(x)   BECAUSE S22;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => h(a,b)   BECAUSE S12;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(UNION b)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x) /\ IsOrdinal(UNION b)   BECAUSE CIA;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE TI;
\* because UNION b is infinite, only the first case is possible.
IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE S23;
\A o : IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE TI;
\A x : \A b : x = b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(b))   BECAUSE E_SCHEME;
x = UNION b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(UNION b))   BECAUSE \A(x <- x, b <- UNION b);
h(a,b) /\ IsFiniteOrdinal(x) => IsLimitOrdinal(UNION b)   BECAUSE TI;
killCaseB(h,a,b,c) == (h => ~a) => ((h => c) => (((b => (a <=> c)) => (h => ~b))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x # UNION b   BECAUSE killCaseB;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(x) /\ UNION b \in x => IsFiniteOrdinal(UNION b)   BECAUSE \A(o <- x, x <- UNION b);
IsFiniteOrdinal(UNION b) => ~IsLimitOrdinal(UNION b)   BECAUSE \A(o <- UNION b);
IsFiniteOrdinal(x) /\ UNION b \in x => ~IsLimitOrdinal(UNION b)   BECAUSE TI;
IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE HypoAndToImpl;
h(a,b) /\ IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE TI;
killCaseD(h,a,b) == (h => (b => ~a)) => ((h => a) => (h => ~b))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => UNION b \notin x   BECAUSE killCaseD;
killCaseE(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b   BECAUSE killCaseE;

\* Conversely, x \in UNION b is an ordinal as an element of an ordinal.
\* And x \in t \in b where t is a finite ordinal, so x is finite too.
IsFiniteOrdinal(t) /\ x \in t => IsFiniteOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => IsFiniteOrdinal(x)) => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE TI2;
h(a,b) /\ x \in UNION b => x \in UNION b   BECAUSE S22;
h(a,b) /\ x \in UNION b => (\E t : t \in b /\ x \in t)   BECAUSE TI;
h(a,b) /\ x \in UNION b => \E t : IsFiniteOrdinal(x)   BECAUSE KillMiddleHypo;
(\E t : IsFiniteOrdinal(x)) => IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE HIE;
\A x : h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;

hA(a) == {} \in a /\ (\A x : x \in a => successor(x) \in a);
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))
   => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE TI;
hA(a) => (\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x))   BECAUSE PT1;
hA(a) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE KillMiddleHypo;
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE \E(o <- UNION b);
(\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
hA(a) => (\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE TI;
(\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => (\E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
hA(a) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE TI;
(\E a : hA(a)) => \E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
(\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;

\* Proof that Nat is unique. By extensionality, being in another Nat
\* is equivalent, it is being a finite ordinal.
ho(o) == \A x : x \in o <=> IsFiniteOrdinal(x);
\A z : \A o : z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE E_SCHEME;
z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE \A(z <- z, o <- o);
killCaseF(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
ho(o) /\ z = o => (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE killCaseF;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in o) => z = o   BECAUSE \A(a <- z, b <- o);
ho(o) => (x \in o <=> IsFiniteOrdinal(x))   BECAUSE \A(x <- x);
tEquiv(a,b,c,h) == (h => (a <=> b)) => (h => ((c <=> b) => (c <=> a)))   PROPO_TAUTO;
ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE tEquiv;
\A x : ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE GENERALIZATION;
ho(o) => (\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE Q_SCHEME;
(\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o)) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE Q_SCHEME;
ho(o) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE TI;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o)   BECAUSE HypoImplToAnd;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => z = o   BECAUSE TI;
ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE HIE;
\A z : ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
ho(o) => (\A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\E o : ho(o)) => (\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE CHOOSE Nat;

\* Extract the fact that Nat is a limit ordinal
UNION b = Nat <=> (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- UNION b);
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => UNION b = Nat   BECAUSE EquivToImplReverse;
h(a,b) => UNION b = Nat   BECAUSE TI;
\A x : \A y : x = y => (IsLimitOrdinal(x) <=> IsLimitOrdinal(y))   BECAUSE E_SCHEME;
UNION b = Nat => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE \A(x <- UNION b, y <- Nat);
h(a,b) => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE TI;
(IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat)) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE EquivToImpl;
h(a,b) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE TI;
h(a,b) => IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat)) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE TI;
hA(a) => \E b : IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
(\E a : hA(a)) => \E a : \E b : IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
\E a : \E b : IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
(\E a : \E b : IsLimitOrdinal(Nat)) => (\E b : IsLimitOrdinal(Nat))  BECAUSE Q_SCHEME;
(\E b : IsLimitOrdinal(Nat))   BECAUSE MODUS_PONENS;
(\E b : IsLimitOrdinal(Nat)) => IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
NatExists   BECAUSE IntroAndRight;
QED
