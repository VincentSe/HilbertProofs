EXTENDS ZFC

(*
   The class of well-orders, orders where each nonempty subset has a minimum.
   They allow to count :
      - in the well-order, take the minimum and call it zero
      - in the nonzero elements of the well-order, take the minimum and call it one
      - in the elements of the well-order that are neither zero nor one,
        take the minimum and call it two
      - iterate
   
   For this reason, some well-orders (the finite ones) define the natural numbers.
   The well-orders are stable under disjoint unions, which they call addition.
   They are also stable under cartesian products, which they call multiplication.
*)
IsWellOrder(w) == IsOrder(w)
   /\ (\A part : (part # {} /\ (\A x : x \in part => IsDefinedOn(w,x)))
         => \E min : min \in part /\ \A b : b \in part => <<min,b>> \in w)

\* Define a well-order on the disjoint union of two well-orders.
\* This order simply pastes v after u.
IsInWellOrderAddition(x,u,v) == \E m : \E n :
   (m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
     \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
     \/ (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v)
wellOrderAddition(u,v) == CHOOSE b : \A x : x \in b <=> IsInWellOrderAddition(x,u,v)

woAddDomain(u,v) == disjointUnion(Domain(u), Domain(v))
wellOrderAdditionExists == \A u : \A v : \A x : x \in wellOrderAddition(u,v) <=> IsInWellOrderAddition(x,u,v)
THEOREM wellOrderAdditionExists
PROOF
\* By separation in woAddDomain(u,v) \X woAddDomain(u,v)
VARIABLES a,b,m,n,u,v,x,y,z;
(\A x : x \in wellOrderAddition(u,v) <=> IsInWellOrderAddition(x,u,v))
   <=> (\E b : \A x : x \in b <=> IsInWellOrderAddition(x,u,v))   BECAUSE CHOOSE;
\A a : \E b : \A x : x \in b <=> ( (x \in a) /\ IsInWellOrderAddition(x,u,v) )   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> ( (x \in (woAddDomain(u,v) \X woAddDomain(u,v)))
   /\ IsInWellOrderAddition(x,u,v) )   BECAUSE \A(a <- woAddDomain(u,v) \X woAddDomain(u,v));

disjUnionFirstInc   BECAUSE THEOREM;
m \in Domain(u) => <<m,{}>> \in woAddDomain(u,v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- m);
n \in Domain(u) => <<n,{}>> \in woAddDomain(u,v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- n);
disjUnionSecondInc   BECAUSE THEOREM;
m \in Domain(v) => <<m,ordinalOne>> \in woAddDomain(u,v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- m);
n \in Domain(v) => <<n,ordinalOne>> \in woAddDomain(u,v)   BECAUSE \A(x <- Domain(u), y <- Domain(v), z <- n);

\* First case m \in Domain(u) /\ n \in Domain(v)
(m \in Domain(u) /\ n \in Domain(v)) => (<<m,{}>> \in woAddDomain(u,v) /\ <<n,ordinalOne>> \in woAddDomain(u,v))   BECAUSE MergeImplicationsAnd;
cartesianProductInc   BECAUSE THEOREM;
(<<m,{}>> \in woAddDomain(u,v) /\ <<n,ordinalOne>> \in woAddDomain(u,v))
   => << <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE \A(x <- woAddDomain(u,v), y <- woAddDomain(u,v), a <- <<m,{}>>, b <- <<n,ordinalOne>>);
(m \in Domain(u) /\ n \in Domain(v))
   => << <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
x = << <<m,{}>>, <<n,ordinalOne>> >>
   => (x \in (woAddDomain(u,v) \X woAddDomain(u,v)) <=> << <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))   BECAUSE E_SCHEME;
(x = << <<m,{}>>, <<n,ordinalOne>> >> /\ << <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE HypoEquivToAndReverse;
x = << <<m,{}>>, <<n,ordinalOne>> >> => x = << <<m,{}>>, <<n,ordinalOne>> >>   BECAUSE ImplyOneself;
(m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
   => (<< <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)   BECAUSE MergeImplicationsAnd;
(<< <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
   => (x = << <<m,{}>>, <<n,ordinalOne>> >> /\ << <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))   BECAUSE AndSymmetry;
(<< <<m,{}>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
(m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
   
\* Second case <<m,n>> \in u
(m \in Domain(u) /\ n \in Domain(u)) => (<<m,{}>> \in woAddDomain(u,v) /\ <<n,{}>> \in woAddDomain(u,v))   BECAUSE MergeImplicationsAnd;
(<<m,{}>> \in woAddDomain(u,v) /\ <<n,{}>> \in woAddDomain(u,v))
   => << <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE \A(x <- woAddDomain(u,v), y <- woAddDomain(u,v), a <- <<m,{}>>, b <- <<n,{}>>);
(m \in Domain(u) /\ n \in Domain(u))
   => << <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
x = << <<m,{}>>, <<n,{}>> >>
   => (x \in (woAddDomain(u,v) \X woAddDomain(u,v)) <=> << <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))   BECAUSE E_SCHEME;
(x = << <<m,{}>>, <<n,{}>> >> /\ << <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE HypoEquivToAndReverse;
x = << <<m,{}>>, <<n,{}>> >> => x = << <<m,{}>>, <<n,{}>> >>   BECAUSE ImplyOneself;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >>)
   => (<< <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,{}>>, <<n,{}>> >>)   BECAUSE MergeImplicationsAnd;
(<< <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,{}>>, <<n,{}>> >>)
   => (x = << <<m,{}>>, <<n,{}>> >> /\ << <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))   BECAUSE AndSymmetry;
(<< <<m,{}>>, <<n,{}>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,{}>>, <<n,{}>> >>)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >>)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
   => (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >>)   BECAUSE DropAndRight;
(m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;

\* Thirs case <<m,n>> \in v
(m \in Domain(v) /\ n \in Domain(v)) => (<<m,ordinalOne>> \in woAddDomain(u,v) /\ <<n,ordinalOne>> \in woAddDomain(u,v))   BECAUSE MergeImplicationsAnd;
(<<m,ordinalOne>> \in woAddDomain(u,v) /\ <<n,ordinalOne>> \in woAddDomain(u,v))
   => << <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE \A(x <- woAddDomain(u,v), y <- woAddDomain(u,v), a <- <<m,ordinalOne>>, b <- <<n,ordinalOne>>);
(m \in Domain(v) /\ n \in Domain(v))
   => << <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>
   => (x \in (woAddDomain(u,v) \X woAddDomain(u,v)) <=> << <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))   BECAUSE E_SCHEME;
(x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ << <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE HypoEquivToAndReverse;
x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> => x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>   BECAUSE ImplyOneself;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)
   => (<< <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)   BECAUSE MergeImplicationsAnd;
(<< <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)
   => (x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ << <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)))   BECAUSE AndSymmetry;
(<< <<m,ordinalOne>>, <<n,ordinalOne>> >> \in (woAddDomain(u,v) \X woAddDomain(u,v)) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v)
   => (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >>)   BECAUSE DropAndRight;
(m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v)
   => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;

\* Drop the holding set in the separation
((m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
    \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u))
 => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE CombineImplicationsStart;
((m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
    \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
    \/ (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v))
 => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE CombineImplicationsStart;
(\E n : (m \in Domain(u) /\ n \in Domain(v) /\ x = << <<m,{}>>, <<n,ordinalOne>> >>)
    \/ (m \in Domain(u) /\ n \in Domain(u) /\ x = << <<m,{}>>, <<n,{}>> >> /\ <<m,n>> \in u)
    \/ (m \in Domain(v) /\ n \in Domain(v) /\ x = << <<m,ordinalOne>>, <<n,ordinalOne>> >> /\ <<m,n>> \in v))
 => \E n : x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE Q_SCHEME;
IsInWellOrderAddition(x,u,v) => \E m : \E n : x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE Q_SCHEME;
(\E m : \E n : x \in (woAddDomain(u,v) \X woAddDomain(u,v))) => \E n : x \in (woAddDomain(u,v) \X woAddDomain(u,v))  BECAUSE Q_SCHEME;
(\E n : x \in (woAddDomain(u,v) \X woAddDomain(u,v))) => x \in (woAddDomain(u,v) \X woAddDomain(u,v))  BECAUSE Q_SCHEME;
IsInWellOrderAddition(x,u,v) => \E n : x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
IsInWellOrderAddition(x,u,v) => x \in (woAddDomain(u,v) \X woAddDomain(u,v))   BECAUSE TransitImplication;
IsInWellOrderAddition(x,u,v) => IsInWellOrderAddition(x,u,v)   BECAUSE ImplyOneself;
IsInWellOrderAddition(x,u,v) => ( (x \in (woAddDomain(u,v) \X woAddDomain(u,v))) /\ IsInWellOrderAddition(x,u,v) )   BECAUSE CombineImplicationsEnd;
( (x \in (woAddDomain(u,v) \X woAddDomain(u,v))) /\ IsInWellOrderAddition(x,u,v) ) => IsInWellOrderAddition(x,u,v)   BECAUSE DropAndLeft;
IsInWellOrderAddition(x,u,v) <=> ( (x \in (woAddDomain(u,v) \X woAddDomain(u,v))) /\ IsInWellOrderAddition(x,u,v) )   BECAUSE IntroEquiv;
(x \in b <=> ( (x \in (woAddDomain(u,v) \X woAddDomain(u,v))) /\ IsInWellOrderAddition(x,u,v) ))
   => (x \in b <=> IsInWellOrderAddition(x,u,v) )   BECAUSE TransitEquiv2;
(\A x : x \in b <=> ( (x \in (woAddDomain(u,v) \X woAddDomain(u,v))) /\ IsInWellOrderAddition(x,u,v) ))
   => (\A x : x \in b <=> IsInWellOrderAddition(x,u,v) )   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> ( (x \in (woAddDomain(u,v) \X woAddDomain(u,v))) /\ IsInWellOrderAddition(x,u,v) ))
   => (\E b : \A x : x \in b <=> IsInWellOrderAddition(x,u,v) )   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> IsInWellOrderAddition(x,u,v)   BECAUSE MODUS_PONENS;
\A x : x \in wellOrderAddition(u,v) <=> IsInWellOrderAddition(x,u,v)   BECAUSE MODUS_PONENS;
wellOrderAdditionExists   BECAUSE GENERALIZATION;
QED

woAddIsWo == \A u : \A v : (IsWellOrder(u) /\ IsWellOrder(v)) => IsWellOrder(wellOrderAddition(u,v))
THEOREM woAddIsWo

(*
   At the moment, the addition and multiplication of well-orders are not commutative,
   even for finite ones. wellOrderAddition(u,v) and wellOrderAddition(v,u) are
   isomorphic as well-orders, but not equal.

   It would be convenient to fix one representative in each well-order isomorphy
   class, so that addition and multiplication get their usual properties. The
   ordinals achieve that, they find canonical elements for the well-orders' domains.
*)
TransitiveSet(x) == \A a : a \in x => a \subseteq x

(*
   Predicate asserting that the set x is strictly well-ordered by the membership
   relation \in. In those sets, \in behaves like < on the natural numbers. Actually,
   those sets start with the natural numbers and \in will be the definition of <.
*)
WellOrderedByIn(x) == (\A a : a \in x => a \notin a) \* irreflexive
   /\ (\A a : \A b : \A c : (a \in x /\ b \in x /\ c \in x /\ a \in b /\ b \in c) => a \in c) \* transitive
   /\ (\A p : (p # {} /\ p \subseteq x) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)) \* existence of minimums

(*
   The class of ordinals, which starts with the natural numbers. This predicate
   rigorously defines what could be naively stated as
      0 = {}
      n = { 0, ..., n-1 }
*)
IsOrdinal(o) == TransitiveSet(o) /\ WellOrderedByIn(o)

\* The empty set is the smallest ordinal, called "zero" as an ordinal
ordinalZero == IsOrdinal( {} )
THEOREM ordinalZero
PROOF
\* Just check implications starting with the false formula x \in {}
VARIABLES a,b,c,p,x;
\* Proof of TransitiveSet( {} )
emptySetExists   BECAUSE THEOREM;
a \notin {}   BECAUSE \A(x <- a);
a \in {} => a \subseteq {}   BECAUSE Explosion;
TransitiveSet( {} )   BECAUSE GENERALIZATION;

\* Proof of irreflexive
a \in {} => a \notin a   BECAUSE Explosion;
\A a : a \in {} => a \notin a   BECAUSE GENERALIZATION;

\* Proof of transitive order
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c)
   => (a \in {} /\ b \in {} /\ c \in {})   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {}) => a \in {}   BECAUSE DropAndRight2;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in {}   BECAUSE TransitImplication;
a \in {} => a \in c   BECAUSE Explosion;
(a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE TransitImplication;
\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c   BECAUSE GENERALIZATION;

\* Proof of minimums
includedInEmpty   BECAUSE THEOREM;
p \subseteq {} => p = {}   BECAUSE \A(x <- p);
(p \subseteq {} => p = {}) <=> (~(p \subseteq {}) \/ p = {})   BECAUSE BooleanImplication;
~(p \subseteq {}) \/ p = {}   BECAUSE MODUS_PONENS;
p = {} \/ ~(p \subseteq {})   BECAUSE OrSymmetry;
~~(p = {} \/ ~(p \subseteq {}))   BECAUSE IntroNotNot;
~(p = {} \/ ~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE Explosion;
~(p = {} \/ ~(p \subseteq {})) <=> (p # {} /\ ~~(p \subseteq {}))   BECAUSE DistribNotOr;
(p # {} /\ ~~(p \subseteq {})) => ~(p = {} \/ ~(p \subseteq {}))   BECAUSE EquivToImplReverse;
(p # {} /\ ~~(p \subseteq {})) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TransitImplication;
p \subseteq {} => ~~(p \subseteq {})   BECAUSE IntroNotNot;
p # {} => p # {}   BECAUSE ImplyOneself;
(p # {} /\ p \subseteq {}) => (p # {} /\ ~~(p \subseteq {}))   BECAUSE MergeImplicationsAnd;
(p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE TransitImplication;
\A p : (p # {} /\ p \subseteq {}) => \E a : a \in p /\ \A b : b \in p => (b = a \/ a \in b)   BECAUSE GENERALIZATION;

\* Conclude with PT6
(\A a : a \in {} => a \notin a)
   /\ (\A a : \A b : \A c : (a \in {} /\ b \in {} /\ c \in {} /\ a \in b /\ b \in c) => a \in c)   BECAUSE IntroAndRight;
WellOrderedByIn( {} )   BECAUSE IntroAndRight;
ordinalZero   BECAUSE IntroAndRight;
QED

\* The +1 operation on ordinals
successor(o) == o \union { o }

ordinalSuccessorStable == \A o : IsOrdinal(o) => IsOrdinal( successor(o) )
THEOREM ordinalSuccessorStable

IsLimitOrdinal(o) == IsOrdinal(o) /\ o # {} /\ \A x : x \in o => o # successor(x)

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE o : IsLimitOrdinal(o) /\ \A x : x \in o => ~IsLimitOrdinal(x)
naturalNumbersExist == IsLimitOrdinal(Nat) /\ \A x : x \in Nat => ~IsLimitOrdinal(x)
THEOREM naturalNumbersExist

(*
   The addition function on natural numbers. It could be declared as an operator
   natAddition(x,y) = CHOOSE z : ...
   however it would be recursive (or use well-orders). Keep it a simple function here.
*)
natAddition == CHOOSE f : IsFunction(f)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in f) \* f : Nat \X Nat -> Nat
   /\ (\A x : x \in Nat => << <<x,{}>>, x >> \in f) \* f(x,0) = x
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : << <<x,y>>, u >> \in f /\ << <<x,successor(y)>>, successor(u) >> \in f) \* f(x,y+1) = f(x,y)+1

natAdditionExists == IsFunction(natAddition)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in natAddition)
   /\ (\A x : x \in Nat => << <<x,{}>>, x >> \in natAddition)
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : << <<x,y>>, u >> \in natAddition /\ << <<x,successor(y)>>, successor(u) >> \in natAddition)

THEOREM natAdditionExists

(*
   The multiplication function on natural numbers.
*)
natMultiplication == CHOOSE f : IsFunction(f)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in f) \* f : Nat \X Nat -> Nat
   /\ (\A x : x \in Nat => << <<x,{}>>, {} >> \in f) \* f(x,0) = 0
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : \E v : << <<x,y>>, u >> \in f /\ << <<x,successor(y)>>, v>> \in f
	                  /\ << <<u,x>>, v >> \in natAddition) \* u=f(x,y) and v=f(x,y+1) and v=u+x, ie f(x,y+1) = f(x,y)+x

natMultiplicationExists == IsFunction(natMultiplication)
   /\ (\A x : x \in Nat \X Nat => \E y : y \in Nat /\ <<x,y>> \in natMultiplication)
   /\ (\A x : x \in Nat => << <<x,{}>>, {} >> \in natMultiplication)
   /\ (\A x : \A y : (x \in Nat /\ y \in Nat)
         => \E u : \E v : << <<x,y>>, u >> \in natMultiplication /\ << <<x,successor(y)>>, v>> \in natMultiplication /\ << <<u,x>>, v >> \in natAddition)

THEOREM natMultiplicationExists