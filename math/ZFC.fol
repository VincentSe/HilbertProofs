(*
   This file contains the basic definitions for mathematics, the ZFC axioms of set
   theory. For more information : en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory.

   The membership relation \in is declared (without a definition because it is
   primitive), then the inclusion relation \subseteq.

   The axioms defined are extensionality, powerset, union and infinity. The axiom
   schemes of separation and replacement are also defined.

   The operators defined are the empty set, singleton of a set, pair of sets, couples,
   union of two sets, intersection of two sets, cartesian product and disjoint union.

   The relations defined are graphs, functions and equivalence relations. The function
   application operator is also defined.
*)

EXTENDS Tautologies

\* The membership binary relation, the only primitive symbol of ZFC :
CONSTANT _ \in _

aSetExists == \E x : x = x

THEOREM aSetExists
PROOF
VARIABLES x;
(\A x : ~(x = x)) => ~(x = x)   BECAUSE \A(x <- x);
~~(x = x) => ~(\A x : ~(x = x))   BECAUSE Contraposition;
x = x => ~~(x = x)   BECAUSE IntroNotNot;
x = x   BECAUSE E_SCHEME;
~~(x = x)   BECAUSE MODUS_PONENS;
~(\A x : ~(x = x))   BECAUSE MODUS_PONENS;
(\E x : x = x)  <=>  ~(\A x : ~(x = x))   BECAUSE Q_SCHEME;
aSetExists   BECAUSE MODUS_PONENS;
QED

(*
   The theorem above uses only logical axioms, the constant binary
   relation \in does not appear in the proof. It is a general property
   of first-order logic with equality : something exists.

   Let's continue with a property of binary relations in
   first-order logic.
*)
russellParadox == ~\E x : \A y : y \in x <=> ~(y \in y)

contraposNeg(a,b) == (a <=> ~b) => (b => ~a)  PROPO_TAUTO contraposNeg

THEOREM russellParadox
PROOF
VARIABLES x,y,a,h,b;
\* If such a set x existed, it would both belong and not belong to itself
(\A y : y \in x <=> ~(y \in y)) => (x \in x <=> ~(x \in x))   BECAUSE \A(y <- x);
~(\A y : y \in x <=> ~(y \in y))   BECAUSE ContradictionEquiv;
\A x : ~(\A y : y \in x <=> ~(y \in y))   BECAUSE GENERALIZATION;
(\E x : \A y : y \in x <=> ~(y \in y)) <=> ~(\A x : ~(\A y : y \in x <=> ~(y \in y)))  BECAUSE Q_SCHEME;
(\A x : ~(\A y : y \in x <=> ~(y \in y))) => ~(\E x : \A y : y \in x <=> ~(y \in y))  BECAUSE contraposNeg;
russellParadox   BECAUSE MODUS_PONENS;
QED

(*
   We still don't have axioms to define what sets are.
   The proof of Russell's paradox works with any binary relation,
   for example < in Peano arithmetic : it then states that there
   is no number greater than all others.

   Russell's paradox constrains what axioms we can take for sets.
   If we are not careful, we can choose axioms proving its contrary.
*)

\* The first axiom for sets : two sets are equal iif they have the same
\* elements, and an element appears at most once in a set.
extensionality == \A a : \A b : (\A x : x \in a <=> x \in b) => a = b
AXIOM extensionality

\* Inclusion of sets.
x \subseteq y == \A z : z \in x => z \in y

bothInclusions == \A a : \A b : (a \subseteq b /\ b \subseteq a) => a = b
THEOREM bothInclusions

PROOF
VARIABLES z, y, x, b, a;
extensionality   BECAUSE AXIOM;
(\A x : x \in a <=> x \in b) => a = b   BECAUSE \A(a <- a, b <- b);
h(a,b) == a \subseteq b /\ b \subseteq a;
(\A z : z \in a => z \in b) => (z \in a => z \in b)   BECAUSE \A(z <- z);
(\A z : z \in b => z \in a) => (z \in b => z \in a)   BECAUSE \A(z <- z);
h(a,b) => ((z \in a => z \in b) /\ (z \in b => z \in a))   BECAUSE MergeImplicationsAnd;
((z \in a => z \in b) /\ (z \in b => z \in a)) => (z \in a <=> z \in b)   BECAUSE IntroEquivAnd;
h(a,b) => (z \in a <=> z \in b)   BECAUSE TransitImplication;
\A z : h(a,b) => (z \in a <=> z \in b)   BECAUSE GENERALIZATION;
h(a,b) => (\A z : z \in a <=> z \in b)   BECAUSE Q_SCHEME;

(\A z : z \in a <=> z \in b) => (x \in a <=> x \in b)   BECAUSE \A(z <- x);
h(a,b) => (x \in a <=> x \in b)   BECAUSE TransitImplication;
\A x : h(a,b) => (x \in a <=> x \in b)   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in a <=> x \in b)   BECAUSE Q_SCHEME;
h(a,b) => a = b    BECAUSE TransitImplication;
bothInclusions   BECAUSE GENERALIZATION;
QED

inclusionInOneself == \A x : x \subseteq x
THEOREM inclusionInOneself
PROOF
VARIABLES z, x;
z \in x => z \in x   BECAUSE ImplyOneself;
\A z : z \in x => z \in x   BECAUSE GENERALIZATION;
inclusionInOneself   BECAUSE GENERALIZATION;
QED

(*
   The axiom scheme of separation. Although it can be deduced from the
   axiom scheme of replacement, we declare it for easier use
   and better tracking of where replacement is needed.

   The variable "a" can be free in F as in the axiom
       \A a : \E b : \A x : x \in b <=> (x \in a /\ x \subseteq a)
   However we exclude b from the free variables of F, to avoid the
   self-contradicting formula
       \A a : \E b : \A x : x \in b <=> (x \in a /\ x \notin b)
   t is contrary to Russell's paradox so we cannot have it as an axiom.

   Here is the derivation of the separation axiom scheme from the
   replacement axiom scheme :
   sep(x,y) == x = y /\ F(x)
   sep(x,y) /\ sep(x,y') => x = y /\ x = y'   BECAUSE PT;
   (x = y /\ x = y') => y = y'   BECAUSE AXIOM_SCHEME;
   sep(x,y) /\ sep(x,y') => y = y'   BECAUSE TransitImplication;
   \A x : \A y : \A y' : sep(x,y) /\ sep(x,y') => y = y'   BECAUSE GENERALIZATION;
   \* replacement scheme : by hypothesis formula F has no free occurrences of variable b
   (\A x : \A y : \A y' : sep(x,y) /\ sep(x,y') => y = y')
      => \A a : \E b : \A x : x \in b <=> \E y : y \in a /\ sep(x,y)   BECAUSE AXIOM_SCHEME;
   \A a : \E b : \A x : x \in b <=> \E y : y \in a /\ sep(x,y)   BECAUSE MODUS_PONENS;
*)
separation(F) == \A a : \E b : \A x : x \in b <=> (x \in a /\ F)
AXIOM_SCHEME BOUND_VAR(b) separation

(*
   The full axiom scheme of replacement : the image of a set by
   a functional relation is a set. It can be interpreted as a size
   guard, the image b is smaller than the starting set a, so
   there is no risk of b exploding outside the limits of sets.
*)
replacement(F) == (\A x : \A y : \A z : (F /\ F(y <- z)) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ F)
AXIOM_SCHEME BOUND_VAR(b) replacement


(*
   There exists a set such that any set is not a member of it. It is called
   the empty set. This empty set is rather mysterious : it exists so it is
   something, however there is nothing in it, so by extensionality it should
   be nothing too.

   Besides, we will see with the axiom of foundation that this empty set is
   the atom, the elementary building block for all sets, ie all mathematics.
*)
{} == CHOOSE b : \A x : x \notin b
emptySetExists == \A x : x \notin {}

THEOREM emptySetExists
PROOF
VARIABLES x, a, b;
\* Construct the empty set by the separation axiom with a contradictory formula
\A a : \E b : \A x : x \in b <=> (x \in a /\ x # x)   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in a /\ x # x)   BECAUSE \A(a <- a);

\* Take one such set b and show no set x can be in it
chooseB(a) == CHOOSE b : \A x : x \in b <=> (x \in a /\ x # x);
(\A x : x \in chooseB(a) <=> (x \in a /\ x # x)) <=> \E b : \A x : x \in b <=> (x \in a /\ x # x)
   BECAUSE CHOOSE chooseB(a);
\A x : x \in chooseB(a) <=> (x \in a /\ x # x)   BECAUSE MODUS_PONENS;
x \in chooseB(a) <=> (x \in a /\ x # x)   BECAUSE \A(x <- x);
x \in chooseB(a) => (x \in a /\ x # x)   BECAUSE EquivToImpl;
(x \in a /\ x # x) => x # x   BECAUSE DropAndLeft;
x \in chooseB(a) => x # x   BECAUSE TransitImplication;
~(x # x) => x \notin chooseB(a)   BECAUSE Contraposition;
x = x   BECAUSE E_SCHEME;
~(x # x)   BECAUSE IntroNotNot;
x \notin chooseB(a)   BECAUSE MODUS_PONENS;
\A x : x \notin chooseB(a)   BECAUSE GENERALIZATION;

\* Conclude chooseB(a) is the empty set
(\A x : x \notin {}) <=> \E b : \A x : x \notin b   BECAUSE CHOOSE {};
\E b : \A x : x \notin b   BECAUSE \E(b <- chooseB(a));
emptySetExists   BECAUSE MODUS_PONENS;
QED

equivImpossible(a,b) == ~b => (~a => (a <=> b))
PROPO_TAUTO equivImpossible

emptySetUnique == \A a : (\A x : x \notin a) => a = {}
THEOREM emptySetUnique
PROOF
VARIABLES a,b,x;
emptySetExists BECAUSE THEOREM;
x \notin {} BECAUSE \A(x <- x);
(x \notin {}) => ((x \notin a) => (x \in a <=> x \in {}))   BECAUSE equivImpossible;
(x \notin a) => (x \in a <=> x \in {})  BECAUSE MODUS_PONENS;
(\A x : x \notin a) => (\A x : x \in a <=> x \in {})   BECAUSE Q_SCHEME;

extensionality   BECAUSE AXIOM;
(\A x : x \in a <=> x \in {}) => a = {}   BECAUSE \A(a <- a, b <- {});
(\A x : x \notin a) => a = {}   BECAUSE TransitImplication;
\A a : (\A x : x \notin a) => a = {}   BECAUSE GENERALIZATION;
QED

emptyIncludedInAny == \A x : {} \subseteq x
THEOREM emptyIncludedInAny
PROOF
VARIABLES x,z;
emptySetExists   BECAUSE THEOREM;
z \notin {}   BECAUSE \A(x <- z);
z \in {} => z \in x   BECAUSE Explosion;
{} \subseteq x   BECAUSE GENERALIZATION;
emptyIncludedInAny   BECAUSE GENERALIZATION;
QED

includedInEmpty == \A x : x \subseteq {} => x = {}
THEOREM includedInEmpty
PROOF
VARIABLES a,b,x;
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq x   BECAUSE \A(x <- x);
bothInclusions BECAUSE THEOREM;
(x \subseteq {} /\ {} \subseteq x) => x = {}   BECAUSE \A(a <- x, b <- {});
x \subseteq {} => (x \subseteq {} /\ {} \subseteq x)   BECAUSE IntroAndLeft;
x \subseteq {} => x = {}   BECAUSE TransitImplication;
includedInEmpty   BECAUSE GENERALIZATION;
QED

notEmpty == \A x : x # {} => \E z : z \in x
THEOREM notEmpty
PROOF
VARIABLES a,x,z;
emptySetUnique BECAUSE THEOREM;
(\A x : x \notin a) => a = {} BECAUSE \A(a <- a);
(\A z : z \notin a) => x \notin a   BECAUSE \A(z <- x);
\A x : (\A z : z \notin a) => x \notin a   BECAUSE GENERALIZATION;
(\A z : z \notin a) => \A x : x \notin a   BECAUSE Q_SCHEME;
(\A z : z \notin a) => a = {} BECAUSE TransitImplication;
(\E z : z \in a) <=> ~(\A z : z \notin a)   BECAUSE Q_SCHEME;
~(\A z : z \notin a) => (\E z : z \in a)   BECAUSE EquivToImplReverse;
a # {} => ~(\A z : z \notin a) BECAUSE Contraposition;
a # {} => \E z : z \in a   BECAUSE TransitImplication;
\A a : a # {} => \E z : z \in a   BECAUSE GENERALIZATION;
x # {} => \E z : z \in x   BECAUSE \A(a <- x);
notEmpty   BECAUSE GENERALIZATION;
QED

pullHypo(a,b,c) == (a <=> (b /\ c)) => (b => (a <=> c))
PROPO_TAUTO pullHypo

\* All sets together are too big to form a set. We say instead the class of sets.
noSetOfSets == ~\E a : \A y : y \in a
THEOREM noSetOfSets
PROOF
VARIABLES a,b,x,y;
\* If such a set existed, by separation we would create the forbidden set of the Russell's paradox
\A a : \E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))   BECAUSE \A(a <- a);

\* Rename bound variable x -> y
(\A x : x \in b <=> (x \in a /\ ~(x \in x))) => (y \in b <=> (y \in a /\ ~(y \in y)))   BECAUSE \A(x <- y);
\A y : (\A x : x \in b <=> (x \in a /\ ~(x \in x))) => (y \in b <=> (y \in a /\ ~(y \in y)))   BECAUSE GENERALIZATION;
(\A x : x \in b <=> (x \in a /\ ~(x \in x))) => (\A y : y \in b <=> (y \in a /\ ~(y \in y)))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))) => \E b : \A y : y \in b <=> (y \in a /\ ~(y \in y))   BECAUSE Q_SCHEME;
\E b : \A y : y \in b <=> (y \in a /\ ~(y \in y))   BECAUSE MODUS_PONENS;

\* Force the hypothesis that a is the set of all sets
(y \in b <=> (y \in a /\ ~(y \in y))) => ((y \in a) => (y \in b <=> ~(y \in y)))   BECAUSE pullHypo;
(\A y : y \in b <=> (y \in a /\ ~(y \in y))) => (\A y : (y \in a) => (y \in b <=> ~(y \in y)))   BECAUSE Q_SCHEME;
(\A y : (y \in a) => (y \in b <=> ~(y \in y))) => ((\A y : y \in a) => (\A y : y \in b <=> ~(y \in y)))   BECAUSE Q_SCHEME;
(\A y : y \in b <=> (y \in a /\ ~(y \in y))) => ((\A y : y \in a) => (\A y : y \in b <=> ~(y \in y)))   BECAUSE TransitImplication;
(\E b : \A y : y \in b <=> (y \in a /\ ~(y \in y))) => (\E b : (\A y : y \in a) => (\A y : y \in b <=> ~(y \in y)))   BECAUSE Q_SCHEME;
\E b : (\A y : y \in a) => (\A y : y \in b <=> ~(y \in y))   BECAUSE MODUS_PONENS;
(\A y : y \in a) => (\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E a : \A y : y \in a) => (\E a : \E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E a : \E b : \A y : y \in b <=> ~(y \in y)) => (\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E a : \A y : y \in a) => \E b : \A y : y \in b <=> ~(y \in y)   BECAUSE TransitImplication;

~(\E b : \A y : y \in b <=> ~(y \in y)) => noSetOfSets   BECAUSE Contraposition;

\* Rename bound variables of russelParadox to prove the previous hypothesis
russellParadox   BECAUSE THEOREM;
(\E x : \A y : y \in x <=> ~(y \in y)) <=> ~(\A x : ~\A y : y \in x <=> ~(y \in y))   BECAUSE Q_SCHEME;
~(\A x : ~\A y : y \in x <=> ~(y \in y)) => (\E x : \A y : y \in x <=> ~(y \in y))   BECAUSE EquivToImplReverse;
russellParadox => ~~(\A x : ~\A y : y \in x <=> ~(y \in y))   BECAUSE Contraposition;
~~(\A x : ~\A y : y \in x <=> ~(y \in y))   BECAUSE MODUS_PONENS;
\A x : ~\A y : y \in x <=> ~(y \in y)   BECAUSE DropNotNot;
~\A y : y \in b <=> ~(y \in y)   BECAUSE \A(x <- b);
\A b : ~\A y : y \in b <=> ~(y \in y)   BECAUSE GENERALIZATION;
(\E b : \A y : y \in b <=> ~(y \in y)) <=> ~(\A b : ~\A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> ~(y \in y)) => ~(\A b : ~\A y : y \in b <=> ~(y \in y))   BECAUSE EquivToImpl;
~~(\A b : ~\A y : y \in b <=> ~(y \in y)) => ~(\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Contraposition;
~~(\A b : ~\A y : y \in b <=> ~(y \in y))   BECAUSE IntroNotNot;
~(\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE MODUS_PONENS;
noSetOfSets  BECAUSE MODUS_PONENS;
QED

\* The union of a set x is the set of elements of elements of x.
UNION b == CHOOSE u : \A z : (z \in u <=> \E t : (t \in b /\ z \in t))
unionExists == \A b : \A z : (z \in UNION b <=> \E t : t \in b /\ z \in t)
AXIOM unionExists

inInUnion == \A a : \A b : \A c : (a \in b /\ b \in c) => a \in UNION c
THEOREM inInUnion
PROOF
VARIABLES a,b,c,t,z;
unionExists   BECAUSE AXIOM;
a \in UNION c <=> \E t : (t \in c /\ a \in t)   BECAUSE \A(b <- c, z <- a);
(\E t : t \in c /\ a \in t) => a \in UNION c   BECAUSE EquivToImplReverse;
(b \in c /\ a \in b) => \E t : t \in c /\ a \in t   BECAUSE \E(t <- b);
(b \in c /\ a \in b) => a \in UNION c   BECAUSE TransitImplication;
(a \in b /\ b \in c) => (b \in c /\ a \in b)   BECAUSE AndSymmetry;
(a \in b /\ b \in c) => a \in UNION c   BECAUSE TransitImplication;
inInUnion   BECAUSE GENERALIZATION;
QED

\* The intersection of two sets is the set of common elements
u \intersect v == CHOOSE b : \A x : x \in b <=> (x \in u /\ x \in v)

intersectionExists == \A u : \A v : \A x :
   x \in (u \intersect v) <=> (x \in u /\ x \in v)
THEOREM intersectionExists
PROOF
VARIABLES a,b,u,v,x;
\* By separation in u
(\A x : x \in (u \intersect v) <=> (x \in u /\ x \in v)) <=> \E b : (\A x : x \in b <=> (x \in u /\ x \in v))
   BECAUSE CHOOSE u \intersect v;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (x \in u /\ x \in v))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))   BECAUSE \A(a <- u);
(x \in u /\ x \in v) => x \in u   BECAUSE DropAndRight;
(x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (x \in b <=> (x \in u /\ x \in v))   BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (\A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (\E b : \A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (x \in u /\ x \in v)   BECAUSE MODUS_PONENS;
\A x : x \in (u \intersect v) <=> (x \in u /\ x \in v)   BECAUSE MODUS_PONENS;
intersectionExists   BECAUSE GENERALIZATION;
QED


SUBSET x == CHOOSE y : \A z : z \in y <=> z \subseteq x

powersetExists == \A x : \A z : z \in SUBSET x <=> z \subseteq x
AXIOM powersetExists

\* Representation of number 1 as a set
ordinalOne == SUBSET {}
elemOfOne == \A x : x \in ordinalOne <=> x = {}

THEOREM elemOfOne
PROOF
VARIABLES x,z;
powersetExists   BECAUSE AXIOM;
x \in ordinalOne <=> x \subseteq {}   BECAUSE \A(x <- {}, z <- x);

includedInEmpty   BECAUSE THEOREM;
x \subseteq {} => x = {}   BECAUSE \A(x <- x);
x \in ordinalOne => x \subseteq {}   BECAUSE EquivToImpl;
x \in ordinalOne => x = {}   BECAUSE TransitImplication;

\* Proof that {} \in ordinalOne
{} \in ordinalOne <=> {} \subseteq {}   BECAUSE \A(x <- {}, z <- {});
inclusionInOneself   BECAUSE THEOREM;
{} \subseteq {}   BECAUSE \A(x <- {});
{} \in ordinalOne   BECAUSE MODUS_PONENS;

x = {} => (x \in ordinalOne <=> {} \in ordinalOne)   BECAUSE E_SCHEME;
x = {} => x \in ordinalOne   BECAUSE ImplyEquivTrue;

x \in ordinalOne <=> x = {}   BECAUSE IntroEquiv;
elemOfOne   BECAUSE GENERALIZATION;
QED

ordinalTwo == SUBSET ordinalOne
elemOfTwo == \A x : x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)

THEOREM elemOfTwo
PROOF
VARIABLES a,b,x,z;
powersetExists   BECAUSE AXIOM;
x \in ordinalTwo <=> x \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne, z <- x);
x \in ordinalTwo => x \subseteq ordinalOne   BECAUSE EquivToImpl;

\* Proof of (x \subseteq ordinalOne /\ x # {}) => {} \in x
elemOfOne   BECAUSE THEOREM;
z \in ordinalOne <=> z = {}   BECAUSE \A(x <- z);
z \in ordinalOne => z = {}   BECAUSE EquivToImpl;
(z \in x => z \in ordinalOne) => (z \in x => z = {})   BECAUSE AddHypothesis;
z \in x => z \in x   BECAUSE ImplyOneself;
(z \in x => z = {}) => (z \in x => (z \in x /\ z = {}))   BECAUSE CombineImplicationsEnd;
(z \in x => z \in ordinalOne) => (z \in x => (z \in x /\ z = {}))   BECAUSE TransitImplication;
x \subseteq ordinalOne => (\A z : z \in x => (z \in x /\ z = {}))   BECAUSE Q_SCHEME;

notEmpty   BECAUSE THEOREM;
x # {} => \E z : z \in x   BECAUSE \A(x <- x);
(x \subseteq ordinalOne /\ x # {}) => ((\A z : z \in x => (z \in x /\ z = {})) /\ \E z : z \in x)   BECAUSE MergeImplicationsAnd;

(\A z : z \in x => (z \in x /\ z = {})) => ((\E z : z \in x) => \E z : z \in x /\ z = {})   BECAUSE Q_SCHEME;
((\A z : z \in x => (z \in x /\ z = {})) /\ (\E z : z \in x)) => \E z : z \in x /\ z = {}   BECAUSE HypoImplToAnd;
(x \subseteq ordinalOne /\ x # {}) => \E z : z \in x /\ z = {}   BECAUSE TransitImplication;

z = {} => (z \in x <=> {} \in x)   BECAUSE E_SCHEME;
(z \in x <=> {} \in x) => (z \in x => {} \in x)   BECAUSE EquivToImpl;
z = {} => (z \in x => {} \in x)   BECAUSE TransitImplication;
(z = {} /\ z \in x) => {} \in x   BECAUSE HypoImplToAnd;
(z \in x /\ z = {}) => (z = {} /\ z \in x)   BECAUSE AndSymmetry;
(z \in x /\ z = {}) => {} \in x   BECAUSE TransitImplication;
(\E z : z \in x /\ z = {}) => \E z : {} \in x   BECAUSE Q_SCHEME;
(\E z : {} \in x) => {} \in x   BECAUSE Q_SCHEME;
(x \subseteq ordinalOne /\ x # {}) => \E z : z \in x /\ z = {}   BECAUSE TransitImplication;
(x \subseteq ordinalOne /\ x # {}) => \E z : {} \in x   BECAUSE TransitImplication;
(x \subseteq ordinalOne /\ x # {}) => {} \in x   BECAUSE TransitImplication;

\* Proof of {} \in x => ordinalOne \subseteq x
z \in ordinalOne => (z \in x <=> {} \in x)   BECAUSE TransitImplication;
(z \in x <=> {} \in x) => ({} \in x => z \in x)   BECAUSE EquivToImplReverse;
z \in ordinalOne => ({} \in x => z \in x)   BECAUSE TransitImplication;
{} \in x => (z \in ordinalOne => z \in x)   BECAUSE SwitchHypos;
\A z : {} \in x => (z \in ordinalOne => z \in x)   BECAUSE GENERALIZATION;
{} \in x => ordinalOne \subseteq x   BECAUSE Q_SCHEME;
(x \subseteq ordinalOne /\ x # {}) => ordinalOne \subseteq x   BECAUSE TransitImplication;

(x \subseteq ordinalOne /\ x # {}) => x \subseteq ordinalOne   BECAUSE DropAndRight;
(x \subseteq ordinalOne /\ x # {}) => (x \subseteq ordinalOne /\ ordinalOne \subseteq x)   BECAUSE CombineImplicationsEnd;
bothInclusions BECAUSE THEOREM;
(x \subseteq ordinalOne /\ ordinalOne \subseteq x) => x = ordinalOne   BECAUSE \A(a <- x, b <- ordinalOne);
(x \subseteq ordinalOne /\ x # {}) => x = ordinalOne   BECAUSE TransitImplication;

x \subseteq ordinalOne => (x # {} => x = ordinalOne)   BECAUSE HypoAndToImpl;
x \in ordinalTwo => (x # {} => x = ordinalOne)   BECAUSE TransitImplication;
x \in ordinalTwo => (x = {} \/ x = ordinalOne)   BECAUSE ImplyExcludedMiddle;

\* Reverse proof
inclusionInOneself   BECAUSE THEOREM;
ordinalOne \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne);
x \subseteq ordinalOne => x \in ordinalTwo   BECAUSE EquivToImplReverse;
x = ordinalOne => (x \subseteq ordinalOne <=> ordinalOne \subseteq ordinalOne)   BECAUSE E_SCHEME;
x = ordinalOne => x \subseteq ordinalOne   BECAUSE ImplyEquivTrue;
x = ordinalOne => x \in ordinalTwo   BECAUSE TransitImplication;

x \in ordinalOne <=> x = {}   BECAUSE \A(x <- x);
x = {} => (x \subseteq ordinalOne <=> {} \subseteq ordinalOne)   BECAUSE E_SCHEME;
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne);
x = {} => x \subseteq ordinalOne   BECAUSE ImplyEquivTrue;
x = {} => x \in ordinalTwo   BECAUSE TransitImplication;

(x = {} \/ x = ordinalOne) => x \in ordinalTwo   BECAUSE CombineImplicationsStart;
x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)   BECAUSE IntroEquiv;
elemOfTwo   BECAUSE GENERALIZATION;
QED

(* Singleton and pair operators *)
{ a } == CHOOSE b : \A x : x \in b <=> x = a

singletonExists == \A a : \A x : x \in { a } <=> x = a
THEOREM singletonExists
PROOF
VARIABLES a,b,c,x,z;
\* Proof by separation in the powerset of a
(\A x : x \in { a } <=> x = a) <=> \E b : \A x : x \in b <=> x = a   BECAUSE CHOOSE { a };
\A a : \E b : \A x : x \in b <=> (x \in a /\ x = c)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = c)   BECAUSE \A(a <- SUBSET a);
\A c : \E b : \A x : x \in b <=> (x \in SUBSET a /\ x = c)   BECAUSE GENERALIZATION;
\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = a)   BECAUSE \A(c <- a);

\* Proof that (x \in SUBSET a /\ x = a) <=> x = a
(x \in SUBSET a /\ x = a) => x = a   BECAUSE DropAndLeft;
x = a => (x \in SUBSET a <=> a \in SUBSET a)   BECAUSE E_SCHEME;
inclusionInOneself   BECAUSE THEOREM;
a \subseteq a   BECAUSE \A(x <- a);
powersetExists   BECAUSE AXIOM;
a \in SUBSET a <=> a \subseteq a   BECAUSE \A(x <- a, z <- a);
a \in SUBSET a   BECAUSE MODUS_PONENS;
x = a => x \in SUBSET a   BECAUSE ImplyEquivTrue;
x = a => x = a   BECAUSE ImplyOneself;
x = a => (x \in SUBSET a /\ x = a)   BECAUSE CombineImplicationsEnd;
x = a <=> (x \in SUBSET a /\ x = a)   BECAUSE IntroEquiv;

(x \in b <=> (x \in SUBSET a /\ x = a)) => (x \in b <=> x = a)   BECAUSE TransitEquiv2;
(\A x : x \in b <=> (x \in SUBSET a /\ x = a)) => (\A x : x \in b <=> x = a)   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = a)) => (\E b : \A x : x \in b <=> x = a)   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> x = a)   BECAUSE MODUS_PONENS;
(\A x : x \in { a } <=> x = a)   BECAUSE MODUS_PONENS;
singletonExists   BECAUSE GENERALIZATION;
QED

{ c, d } == CHOOSE b : \A y : y \in b <=> (y = c \/ y = d)

pairExists == \A c : \A d : \A y : y \in { c, d } <=> (y = c \/ y = d)
THEOREM pairExists
PROOF
VARIABLES a,b,c,d,i,j,x,y,z;
\* Proof by replacement of ordinalTwo with the functional {} -> c, ordinalOne -> d
(\A y : y \in { c, d } <=> (y = c \/ y = d)) <=> \E b : \A y : y \in b <=> (y = c \/ y = d)   BECAUSE CHOOSE {c, d};
F(c,d,x,y) == (x = {} /\ y = c) \/ (x = ordinalOne /\ y = d);
(\A x : \A y : \A z : (((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d))
      	       	        /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE AXIOM_SCHEME;

   \* Proof that F is functional
(F(c,d,x,y) /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d)))
   => ((F(c,d,x,y) /\ (x = {} /\ z = c)) \/ (F(c,d,x,y) /\ (x = ordinalOne /\ z = d)))   BECAUSE DistribAndOrLeft;
\* Case x = {}
(F(c,d,x,y) /\ (x = {} /\ z = c))
   => (((x = {} /\ y = c) /\ (x = {} /\ z = c)) \/ ((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)))   BECAUSE DistribAndOrRight;
(x = {} /\ z = c) => x = {}   BECAUSE DropAndRight;
(x = ordinalOne /\ y = d) => x = ordinalOne   BECAUSE DropAndRight;
((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)) => (x = ordinalOne /\ x = {})   BECAUSE MergeImplicationsAnd;
(x = ordinalOne /\ x = {}) => ordinalOne = {}   BECAUSE E_SCHEME;
((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)) => ordinalOne = {}   BECAUSE TransitImplication;
(x = {} /\ y = c) => y = c   BECAUSE DropAndLeft;
(x = {} /\ z = c) => z = c   BECAUSE DropAndLeft;
((x = {} /\ y = c) /\ (x = {} /\ z = c)) => (y = c /\ z = c)   BECAUSE MergeImplicationsAnd;
(y = c /\ z = c) => y = z   BECAUSE E_SCHEME;
((x = {} /\ y = c) /\ (x = {} /\ z = c)) => y = z   BECAUSE TransitImplication;
(((x = {} /\ y = c) /\ (x = {} /\ z = c)) \/ ((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c))) => ((y = z) \/ (ordinalOne = {}))   BECAUSE MergeImplicationsOr;
(F(c,d,x,y) /\ (x = {} /\ z = c)) => (y = z \/ ordinalOne = {})   BECAUSE TransitImplication;

\* Proof that ordinalOne # {}
powersetExists   BECAUSE AXIOM;
{} \in ordinalOne <=> {} \subseteq {}   BECAUSE \A(x <- {}, z <- {});
inclusionInOneself   BECAUSE THEOREM;
{} \subseteq {}   BECAUSE \A(x <- {});
{} \in ordinalOne   BECAUSE MODUS_PONENS;
emptySetExists   BECAUSE THEOREM;
\A i : \A j : i = j => ((\A x : x \notin i) <=> (\A x : x \notin j))   BECAUSE E_SCHEME;
ordinalOne = {} => ((\A x : x \notin ordinalOne) <=> emptySetExists)   BECAUSE \A(i <- ordinalOne, j <- {});
ordinalOne = {} => (\A x : x \notin ordinalOne)   BECAUSE ImplyEquivTrue;
(\A x : x \notin ordinalOne) => {} \notin ordinalOne   BECAUSE \A(x <- {});
ordinalOne = {} => {} \notin ordinalOne   BECAUSE TransitImplication;
~({} \notin ordinalOne) => ordinalOne # {}   BECAUSE Contraposition;
{} \in ordinalOne => ~({} \notin ordinalOne)   BECAUSE IntroNotNot;
{} \in ordinalOne => ordinalOne # {}   BECAUSE TransitImplication;
ordinalOne # {}   BECAUSE MODUS_PONENS;

(y = z \/ ordinalOne = {}) => y = z   BECAUSE OrFalseStart;
(F(c,d,x,y) /\ (x = {} /\ z = c)) => y = z   BECAUSE TransitImplication;

\* Case x = ordinalOne
(F(c,d,x,y) /\ (x = ordinalOne /\ z = d))
   => (((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) \/ ((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)))   BECAUSE DistribAndOrRight;
(x = {} /\ y = c) => x = {}   BECAUSE DropAndRight;
(x = ordinalOne /\ z = d) => x = ordinalOne   BECAUSE DropAndRight;
((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) => (x = {} /\ x = ordinalOne)   BECAUSE MergeImplicationsAnd;
(x = {} /\ x = ordinalOne) => {} = ordinalOne   BECAUSE E_SCHEME;
((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) => {} = ordinalOne   BECAUSE TransitImplication;
(x = ordinalOne /\ y = d) => y = d   BECAUSE DropAndLeft;
(x = ordinalOne /\ z = d) => z = d   BECAUSE DropAndLeft;
((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)) => (y = d /\ z = d)   BECAUSE MergeImplicationsAnd;
(y = d /\ z = d) => y = z   BECAUSE E_SCHEME;
((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)) => y = z   BECAUSE TransitImplication;
(((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) \/ ((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d))) => ({} = ordinalOne \/ y = z)   BECAUSE MergeImplicationsOr;
(F(c,d,x,y) /\ (x = ordinalOne /\ z = d)) => ({} = ordinalOne \/ y = z)   BECAUSE TransitImplication;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
ordinalOne # {} => {} # ordinalOne   BECAUSE Contraposition;
{} # ordinalOne   BECAUSE MODUS_PONENS;
({} = ordinalOne \/ y = z) => y = z   BECAUSE FalseOrStart;
(F(c,d,x,y) /\ (x = ordinalOne /\ z = d)) => y = z   BECAUSE TransitImplication;

((F(c,d,x,y) /\ (x = {} /\ z = c)) \/ (F(c,d,x,y) /\ (x = ordinalOne /\ z = d))) => y = z   BECAUSE CombineImplicationsStart;
(F(c,d,x,y) /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z   BECAUSE TransitImplication;
\A x : \A y : \A z : (F(c,d,x,y) /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z   BECAUSE GENERALIZATION;
\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ F(c,d,x,y)   BECAUSE MODUS_PONENS;
\E b : \A y : y \in b <=> \E x : x \in ordinalTwo /\ F(c,d,x,y)   BECAUSE \A(a <- ordinalTwo);

   \* Proof that b works, ie that (\E x : x \in ordinalTwo /\ F) <=> (y = c \/ y = d)
elemOfTwo   BECAUSE THEOREM;
x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)   BECAUSE \A(x <- x);
x \in ordinalTwo => (x = {} \/ x = ordinalOne)   BECAUSE EquivToImpl;
(x = {} \/ x = ordinalOne) => x \in ordinalTwo   BECAUSE EquivToImplReverse;

F(c,d,x,y) => (y = c \/ y = d)   BECAUSE MergeImplicationsOr;
(x \in ordinalTwo /\ F(c,d,x,y)) => F(c,d,x,y)   BECAUSE DropAndLeft;
(x \in ordinalTwo /\ F(c,d,x,y)) => (y = c \/ y = d)   BECAUSE TransitImplication;
(\E x : x \in ordinalTwo /\ F(c,d,x,y)) => (\E x : y = c \/ y = d)   BECAUSE Q_SCHEME;
(\E x : y = c \/ y = d) => (y = c \/ y = d)   BECAUSE Q_SCHEME;
(\E x : x \in ordinalTwo /\ F(c,d,x,y)) => (y = c \/ y = d)   BECAUSE TransitImplication;

\* Case y = c
({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))) => (\E x : x \in ordinalTwo /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE \E(x <- {});
{} = {}   BECAUSE E_SCHEME;
y = c => ({} = {} /\ y = c)   BECAUSE IntroAndRight;
({} = {} /\ y = c) => (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))   BECAUSE PT9;
y = c => (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))   BECAUSE TransitImplication;
x = {} => (x = {} \/ x = ordinalOne)   BECAUSE PT9;
x = {} => x \in ordinalTwo   BECAUSE TransitImplication;
\A x : x = {} => x \in ordinalTwo   BECAUSE GENERALIZATION;
{} = {} => {} \in ordinalTwo   BECAUSE \A(x <- {});
{} \in ordinalTwo   BECAUSE MODUS_PONENS;
(({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))
   => ({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d)))   BECAUSE IntroAndRight;
y = c => ({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d)))   BECAUSE TransitImplication;
y = c => (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE TransitImplication;

\* Case y = d
(ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))) => (\E x : x \in ordinalTwo /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE \E(x <- ordinalOne);
ordinalOne = ordinalOne   BECAUSE E_SCHEME;
y = d => (ordinalOne = ordinalOne /\ y = d)   BECAUSE IntroAndRight;
(ordinalOne = ordinalOne /\ y = d) => ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))   BECAUSE IntroOrRight;
y = d => ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))   BECAUSE TransitImplication;
x = ordinalOne => (x = {} \/ x = ordinalOne)   BECAUSE IntroOrRight;
x = ordinalOne => x \in ordinalTwo   BECAUSE TransitImplication;
\A x : x = ordinalOne => x \in ordinalTwo   BECAUSE GENERALIZATION;
ordinalOne = ordinalOne => ordinalOne \in ordinalTwo   BECAUSE \A(x <- ordinalOne);
ordinalOne \in ordinalTwo   BECAUSE MODUS_PONENS;
((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))
   => (ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d)))   BECAUSE IntroAndRight;
y = d => (ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d)))   BECAUSE TransitImplication;
y = d => (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE TransitImplication;

(y = c \/ y = d) => (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE CombineImplicationsStart;
(y = c \/ y = d) <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE IntroEquiv;
(y \in b <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))) => (y \in b <=> (y = c \/ y = d))   BECAUSE TransitEquiv2;
(\A y : y \in b <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))) => (\A y : y \in b <=> (y = c \/ y = d))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))) => (\E b : \A y : y \in b <=> (y = c \/ y = d))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> (y = c \/ y = d))   BECAUSE MODUS_PONENS;
\A y : y \in { c, d } <=> (y = c \/ y = d)   BECAUSE MODUS_PONENS;
pairExists   BECAUSE GENERALIZATION;
QED

pairSymmetry == \A a : \A b : {a, b} = {b, a}
THEOREM pairSymmetry
PROOF
VARIABLES a,b,c,d,x,y;
pairExists   BECAUSE THEOREM;
x \in { a, b } <=> (x = a \/ x = b)   BECAUSE \A(c <- a, d <- b, y <- x);
x \in { b, a } <=> (x = b \/ x = a)   BECAUSE \A(c <- b, d <- a, y <- x);
(x = a \/ x = b) => (x = b \/ x = a)   BECAUSE OrSymmetry;
(x = b \/ x = a) => (x = a \/ x = b)   BECAUSE OrSymmetry;
(x = a \/ x = b) <=> (x = b \/ x = a)   BECAUSE IntroEquiv;
x \in { a, b } <=> (x = b \/ x = a)   BECAUSE   TransitEquiv;
x \in { a, b } <=> x \in { b, a }   BECAUSE   TransitEquiv2;
\A x : x \in { a, b } <=> x \in { b, a }   BECAUSE   GENERALIZATION;
extensionality   BECAUSE AXIOM;
(\A x : x \in {a,b} <=> x \in {b,a}) => {a,b} = {b,a}   BECAUSE \A(a <- {a,b}, b <- {b,a});
{a,b} = {b,a}   BECAUSE MODUS_PONENS;
pairSymmetry   BECAUSE GENERALIZATION;
QED

sameFirstPairs == \A a : \A b : \A c : {a,b} = {a,c} => b = c
THEOREM sameFirstPairs
PROOF
VARIABLES a,b,c,d,x,y;
pairExists   BECAUSE THEOREM;
b \in { a, b } <=> (b = a \/ b = b)   BECAUSE \A(c <- a, d <- b, y <- b);
b = b   BECAUSE E_SCHEME;
b = a \/ b = b   BECAUSE IntroOrRight;
b \in {a,b}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (b \in x <=> b \in y)   BECAUSE E_SCHEME;
{a,b} = {a,c} => (b \in {a,b} <=> b \in {a,c})   BECAUSE \A(x <- {a,b}, y <- {a,c});
{a,b} = {a,c} => b \in {a,c}   BECAUSE ImplyTrueEquiv;
b \in { a,c } <=> (b = a \/ b = c)   BECAUSE \A(c <- a, d <- c, y <- b);
b \in { a,c } => (b = a \/ b = c)   BECAUSE EquivToImpl;
{a,b} = {a,c} => (b = a \/ b = c)   BECAUSE TransitImplication;

c \in { a, c } <=> (c = a \/ c = c)   BECAUSE \A(c <- a, d <- c, y <- c);
c = c   BECAUSE E_SCHEME;
c = a \/ c = c   BECAUSE IntroOrRight;
c \in {a,c}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (c \in x <=> c \in y)   BECAUSE E_SCHEME;
{a,b} = {a,c} => (c \in {a,b} <=> c \in {a,c})   BECAUSE \A(x <- {a,b}, y <- {a,c});
{a,b} = {a,c} => c \in {a,b}   BECAUSE ImplyEquivTrue;
c \in { a,b } <=> (c = a \/ c = b)   BECAUSE \A(c <- a, d <- b, y <- c);
c \in { a,b } => (c = a \/ c = b)   BECAUSE EquivToImpl;
{a,b} = {a,c} => (c = a \/ c = b)   BECAUSE TransitImplication;
c = b => b = c   BECAUSE E_SCHEME;
c = a => c = a   BECAUSE ImplyOneself;
(c = a \/ c = b) => (c = a \/ b = c)  BECAUSE MergeImplicationsOr;
{a,b} = {a,c} => (c = a \/ b = c)  BECAUSE TransitImplication;

{a,b} = {a,c} => ((b = a \/ b = c) /\ (c = a \/ b = c))   BECAUSE CombineImplicationsEnd;
((b = a \/ b = c) /\ (c = a \/ b = c)) => ((b = a /\ c = a) \/ b = c)  BECAUSE FactorOrAndRight;
{a,b} = {a,c} => ((b = a /\ c = a) \/ b = c)  BECAUSE TransitImplication;
(b = a /\ c = a) => b = c   BECAUSE E_SCHEME;
b = c => b = c   BECAUSE ImplyOneself;
((b = a /\ c = a) \/ b = c) => (b = c \/ b = c)   BECAUSE MergeImplicationsOr;
{a,b} = {a,c} => (b = c \/ b = c)  BECAUSE TransitImplication;
(b = c \/ b = c) => b = c   BECAUSE OrSelf;
{a,b} = {a,c} => b = c  BECAUSE TransitImplication;
sameFirstPairs   BECAUSE GENERALIZATION;
QED

pairInclusion == \A x : \A y : \A t : (x \in t /\ y \in t) => {x,y} \subseteq t
THEOREM pairInclusion
PROOF
VARIABLES a,c,d,t,x,y,z;
z = x => (z \in t <=> x \in t)   BECAUSE E_SCHEME;
(z \in t <=> x \in t) => (x \in t => z \in t)   BECAUSE EquivToImplReverse;
z = x => (x \in t => z \in t)   BECAUSE TransitImplication;
(z = x /\ x \in t) => z \in t   BECAUSE HypoImplToAnd;
(x \in t /\ z = x) => (z = x /\ x \in t)   BECAUSE AndSymmetry;
(x \in t /\ z = x) => z \in t   BECAUSE TransitImplication;
x \in t => (z = x => z \in t)   BECAUSE HypoAndToImpl;
z = y => (z \in t <=> y \in t)   BECAUSE E_SCHEME;
(z \in t <=> y \in t) => (y \in t => z \in t)   BECAUSE EquivToImplReverse;
z = y => (y \in t => z \in t)   BECAUSE TransitImplication;
(z = y /\ y \in t) => z \in t   BECAUSE HypoImplToAnd;
(y \in t /\ z = y) => (z = y /\ y \in t)   BECAUSE AndSymmetry;
(y \in t /\ z = y) => z \in t   BECAUSE TransitImplication;
y \in t => (z = y => z \in t)   BECAUSE HypoAndToImpl;

(x \in t /\ y \in t) => ((z = x => z \in t) /\ (z = y => z \in t))   BECAUSE MergeImplicationsAnd;
((z = x => z \in t) /\ (z = y => z \in t)) => ((z=x \/ z=y) => z \in t)   BECAUSE FactorAndImpl;
(x \in t /\ y \in t) => ((z = x \/ z = y) => z \in t)   BECAUSE TransitImplication;
pairExists   BECAUSE THEOREM;
z \in { x, y } <=> (z = x \/ z = y)   BECAUSE \A(c <- x, d <- y, y <- z);
z \in { x, y } => (z = x \/ z = y)   BECAUSE EquivToImpl;
((z = x \/ z = y) => z \in t) => (z \in {x,y} => z \in t)   BECAUSE TransitImplication;
(x \in t /\ y \in t) => (z \in {x,y} => z \in t)   BECAUSE TransitImplication;
\A z : (x \in t /\ y \in t) => (z \in {x,y} => z \in t)   BECAUSE GENERALIZATION;
(x \in t /\ y \in t) => {x,y} \subseteq t   BECAUSE Q_SCHEME;
pairInclusion   BECAUSE GENERALIZATION;
QED

\* The pair allows to define the union of two sets
x \union y == UNION { x, y }

unionFirstInc == \A x : \A y : x \subseteq (x \union y)
THEOREM unionFirstInc
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
x \in { x, y } <=> (x = x \/ x = y)   BECAUSE \A(c <- x, d <- y, y <- x);
x = x   BECAUSE E_SCHEME;
x = x \/ x = y   BECAUSE PT9;
x \in {x,y}   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
(z \in x /\ x \in {x,y}) => z \in (x \union y)   BECAUSE \A(a <- z, b <- x, c <- {x,y});
z \in x => (z \in x /\ x \in {x,y})   BECAUSE IntroAndLeft;
z \in x => z \in (x \union y)   BECAUSE TransitImplication;
unionFirstInc   BECAUSE GENERALIZATION;
QED

unionSecondInc == \A x : \A y : y \subseteq (x \union y)
THEOREM unionSecondInc
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
y \in { x, y } <=> (y = x \/ y = y)   BECAUSE \A(c <- x, d <- y, y <- y);
y = y   BECAUSE E_SCHEME;
y = x \/ y = y   BECAUSE IntroOrRight;
y \in {x,y}   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
(z \in y /\ y \in {x,y}) => z \in (x \union y)   BECAUSE \A(a <- z, b <- y, c <- {x,y});
z \in y => (z \in y /\ y \in {x,y})   BECAUSE IntroAndLeft;
z \in y => z \in (x \union y)   BECAUSE TransitImplication;
unionSecondInc   BECAUSE GENERALIZATION;
QED

unionSymmetry == \A x : \A y : (x \union y) = (y \union x)
THEOREM unionSymmetry
PROOF
VARIABLES a,b,x,y;
pairSymmetry   BECAUSE THEOREM;
{x, y} = {y, x}   BECAUSE \A(a <- x, b <- y);
\A x : \A y : x = y => (UNION x = UNION y)   BECAUSE E_SCHEME;
{x, y} = {y, x} => (UNION {x,y} = UNION {y,x})   BECAUSE \A(x <- {x,y}, y <- {y,x});
(x \union y) = (y \union x)   BECAUSE MODUS_PONENS;
unionSymmetry   BECAUSE GENERALIZATION;
QED

(* Tuples *)
<< c, d >> == { { c } , {c,d} }

\* This definition of binary tuples is a bit cryptic at first glance ;
\* it does yield the usual decomposition theorem :
tupleDecomposition == \A a : \A b : \A c : \A d : <<a, b>> = <<c, d>>  =>  (a = c /\ b = d)

THEOREM tupleDecomposition
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
y \in { { a } , {a,b} } <=> (y = {a} \/ y = {a,b})   BECAUSE \A(c <- {a}, d <- {a,b}, y <- y);
y \in { { c } , {c,d} } <=> (y = {c} \/ y = {c,d})   BECAUSE \A(c <- {c}, d <- {c,d}, y <- y);
\A x : \A z : x = z => (y \in x <=> y \in z)   BECAUSE E_SCHEME;
<<a,b>> = <<c,d>>  =>  (y \in <<a,b>> <=> y \in <<c,d>>)   BECAUSE \A(x <- <<a,b>>, z <- <<c,d>>);
(y = {a} \/ y = {a,b}) <=> y \in <<a,b>>   BECAUSE EquivSymmetry;
(y \in <<a,b>> <=> y \in <<c,d>>) => ((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>)   BECAUSE TransitEquiv;
<<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>)   BECAUSE TransitImplication;
(y = {c} \/ y = {c,d}) <=> y \in <<c,d>>   BECAUSE EquivSymmetry;
((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>) => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE TransitEquiv2;
<<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE TransitImplication;
\A y : <<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE GENERALIZATION;

\* Proof of <<a,b>> = <<c,d>> => a = c
<<a,b>> = <<c,d>> => (({c} = {a} \/ {c} = {a,b}) <=> ({c} = {c} \/ {c} = {c,d}))   BECAUSE \A(y <- {c});
{c} = {c}   BECAUSE E_SCHEME;
{c} = {c} \/ {c} = {c,d}   BECAUSE PT9;
<<a,b>> = <<c,d>> => ({c} = {a} \/ {c} = {a,b})   BECAUSE ImplyEquivTrue;

singletonExists   BECAUSE THEOREM;
c \in { a } <=> c = a   BECAUSE \A(a <- a, x <- c);
c \in { a } => c = a   BECAUSE EquivToImpl;
c \in { c } <=> c = c   BECAUSE \A(a <- c, x <- c);
c = c   BECAUSE E_SCHEME;
c \in { c }   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (c \in x <=> c \in y)   BECAUSE E_SCHEME;
{c} = {a} => (c \in {c} <=> c \in {a})   BECAUSE \A(x <- {c}, y <- {a});
(c \in {c} <=> c \in {a}) => c \in {a}   BECAUSE TrueEquiv;
{c} = {a} => c \in {a}   BECAUSE TransitImplication;
{c} = {a} => c = a   BECAUSE TransitImplication;
c = a => a = c   BECAUSE E_SCHEME;
{c} = {a} => a = c   BECAUSE TransitImplication;

a \in {a,b} <=> (a = a \/ a = b)   BECAUSE \A(c <- a, d <- b, y <- a);
a = a   BECAUSE E_SCHEME;
a = a \/ a = b   BECAUSE PT9;
a \in {a,b}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
{c} = {a,b} => (a \in {c} <=> a \in {a,b})   BECAUSE \A(x <- {c}, y <- {a,b});
(a \in {c} <=> a \in {a,b}) => a \in {c}   BECAUSE EquivTrue;
{c} = {a,b} => a \in {c}   BECAUSE TransitImplication;
a \in { c } <=> a = c   BECAUSE \A(a <- c, x <- a);
a \in { c } => a = c   BECAUSE EquivToImpl;
{c} = {a,b} => a = c   BECAUSE TransitImplication;

({c} = {a} \/ {c} = {a,b}) => a = c   BECAUSE CombineImplicationsStart;
<<a,b>> = <<c,d>> => a = c   BECAUSE TransitImplication;

\* Replace c by a
\A x : \A y : x = y => (<<a,b>> = <<x,d>> <=> <<a,b>> = <<y,d>>)   BECAUSE E_SCHEME;
a = c => (<<a,b>> = <<a,d>> <=> <<a,b>> = <<c,d>>)   BECAUSE \A(x <- a, y <- c);
<<a,b>> = <<c,d>> => (<<a,b>> = <<a,d>> <=> <<a,b>> = <<c,d>>)   BECAUSE TransitImplication;
<<a,b>> = <<c,d>> => <<a,b>> = <<a,d>>   BECAUSE ImplyEquivSelf;

\* Proof of <<a,b>> = <<a,d>> => b = d
sameFirstPairs   BECAUSE THEOREM;
{ {a},{a,b} } = {{a},{a,d}} => {a,b} = {a,d}   BECAUSE \A(a <- {a}, b <- {a,b}, c <- {a,d});
<<a,b>> = <<c,d>> => {a,b} = {a,d}   BECAUSE TransitImplication;
{ a,b } = {a,d} => b = d   BECAUSE \A(a <- a, b <- b, c <- d);
<<a,b>> = <<c,d>> => b = d   BECAUSE TransitImplication;
<<a,b>> = <<c,d>> => (a = c /\ b = d)   BECAUSE CombineImplicationsEnd;
tupleDecomposition   BECAUSE GENERALIZATION;
QED

IsCouple(c) == \E x : \E y : c = <<x,y>>
fst(c) == CHOOSE x : \E y : c = <<x,y>>
snd(c) == CHOOSE y : c = <<fst(c), y>>

tupleComposition == \A c : IsCouple(c) => c = <<fst(c), snd(c)>>
THEOREM tupleComposition
PROOF
VARIABLES c,x,y;
(\E y : c = <<fst(c),y>>) <=> \E x : \E y : c = <<x,y>>   BECAUSE CHOOSE fst(c);
IsCouple(c) => (\E y : c = <<fst(c),y>>)   BECAUSE EquivToImplReverse;
c = <<fst(c),snd(c)>> <=> \E y : c = <<fst(c),y>>   BECAUSE CHOOSE snd(c);
(\E y : c = <<fst(c),y>>) => c = <<fst(c),snd(c)>>   BECAUSE EquivToImplReverse;
IsCouple(c) => c = <<fst(c),snd(c)>>   BECAUSE TransitImplication;
tupleComposition   BECAUSE GENERALIZATION;
QED

fstExists == \A a : \A b : a = fst(<<a,b>>)
THEOREM fstExists
PROOF
VARIABLES a,b,c,d,x,y;
tupleComposition   BECAUSE THEOREM;
IsCouple(<<a,b>>) => <<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE \A(c <- <<a,b>>);
<<a,b>> = <<a,b>> => \E x : \E y : <<a,b>> = <<x,y>>   BECAUSE \E(x <- a, y <- b);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
IsCouple(<<a,b>>)   BECAUSE MODUS_PONENS;
<<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE MODUS_PONENS;
tupleDecomposition   BECAUSE THEOREM;
<<a, b>> = <<fst(<<a,b>>), snd(<<a,b>>)>> => (a = fst(<<a,b>>) /\ b = snd(<<a,b>>))   BECAUSE \A(a <- a, b <- b, c <- fst(<<a,b>>), d <- snd(<<a,b>>));
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE MODUS_PONENS;
a = fst(<<a,b>>)   BECAUSE DropAndRight;
fstExists   BECAUSE GENERALIZATION;
QED

sndExists == \A a : \A b : b = snd(<<a,b>>)
THEOREM sndExists
PROOF
VARIABLES a,b,c,d,x,y;
tupleComposition   BECAUSE THEOREM;
IsCouple(<<a,b>>) => <<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE \A(c <- <<a,b>>);
<<a,b>> = <<a,b>> => \E x : \E y : <<a,b>> = <<x,y>>   BECAUSE \E(x <- a, y <- b);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
IsCouple(<<a,b>>)   BECAUSE MODUS_PONENS;
<<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE MODUS_PONENS;
tupleDecomposition   BECAUSE THEOREM;
<<a, b>> = <<fst(<<a,b>>), snd(<<a,b>>)>> => (a = fst(<<a,b>>) /\ b = snd(<<a,b>>))   BECAUSE \A(a <- a, b <- b, c <- fst(<<a,b>>), d <- snd(<<a,b>>));
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE MODUS_PONENS;
b = snd(<<a,b>>)   BECAUSE DropAndLeft;
sndExists   BECAUSE GENERALIZATION;
QED


\* The class of oriented graphs, ie sets of couples.
IsGraph(g) == \A x : x \in g => IsCouple(x)

IsDefinedOn(g,x) == \E y : <<x,y>> \in g
Domain(g) == CHOOSE b : \A x : x \in b <=> IsDefinedOn(g,x)
Image(g) == CHOOSE b : \A x : x \in b <=> \E y : <<y,x>> \in g
IsReflexive(g) == \A u : u \in g => (<<fst(u), fst(u)>> \in g /\ <<snd(u), snd(u)>> \in g)

nodesInUnionUnion == \A x : \A y : \A g : <<x,y>> \in g
   => (x \in UNION UNION g /\ y \in UNION UNION g)
THEOREM nodesInUnionUnion
PROOF
VARIABLES a,b,c,d,g,x,y;
pairExists   BECAUSE THEOREM;
{x} \in <<x,y>> <=> ({x} = {x} \/ {x} = {x,y})   BECAUSE \A(c <- {x}, d <- {x,y}, y <- {x});
{x} = {x}   BECAUSE E_SCHEME;
{x} = {x} \/ {x} = {x,y}   BECAUSE PT9;
{x} \in <<x,y>>   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
({x} \in <<x,y>> /\ <<x,y>> \in g) => {x} \in UNION g   BECAUSE \A(a <- {x}, b <- <<x,y>>, c <- g);
<<x,y>> \in g => ({x} \in <<x,y>> /\ <<x,y>> \in g)   BECAUSE IntroAndRight;
<<x,y>> \in g => {x} \in UNION g   BECAUSE TransitImplication;
singletonExists   BECAUSE THEOREM;
x \in { x } <=> x = x   BECAUSE \A(a <- x, x <- x);
x = x   BECAUSE E_SCHEME;
x \in { x }   BECAUSE MODUS_PONENS;
(x \in {x} /\ {x} \in UNION g) => x \in UNION UNION g   BECAUSE \A(a <- x, b <- {x}, c <- UNION g);
{x} \in UNION g => (x \in {x} /\ {x} \in UNION g)   BECAUSE IntroAndRight;
{x} \in UNION g => x \in UNION UNION g   BECAUSE TransitImplication;
<<x,y>> \in g => x \in UNION UNION g   BECAUSE TransitImplication;

{x,y} \in <<x,y>> <=> ({x,y} = {x} \/ {x,y} = {x,y})   BECAUSE \A(c <- {x}, d <- {x,y}, y <- {x,y});
{x,y} = {x,y}   BECAUSE E_SCHEME;
{x,y} = {x} \/ {x,y} = {x,y}   BECAUSE IntroOrRight;
{x,y} \in <<x,y>>   BECAUSE MODUS_PONENS;
({x,y} \in <<x,y>> /\ <<x,y>> \in g) => {x,y} \in UNION g   BECAUSE \A(a <- {x,y}, b <- <<x,y>>, c <- g);
<<x,y>> \in g => ({x,y} \in <<x,y>> /\ <<x,y>> \in g)   BECAUSE IntroAndRight;
<<x,y>> \in g => {x,y} \in UNION g   BECAUSE TransitImplication;
y \in { x, y } <=> (y = x \/ y = y)   BECAUSE \A(c <- x, d <- y, y <- y);
y = y   BECAUSE E_SCHEME;
y = x \/ y = y   BECAUSE IntroOrRight;
y \in { x, y }   BECAUSE MODUS_PONENS;
(y \in {x,y} /\ {x,y} \in UNION g) => y \in UNION UNION g   BECAUSE \A(a <- y, b <- {x,y}, c <- UNION g);
{x,y} \in UNION g => (y \in {x,y} /\ {x,y} \in UNION g)   BECAUSE IntroAndRight;
{x,y} \in UNION g => y \in UNION UNION g   BECAUSE TransitImplication;
<<x,y>> \in g => y \in UNION UNION g   BECAUSE TransitImplication;

<<x,y>> \in g => (x \in UNION UNION g /\ y \in UNION UNION g)   BECAUSE CombineImplicationsEnd;
nodesInUnionUnion   BECAUSE GENERALIZATION;
QED

domainExists == \A g : \A x : x \in Domain(g) <=> IsDefinedOn(g,x)
THEOREM domainExists
PROOF
VARIABLES a,b,g,x,y;
\* By separation in UNION UNION g
(\A x : x \in Domain(g) <=> IsDefinedOn(g,x))
   <=> \E b : \A x : x \in b <=> IsDefinedOn(g,x)   BECAUSE CHOOSE Domain(g);
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsDefinedOn(g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))   BECAUSE \A(a <- UNION UNION g);
(x \in UNION UNION g /\ IsDefinedOn(g,x)) => IsDefinedOn(g,x)   BECAUSE DropAndLeft;
nodesInUnionUnion   BECAUSE THEOREM;
<<x,y>> \in g => (x \in UNION UNION g /\ y \in UNION UNION g)   BECAUSE \A(x <- x, y <- y, g <- g);
(x \in UNION UNION g /\ y \in UNION UNION g) => x \in UNION UNION g   BECAUSE DropAndRight;
<<x,y>> \in g => x \in UNION UNION g   BECAUSE TransitImplication;
IsDefinedOn(g,x) => \E y : x \in UNION UNION g   BECAUSE Q_SCHEME;
(\E y : x \in UNION UNION g) => x \in UNION UNION g   BECAUSE Q_SCHEME;
IsDefinedOn(g,x) => x \in UNION UNION g   BECAUSE TransitImplication;
(x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (x \in b <=> IsDefinedOn(g,x))   BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (\A x : x \in b <=> IsDefinedOn(g,x))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (\E b : \A x : x \in b <=> IsDefinedOn(g,x))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> IsDefinedOn(g,x)   BECAUSE MODUS_PONENS;
\A x : x \in Domain(g) <=> IsDefinedOn(g,x)   BECAUSE MODUS_PONENS;
domainExists   BECAUSE GENERALIZATION;
QED

imageExists == \A g : \A x : x \in Image(g) <=> \E y : <<y,x>> \in g
THEOREM imageExists
PROOF
VARIABLES a,b,g,x,y;
\* By separation in UNION UNION g
(\A x : x \in Image(g) <=> \E y : <<y,x>> \in g)
   <=> (\E b : \A x : x \in b <=> \E y : <<y,x>> \in g)   BECAUSE CHOOSE Image(g);
\A a : \E b : \A x : x \in b <=> (x \in a /\ \E y : <<y,x>> \in g)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in UNION UNION g /\ \E y : <<y,x>> \in g)   BECAUSE \A(a <- UNION UNION g);
(x \in UNION UNION g /\ \E y : <<y,x>> \in g) => \E y : <<y,x>> \in g   BECAUSE DropAndLeft;
nodesInUnionUnion   BECAUSE THEOREM;
<<y,x>> \in g => (y \in UNION UNION g /\ x \in UNION UNION g)   BECAUSE \A(x <- y, y <- x, g <- g);
(y \in UNION UNION g /\ x \in UNION UNION g) => x \in UNION UNION g   BECAUSE DropAndLeft;
<<y,x>> \in g => x \in UNION UNION g   BECAUSE TransitImplication;
(\E y : <<y,x>> \in g) => \E y : x \in UNION UNION g   BECAUSE Q_SCHEME;
(\E y : x \in UNION UNION g) => x \in UNION UNION g   BECAUSE Q_SCHEME;
(\E y : <<y,x>> \in g) => x \in UNION UNION g   BECAUSE TransitImplication;
(x \in b <=> (x \in UNION UNION g /\ (\E y : <<y,x>> \in g))) => (x \in b <=> (\E y : <<y,x>> \in g))   BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in UNION UNION g /\ (\E y : <<y,x>> \in g))) => (\A x : x \in b <=> (\E y : <<y,x>> \in g))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in UNION UNION g /\ (\E y : <<y,x>> \in g))) => (\E b : \A x : x \in b <=> (\E y : <<y,x>> \in g))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (\E y : <<y,x>> \in g)   BECAUSE MODUS_PONENS;
\A x : x \in Image(g) <=> (\E y : <<y,x>> \in g)   BECAUSE MODUS_PONENS;
imageExists   BECAUSE GENERALIZATION;
QED

imageInc == \A g : \A x : \A y : <<y,x>> \in g => x \in Image(g)
THEOREM imageInc
PROOF
VARIABLES g,x,y;
imageExists   BECAUSE THEOREM;
x \in Image(g) <=> \E y : <<y,x>> \in g   BECAUSE \A(g <- g, x <- x);
(\E y : <<y,x>> \in g) => x \in Image(g)   BECAUSE EquivToImplReverse;
<<y,x>> \in g => (\E y : <<y,x>> \in g)   BECAUSE \E(y <- y);
<<y,x>> \in g => x \in Image(g)   BECAUSE TransitImplication;
imageInc   BECAUSE GENERALIZATION;
QED

(*
   The class of functions : graphs that have at most one output for each
   input. A function as a set represents a computation, like addition
   or multiplication, something that always produces the same output
   when given the same input.
*)
IsFunction(f) == IsGraph(f)
   /\ \A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c

\* The application of functions :
f[x] == CHOOSE y : <<x,y>> \in f
multiApply(f,multiX) == CHOOSE b : \A x : x \in b <=> \E u : u \in multiX /\ <<u,x>> \in f

multiApplyExists == \A f : \A multiX : \A x : x \in multiApply(f,multiX)
   <=> \E u : u \in multiX /\ <<u,x>> \in f
THEOREM multiApplyExists
PROOF
VARIABLES a,b,c,f,g,u,x,y,multiX;
\* By separation in Image(f)
(\A x : x \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,x>> \in f)
   <=> (\E b : \A x : x \in b <=> \E u : u \in multiX /\ <<u,x>> \in f)
   BECAUSE CHOOSE multiApply(f,multiX);
\A a : \E b : \A x : x \in b <=> ( x \in a /\ (\E u : u \in multiX /\ <<u,x>> \in f) )   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) )   BECAUSE \A(a <- Image(f));

imageInc   BECAUSE THEOREM;
<<u,x>> \in f => x \in Image(f)   BECAUSE \A(g <- f, x <- x, y <- u);
(u \in multiX /\ <<u,x>> \in f) => <<u,x>> \in f   BECAUSE DropAndLeft;
(u \in multiX /\ <<u,x>> \in f) => x \in Image(f)   BECAUSE TransitImplication;
(\E u : u \in multiX /\ <<u,x>> \in f) => \E u : x \in Image(f)   BECAUSE Q_SCHEME;
(\E u : x \in Image(f)) => x \in Image(f)   BECAUSE Q_SCHEME;
(\E u : u \in multiX /\ <<u,x>> \in f) => x \in Image(f)   BECAUSE TransitImplication;
(x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) ))
   => (x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f) )
   BECAUSE SeparationTauto;
(\A x : x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) ))
   => (\A x : x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f) )
   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) ))
   => (\E b : \A x : x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f) )
   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f)   BECAUSE MODUS_PONENS;
\A x : x \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,x>> \in f   BECAUSE MODUS_PONENS;
multiApplyExists   BECAUSE GENERALIZATION;
QED

multiApplySubsetImage == \A f : \A multiX : multiApply(f,multiX) \subseteq Image(f)
THEOREM multiApplySubsetImage
PROOF
VARIABLES f,g,u,x,y,z,multiX;
multiApplyExists   BECAUSE THEOREM;
z \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,z>> \in f   BECAUSE \A(f <- f, multiX <- multiX, x <- z);
z \in multiApply(f,multiX) => \E u : u \in multiX /\ <<u,z>> \in f   BECAUSE EquivToImpl;
(u \in multiX /\ <<u,z>> \in f) => <<u,z>> \in f   BECAUSE DropAndLeft;
(\E u : u \in multiX /\ <<u,z>> \in f) => \E u : <<u,z>> \in f   BECAUSE Q_SCHEME;
(\E u : <<u,z>> \in f) => <<u,z>> \in f   BECAUSE Q_SCHEME;
(\E u : u \in multiX /\ <<u,z>> \in f) => <<u,z>> \in f   BECAUSE TransitImplication;
z \in multiApply(f,multiX) => <<u,z>> \in f   BECAUSE TransitImplication;
imageInc   BECAUSE THEOREM;
<<u,z>> \in f => z \in Image(f)   BECAUSE \A(g <- f, x <- z, y <- u);
z \in multiApply(f,multiX) => z \in Image(f)   BECAUSE TransitImplication;
multiApplySubsetImage   BECAUSE GENERALIZATION;
QED

IsInjection(f) == IsFunction(f)
   /\ \A a : \A b : \A c : (<<a,c>> \in f /\ <<b,c>> \in f) => a = b

(*
   Definition of the cartesian product, the set of couples between two sets.
*)
i \X j == CHOOSE b : \A x : x \in b
   <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>

cartesianProductExists == \A i : \A j : \A x :
   x \in (i \X j) <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>

THEOREM cartesianProductExists
PROOF
VARIABLES a,b,c,d,i,j,t,u,v,x,y,z;
\* By separation in SUBSET SUBSET (x \union y)
(\A x : x \in (i \X j) <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)
   <=> (\E b : \A x : x \in b <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)   BECAUSE CHOOSE i \X j;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))   BECAUSE \A(a <- SUBSET SUBSET (i \union j));
\* Proof that <<u,v>> \subseteq SUBSET (i \union j), ie that {u} \in SUBSET (i \union j),
\* ie that {u} \subseteq (i \union j)
unionFirstInc   BECAUSE THEOREM;
i \subseteq (i \union j)   BECAUSE \A(x <- i, y <- j);
u \in i => u \in (i \union j)   BECAUSE \A(z <- u);
singletonExists   BECAUSE THEOREM;
z \in { u } <=> z = u   BECAUSE \A(a <-u, x <- z);
z \in { u } => z = u   BECAUSE EquivToImpl;
(u \in i /\ z \in {u}) => (u \in (i \union j) /\ z = u)   BECAUSE MergeImplicationsAnd;
z = u => (z \in (i \union j) <=> u \in (i \union j))   BECAUSE E_SCHEME;
(z \in (i \union j) <=> u \in (i \union j)) => (u \in (i \union j) => z \in (i \union j))   BECAUSE EquivToImplReverse;
z = u => (u \in (i \union j) => z \in (i \union j))   BECAUSE TransitImplication;
(z = u /\ u \in (i \union j)) => z \in (i \union j)   BECAUSE HypoImplToAnd;
(u \in (i \union j) /\ z = u) => (z = u /\ u \in (i \union j))   BECAUSE AndSymmetry;
(u \in (i \union j) /\ z = u) => z \in (i \union j)   BECAUSE TransitImplication;
(u \in i /\ z \in {u}) => z \in (i \union j)   BECAUSE TransitImplication;
u \in i => (z \in {u} => z \in (i \union j))   BECAUSE HypoAndToImpl;
\A z : u \in i => (z \in {u} => z \in (i \union j))   BECAUSE GENERALIZATION;
u \in i => {u} \subseteq (i \union j)   BECAUSE Q_SCHEME;
powersetExists   BECAUSE AXIOM;
{u} \in SUBSET (i \union j) <=> {u} \subseteq (i \union j)   BECAUSE \A(x <- i \union j, z <- {u});
{u} \subseteq (i \union j) => {u} \in SUBSET (i \union j)   BECAUSE EquivToImplReverse;
u \in i => {u} \in SUBSET (i \union j)   BECAUSE TransitImplication;

\* Proof of {u,v} \in SUBSET (i \union j)
unionSecondInc   BECAUSE THEOREM;
j \subseteq (i \union j)   BECAUSE \A(x <- i, y <- j);
v \in j => v \in (i \union j)   BECAUSE \A(z <- v);
(u \in i /\ v \in j) => (u \in (i \union j) /\ v \in (i \union j))   BECAUSE MergeImplicationsAnd;
pairInclusion   BECAUSE THEOREM;
(u \in (i \union j) /\ v \in (i \union j)) => {u,v} \subseteq (i \union j)   BECAUSE \A(x <- u, y <- v, t <- i \union j);
(u \in i /\ v \in j) => {u,v} \subseteq (i \union j)   BECAUSE TransitImplication;
{u,v} \in SUBSET (i \union j) <=> {u,v} \subseteq (i \union j)   BECAUSE \A(x <- i \union j, z <- {u,v});
{u,v} \subseteq (i \union j) => {u,v} \in SUBSET (i \union j)   BECAUSE EquivToImplReverse;
(u \in i /\ v \in j) => {u,v} \in SUBSET (i \union j)   BECAUSE TransitImplication;

\* Proof of (u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)
(u \in i /\ v \in j) => u \in i   BECAUSE DropAndRight;
(u \in i /\ v \in j) => {u} \in SUBSET (i \union j)   BECAUSE TransitImplication;
(u \in i /\ v \in j) => ({u} \in SUBSET (i \union j) /\ {u,v} \in SUBSET (i \union j))   BECAUSE CombineImplicationsEnd;
({u} \in SUBSET (i \union j) /\ {u,v} \in SUBSET (i \union j))
   => <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE \A(x <- {u}, y <- {u,v}, t <- SUBSET (i \union j));
(u \in i /\ v \in j) => <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE TransitImplication;
<<u,v>> \in SUBSET SUBSET (i \union j)
   <=> <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE \A(x <- SUBSET (i \union j), z <- <<u,v>>);
<<u,v>> \subseteq SUBSET (i \union j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE EquivToImplReverse;
(u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE TransitImplication;

x = <<u,v>> => (x \in SUBSET SUBSET (i \union j) <=> <<u,v>> \in SUBSET SUBSET (i \union j))   BECAUSE E_SCHEME;
(x \in SUBSET SUBSET (i \union j) <=> <<u,v>> \in SUBSET SUBSET (i \union j))
   => (<<u,v>> \in SUBSET SUBSET (i \union j) => x \in SUBSET SUBSET (i \union j))   BECAUSE EquivToImplReverse;
x = <<u,v>> => (<<u,v>> \in SUBSET SUBSET (i \union j) => x \in SUBSET SUBSET (i \union j))   BECAUSE TransitImplication;
<<u,v>> \in SUBSET SUBSET (i \union j) => (x = <<u,v>> => x \in SUBSET SUBSET (i \union j))   BECAUSE SwitchHypos;
(u \in i /\ v \in j) => (x = <<u,v>> => x \in SUBSET SUBSET (i \union j))   BECAUSE TransitImplication;
(u \in i /\ v \in j /\ x = <<u,v>>) => x \in SUBSET SUBSET (i \union j)   BECAUSE HypoImplToAnd;
(\E v : u \in i /\ v \in j /\ x = <<u,v>>) => \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => \E u : \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : x \in SUBSET SUBSET (i \union j)) => \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE TransitImplication;
(\E v : x \in SUBSET SUBSET (i \union j)) => x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => x \in SUBSET SUBSET (i \union j)   BECAUSE TransitImplication;
(x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)))
   => (x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)) BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)))
   => (\A x : x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)) BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)))
   => (\E b : \A x : x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)) BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) BECAUSE MODUS_PONENS;
\A x : x \in (i \X j) <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>   BECAUSE MODUS_PONENS;
cartesianProductExists   BECAUSE GENERALIZATION;
QED

cartesianProductInc == \A x : \A y : \A a : \A b :
   (a \in x /\ b \in y) => <<a,b>> \in (x \X y)
THEOREM cartesianProductInc
PROOF
VARIABLES a,b,i,j,u,v,x,y;
cartesianProductExists   BECAUSE THEOREM;
<<a,b>> \in (x \X y) <=> \E u : \E v : u \in x /\ v \in y /\ <<a,b>> = <<u,v>>   BECAUSE \A(i <- x, j <- y, x <- <<a,b>>);
(\E u : \E v : u \in x /\ v \in y /\ <<a,b>> = <<u,v>>) => <<a,b>> \in (x \X y)   BECAUSE EquivToImplReverse;
(a \in x /\ b \in y /\ <<a,b>> = <<a,b>>) => \E u : \E v : u \in x /\ v \in y /\ <<a,b>> = <<u,v>>   BECAUSE \E(u <- a, v <- b);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
(a \in x /\ b \in y) => (a \in x /\ b \in y /\ <<a,b>> = <<a,b>>)   BECAUSE IntroAndLeft;
(a \in x /\ b \in y) => \E u : \E v : u \in x /\ v \in y /\ <<a,b>> = <<u,v>>   BECAUSE TransitImplication;
(a \in x /\ b \in y) => <<a,b>> \in (x \X y)   BECAUSE TransitImplication;
cartesianProductInc   BECAUSE GENERALIZATION;
QED

\* Two functions called in parallel
parallelFunc(f,g) == CHOOSE h : \A x : x \in h <=> \* x = << <<a, b>>, <<f[a], f[b]>> >>
  (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
   /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g)

parallelFuncExists == (\A f : \A g : \A x : x \in parallelFunc(f,g) <=>
      (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
      /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g))
   /\ \A f : \A g : parallelFunc(f,g) \subseteq ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
THEOREM parallelFuncExists
PROOF
VARIABLES a,c,f,g,x;
\* TODO
\* By separation in (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))
\A a : \E b : \A x : x \in b <=> (x \in a /\ (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x)) /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x)) /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g))   BECAUSE \A(a <- (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)));

\* Proof that fst(x) \in Domain(f) \X Domain(g)
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
x = <<fst(x), snd(x)>> => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE E_SCHEME;
IsCouple(fst(x)) => fst(x) = <<fst(fst(x)), snd(fst(x))>>   BECAUSE \A(c <- fst(x));
fst(x) = <<fst(fst(x)), snd(fst(x))>> => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE E_SCHEME;
\*<<fst(fst(x)), fst(snd(x)) >> \in f => fst(fst(x)) \in Domain(f)   BECAUSE DomainInc
QED

parallelImage == \A f : \A g : Image(parallelFunc(f,g)) = Image(f) \X Image(g)
THEOREM parallelImage
PROOF
VARIABLES a,b,f,g;
extensionality   BECAUSE AXIOM;
(\A x : x \in Image(parallelFunc(f,g)) <=> x \in (Image(f) \X Image(g)))
   => Image(parallelFunc(f,g)) = (Image(f) \X Image(g))
   BECAUSE \A(a <- Image(parallelFunc(f,g)), b <- Image(f) \X Image(g));
parallelFuncExists   BECAUSE THEOREM;
QED

(*
   Definition of the disjoint union : the union of 2 sets where the common
   elements are copied so that they are different in the union. The disjoint
   union of natural number is very close to their addition, this will be
   made rigorous in the Ordinals module.
*)
disjointUnion(x,y) == (x \X {{}}) \union (y \X {ordinalOne})

disjUnionFirstInc == \A x : \A y : \A z : z \in x => <<z,{}>> \in disjointUnion(x,y)
THEOREM disjUnionFirstInc
PROOF
VARIABLES a,b,i,j,x,y,z;
cartesianProductInc   BECAUSE THEOREM;
(z \in x /\ {} \in {{}}) => <<z,{}>> \in (x \X {{}})   BECAUSE \A(x <- x, y <- {{}}, a <- z, b <- {});
singletonExists   BECAUSE THEOREM;
{} \in { {} } <=> {} = {}   BECAUSE \A(a <- {}, x <- {});
{} = {}   BECAUSE E_SCHEME;
{} \in { {} }   BECAUSE MODUS_PONENS;
z \in x => (z \in x /\ {} \in {{}})   BECAUSE IntroAndLeft;
z \in x => <<z,{}>> \in (x \X {{}})   BECAUSE TransitImplication;
unionFirstInc   BECAUSE THEOREM;
(x \X {{}}) \subseteq disjointUnion(x,y)   BECAUSE \A(x <- x \X {{}}, y <- y \X {ordinalOne});
<<z,{}>> \in (x \X {{}}) => <<z,{}>> \in disjointUnion(x,y)   BECAUSE \A(z <- <<z,{}>>);
z \in x => <<z,{}>> \in disjointUnion(x,y)   BECAUSE TransitImplication;
disjUnionFirstInc   BECAUSE GENERALIZATION;
QED

disjUnionSecondInc == \A x : \A y : \A z : z \in y => <<z,ordinalOne>> \in disjointUnion(x,y)
THEOREM disjUnionSecondInc
PROOF
VARIABLES a,b,i,j,x,y,z;
cartesianProductInc   BECAUSE THEOREM;
(z \in y /\ ordinalOne \in {ordinalOne}) => <<z,ordinalOne>> \in (y \X {ordinalOne})   BECAUSE \A(x <- y, y <- {ordinalOne}, a <- z, b <- ordinalOne);
singletonExists   BECAUSE THEOREM;
ordinalOne \in { ordinalOne } <=> ordinalOne = ordinalOne   BECAUSE \A(a <- ordinalOne, x <- ordinalOne);
ordinalOne = ordinalOne   BECAUSE E_SCHEME;
ordinalOne \in { ordinalOne }   BECAUSE MODUS_PONENS;
z \in y => (z \in y /\ ordinalOne \in {ordinalOne})   BECAUSE IntroAndLeft;
z \in y => <<z,ordinalOne>> \in (y \X {ordinalOne})   BECAUSE TransitImplication;
unionSecondInc   BECAUSE THEOREM;
(y \X {ordinalOne}) \subseteq disjointUnion(x,y)   BECAUSE \A(x <- x \X {{}}, y <- y \X {ordinalOne});
<<z,ordinalOne>> \in (y \X {ordinalOne}) => <<z,ordinalOne>> \in disjointUnion(x,y)   BECAUSE \A(z <- <<z,ordinalOne>>);
z \in y => <<z,ordinalOne>> \in disjointUnion(x,y)   BECAUSE TransitImplication;
disjUnionSecondInc   BECAUSE GENERALIZATION;
QED

Infinity == \E a : {} \in a /\ \A x : x \in a => x \union {x} \in a
AXIOM Infinity