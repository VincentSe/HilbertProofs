(*
   This file contains the basic definitions for mathematics, the ZFC axioms of set
   theory. For more information : en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory.

   The membership relation \in is declared (without a definition because it is
   primitive), then the inclusion relation \subseteq.

   The axioms defined are extensionality, powerset, union and infinity. The axiom
   schemes of separation and replacement are also defined.

   The operators defined are the empty set, singleton of a set, pair of sets, couples,
   union of two sets, intersection of two sets, cartesian product and disjoint union.

   The relations defined are graphs and equivalence relations.
*)

EXTENDS Tautologies

\* The membership binary relation, the only primitive symbol of ZFC :
CONSTANT _ \in _

aSetExists == \E x : x = x

THEOREM aSetExists
PROOF
VARIABLES x;
(\A x : ~(x = x)) => ~(x = x)   BECAUSE \A(x <- x);
~~(x = x) => ~(\A x : ~(x = x))   BECAUSE Contraposition;
x = x   BECAUSE E_SCHEME;
~~(x = x)   BECAUSE IntroNotNot;
~(\A x : ~(x = x))   BECAUSE MODUS_PONENS;
(\E x : x = x)  <=>  ~(\A x : ~(x = x))   BECAUSE Q_SCHEME;
aSetExists   BECAUSE MODUS_PONENS;
QED

(*
   The theorem above uses only logical axioms, the constant binary
   relation \in does not appear in the proof. It is a general property
   of first-order logic with equality : something exists.

   Let's continue with a property of binary relations in
   first-order logic.
*)
russellParadox == ~\E x : \A y : y \in x <=> ~(y \in y)

THEOREM russellParadox
PROOF
VARIABLES x,y,a,h,b;
\* If such a set x existed, it would both belong and not belong to itself
(\A y : y \in x <=> ~(y \in y)) => (x \in x <=> ~(x \in x))   BECAUSE \A(y <- x);
~(\A y : y \in x <=> ~(y \in y))   BECAUSE ContradictionEquiv;
\A x : ~(\A y : y \in x <=> ~(y \in y))   BECAUSE GENERALIZATION;
(\E x : \A y : y \in x <=> ~(y \in y)) <=> ~(\A x : ~(\A y : y \in x <=> ~(y \in y)))  BECAUSE Q_SCHEME;
contraposNeg(a,b) == (a <=> ~b) => (b => ~a)  PROPO_TAUTO;
(\A x : ~(\A y : y \in x <=> ~(y \in y))) => ~(\E x : \A y : y \in x <=> ~(y \in y))  BECAUSE contraposNeg;
russellParadox   BECAUSE MODUS_PONENS;
QED

(*
   We still don't have axioms to define what sets are.
   The proof of Russell's paradox works with any binary relation,
   for example < in Peano arithmetic : it then states that there
   is no number greater than all others.

   Russell's paradox constrains what axioms we can take for sets.
   If we are not careful, we can choose axioms proving its contrary.
*)

\* The first axiom for sets : two sets are equal iif they have the same
\* elements, and an element appears at most once in a set.
extensionality == \A a : \A b : (\A x : x \in a <=> x \in b) => a = b
AXIOM extensionality

\* Inclusion of sets.
x \subseteq y == \A z : z \in x => z \in y

bothInclusions == \A a : \A b : (a \subseteq b /\ b \subseteq a) => a = b
THEOREM bothInclusions

PROOF
VARIABLES z, y, x, b, a;
extensionality   BECAUSE AXIOM;
(\A x : x \in a <=> x \in b) => a = b   BECAUSE \A(a <- a, b <- b);
h(a,b) == a \subseteq b /\ b \subseteq a;
(\A z : z \in a => z \in b) => (z \in a => z \in b)   BECAUSE \A(z <- z);
(\A z : z \in b => z \in a) => (z \in b => z \in a)   BECAUSE \A(z <- z);
h(a,b) => ((z \in a => z \in b) /\ (z \in b => z \in a))   BECAUSE MergeImplicationsAnd;
((z \in a => z \in b) /\ (z \in b => z \in a)) => (z \in a <=> z \in b)   BECAUSE IntroEquivAnd;
h(a,b) => (z \in a <=> z \in b)   BECAUSE TI;
\A z : h(a,b) => (z \in a <=> z \in b)   BECAUSE GENERALIZATION;
h(a,b) => (\A z : z \in a <=> z \in b)   BECAUSE Q_SCHEME;

(\A z : z \in a <=> z \in b) => (x \in a <=> x \in b)   BECAUSE \A(z <- x);
h(a,b) => (x \in a <=> x \in b)   BECAUSE TI;
\A x : h(a,b) => (x \in a <=> x \in b)   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in a <=> x \in b)   BECAUSE Q_SCHEME;
h(a,b) => a = b    BECAUSE TI;
bothInclusions   BECAUSE GENERALIZATION;
QED

inclusionInOneself == \A x : x \subseteq x
THEOREM inclusionInOneself
PROOF
VARIABLES z, x;
z \in x => z \in x   BECAUSE ImplySelf;
\A z : z \in x => z \in x   BECAUSE GENERALIZATION;
inclusionInOneself   BECAUSE GENERALIZATION;
QED

(*
   The axiom scheme of separation. Although it can be deduced from the
   axiom scheme of replacement, we declare it for easier use
   and better tracking of where replacement is needed.

   The variable "a" can be free in F as in the axiom
       \A a : \E b : \A x : x \in b <=> (x \in a /\ x \subseteq a)
   However we exclude b from the free variables of F, to avoid the
   self-contradicting formula
       \A a : \E b : \A x : x \in b <=> (x \in a /\ x \notin b)
   t is contrary to Russell's paradox so we cannot have it as an axiom.

   Here is the derivation of the separation axiom scheme from the
   replacement axiom scheme :
   sep(x,y) == x = y /\ F(x)
   sep(x,y) /\ sep(x,y') => x = y /\ x = y'   BECAUSE PT;
   (x = y /\ x = y') => y = y'   BECAUSE AXIOM_SCHEME;
   sep(x,y) /\ sep(x,y') => y = y'   BECAUSE TI;
   \A x : \A y : \A y' : sep(x,y) /\ sep(x,y') => y = y'   BECAUSE GENERALIZATION;
   \* replacement scheme : by hypothesis formula F has no free occurrences of variable b
   (\A x : \A y : \A y' : sep(x,y) /\ sep(x,y') => y = y')
      => \A a : \E b : \A x : x \in b <=> \E y : y \in a /\ sep(x,y)   BECAUSE AXIOM_SCHEME;
   \A a : \E b : \A x : x \in b <=> \E y : y \in a /\ sep(x,y)   BECAUSE MODUS_PONENS;
*)
separation(F) == \A a : \E b : \A x : x \in b <=> (x \in a /\ F)
AXIOM_SCHEME BOUND_VAR(b) separation

(*
   The full axiom scheme of replacement : the image of a set by
   a functional relation is a set. It can be interpreted as a size
   guard, the image b is smaller than the starting set a, so
   there is no risk of b exploding outside the limits of sets.
*)
replacement(F) == (\A x : \A y : \A z : (F /\ F(y <- z)) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ F)
AXIOM_SCHEME BOUND_VAR(b) replacement


(*
   There exists a set such that any set is not a member of it. It is called
   the empty set. This empty set is rather mysterious : it exists so it is
   something, however there is nothing in it, so by extensionality it should
   be nothing too.

   Besides, we will see with the axiom of foundation that this empty set is
   the atom, the elementary building block for all sets, ie all mathematics.
*)
{} == CHOOSE b : \A x : x \notin b
emptySetExists == \A x : x \notin {}

THEOREM emptySetExists
PROOF
VARIABLES x, a, b;
\* Construct the empty set by the separation axiom with a contradictory formula
\A a : \E b : \A x : x \in b <=> (x \in a /\ x # x)   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in a /\ x # x)   BECAUSE \A(a <- a);

\* Take one such set b and show no set x can be in it
chooseB(a) == CHOOSE b : \A x : x \in b <=> (x \in a /\ x # x);
(\A x : x \in chooseB(a) <=> (x \in a /\ x # x)) <=> \E b : \A x : x \in b <=> (x \in a /\ x # x)
   BECAUSE CHOOSE chooseB(a);
\A x : x \in chooseB(a) <=> (x \in a /\ x # x)   BECAUSE MODUS_PONENS;
x \in chooseB(a) <=> (x \in a /\ x # x)   BECAUSE \A(x <- x);
x \in chooseB(a) => (x \in a /\ x # x)   BECAUSE EquivToImpl;
(x \in a /\ x # x) => x # x   BECAUSE DropAndLeft;
x \in chooseB(a) => x # x   BECAUSE TI;
~(x # x) => x \notin chooseB(a)   BECAUSE Contraposition;
x = x   BECAUSE E_SCHEME;
~(x # x)   BECAUSE IntroNotNot;
x \notin chooseB(a)   BECAUSE MODUS_PONENS;
\A x : x \notin chooseB(a)   BECAUSE GENERALIZATION;

\* Conclude chooseB(a) is the empty set
(\A x : x \notin {}) <=> \E b : \A x : x \notin b   BECAUSE CHOOSE {};
\E b : \A x : x \notin b   BECAUSE \E(b <- chooseB(a));
emptySetExists   BECAUSE MODUS_PONENS;
QED

(*
   Another clue to the importance and solidity of the empty set :
   it is unique. There are not different ways of being empty,
   the empty set only has only one form, it is the same everywhere
   we use it.
*)
emptySetUnique == \A a : (\A x : x \notin a) => a = {}
THEOREM emptySetUnique
PROOF
VARIABLES a,b,x;
emptySetExists BECAUSE THEOREM;
x \notin {} BECAUSE \A(x <- x);
equivImpossible(a,b) == ~b => (~a => (a <=> b)) PROPO_TAUTO;
(x \notin a) => (x \in a <=> x \in {})  BECAUSE equivImpossible;
(\A x : x \notin a) => (\A x : x \in a <=> x \in {})   BECAUSE Q_SCHEME;

extensionality   BECAUSE AXIOM;
(\A x : x \in a <=> x \in {}) => a = {}   BECAUSE \A(a <- a, b <- {});
(\A x : x \notin a) => a = {}   BECAUSE TI;
\A a : (\A x : x \notin a) => a = {}   BECAUSE GENERALIZATION;
QED

emptyIncludedInAny == \A x : {} \subseteq x
THEOREM emptyIncludedInAny
PROOF
VARIABLES x,z;
emptySetExists   BECAUSE THEOREM;
z \notin {}   BECAUSE \A(x <- z);
z \in {} => z \in x   BECAUSE Explosion;
{} \subseteq x   BECAUSE GENERALIZATION;
emptyIncludedInAny   BECAUSE GENERALIZATION;
QED

includedInEmpty == \A x : x \subseteq {} => x = {}
THEOREM includedInEmpty
PROOF
VARIABLES a,b,x;
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq x   BECAUSE \A(x <- x);
bothInclusions BECAUSE THEOREM;
(x \subseteq {} /\ {} \subseteq x) => x = {}   BECAUSE \A(a <- x, b <- {});
x \subseteq {} => (x \subseteq {} /\ {} \subseteq x)   BECAUSE IntroAndLeft;
x \subseteq {} => x = {}   BECAUSE TI;
includedInEmpty   BECAUSE GENERALIZATION;
QED

notEmpty == \A x : x # {} => \E z : z \in x
THEOREM notEmpty
PROOF
VARIABLES a,x,z;
emptySetUnique BECAUSE THEOREM;
(\A x : x \notin a) => a = {} BECAUSE \A(a <- a);
(\A z : z \notin a) => x \notin a   BECAUSE \A(z <- x);
\A x : (\A z : z \notin a) => x \notin a   BECAUSE GENERALIZATION;
(\A z : z \notin a) => \A x : x \notin a   BECAUSE Q_SCHEME;
(\A z : z \notin a) => a = {} BECAUSE TI;
(\E z : z \in a) <=> ~(\A z : z \notin a)   BECAUSE Q_SCHEME;
~(\A z : z \notin a) => (\E z : z \in a)   BECAUSE EquivToImplReverse;
a # {} => ~(\A z : z \notin a) BECAUSE Contraposition;
a # {} => \E z : z \in a   BECAUSE TI;
\A a : a # {} => \E z : z \in a   BECAUSE GENERALIZATION;
x # {} => \E z : z \in x   BECAUSE \A(a <- x);
notEmpty   BECAUSE GENERALIZATION;
QED

\* All sets together are too big to form a set. We speak of the class of sets instead.
noSetOfSets == ~\E a : \A y : y \in a
THEOREM noSetOfSets
PROOF
VARIABLES a,b,x,y;
\* If such a set existed, by separation we would create the forbidden set of the Russell's paradox
\A a : \E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))   BECAUSE \A(a <- a);
chooseB(a) == CHOOSE b : \A x : x \in b <=> (x \in a /\ ~(x \in x));
(\A x : x \in chooseB(a) <=> (x \in a /\ ~(x \in x))) <=> \E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))
   BECAUSE CHOOSE chooseB(a);
\A x : x \in chooseB(a) <=> (x \in a /\ ~(x \in x))   BECAUSE MODUS_PONENS;
y \in chooseB(a) <=> (y \in a /\ ~(y \in y))   BECAUSE \A(x <- y);

\* Force the hypothesis that a is the set of all sets (\A y : y \in a)
y \in a => (y \in a /\ (y \in chooseB(a) <=> (y \in a /\ ~(y \in y))))   BECAUSE IntroAndLeft;
equivTrue(a,b,t) == (t /\ (a <=> (t /\ b))) => (a <=> b)   PROPO_TAUTO;
(y \in a /\ (y \in chooseB(a) <=> (y \in a /\ ~(y \in y)))) => (y \in chooseB(a) <=> ~(y \in y))   BECAUSE equivTrue;
y \in a => (y \in chooseB(a) <=> ~(y \in y))   BECAUSE TI;
(\A y : y \in a) => (\A y : y \in chooseB(a) <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\A y : y \in chooseB(a) <=> ~(y \in y)) => \E x : \A y : y \in x <=> ~(y \in y)   BECAUSE \E(x <- chooseB(a));
(\A y : y \in a) => \E x : \A y : y \in x <=> ~(y \in y)   BECAUSE TI;
(\E a : \A y : y \in a) => \E a : \E x : \A y : y \in x <=> ~(y \in y)   BECAUSE Q_SCHEME;
(\E a : \E x : \A y : y \in x <=> ~(y \in y)) => \E x : \A y : y \in x <=> ~(y \in y)   BECAUSE Q_SCHEME;
(\E a : \A y : y \in a) => \E x : \A y : y \in x <=> ~(y \in y)   BECAUSE TI;

russellParadox => noSetOfSets   BECAUSE Contraposition;
russellParadox   BECAUSE THEOREM;
noSetOfSets  BECAUSE MODUS_PONENS;
QED

\* The union of a set x is the set of elements of elements of x.
UNION b == CHOOSE u : \A z : (z \in u <=> \E t : (t \in b /\ z \in t))
unionExists == \A b : \A z : (z \in UNION b <=> \E t : t \in b /\ z \in t)
AXIOM unionExists

inInUnion == \A a : \A b : \A c : (a \in b /\ b \in c) => a \in UNION c
THEOREM inInUnion
PROOF
VARIABLES a,b,c,t,z;
unionExists   BECAUSE AXIOM;
a \in UNION c <=> \E t : (t \in c /\ a \in t)   BECAUSE \A(b <- c, z <- a);
(\E t : t \in c /\ a \in t) => a \in UNION c   BECAUSE EquivToImplReverse;
(b \in c /\ a \in b) => \E t : t \in c /\ a \in t   BECAUSE \E(t <- b);
(b \in c /\ a \in b) => a \in UNION c   BECAUSE TI;
(a \in b /\ b \in c) => (b \in c /\ a \in b)   BECAUSE AndSymmetry;
(a \in b /\ b \in c) => a \in UNION c   BECAUSE TI;
inInUnion   BECAUSE GENERALIZATION;
QED

\* The intersection of two sets is the set of common elements
u \intersect v == CHOOSE b : \A x : x \in b <=> (x \in u /\ x \in v)

intersectionExists == \A u : \A v : \A x :
   x \in (u \intersect v) <=> (x \in u /\ x \in v)
THEOREM intersectionExists
PROOF
VARIABLES a,b,u,v,x;
\* By separation in u
(\A x : x \in (u \intersect v) <=> (x \in u /\ x \in v)) <=> \E b : (\A x : x \in b <=> (x \in u /\ x \in v))
   BECAUSE CHOOSE u \intersect v;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (x \in u /\ x \in v))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))   BECAUSE \A(a <- u);
(x \in u /\ x \in v) => x \in u   BECAUSE DropAndRight;
(x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (x \in b <=> (x \in u /\ x \in v))   BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (\A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (\E b : \A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (x \in u /\ x \in v)   BECAUSE MODUS_PONENS;
\A x : x \in (u \intersect v) <=> (x \in u /\ x \in v)   BECAUSE MODUS_PONENS;
intersectionExists   BECAUSE GENERALIZATION;
QED

AreDisjoint(x,y) == x \intersect y = {}
noCommonElements == \A x : \A y : AreDisjoint(x,y) <=> \A z : ~(z \in x /\ z \in y)
THEOREM noCommonElements
PROOF
VARIABLES a,u,v,x,y,z;
intersectionExists   BECAUSE THEOREM;
z \in (x \intersect y) <=> (z \in x /\ z \in y)   BECAUSE \A(u <- x, v <- y, x <- z);
contraEquiv(a,b) == (a <=> b) => (~a <=> ~b)   PROPO_TAUTO;
z \notin (x \intersect y) <=> ~(z \in x /\ z \in y)   BECAUSE contraEquiv;
emptySetExists   BECAUSE THEOREM;
z \notin {}   BECAUSE   \A(x <- z);
\A x : \A y : x = y => (z \in x <=> z \in y)   BECAUSE E_SCHEME;
AreDisjoint(x,y) => (z \in (x \intersect y) <=> z \in {})   BECAUSE \A(x <- x \intersect y, y <- {});
implyEquivFalse(a,b,f) == ~f => ((a => (b <=> f)) => (a => ~b))   PROPO_TAUTO;
AreDisjoint(x,y) => z \notin (x \intersect y)   BECAUSE implyEquivFalse;
z \notin (x \intersect y) => ~(z \in x /\ z \in y)   BECAUSE EquivToImpl;
AreDisjoint(x,y) => ~(z \in x /\ z \in y)   BECAUSE TI;
\A z : AreDisjoint(x,y) => ~(z \in x /\ z \in y)   BECAUSE GENERALIZATION;
AreDisjoint(x,y) => \A z : ~(z \in x /\ z \in y)   BECAUSE Q_SCHEME;

emptySetUnique   BECAUSE THEOREM;
(\A x : x \notin a) => a = {}   BECAUSE \A(a <- a);
(\A z : z \notin a) => x \notin a   BECAUSE \A(z <- x);
\A x : (\A z : z \notin a) => x \notin a   BECAUSE GENERALIZATION;
(\A z : z \notin a) => \A x : x \notin a   BECAUSE Q_SCHEME;
(\A z : z \notin a) => a = {}   BECAUSE TI;
\A a : (\A z : z \notin a) => a = {}   BECAUSE GENERALIZATION;
(\A z : z \notin (x \intersect y)) => (x \intersect y) = {}   BECAUSE \A(a <- x \intersect y);
~(z \in x /\ z \in y) => z \notin (x \intersect y)   BECAUSE EquivToImplReverse;
(\A z : ~(z \in x /\ z \in y)) => (\A z : z \notin (x \intersect y))   BECAUSE Q_SCHEME;
(\A z : ~(z \in x /\ z \in y)) => AreDisjoint(x,y)   BECAUSE TI;
AreDisjoint(x,y) <=> \A z : ~(z \in x /\ z \in y)   BECAUSE IntroEquiv;
noCommonElements   BECAUSE GENERALIZATION;
QED

SUBSET x == CHOOSE y : \A z : z \in y <=> z \subseteq x

powersetExists == \A x : \A z : z \in SUBSET x <=> z \subseteq x
AXIOM powersetExists

\* Representation of number 1 as a set
ordinalOne == SUBSET {}

\* The only element of ordinalOne is the empty set {},
\* which is why ordinalOne represents the number 1.
elemOfOne == \A x : x \in ordinalOne <=> x = {}
THEOREM elemOfOne
PROOF
VARIABLES x,y,z;
powersetExists   BECAUSE AXIOM;
x \in ordinalOne <=> x \subseteq {}   BECAUSE \A(x <- {}, z <- x);
includedInEmpty   BECAUSE THEOREM;
x \subseteq {} => x = {}   BECAUSE \A(x <- x);
inclusionInOneself   BECAUSE THEOREM;
{} \subseteq {}   BECAUSE \A(x <- {});
\A x : \A y : x = y => (x \subseteq {} <=> y \subseteq {})   BECAUSE E_SCHEME;
x = {} => (x \subseteq {} <=> {} \subseteq {})   BECAUSE \A(x <- x, y <- {});
x = {} => x \subseteq {}   BECAUSE ImplyEquivTrue;
x \subseteq {} <=> x = {}   BECAUSE IntroEquiv;
x \in ordinalOne <=> x = {}   BECAUSE TransitEquiv;
elemOfOne   BECAUSE GENERALIZATION;
QED

ordinalTwo == SUBSET ordinalOne
elemOfTwo == \A x : x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)

THEOREM elemOfTwo
PROOF
VARIABLES a,b,x,z;
powersetExists   BECAUSE AXIOM;
x \in ordinalTwo <=> x \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne, z <- x);
x \in ordinalTwo => x \subseteq ordinalOne   BECAUSE EquivToImpl;

\* Proof of (x \subseteq ordinalOne /\ x # {}) => {} \in x
elemOfOne   BECAUSE THEOREM;
z \in ordinalOne <=> z = {}   BECAUSE \A(x <- z);
z \in ordinalOne => z = {}   BECAUSE EquivToImpl;
(z \in x => z \in ordinalOne) => (z \in x => z = {})   BECAUSE AddHypothesis;
z \in x => z \in x   BECAUSE ImplySelf;
(z \in x => z = {}) => (z \in x => (z \in x /\ z = {}))   BECAUSE CombineImplicationsEnd;
(z \in x => z \in ordinalOne) => (z \in x => (z \in x /\ z = {}))   BECAUSE TI;
x \subseteq ordinalOne => (\A z : z \in x => (z \in x /\ z = {}))   BECAUSE Q_SCHEME;

notEmpty   BECAUSE THEOREM;
x # {} => \E z : z \in x   BECAUSE \A(x <- x);
(x \subseteq ordinalOne /\ x # {}) => ((\A z : z \in x => (z \in x /\ z = {})) /\ \E z : z \in x)   BECAUSE MergeImplicationsAnd;

(\A z : z \in x => (z \in x /\ z = {})) => ((\E z : z \in x) => \E z : z \in x /\ z = {})   BECAUSE Q_SCHEME;
((\A z : z \in x => (z \in x /\ z = {})) /\ (\E z : z \in x)) => \E z : z \in x /\ z = {}   BECAUSE HypoImplToAnd;
(x \subseteq ordinalOne /\ x # {}) => \E z : z \in x /\ z = {}   BECAUSE TI;

\A z : \A a : z = a => (z \in x <=> a \in x)   BECAUSE E_SCHEME;
z = {} => (z \in x <=> {} \in x)   BECAUSE \A(z <- z, a <- {});
(z \in x <=> {} \in x) => (z \in x => {} \in x)   BECAUSE EquivToImpl;
z = {} => (z \in x => {} \in x)   BECAUSE TI;
(z = {} /\ z \in x) => {} \in x   BECAUSE HypoImplToAnd;
(z \in x /\ z = {}) => (z = {} /\ z \in x)   BECAUSE AndSymmetry;
(z \in x /\ z = {}) => {} \in x   BECAUSE TI;
(\E z : z \in x /\ z = {}) => \E z : {} \in x   BECAUSE Q_SCHEME;
(\E z : {} \in x) => {} \in x   BECAUSE Q_SCHEME;
(x \subseteq ordinalOne /\ x # {}) => \E z : z \in x /\ z = {}   BECAUSE TI;
(x \subseteq ordinalOne /\ x # {}) => \E z : {} \in x   BECAUSE TI;
(x \subseteq ordinalOne /\ x # {}) => {} \in x   BECAUSE TI;

\* Proof of {} \in x => ordinalOne \subseteq x
z \in ordinalOne => (z \in x <=> {} \in x)   BECAUSE TI;
(z \in x <=> {} \in x) => ({} \in x => z \in x)   BECAUSE EquivToImplReverse;
z \in ordinalOne => ({} \in x => z \in x)   BECAUSE TI;
{} \in x => (z \in ordinalOne => z \in x)   BECAUSE SwitchHypos;
\A z : {} \in x => (z \in ordinalOne => z \in x)   BECAUSE GENERALIZATION;
{} \in x => ordinalOne \subseteq x   BECAUSE Q_SCHEME;
(x \subseteq ordinalOne /\ x # {}) => ordinalOne \subseteq x   BECAUSE TI;

(x \subseteq ordinalOne /\ x # {}) => x \subseteq ordinalOne   BECAUSE DropAndRight;
(x \subseteq ordinalOne /\ x # {}) => (x \subseteq ordinalOne /\ ordinalOne \subseteq x)   BECAUSE CombineImplicationsEnd;
bothInclusions BECAUSE THEOREM;
(x \subseteq ordinalOne /\ ordinalOne \subseteq x) => x = ordinalOne   BECAUSE \A(a <- x, b <- ordinalOne);
(x \subseteq ordinalOne /\ x # {}) => x = ordinalOne   BECAUSE TI;

x \subseteq ordinalOne => (x # {} => x = ordinalOne)   BECAUSE HypoAndToImpl;
x \in ordinalTwo => (x # {} => x = ordinalOne)   BECAUSE TI;
x \in ordinalTwo => (x = {} \/ x = ordinalOne)   BECAUSE ImplyExcludedMiddle;

\* Reverse proof
inclusionInOneself   BECAUSE THEOREM;
ordinalOne \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne);
x \subseteq ordinalOne => x \in ordinalTwo   BECAUSE EquivToImplReverse;
\A x : \A z : x = z => (x \subseteq ordinalOne <=> z \subseteq ordinalOne)   BECAUSE E_SCHEME;
x = ordinalOne => (x \subseteq ordinalOne <=> ordinalOne \subseteq ordinalOne)   BECAUSE \A(x <- x, z <- ordinalOne);
x = ordinalOne => x \subseteq ordinalOne   BECAUSE ImplyEquivTrue;
x = ordinalOne => x \in ordinalTwo   BECAUSE TI;

x \in ordinalOne <=> x = {}   BECAUSE \A(x <- x);
\A x : \A z : x = z => (x \subseteq ordinalOne <=> z \subseteq ordinalOne)   BECAUSE E_SCHEME;
x = {} => (x \subseteq ordinalOne <=> {} \subseteq ordinalOne)   BECAUSE \A(x <- x, z <- {});
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne);
x = {} => x \subseteq ordinalOne   BECAUSE ImplyEquivTrue;
x = {} => x \in ordinalTwo   BECAUSE TI;

(x = {} \/ x = ordinalOne) => x \in ordinalTwo   BECAUSE CombineImplicationsStart;
x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)   BECAUSE IntroEquiv;
elemOfTwo   BECAUSE GENERALIZATION;
QED

(* Singleton and pair operators *)
{ a } == CHOOSE b : \A x : x \in b <=> x = a

singletonExists == \A a : \A x : x \in { a } <=> x = a
THEOREM singletonExists
PROOF
VARIABLES a,b,c,x,z;
\* Proof by separation in the powerset of a
(\A x : x \in { a } <=> x = a) <=> \E b : \A x : x \in b <=> x = a   BECAUSE CHOOSE { a };
\A a : \E b : \A x : x \in b <=> (x \in a /\ x = c)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = c)   BECAUSE \A(a <- SUBSET a);
\A c : \E b : \A x : x \in b <=> (x \in SUBSET a /\ x = c)   BECAUSE GENERALIZATION;
\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = a)   BECAUSE \A(c <- a);

\* Proof that (x \in SUBSET a /\ x = a) <=> x = a
(x \in SUBSET a /\ x = a) => x = a   BECAUSE DropAndLeft;
\A x : \A a : x = a => (x \in SUBSET a <=> a \in SUBSET a)   BECAUSE E_SCHEME;
x = a => (x \in SUBSET a <=> a \in SUBSET a)   BECAUSE \A(x <- x, a <- a);
inclusionInOneself   BECAUSE THEOREM;
a \subseteq a   BECAUSE \A(x <- a);
powersetExists   BECAUSE AXIOM;
a \in SUBSET a <=> a \subseteq a   BECAUSE \A(x <- a, z <- a);
a \in SUBSET a   BECAUSE MODUS_PONENS;
x = a => x \in SUBSET a   BECAUSE ImplyEquivTrue;
x = a => x = a   BECAUSE ImplySelf;
x = a => (x \in SUBSET a /\ x = a)   BECAUSE CombineImplicationsEnd;
x = a <=> (x \in SUBSET a /\ x = a)   BECAUSE IntroEquiv;

(x \in b <=> (x \in SUBSET a /\ x = a)) => (x \in b <=> x = a)   BECAUSE TransitEquiv2;
(\A x : x \in b <=> (x \in SUBSET a /\ x = a)) => (\A x : x \in b <=> x = a)   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = a)) => (\E b : \A x : x \in b <=> x = a)   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> x = a)   BECAUSE MODUS_PONENS;
(\A x : x \in { a } <=> x = a)   BECAUSE MODUS_PONENS;
singletonExists   BECAUSE GENERALIZATION;
QED

{ c, d } == CHOOSE b : \A y : y \in b <=> (y = c \/ y = d)

pairExists == \A c : \A d : \A y : y \in { c, d } <=> (y = c \/ y = d)
THEOREM pairExists
PROOF
VARIABLES a,b,c,d,i,j,x,y,z;
\* Proof by replacement of ordinalTwo with the functional {} -> c, ordinalOne -> d
(\A y : y \in { c, d } <=> (y = c \/ y = d)) <=> \E b : \A y : y \in b <=> (y = c \/ y = d)   BECAUSE CHOOSE {c, d};
F(c,d,x,y) == (x = {} /\ y = c) \/ (x = ordinalOne /\ y = d);
(\A x : \A y : \A z : (((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d))
      	       	        /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE AXIOM_SCHEME;

   \* Proof that F is functional
(F(c,d,x,y) /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d)))
   => ((F(c,d,x,y) /\ (x = {} /\ z = c)) \/ (F(c,d,x,y) /\ (x = ordinalOne /\ z = d)))   BECAUSE DistribAndOrLeft;
\* Case x = {}
(F(c,d,x,y) /\ (x = {} /\ z = c))
   => (((x = {} /\ y = c) /\ (x = {} /\ z = c)) \/ ((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)))   BECAUSE DistribAndOrRight;
(x = {} /\ z = c) => x = {}   BECAUSE DropAndRight;
(x = ordinalOne /\ y = d) => x = ordinalOne   BECAUSE DropAndRight;
((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)) => (x = ordinalOne /\ x = {})   BECAUSE MergeImplicationsAnd;
(x = ordinalOne /\ x = {}) => ordinalOne = {}   BECAUSE E_SCHEME;
((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)) => ordinalOne = {}   BECAUSE TI;
(x = {} /\ y = c) => y = c   BECAUSE DropAndLeft;
(x = {} /\ z = c) => z = c   BECAUSE DropAndLeft;
((x = {} /\ y = c) /\ (x = {} /\ z = c)) => (y = c /\ z = c)   BECAUSE MergeImplicationsAnd;
(y = c /\ z = c) => y = z   BECAUSE E_SCHEME;
((x = {} /\ y = c) /\ (x = {} /\ z = c)) => y = z   BECAUSE TI;
(((x = {} /\ y = c) /\ (x = {} /\ z = c)) \/ ((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c))) => ((y = z) \/ (ordinalOne = {}))   BECAUSE MergeImplicationsOr;
(F(c,d,x,y) /\ (x = {} /\ z = c)) => (y = z \/ ordinalOne = {})   BECAUSE TI;

\* Proof that ordinalOne # {}
powersetExists   BECAUSE AXIOM;
{} \in ordinalOne <=> {} \subseteq {}   BECAUSE \A(x <- {}, z <- {});
inclusionInOneself   BECAUSE THEOREM;
{} \subseteq {}   BECAUSE \A(x <- {});
{} \in ordinalOne   BECAUSE MODUS_PONENS;
emptySetExists   BECAUSE THEOREM;
\A i : \A j : i = j => ((\A x : x \notin i) <=> (\A x : x \notin j))   BECAUSE E_SCHEME;
ordinalOne = {} => ((\A x : x \notin ordinalOne) <=> emptySetExists)   BECAUSE \A(i <- ordinalOne, j <- {});
ordinalOne = {} => (\A x : x \notin ordinalOne)   BECAUSE ImplyEquivTrue;
(\A x : x \notin ordinalOne) => {} \notin ordinalOne   BECAUSE \A(x <- {});
ordinalOne = {} => {} \notin ordinalOne   BECAUSE TI;
~({} \notin ordinalOne) => ordinalOne # {}   BECAUSE Contraposition;
{} \in ordinalOne => ~({} \notin ordinalOne)   BECAUSE IntroNotNot;
{} \in ordinalOne => ordinalOne # {}   BECAUSE TI;
ordinalOne # {}   BECAUSE MODUS_PONENS;

(y = z \/ ordinalOne = {}) => y = z   BECAUSE OrFalseStart;
(F(c,d,x,y) /\ (x = {} /\ z = c)) => y = z   BECAUSE TI;

\* Case x = ordinalOne
(F(c,d,x,y) /\ (x = ordinalOne /\ z = d))
   => (((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) \/ ((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)))   BECAUSE DistribAndOrRight;
(x = {} /\ y = c) => x = {}   BECAUSE DropAndRight;
(x = ordinalOne /\ z = d) => x = ordinalOne   BECAUSE DropAndRight;
((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) => (x = {} /\ x = ordinalOne)   BECAUSE MergeImplicationsAnd;
(x = {} /\ x = ordinalOne) => {} = ordinalOne   BECAUSE E_SCHEME;
((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) => {} = ordinalOne   BECAUSE TI;
(x = ordinalOne /\ y = d) => y = d   BECAUSE DropAndLeft;
(x = ordinalOne /\ z = d) => z = d   BECAUSE DropAndLeft;
((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)) => (y = d /\ z = d)   BECAUSE MergeImplicationsAnd;
(y = d /\ z = d) => y = z   BECAUSE E_SCHEME;
((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)) => y = z   BECAUSE TI;
(((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) \/ ((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d))) => ({} = ordinalOne \/ y = z)   BECAUSE MergeImplicationsOr;
(F(c,d,x,y) /\ (x = ordinalOne /\ z = d)) => ({} = ordinalOne \/ y = z)   BECAUSE TI;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
ordinalOne # {} => {} # ordinalOne   BECAUSE Contraposition;
{} # ordinalOne   BECAUSE MODUS_PONENS;
({} = ordinalOne \/ y = z) => y = z   BECAUSE FalseOrStart;
(F(c,d,x,y) /\ (x = ordinalOne /\ z = d)) => y = z   BECAUSE TI;

((F(c,d,x,y) /\ (x = {} /\ z = c)) \/ (F(c,d,x,y) /\ (x = ordinalOne /\ z = d))) => y = z   BECAUSE CombineImplicationsStart;
(F(c,d,x,y) /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z   BECAUSE TI;
\A x : \A y : \A z : (F(c,d,x,y) /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z   BECAUSE GENERALIZATION;
\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ F(c,d,x,y)   BECAUSE MODUS_PONENS;
\E b : \A y : y \in b <=> \E x : x \in ordinalTwo /\ F(c,d,x,y)   BECAUSE \A(a <- ordinalTwo);

   \* Proof that b works, ie that (\E x : x \in ordinalTwo /\ F) <=> (y = c \/ y = d)
elemOfTwo   BECAUSE THEOREM;
x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)   BECAUSE \A(x <- x);
x \in ordinalTwo => (x = {} \/ x = ordinalOne)   BECAUSE EquivToImpl;
(x = {} \/ x = ordinalOne) => x \in ordinalTwo   BECAUSE EquivToImplReverse;

F(c,d,x,y) => (y = c \/ y = d)   BECAUSE MergeImplicationsOr;
(x \in ordinalTwo /\ F(c,d,x,y)) => F(c,d,x,y)   BECAUSE DropAndLeft;
(x \in ordinalTwo /\ F(c,d,x,y)) => (y = c \/ y = d)   BECAUSE TI;
(\E x : x \in ordinalTwo /\ F(c,d,x,y)) => (\E x : y = c \/ y = d)   BECAUSE Q_SCHEME;
(\E x : y = c \/ y = d) => (y = c \/ y = d)   BECAUSE Q_SCHEME;
(\E x : x \in ordinalTwo /\ F(c,d,x,y)) => (y = c \/ y = d)   BECAUSE TI;

\* Case y = c
({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))) => (\E x : x \in ordinalTwo /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE \E(x <- {});
{} = {}   BECAUSE E_SCHEME;
y = c => ({} = {} /\ y = c)   BECAUSE IntroAndRight;
({} = {} /\ y = c) => (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))   BECAUSE IntroOrLeft;
y = c => (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))   BECAUSE TI;
x = {} => (x = {} \/ x = ordinalOne)   BECAUSE IntroOrLeft;
x = {} => x \in ordinalTwo   BECAUSE TI;
\A x : x = {} => x \in ordinalTwo   BECAUSE GENERALIZATION;
{} = {} => {} \in ordinalTwo   BECAUSE \A(x <- {});
{} \in ordinalTwo   BECAUSE MODUS_PONENS;
(({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))
   => ({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d)))   BECAUSE IntroAndRight;
y = c => ({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d)))   BECAUSE TI;
y = c => (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE TI;

\* Case y = d
(ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))) => (\E x : x \in ordinalTwo /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE \E(x <- ordinalOne);
ordinalOne = ordinalOne   BECAUSE E_SCHEME;
y = d => (ordinalOne = ordinalOne /\ y = d)   BECAUSE IntroAndRight;
(ordinalOne = ordinalOne /\ y = d) => ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))   BECAUSE IntroOrRight;
y = d => ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))   BECAUSE TI;
x = ordinalOne => (x = {} \/ x = ordinalOne)   BECAUSE IntroOrRight;
x = ordinalOne => x \in ordinalTwo   BECAUSE TI;
\A x : x = ordinalOne => x \in ordinalTwo   BECAUSE GENERALIZATION;
ordinalOne = ordinalOne => ordinalOne \in ordinalTwo   BECAUSE \A(x <- ordinalOne);
ordinalOne \in ordinalTwo   BECAUSE MODUS_PONENS;
((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))
   => (ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d)))   BECAUSE IntroAndRight;
y = d => (ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d)))   BECAUSE TI;
y = d => (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE TI;

(y = c \/ y = d) => (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE CombineImplicationsStart;
(y = c \/ y = d) <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))   BECAUSE IntroEquiv;
(y \in b <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))) => (y \in b <=> (y = c \/ y = d))   BECAUSE TransitEquiv2;
(\A y : y \in b <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))) => (\A y : y \in b <=> (y = c \/ y = d))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> (\E x : x \in ordinalTwo /\ F(c,d,x,y))) => (\E b : \A y : y \in b <=> (y = c \/ y = d))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> (y = c \/ y = d))   BECAUSE MODUS_PONENS;
\A y : y \in { c, d } <=> (y = c \/ y = d)   BECAUSE MODUS_PONENS;
pairExists   BECAUSE GENERALIZATION;
QED

pairSymmetry == \A a : \A b : {a, b} = {b, a}
THEOREM pairSymmetry
PROOF
VARIABLES a,b,c,d,x,y;
pairExists   BECAUSE THEOREM;
x \in { a, b } <=> (x = a \/ x = b)   BECAUSE \A(c <- a, d <- b, y <- x);
x \in { b, a } <=> (x = b \/ x = a)   BECAUSE \A(c <- b, d <- a, y <- x);
(x = a \/ x = b) => (x = b \/ x = a)   BECAUSE OrSymmetry;
(x = b \/ x = a) => (x = a \/ x = b)   BECAUSE OrSymmetry;
(x = a \/ x = b) <=> (x = b \/ x = a)   BECAUSE IntroEquiv;
x \in { a, b } <=> (x = b \/ x = a)   BECAUSE   TransitEquiv;
x \in { a, b } <=> x \in { b, a }   BECAUSE   TransitEquiv2;
\A x : x \in { a, b } <=> x \in { b, a }   BECAUSE   GENERALIZATION;
extensionality   BECAUSE AXIOM;
(\A x : x \in {a,b} <=> x \in {b,a}) => {a,b} = {b,a}   BECAUSE \A(a <- {a,b}, b <- {b,a});
{a,b} = {b,a}   BECAUSE MODUS_PONENS;
pairSymmetry   BECAUSE GENERALIZATION;
QED

sameFirstPairs == \A a : \A b : \A c : {a,b} = {a,c} => b = c
THEOREM sameFirstPairs
PROOF
VARIABLES a,b,c,d,x,y;
pairExists   BECAUSE THEOREM;
b \in { a, b } <=> (b = a \/ b = b)   BECAUSE \A(c <- a, d <- b, y <- b);
b = b   BECAUSE E_SCHEME;
b = a \/ b = b   BECAUSE IntroOrRight;
b \in {a,b}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (b \in x <=> b \in y)   BECAUSE E_SCHEME;
{a,b} = {a,c} => (b \in {a,b} <=> b \in {a,c})   BECAUSE \A(x <- {a,b}, y <- {a,c});
{a,b} = {a,c} => b \in {a,c}   BECAUSE ImplyTrueEquiv;
b \in { a,c } <=> (b = a \/ b = c)   BECAUSE \A(c <- a, d <- c, y <- b);
b \in { a,c } => (b = a \/ b = c)   BECAUSE EquivToImpl;
{a,b} = {a,c} => (b = a \/ b = c)   BECAUSE TI;

c \in { a, c } <=> (c = a \/ c = c)   BECAUSE \A(c <- a, d <- c, y <- c);
c = c   BECAUSE E_SCHEME;
c = a \/ c = c   BECAUSE IntroOrRight;
c \in {a,c}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (c \in x <=> c \in y)   BECAUSE E_SCHEME;
{a,b} = {a,c} => (c \in {a,b} <=> c \in {a,c})   BECAUSE \A(x <- {a,b}, y <- {a,c});
{a,b} = {a,c} => c \in {a,b}   BECAUSE ImplyEquivTrue;
c \in { a,b } <=> (c = a \/ c = b)   BECAUSE \A(c <- a, d <- b, y <- c);
c \in { a,b } => (c = a \/ c = b)   BECAUSE EquivToImpl;
{a,b} = {a,c} => (c = a \/ c = b)   BECAUSE TI;
c = b => b = c   BECAUSE E_SCHEME;
c = a => c = a   BECAUSE ImplySelf;
(c = a \/ c = b) => (c = a \/ b = c)  BECAUSE MergeImplicationsOr;
{a,b} = {a,c} => (c = a \/ b = c)  BECAUSE TI;

{a,b} = {a,c} => ((b = a \/ b = c) /\ (c = a \/ b = c))   BECAUSE CombineImplicationsEnd;
((b = a \/ b = c) /\ (c = a \/ b = c)) => ((b = a /\ c = a) \/ b = c)  BECAUSE FactorOrAndRight;
{a,b} = {a,c} => ((b = a /\ c = a) \/ b = c)  BECAUSE TI;
(b = a /\ c = a) => b = c   BECAUSE E_SCHEME;
b = c => b = c   BECAUSE ImplySelf;
((b = a /\ c = a) \/ b = c) => (b = c \/ b = c)   BECAUSE MergeImplicationsOr;
{a,b} = {a,c} => (b = c \/ b = c)  BECAUSE TI;
(b = c \/ b = c) => b = c   BECAUSE OrSelf;
{a,b} = {a,c} => b = c  BECAUSE TI;
sameFirstPairs   BECAUSE GENERALIZATION;
QED

pairInclusion == \A x : \A y : \A t : (x \in t /\ y \in t) => {x,y} \subseteq t
THEOREM pairInclusion
PROOF
VARIABLES a,c,d,t,x,y,z;
\A z : \A x : z = x => (z \in t <=> x \in t)   BECAUSE E_SCHEME;
z = x => (z \in t <=> x \in t)   BECAUSE \A(z <- z, x <- x);
(z \in t <=> x \in t) => (x \in t => z \in t)   BECAUSE EquivToImplReverse;
z = x => (x \in t => z \in t)   BECAUSE TI;
(z = x /\ x \in t) => z \in t   BECAUSE HypoImplToAnd;
(x \in t /\ z = x) => (z = x /\ x \in t)   BECAUSE AndSymmetry;
(x \in t /\ z = x) => z \in t   BECAUSE TI;
x \in t => (z = x => z \in t)   BECAUSE HypoAndToImpl;
\A z : \A y : z = y => (z \in t <=> y \in t)   BECAUSE E_SCHEME;
z = y => (z \in t <=> y \in t)   BECAUSE \A(z <- z, y <- y);
(z \in t <=> y \in t) => (y \in t => z \in t)   BECAUSE EquivToImplReverse;
z = y => (y \in t => z \in t)   BECAUSE TI;
(z = y /\ y \in t) => z \in t   BECAUSE HypoImplToAnd;
(y \in t /\ z = y) => (z = y /\ y \in t)   BECAUSE AndSymmetry;
(y \in t /\ z = y) => z \in t   BECAUSE TI;
y \in t => (z = y => z \in t)   BECAUSE HypoAndToImpl;

(x \in t /\ y \in t) => ((z = x => z \in t) /\ (z = y => z \in t))   BECAUSE MergeImplicationsAnd;
((z = x => z \in t) /\ (z = y => z \in t)) => ((z=x \/ z=y) => z \in t)   BECAUSE FactorAndImpl;
(x \in t /\ y \in t) => ((z = x \/ z = y) => z \in t)   BECAUSE TI;
pairExists   BECAUSE THEOREM;
z \in { x, y } <=> (z = x \/ z = y)   BECAUSE \A(c <- x, d <- y, y <- z);
z \in { x, y } => (z = x \/ z = y)   BECAUSE EquivToImpl;
((z = x \/ z = y) => z \in t) => (z \in {x,y} => z \in t)   BECAUSE TI;
(x \in t /\ y \in t) => (z \in {x,y} => z \in t)   BECAUSE TI;
\A z : (x \in t /\ y \in t) => (z \in {x,y} => z \in t)   BECAUSE GENERALIZATION;
(x \in t /\ y \in t) => {x,y} \subseteq t   BECAUSE Q_SCHEME;
pairInclusion   BECAUSE GENERALIZATION;
QED

\* The pair allows to define the union of two sets
x \union y == UNION { x, y }

unionInc == \A x : \A y : \A z : z \in (x \union y) <=> (z \in x \/ z \in y)
THEOREM unionInc
PROOF
VARIABLES a,b,c,d,t,x,y,z;
unionExists   BECAUSE AXIOM;
z \in UNION {x,y} <=> \E t : t \in {x,y} /\ z \in t   BECAUSE \A(b <- {x,y}, z <- z);
z \in UNION {x,y} => \E t : t \in {x,y} /\ z \in t   BECAUSE EquivToImpl;
pairExists   BECAUSE THEOREM;
t \in { x,y } <=> (t = x \/ t = y)   BECAUSE \A(c <- x, d <- y, y <- t);
t \in { x,y } => (t = x \/ t = y)   BECAUSE EquivToImpl;
z \in t => z \in t   BECAUSE ImplySelf;
(t \in { x,y } /\ z \in t) => ((t = x \/ t = y) /\ z \in t)   BECAUSE MergeImplicationsAnd;
((t = x \/ t = y) /\ z \in t) => ((t = x /\ z \in t) \/ (t = y /\ z \in t))
   BECAUSE DistribAndOrRight;
(t \in { x,y } /\ z \in t) => ((t = x /\ z \in t) \/ (t = y /\ z \in t))
   BECAUSE TI;
\A t : \A x : t = x => (z \in t <=> z \in x)   BECAUSE E_SCHEME;
t = x => (z \in t <=> z \in x)   BECAUSE \A(t <- t, x <- x);
(t = x /\ z \in t) => z \in x   BECAUSE HypoEquivToAnd;
\A t : \A y : t = y => (z \in t <=> z \in y)   BECAUSE E_SCHEME;
t = y => (z \in t <=> z \in y)   BECAUSE \A(t <- t, y <- y);
(t = y /\ z \in t) => z \in y   BECAUSE HypoEquivToAnd;
((t = x /\ z \in t) \/ (t = y /\ z \in t)) => (z \in x \/ z \in y)   BECAUSE MergeImplicationsOr;
(t \in { x,y } /\ z \in t) => (z \in x \/ z \in y)   BECAUSE TI;
(\E t : t \in { x,y } /\ z \in t) => \E t : (z \in x \/ z \in y)   BECAUSE Q_SCHEME;
z \in (x \union y) => \E t : (z \in x \/ z \in y)   BECAUSE TI;
(\E t : (z \in x \/ z \in y)) => (z \in x \/ z \in y)   BECAUSE Q_SCHEME;
z \in (x \union y) => (z \in x \/ z \in y)   BECAUSE TI;

\* Conversely
inInUnion   BECAUSE THEOREM;
(z \in x /\ x \in {x,y}) => z \in UNION {x,y}   BECAUSE \A(a <- z, b <- x, c <- {x,y});
x \in { x,y } <=> (x = x \/ x = y)   BECAUSE \A(c <- x, d <- y, y <- x);
x = x   BECAUSE E_SCHEME;
x = x \/ x = y   BECAUSE IntroOrLeft;
x \in {x,y}   BECAUSE MODUS_PONENS;
z \in x => (z \in x /\ x \in {x,y})   BECAUSE IntroAndLeft;
z \in x => z \in (x \union y)   BECAUSE TI;
(z \in y /\ y \in {x,y}) => z \in UNION {x,y}   BECAUSE \A(a <- z, b <- y, c <- {x,y});
y \in { x,y } <=> (y = x \/ y = y)   BECAUSE \A(c <- x, d <- y, y <- y);
y = y   BECAUSE E_SCHEME;
y = x \/ y = y   BECAUSE IntroOrRight;
y \in {x,y}   BECAUSE MODUS_PONENS;
z \in y => (z \in y /\ y \in {x,y})   BECAUSE IntroAndLeft;
z \in y => z \in (x \union y)   BECAUSE TI;
(z \in x \/ z \in y) => z \in (x \union y)   BECAUSE CombineImplicationsStart;
z \in (x \union y) <=> (z \in x \/ z \in y)   BECAUSE IntroEquiv;
unionInc   BECAUSE GENERALIZATION;
QED

unionFirstInc == \A x : \A y : x \subseteq (x \union y)
THEOREM unionFirstInc
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
x \in { x, y } <=> (x = x \/ x = y)   BECAUSE \A(c <- x, d <- y, y <- x);
x = x   BECAUSE E_SCHEME;
x = x \/ x = y   BECAUSE IntroOrLeft;
x \in {x,y}   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
(z \in x /\ x \in {x,y}) => z \in (x \union y)   BECAUSE \A(a <- z, b <- x, c <- {x,y});
z \in x => (z \in x /\ x \in {x,y})   BECAUSE IntroAndLeft;
z \in x => z \in (x \union y)   BECAUSE TI;
unionFirstInc   BECAUSE GENERALIZATION;
QED

unionSecondInc == \A x : \A y : y \subseteq (x \union y)
THEOREM unionSecondInc
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
y \in { x, y } <=> (y = x \/ y = y)   BECAUSE \A(c <- x, d <- y, y <- y);
y = y   BECAUSE E_SCHEME;
y = x \/ y = y   BECAUSE IntroOrRight;
y \in {x,y}   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
(z \in y /\ y \in {x,y}) => z \in (x \union y)   BECAUSE \A(a <- z, b <- y, c <- {x,y});
z \in y => (z \in y /\ y \in {x,y})   BECAUSE IntroAndLeft;
z \in y => z \in (x \union y)   BECAUSE TI;
unionSecondInc   BECAUSE GENERALIZATION;
QED

unionSymmetry == \A x : \A y : (x \union y) = (y \union x)
THEOREM unionSymmetry
PROOF
VARIABLES a,b,x,y;
pairSymmetry   BECAUSE THEOREM;
{x, y} = {y, x}   BECAUSE \A(a <- x, b <- y);
\A x : \A y : x = y => (UNION x = UNION y)   BECAUSE E_SCHEME;
{x, y} = {y, x} => (UNION {x,y} = UNION {y,x})   BECAUSE \A(x <- {x,y}, y <- {y,x});
(x \union y) = (y \union x)   BECAUSE MODUS_PONENS;
unionSymmetry   BECAUSE GENERALIZATION;
QED

(* Tuples *)
<< c, d >> == { { c } , {c,d} }

\* This definition of binary tuples is a bit cryptic at first glance ;
\* it does yield the usual decomposition theorem :
tupleDecomposition == \A a : \A b : \A c : \A d : <<a, b>> = <<c, d>>  =>  (a = c /\ b = d)

THEOREM tupleDecomposition
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
y \in { { a } , {a,b} } <=> (y = {a} \/ y = {a,b})   BECAUSE \A(c <- {a}, d <- {a,b}, y <- y);
y \in { { c } , {c,d} } <=> (y = {c} \/ y = {c,d})   BECAUSE \A(c <- {c}, d <- {c,d}, y <- y);
\A x : \A z : x = z => (y \in x <=> y \in z)   BECAUSE E_SCHEME;
<<a,b>> = <<c,d>>  =>  (y \in <<a,b>> <=> y \in <<c,d>>)   BECAUSE \A(x <- <<a,b>>, z <- <<c,d>>);
(y = {a} \/ y = {a,b}) <=> y \in <<a,b>>   BECAUSE EquivSymmetry;
(y \in <<a,b>> <=> y \in <<c,d>>) => ((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>)   BECAUSE TransitEquiv;
<<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>)   BECAUSE TI;
(y = {c} \/ y = {c,d}) <=> y \in <<c,d>>   BECAUSE EquivSymmetry;
((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>) => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE TransitEquiv2;
<<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE TI;
\A y : <<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE GENERALIZATION;

\* Proof of <<a,b>> = <<c,d>> => a = c
<<a,b>> = <<c,d>> => (({c} = {a} \/ {c} = {a,b}) <=> ({c} = {c} \/ {c} = {c,d}))   BECAUSE \A(y <- {c});
{c} = {c}   BECAUSE E_SCHEME;
{c} = {c} \/ {c} = {c,d}   BECAUSE IntroOrLeft;
<<a,b>> = <<c,d>> => ({c} = {a} \/ {c} = {a,b})   BECAUSE ImplyEquivTrue;

singletonExists   BECAUSE THEOREM;
c \in { a } <=> c = a   BECAUSE \A(a <- a, x <- c);
c \in { a } => c = a   BECAUSE EquivToImpl;
c \in { c } <=> c = c   BECAUSE \A(a <- c, x <- c);
c = c   BECAUSE E_SCHEME;
c \in { c }   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (c \in x <=> c \in y)   BECAUSE E_SCHEME;
{c} = {a} => (c \in {c} <=> c \in {a})   BECAUSE \A(x <- {c}, y <- {a});
(c \in {c} <=> c \in {a}) => c \in {a}   BECAUSE TrueEquiv;
{c} = {a} => c \in {a}   BECAUSE TI;
{c} = {a} => c = a   BECAUSE TI;
c = a => a = c   BECAUSE E_SCHEME;
{c} = {a} => a = c   BECAUSE TI;

a \in {a,b} <=> (a = a \/ a = b)   BECAUSE \A(c <- a, d <- b, y <- a);
a = a   BECAUSE E_SCHEME;
a = a \/ a = b   BECAUSE IntroOrLeft;
a \in {a,b}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
{c} = {a,b} => (a \in {c} <=> a \in {a,b})   BECAUSE \A(x <- {c}, y <- {a,b});
(a \in {c} <=> a \in {a,b}) => a \in {c}   BECAUSE EquivTrue;
{c} = {a,b} => a \in {c}   BECAUSE TI;
a \in { c } <=> a = c   BECAUSE \A(a <- c, x <- a);
a \in { c } => a = c   BECAUSE EquivToImpl;
{c} = {a,b} => a = c   BECAUSE TI;

({c} = {a} \/ {c} = {a,b}) => a = c   BECAUSE CombineImplicationsStart;
<<a,b>> = <<c,d>> => a = c   BECAUSE TI;

\* Replace c by a
\A x : \A y : x = y => (<<a,b>> = <<x,d>> <=> <<a,b>> = <<y,d>>)   BECAUSE E_SCHEME;
a = c => (<<a,b>> = <<a,d>> <=> <<a,b>> = <<c,d>>)   BECAUSE \A(x <- a, y <- c);
<<a,b>> = <<c,d>> => (<<a,b>> = <<a,d>> <=> <<a,b>> = <<c,d>>)   BECAUSE TI;
<<a,b>> = <<c,d>> => <<a,b>> = <<a,d>>   BECAUSE ImplyEquivSelf;

\* Proof of <<a,b>> = <<a,d>> => b = d
sameFirstPairs   BECAUSE THEOREM;
{ {a},{a,b} } = {{a},{a,d}} => {a,b} = {a,d}   BECAUSE \A(a <- {a}, b <- {a,b}, c <- {a,d});
<<a,b>> = <<c,d>> => {a,b} = {a,d}   BECAUSE TI;
{ a,b } = {a,d} => b = d   BECAUSE \A(a <- a, b <- b, c <- d);
<<a,b>> = <<c,d>> => b = d   BECAUSE TI;
<<a,b>> = <<c,d>> => (a = c /\ b = d)   BECAUSE CombineImplicationsEnd;
tupleDecomposition   BECAUSE GENERALIZATION;
QED

IsCouple(c) == \E x : \E y : c = <<x,y>>
fst(c) == CHOOSE x : \E y : c = <<x,y>>
snd(c) == CHOOSE y : c = <<fst(c), y>>
swap(c) == <<snd(c), fst(c)>>

tupleComposition == \A c : IsCouple(c) => c = <<fst(c), snd(c)>>
THEOREM tupleComposition
PROOF
VARIABLES c,x,y;
(\E y : c = <<fst(c),y>>) <=> \E x : \E y : c = <<x,y>>   BECAUSE CHOOSE fst(c);
IsCouple(c) => (\E y : c = <<fst(c),y>>)   BECAUSE EquivToImplReverse;
c = <<fst(c),snd(c)>> <=> \E y : c = <<fst(c),y>>   BECAUSE CHOOSE snd(c);
(\E y : c = <<fst(c),y>>) => c = <<fst(c),snd(c)>>   BECAUSE EquivToImplReverse;
IsCouple(c) => c = <<fst(c),snd(c)>>   BECAUSE TI;
tupleComposition   BECAUSE GENERALIZATION;
QED

fstExists == \A a : \A b : a = fst(<<a,b>>)
THEOREM fstExists
PROOF
VARIABLES a,b,c,d,x,y;
tupleComposition   BECAUSE THEOREM;
IsCouple(<<a,b>>) => <<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE \A(c <- <<a,b>>);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
IsCouple(<<a,b>>)   BECAUSE \E(x <- a, y <- b);
<<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE MODUS_PONENS;
tupleDecomposition   BECAUSE THEOREM;
<<a, b>> = <<fst(<<a,b>>), snd(<<a,b>>)>> => (a = fst(<<a,b>>) /\ b = snd(<<a,b>>))   BECAUSE \A(a <- a, b <- b, c <- fst(<<a,b>>), d <- snd(<<a,b>>));
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE MODUS_PONENS;
a = fst(<<a,b>>)   BECAUSE DropAndRight;
fstExists   BECAUSE GENERALIZATION;
QED

sndExists == \A a : \A b : b = snd(<<a,b>>)
THEOREM sndExists
PROOF
VARIABLES a,b,c,d,x,y;
tupleComposition   BECAUSE THEOREM;
IsCouple(<<a,b>>) => <<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE \A(c <- <<a,b>>);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
IsCouple(<<a,b>>)   BECAUSE \E(x <- a, y <- b);
<<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE MODUS_PONENS;
tupleDecomposition   BECAUSE THEOREM;
<<a, b>> = <<fst(<<a,b>>), snd(<<a,b>>)>> => (a = fst(<<a,b>>) /\ b = snd(<<a,b>>))   BECAUSE \A(a <- a, b <- b, c <- fst(<<a,b>>), d <- snd(<<a,b>>));
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE MODUS_PONENS;
b = snd(<<a,b>>)   BECAUSE DropAndLeft;
sndExists   BECAUSE GENERALIZATION;
QED


\* The class of oriented graphs, ie sets of couples.
IsGraph(g) == \A x : x \in g => IsCouple(x)
IsDefinedOn(g,x) == \E y : <<x,y>> \in g
Reaches(g,y) == \E x : <<x,y>> \in g
Domain(g) == CHOOSE b : \A x : x \in b <=> IsDefinedOn(g,x)
Image(g) == CHOOSE b : \A y : y \in b <=> Reaches(g,y)

nodesInUnionUnion == \A x : \A y : \A g : <<x,y>> \in g
   => (x \in UNION UNION g /\ y \in UNION UNION g)
THEOREM nodesInUnionUnion
PROOF
VARIABLES a,b,c,d,g,x,y;
pairExists   BECAUSE THEOREM;
{x} \in <<x,y>> <=> ({x} = {x} \/ {x} = {x,y})   BECAUSE \A(c <- {x}, d <- {x,y}, y <- {x});
{x} = {x}   BECAUSE E_SCHEME;
{x} = {x} \/ {x} = {x,y}   BECAUSE IntroOrLeft;
{x} \in <<x,y>>   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
({x} \in <<x,y>> /\ <<x,y>> \in g) => {x} \in UNION g   BECAUSE \A(a <- {x}, b <- <<x,y>>, c <- g);
<<x,y>> \in g => ({x} \in <<x,y>> /\ <<x,y>> \in g)   BECAUSE IntroAndRight;
<<x,y>> \in g => {x} \in UNION g   BECAUSE TI;
singletonExists   BECAUSE THEOREM;
x \in { x } <=> x = x   BECAUSE \A(a <- x, x <- x);
x = x   BECAUSE E_SCHEME;
x \in { x }   BECAUSE MODUS_PONENS;
(x \in {x} /\ {x} \in UNION g) => x \in UNION UNION g   BECAUSE \A(a <- x, b <- {x}, c <- UNION g);
{x} \in UNION g => (x \in {x} /\ {x} \in UNION g)   BECAUSE IntroAndRight;
{x} \in UNION g => x \in UNION UNION g   BECAUSE TI;
<<x,y>> \in g => x \in UNION UNION g   BECAUSE TI;

{x,y} \in <<x,y>> <=> ({x,y} = {x} \/ {x,y} = {x,y})   BECAUSE \A(c <- {x}, d <- {x,y}, y <- {x,y});
{x,y} = {x,y}   BECAUSE E_SCHEME;
{x,y} = {x} \/ {x,y} = {x,y}   BECAUSE IntroOrRight;
{x,y} \in <<x,y>>   BECAUSE MODUS_PONENS;
({x,y} \in <<x,y>> /\ <<x,y>> \in g) => {x,y} \in UNION g   BECAUSE \A(a <- {x,y}, b <- <<x,y>>, c <- g);
<<x,y>> \in g => ({x,y} \in <<x,y>> /\ <<x,y>> \in g)   BECAUSE IntroAndRight;
<<x,y>> \in g => {x,y} \in UNION g   BECAUSE TI;
y \in { x, y } <=> (y = x \/ y = y)   BECAUSE \A(c <- x, d <- y, y <- y);
y = y   BECAUSE E_SCHEME;
y = x \/ y = y   BECAUSE IntroOrRight;
y \in { x, y }   BECAUSE MODUS_PONENS;
(y \in {x,y} /\ {x,y} \in UNION g) => y \in UNION UNION g   BECAUSE \A(a <- y, b <- {x,y}, c <- UNION g);
{x,y} \in UNION g => (y \in {x,y} /\ {x,y} \in UNION g)   BECAUSE IntroAndRight;
{x,y} \in UNION g => y \in UNION UNION g   BECAUSE TI;
<<x,y>> \in g => y \in UNION UNION g   BECAUSE TI;

<<x,y>> \in g => (x \in UNION UNION g /\ y \in UNION UNION g)   BECAUSE CombineImplicationsEnd;
nodesInUnionUnion   BECAUSE GENERALIZATION;
QED

domainExists == \A g : \A x : x \in Domain(g) <=> IsDefinedOn(g,x)
THEOREM domainExists
PROOF
VARIABLES a,b,g,x,y;
\* By separation in UNION UNION g
(\A x : x \in Domain(g) <=> IsDefinedOn(g,x))
   <=> \E b : \A x : x \in b <=> IsDefinedOn(g,x)   BECAUSE CHOOSE Domain(g);
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsDefinedOn(g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))   BECAUSE \A(a <- UNION UNION g);
(x \in UNION UNION g /\ IsDefinedOn(g,x)) => IsDefinedOn(g,x)   BECAUSE DropAndLeft;
nodesInUnionUnion   BECAUSE THEOREM;
<<x,y>> \in g => (x \in UNION UNION g /\ y \in UNION UNION g)   BECAUSE \A(x <- x, y <- y, g <- g);
(x \in UNION UNION g /\ y \in UNION UNION g) => x \in UNION UNION g   BECAUSE DropAndRight;
<<x,y>> \in g => x \in UNION UNION g   BECAUSE TI;
IsDefinedOn(g,x) => \E y : x \in UNION UNION g   BECAUSE Q_SCHEME;
(\E y : x \in UNION UNION g) => x \in UNION UNION g   BECAUSE Q_SCHEME;
IsDefinedOn(g,x) => x \in UNION UNION g   BECAUSE TI;
(x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (x \in b <=> IsDefinedOn(g,x))   BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (\A x : x \in b <=> IsDefinedOn(g,x))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (\E b : \A x : x \in b <=> IsDefinedOn(g,x))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> IsDefinedOn(g,x)   BECAUSE MODUS_PONENS;
\A x : x \in Domain(g) <=> IsDefinedOn(g,x)   BECAUSE MODUS_PONENS;
domainExists   BECAUSE GENERALIZATION;
QED

imageExists == \A g : \A y : y \in Image(g) <=> Reaches(g,y)
THEOREM imageExists
PROOF
VARIABLES a,b,g,x,y;
\* By separation in UNION UNION g
\A a : \E b : \A x : x \in b <=> (x \in a /\ Reaches(g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in UNION UNION g /\ Reaches(g,x))   BECAUSE \A(a <- UNION UNION g);

chooseB(g) == CHOOSE b : \A x : x \in b <=> (x \in UNION UNION g /\ Reaches(g,x));
(\A x : x \in chooseB(g) <=> (x \in UNION UNION g /\ Reaches(g,x)))
   <=> \E b : \A x : x \in b <=> (x \in UNION UNION g /\ Reaches(g,x))   BECAUSE CHOOSE chooseB(g);
\A x : x \in chooseB(g) <=> (x \in UNION UNION g /\ Reaches(g,x))   BECAUSE MODUS_PONENS;
y \in chooseB(g) <=> (y \in UNION UNION g /\ Reaches(g,y))   BECAUSE \A(x <- y);

(y \in UNION UNION g /\ Reaches(g,y)) => Reaches(g,y)   BECAUSE DropAndLeft;
nodesInUnionUnion   BECAUSE THEOREM;
<<x,y>> \in g => (x \in UNION UNION g /\ y \in UNION UNION g)   BECAUSE \A(x <- x, y <- y, g <- g);
(x \in UNION UNION g /\ y \in UNION UNION g) => y \in UNION UNION g   BECAUSE DropAndLeft;
<<x,y>> \in g => y \in UNION UNION g   BECAUSE TI;
(\E x : <<x,y>> \in g) => \E x : y \in UNION UNION g   BECAUSE Q_SCHEME;
(\E x : y \in UNION UNION g) => y \in UNION UNION g   BECAUSE Q_SCHEME;
Reaches(g,y) => y \in UNION UNION g   BECAUSE TI;
y \in chooseB(g) <=> Reaches(g,y)   BECAUSE SeparationTauto;
\A y : y \in chooseB(g) <=> Reaches(g,y)   BECAUSE GENERALIZATION;
\E b : \A y : y \in b <=> Reaches(g,y)   BECAUSE \E(b <- chooseB(g));
(\A y : y \in Image(g) <=> Reaches(g,y))
   <=> (\E b : \A y : y \in b <=> Reaches(g,y))   BECAUSE CHOOSE Image(g);
\A y : y \in Image(g) <=> Reaches(g,y)   BECAUSE MODUS_PONENS;
imageExists   BECAUSE GENERALIZATION;
QED

domainInc == \A g : \A x : \A y : <<x,y>> \in g => x \in Domain(g)
THEOREM domainInc
PROOF
VARIABLES g,x,y;
domainExists   BECAUSE THEOREM;
x \in Domain(g) <=> IsDefinedOn(g,x)   BECAUSE \A(g <- g, x <- x);
(\E y : <<x,y>> \in g) => x \in Domain(g)   BECAUSE EquivToImplReverse;
<<x,y>> \in g => (\E y : <<x,y>> \in g)   BECAUSE \E(y <- y);
<<x,y>> \in g => x \in Domain(g)   BECAUSE TI;
domainInc   BECAUSE GENERALIZATION;
QED

imageInc == \A g : \A x : \A y : <<x,y>> \in g => y \in Image(g)
THEOREM imageInc
PROOF
VARIABLES g,x,y;
imageExists   BECAUSE THEOREM;
y \in Image(g) <=> Reaches(g,y)   BECAUSE \A(g <- g, y <- y);
(\E x : <<x,y>> \in g) => y \in Image(g)   BECAUSE EquivToImplReverse;
<<x,y>> \in g => (\E x : <<x,y>> \in g)   BECAUSE \E(x <- x);
<<x,y>> \in g => y \in Image(g)   BECAUSE TI;
imageInc   BECAUSE GENERALIZATION;
QED

assocCompose == \A f : \A g : \A h : compose(f, compose(g,h)) = compose(compose(f,g), h)
THEOREM assocCompose
\* TODO

multiApply(f, multiX) == CHOOSE b : \A x : x \in b <=> \E u : u \in multiX /\ <<u,x>> \in f

multiApplyExists == \A f : \A multiX : \A x : x \in multiApply(f,multiX)
   <=> \E u : u \in multiX /\ <<u,x>> \in f
THEOREM multiApplyExists
PROOF
VARIABLES a,b,c,f,g,u,x,y,multiX;
\* By separation in Image(f)
(\A x : x \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,x>> \in f)
   <=> (\E b : \A x : x \in b <=> \E u : u \in multiX /\ <<u,x>> \in f)
   BECAUSE CHOOSE multiApply(f,multiX);
\A a : \E b : \A x : x \in b <=> ( x \in a /\ (\E u : u \in multiX /\ <<u,x>> \in f) )   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) )   BECAUSE \A(a <- Image(f));

imageInc   BECAUSE THEOREM;
<<u,x>> \in f => x \in Image(f)   BECAUSE \A(g <- f, x <- u, y <- x);
(u \in multiX /\ <<u,x>> \in f) => <<u,x>> \in f   BECAUSE DropAndLeft;
(u \in multiX /\ <<u,x>> \in f) => x \in Image(f)   BECAUSE TI;
(\E u : u \in multiX /\ <<u,x>> \in f) => \E u : x \in Image(f)   BECAUSE Q_SCHEME;
(\E u : x \in Image(f)) => x \in Image(f)   BECAUSE Q_SCHEME;
(\E u : u \in multiX /\ <<u,x>> \in f) => x \in Image(f)   BECAUSE TI;
(x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) ))
   => (x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f) )
   BECAUSE SeparationTauto;
(\A x : x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) ))
   => (\A x : x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f) )
   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> ( x \in Image(f) /\ (\E u : u \in multiX /\ <<u,x>> \in f) ))
   => (\E b : \A x : x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f) )
   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (\E u : u \in multiX /\ <<u,x>> \in f)   BECAUSE MODUS_PONENS;
\A x : x \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,x>> \in f   BECAUSE MODUS_PONENS;
multiApplyExists   BECAUSE GENERALIZATION;
QED

(*
   Definition of the cartesian product, the set of couples between two sets.
*)
i \X j == CHOOSE b : \A x : x \in b <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)

cartesianProductExists == \A i : \A j : \A x :
   x \in (i \X j) <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)

THEOREM cartesianProductExists
PROOF
VARIABLES a,b,c,d,i,j,t,u,v,x,y,z;
\* By separation in SUBSET SUBSET (i \union j)
(\A x : x \in (i \X j) <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))
   <=> (\E b : \A x : x \in b <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))   BECAUSE CHOOSE i \X j;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))   BECAUSE \A(a <- SUBSET SUBSET (i \union j));
chooseB(i,j) == CHOOSE b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j));
(\A x : x \in chooseB(i,j) <=> (x \in SUBSET SUBSET (i \union j) /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)))
   <=> \E b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))   BECAUSE CHOOSE chooseB(i,j);
\A x : x \in chooseB(i,j) <=> (x \in SUBSET SUBSET (i \union j) /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))
   BECAUSE MODUS_PONENS;
x \in chooseB(i,j) <=> (x \in SUBSET SUBSET (i \union j) /\ (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j))
   BECAUSE \A(x <- x);

\* Proof that (u \in i /\ v \in j) => <<u,v>> \subseteq SUBSET (i \union j), ie that {u} \in SUBSET (i \union j),
\* ie that {u} \subseteq (i \union j)
unionFirstInc   BECAUSE THEOREM;
i \subseteq (i \union j)   BECAUSE \A(x <- i, y <- j);
u \in i => u \in (i \union j)   BECAUSE \A(z <- u);
singletonExists   BECAUSE THEOREM;
z \in { u } <=> z = u   BECAUSE \A(a <-u, x <- z);
z \in { u } => z = u   BECAUSE EquivToImpl;
(u \in i /\ z \in {u}) => (u \in (i \union j) /\ z = u)   BECAUSE MergeImplicationsAnd;
\A z : \A u : z = u => (z \in (i \union j) <=> u \in (i \union j))   BECAUSE E_SCHEME;
z = u => (z \in (i \union j) <=> u \in (i \union j))   BECAUSE \A(z <- z, u <- u);
(z \in (i \union j) <=> u \in (i \union j)) => (u \in (i \union j) => z \in (i \union j))   BECAUSE EquivToImplReverse;
z = u => (u \in (i \union j) => z \in (i \union j))   BECAUSE TI;
(z = u /\ u \in (i \union j)) => z \in (i \union j)   BECAUSE HypoImplToAnd;
(u \in (i \union j) /\ z = u) => (z = u /\ u \in (i \union j))   BECAUSE AndSymmetry;
(u \in (i \union j) /\ z = u) => z \in (i \union j)   BECAUSE TI;
(u \in i /\ z \in {u}) => z \in (i \union j)   BECAUSE TI;
u \in i => (z \in {u} => z \in (i \union j))   BECAUSE HypoAndToImpl;
\A z : u \in i => (z \in {u} => z \in (i \union j))   BECAUSE GENERALIZATION;
u \in i => {u} \subseteq (i \union j)   BECAUSE Q_SCHEME;
powersetExists   BECAUSE AXIOM;
{u} \in SUBSET (i \union j) <=> {u} \subseteq (i \union j)   BECAUSE \A(x <- i \union j, z <- {u});
{u} \subseteq (i \union j) => {u} \in SUBSET (i \union j)   BECAUSE EquivToImplReverse;
u \in i => {u} \in SUBSET (i \union j)   BECAUSE TI;

\* Proof of {u,v} \in SUBSET (i \union j)
unionSecondInc   BECAUSE THEOREM;
j \subseteq (i \union j)   BECAUSE \A(x <- i, y <- j);
v \in j => v \in (i \union j)   BECAUSE \A(z <- v);
(u \in i /\ v \in j) => (u \in (i \union j) /\ v \in (i \union j))   BECAUSE MergeImplicationsAnd;
pairInclusion   BECAUSE THEOREM;
(u \in (i \union j) /\ v \in (i \union j)) => {u,v} \subseteq (i \union j)   BECAUSE \A(x <- u, y <- v, t <- i \union j);
(u \in i /\ v \in j) => {u,v} \subseteq (i \union j)   BECAUSE TI;
{u,v} \in SUBSET (i \union j) <=> {u,v} \subseteq (i \union j)   BECAUSE \A(x <- i \union j, z <- {u,v});
{u,v} \subseteq (i \union j) => {u,v} \in SUBSET (i \union j)   BECAUSE EquivToImplReverse;
(u \in i /\ v \in j) => {u,v} \in SUBSET (i \union j)   BECAUSE TI;

\* Proof of (u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)
(u \in i /\ v \in j) => u \in i   BECAUSE DropAndRight;
(u \in i /\ v \in j) => {u} \in SUBSET (i \union j)   BECAUSE TI;
(u \in i /\ v \in j) => ({u} \in SUBSET (i \union j) /\ {u,v} \in SUBSET (i \union j))   BECAUSE CombineImplicationsEnd;
({u} \in SUBSET (i \union j) /\ {u,v} \in SUBSET (i \union j))
   => <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE \A(x <- {u}, y <- {u,v}, t <- SUBSET (i \union j));
(u \in i /\ v \in j) => <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE TI;
<<u,v>> \in SUBSET SUBSET (i \union j)
   <=> <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE \A(x <- SUBSET (i \union j), z <- <<u,v>>);
<<u,v>> \subseteq SUBSET (i \union j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE EquivToImplReverse;
(u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE TI;

\* Substitution of fst(x) and snd(x) into u and v
\A u : \A v : (u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE GENERALIZATION;
(fst(x) \in i /\ snd(x) \in j) => <<fst(x),snd(x)>> \in SUBSET SUBSET (i \union j)   BECAUSE \A(u <- fst(x), v <- snd(x));
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
(IsCouple(x) /\ (fst(x) \in i /\ snd(x) \in j))
   => (x = <<fst(x), snd(x)>> /\ <<fst(x),snd(x)>> \in SUBSET SUBSET (i \union j))   BECAUSE MergeImplicationsAnd;
\A x : \A y : x = y => (x \in SUBSET SUBSET (i \union j) <=> y \in SUBSET SUBSET (i \union j))
   BECAUSE E_SCHEME;
x = <<fst(x),snd(x)>> => (x \in SUBSET SUBSET (i \union j) <=> <<fst(x),snd(x)>> \in SUBSET SUBSET (i \union j))
   BECAUSE \A(x <- x, y <- <<fst(x),snd(x)>>);
(x = <<fst(x),snd(x)>> /\ <<fst(x),snd(x)>> \in SUBSET SUBSET (i \union j))
   => x \in SUBSET SUBSET (i \union j)   BECAUSE HypoEquivToAndReverse;
(IsCouple(x) /\ (fst(x) \in i /\ snd(x) \in j))
   => x \in SUBSET SUBSET (i \union j)   BECAUSE TI;
(IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j) => (IsCouple(x) /\ (fst(x) \in i /\ snd(x) \in j))   BECAUSE AssocAnd;
(IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)
   => x \in SUBSET SUBSET (i \union j)   BECAUSE TI;
x \in chooseB(i,j) <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)   BECAUSE SeparationTauto;
\A x : x \in chooseB(i,j) <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)   BECAUSE GENERALIZATION;
\E b : \A x : x \in b <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)   BECAUSE \E(b <- chooseB(i,j));
\A x : x \in (i \X j) <=> (IsCouple(x) /\ fst(x) \in i /\ snd(x) \in j)   BECAUSE MODUS_PONENS;
cartesianProductExists   BECAUSE GENERALIZATION;
QED

(*
   Convenience theorem for which couples are in a cartesian product.
   It is weaker than the definition of cartesian products, which adds
   that all elements are couples.
*)
cartesianProductCouples == \A x : \A y : \A a : \A b : (a \in x /\ b \in y) <=> <<a,b>> \in (x \X y)

THEOREM cartesianProductCouples
PROOF
VARIABLES a,b,c,d,i,j,u,v,x,y;
cartesianProductExists   BECAUSE THEOREM;
<<a,b>> \in (x \X y) <=> (IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in x /\ snd(<<a,b>>) \in y)
   BECAUSE \A(i <- x, j <- y, x <- <<a,b>>);
<<a,b>> = <<a,b>>   BECAUSE E_SCHEME;
IsCouple(<<a,b>>)   BECAUSE \E(x <- a, y <- b);
dropTrue(a,b,t) == t => ((t /\ a /\ b) <=> (a /\ b))   PROPO_TAUTO;
(IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in x /\ snd(<<a,b>>) \in y) <=> (fst(<<a,b>>) \in x /\ snd(<<a,b>>) \in y)   BECAUSE dropTrue;
<<a,b>> \in (x \X y) <=> (fst(<<a,b>>) \in x /\ snd(<<a,b>>) \in y)   BECAUSE TransitEquiv;
tupleComposition   BECAUSE THEOREM;
IsCouple(<<a,b>>) => <<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE \A(c <- <<a,b>>);
<<a,b>> = <<fst(<<a,b>>), snd(<<a,b>>)>>   BECAUSE MODUS_PONENS;
tupleDecomposition   BECAUSE THEOREM;
<<a, b>> = <<fst(<<a,b>>), snd(<<a,b>>)>> => (a = fst(<<a,b>>) /\ b = snd(<<a,b>>))
   BECAUSE \A(a <- a, b <- b, c <- fst(<<a,b>>), d <- snd(<<a,b>>));
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE MODUS_PONENS;
\A a : \A u : \A b : \A v : (a = u /\ b = v) => ((a \in x /\ b \in y) <=> (u \in x /\ v \in y))
   BECAUSE E_SCHEME;
(a = fst(<<a,b>>) /\ b = snd(<<a,b>>)) => ((a \in x /\ b \in y) <=> (fst(<<a,b>>) \in x /\ snd(<<a,b>>) \in y))   BECAUSE \A(a <- a, u <- fst(<<a,b>>), b <- b, v <- snd(<<a,b>>));
(a \in x /\ b \in y) <=> (fst(<<a,b>>) \in x /\ snd(<<a,b>>) \in y)   BECAUSE MODUS_PONENS;
<<a,b>> \in (x \X y) <=> (a \in x /\ b \in y)   BECAUSE TransitEquiv2;
(a \in x /\ b \in y) <=> <<a,b>> \in (x \X y)   BECAUSE EquivSymmetry;
cartesianProductCouples   BECAUSE GENERALIZATION;
QED

compose(g,h) == CHOOSE b : \A x : x \in b <=>
   (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)

composeExists == \A g : \A h : \A x : x \in compose(g,h) <=>
   (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)
THEOREM composeExists
PROOF
\* By separation in Domain(h) \X Image(g)
VARIABLES a,b,c,g,h,t,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in (Domain(h) \X Image(g)) /\ (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g))   BECAUSE \A(a <- Domain(h) \X Image(g));
domainInc   BECAUSE THEOREM;
<<fst(x),t>> \in h => fst(x) \in Domain(h)   BECAUSE \A(g <- h, x <- fst(x), y <- t);
imageInc   BECAUSE THEOREM;
<<t,snd(x)>> \in g => snd(x) \in Image(g)   BECAUSE \A(g <- g, x <- t, y <- snd(x));
(<<fst(x),t>> \in h /\ <<t,snd(x)>> \in g) => (fst(x) \in Domain(h) /\ snd(x) \in Image(g))
   BECAUSE MergeImplicationsAnd;
(\E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g) => (\E t : fst(x) \in Domain(h) /\ snd(x) \in Image(g))   BECAUSE Q_SCHEME;
(\E t : fst(x) \in Domain(h) /\ snd(x) \in Image(g)) => (fst(x) \in Domain(h) /\ snd(x) \in Image(g))   BECAUSE Q_SCHEME;
(\E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g) => (fst(x) \in Domain(h) /\ snd(x) \in Image(g))   BECAUSE TI;
cartesianProductCouples   BECAUSE THEOREM;
(fst(x) \in Domain(h) /\ snd(x) \in Image(g)) <=> <<fst(x),snd(x)>> \in (Domain(h) \X Image(g))
   BECAUSE \A(x <- Domain(h), y <- Image(g), a <- fst(x), b <- snd(x)); 
(fst(x) \in Domain(h) /\ snd(x) \in Image(g)) => <<fst(x),snd(x)>> \in (Domain(h) \X Image(g))   BECAUSE EquivToImpl;
(\E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g) => <<fst(x),snd(x)>> \in (Domain(h) \X Image(g))   BECAUSE TI;
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
(IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)
   => (x = <<fst(x), snd(x)>> /\ <<fst(x),snd(x)>> \in (Domain(h) \X Image(g)))   BECAUSE MergeImplicationsAnd;
\A x : \A y : x = y => (x \in (Domain(h) \X Image(g)) <=> y \in (Domain(h) \X Image(g)))   BECAUSE E_SCHEME;
x = <<fst(x), snd(x)>> => (x \in (Domain(h) \X Image(g)) <=> <<fst(x), snd(x)>> \in (Domain(h) \X Image(g)))   BECAUSE \A(x <- x, y <- <<fst(x), snd(x)>>);
(x = <<fst(x), snd(x)>> /\ <<fst(x), snd(x)>> \in (Domain(h) \X Image(g))) => x \in (Domain(h) \X Image(g))   BECAUSE HypoEquivToAndReverse;
(IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g) => x \in (Domain(h) \X Image(g))   BECAUSE TI;
(x \in b <=> (x \in (Domain(h) \X Image(g)) /\ (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g))) => (x \in b <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)) BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in (Domain(h) \X Image(g)) /\ (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g))) => (\A x : x \in b <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)) BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in (Domain(h) \X Image(g)) /\ (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g))) => (\E b : \A x : x \in b <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)) BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)   BECAUSE MODUS_PONENS;
(\A x : x \in compose(g,h) <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)) <=> (\E b : \A x : x \in b <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g))   BECAUSE CHOOSE compose(g,h);
\A x : x \in compose(g,h) <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in h /\ <<t,snd(x)>> \in g)   BECAUSE MODUS_PONENS;
composeExists   BECAUSE GENERALIZATION;
QED

(*
   Definition of the disjoint union : the union of 2 sets where the common
   elements are copied so that they are different in the union. The disjoint
   union of natural number is very close to their addition, this will be
   made rigorous in the Ordinals module.
*)
disjointUnion(x,y) == (x \X {{}}) \union (y \X {ordinalOne})

disjUnionFirstInc == \A x : \A y : \A z : z \in x => <<z,{}>> \in disjointUnion(x,y)
THEOREM disjUnionFirstInc
PROOF
VARIABLES a,b,i,j,x,y,z;
cartesianProductCouples   BECAUSE THEOREM;
(z \in x /\ {} \in {{}}) <=> <<z,{}>> \in (x \X {{}})   BECAUSE \A(x <- x, y <- {{}}, a <- z, b <- {});
singletonExists   BECAUSE THEOREM;
{} \in { {} } <=> {} = {}   BECAUSE \A(a <- {}, x <- {});
{} = {}   BECAUSE E_SCHEME;
{} \in { {} }   BECAUSE MODUS_PONENS;
z \in x => (z \in x /\ {} \in {{}})   BECAUSE IntroAndLeft;
z \in x => <<z,{}>> \in (x \X {{}})   BECAUSE TIE;
unionFirstInc   BECAUSE THEOREM;
(x \X {{}}) \subseteq disjointUnion(x,y)   BECAUSE \A(x <- x \X {{}}, y <- y \X {ordinalOne});
<<z,{}>> \in (x \X {{}}) => <<z,{}>> \in disjointUnion(x,y)   BECAUSE \A(z <- <<z,{}>>);
z \in x => <<z,{}>> \in disjointUnion(x,y)   BECAUSE TI;
disjUnionFirstInc   BECAUSE GENERALIZATION;
QED

disjUnionSecondInc == \A x : \A y : \A z : z \in y => <<z,ordinalOne>> \in disjointUnion(x,y)
THEOREM disjUnionSecondInc
PROOF
VARIABLES a,b,i,j,x,y,z;
cartesianProductCouples   BECAUSE THEOREM;
(z \in y /\ ordinalOne \in {ordinalOne}) <=> <<z,ordinalOne>> \in (y \X {ordinalOne})   BECAUSE \A(x <- y, y <- {ordinalOne}, a <- z, b <- ordinalOne);
singletonExists   BECAUSE THEOREM;
ordinalOne \in { ordinalOne } <=> ordinalOne = ordinalOne   BECAUSE \A(a <- ordinalOne, x <- ordinalOne);
ordinalOne = ordinalOne   BECAUSE E_SCHEME;
ordinalOne \in { ordinalOne }   BECAUSE MODUS_PONENS;
z \in y => (z \in y /\ ordinalOne \in {ordinalOne})   BECAUSE IntroAndLeft;
z \in y => <<z,ordinalOne>> \in (y \X {ordinalOne})   BECAUSE TIE;
unionSecondInc   BECAUSE THEOREM;
(y \X {ordinalOne}) \subseteq disjointUnion(x,y)   BECAUSE \A(x <- x \X {{}}, y <- y \X {ordinalOne});
<<z,ordinalOne>> \in (y \X {ordinalOne}) => <<z,ordinalOne>> \in disjointUnion(x,y)   BECAUSE \A(z <- <<z,ordinalOne>>);
z \in y => <<z,ordinalOne>> \in disjointUnion(x,y)   BECAUSE TI;
disjUnionSecondInc   BECAUSE GENERALIZATION;
QED

Infinity == \E a : {} \in a /\ \A x : x \in a => x \union {x} \in a
AXIOM Infinity