(*
   This file contains the basic definitions for mathematics, the ZFC axioms of set theory.
   For more information : en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory.
   
   The membership relation \in is declared (without a definition because it is primitive),
   then the inclusion relation \subseteq.

   The axioms defined are extensionality, powerset, union and infinity. The axiom schemes
   of separation and replacement are also defined.

   The operators defined are the empty set, singleton of a set, pair of sets, couples,
   union of two sets, intersection of two sets, cartesian product and disjoint union.

   The relations defined are graphs, functions and orders. The function application
   operator is also defined.
*)

EXTENDS Tautologies

\* The membership binary relation, the only primitive symbol of ZFC :
CONSTANT _ \in _

aSetExists == \E x : x = x

THEOREM aSetExists
PROOF
VARIABLES x;
(\A x : ~(x = x)) => ~(x = x)   BECAUSE \A(x <- x);
~~(x = x) => ~(\A x : ~(x = x))   BECAUSE Contraposition;
x = x => ~~(x = x)   BECAUSE IntroNotNot;
x = x   BECAUSE E_SCHEME;
~~(x = x)   BECAUSE MODUS_PONENS;
~(\A x : ~(x = x))   BECAUSE MODUS_PONENS;
(\E x : x = x)  <=>  ~(\A x : ~(x = x))   BECAUSE Q_SCHEME;
aSetExists   BECAUSE MODUS_PONENS;
QED

(*
   The theorem above uses only logical axioms, the constant binary
   relation \in does not appear in the proof. It is a general property
   of first-order logic with equality : something exists.

   Let's continue with a property of binary relations in
   first-order logic.
*)
russellParadox == ~\E x : \A y : y \in x <=> ~(y \in y)

contraposNeg(a,b) == (a <=> ~b) => (b => ~a)  PROPO_TAUTO contraposNeg

THEOREM russellParadox
PROOF
VARIABLES x,y,a,h,b;
\* If such a set x existed, it would both belong and not belong to itself
(\A y : y \in x <=> ~(y \in y)) => (x \in x <=> ~(x \in x))   BECAUSE \A(y <- x);
~(\A y : y \in x <=> ~(y \in y))   BECAUSE ContradictionEquiv;
\A x : ~(\A y : y \in x <=> ~(y \in y))   BECAUSE GENERALIZATION;
(\E x : \A y : y \in x <=> ~(y \in y)) <=> ~(\A x : ~(\A y : y \in x <=> ~(y \in y)))  BECAUSE Q_SCHEME;
(\A x : ~(\A y : y \in x <=> ~(y \in y))) => ~(\E x : \A y : y \in x <=> ~(y \in y))  BECAUSE contraposNeg;
russellParadox   BECAUSE MODUS_PONENS;
QED

(*
   We still don't have axioms to define what sets are.
   The proof of Russell's paradox works with any binary relation,
   for example < in Peano arithmetic : it then states that there
   is no number greater than all others.

   Russell's paradox constrains what axioms we can take for sets.
   If we are not careful, we can choose axioms proving its contrary.
*)

\* The first axiom for sets : two sets are equal iif they have the same
\* elements, and an element appears at most once in a set.
extensionality == \A a : \A b : (\A x : x \in a <=> x \in b) => a = b
AXIOM extensionality

\* Inclusion of sets.
x \subseteq y == \A z : z \in x => z \in y

bothInclusions == \A a : \A b : (a \subseteq b /\ b \subseteq a) => a = b
THEOREM bothInclusions

PROOF
VARIABLES z, y, x, b, a, i, j, t;
extensionality   BECAUSE AXIOM;
(\A x : x \in a <=> x \in b) => a = b   BECAUSE \A(a <- a, b <- b);

h == a \subseteq b /\ b \subseteq a;
((\A z : z \in a => z \in b) /\ (\A z : z \in b => z \in a))
   => \A z : (z \in a => z \in b) /\ (z \in b => z \in a)   BECAUSE Q_SCHEME;
(z \in a => z \in b) => ((z \in b => z \in a) => (z \in a <=> z \in b))   BECAUSE IntroEquiv;
((z \in a => z \in b) /\ (z \in b => z \in a)) => (z \in a <=> z \in b)   BECAUSE HypoImplToAnd;
(\A z : (z \in a => z \in b) /\ (z \in b => z \in a)) => (\A z : z \in a <=> z \in b)   BECAUSE Q_SCHEME;
h => \A z : z \in a <=> z \in b   BECAUSE TransitImplication;

(\A z : z \in a <=> z \in b) => (x \in a <=> x \in b)   BECAUSE \A(z <- x);
\A x : (\A z : z \in a <=> z \in b) => (x \in a <=> x \in b)   BECAUSE GENERALIZATION;
(\A z : z \in a <=> z \in b) => (\A x : x \in a <=> x \in b)   BECAUSE Q_SCHEME;
h => (\A x : x \in a <=> x \in b)   BECAUSE TransitImplication;
h => a = b    BECAUSE TransitImplication;
bothInclusions   BECAUSE GENERALIZATION;
QED

inclusionInOneself == \A x : x \subseteq x
THEOREM inclusionInOneself
PROOF
VARIABLES z, x;
z \in x => z \in x   BECAUSE ImplyOneself;
\A z : z \in x => z \in x   BECAUSE GENERALIZATION;
inclusionInOneself   BECAUSE GENERALIZATION;
QED

(*
   The axiom scheme of separation. Although it can be deduced from the
   axiom scheme of replacement, we declare it for easier use
   and better tracking of where replacement is needed.

   The variable "a" can be free in F as in the axiom
       \A a : \E b : \A x : x \in b <=> (x \in a /\ x \subseteq a)
   However we exclude b from the free variables of F, to avoid the
   self-contradicting formula
       \A a : \E b : \A x : x \in b <=> (x \in a /\ x \notin b)
   t is contrary to Russell's paradox so we cannot have it as an axiom.

   Here is the derivation of the separation axiom scheme from the
   replacement axiom scheme :
   sep(x,y) == x = y /\ F(x)
   sep(x,y) /\ sep(x,y') => x = y /\ x = y'   BECAUSE PT;
   (x = y /\ x = y') => y = y'   BECAUSE AXIOM_SCHEME;
   sep(x,y) /\ sep(x,y') => y = y'   BECAUSE TransitImplication;
   \A x : \A y : \A y' : sep(x,y) /\ sep(x,y') => y = y'   BECAUSE GENERALIZATION;
   \* replacement scheme : by hypothesis formula F has no free occurrences of variable b
   (\A x : \A y : \A y' : sep(x,y) /\ sep(x,y') => y = y')
      => \A a : \E b : \A x : x \in b <=> \E y : y \in a /\ sep(x,y)   BECAUSE AXIOM_SCHEME;
   \A a : \E b : \A x : x \in b <=> \E y : y \in a /\ sep(x,y)   BECAUSE MODUS_PONENS;
*)
separation(F) == \A a : \E b : \A x : x \in b <=> (x \in a /\ F)
AXIOM_SCHEME BOUND_VAR(b) separation

(*
   The full axiom scheme of replacement : the image of a set by
   a functional relation is a set. It can be interpreted as a size
   guard, the image b is smaller than the starting set a, so
   there is no risk of b exploding outside the limits of sets.
*)
replacement(F) == (\A x : \A y : \A z : (F /\ F(y <- z)) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ F)
AXIOM_SCHEME BOUND_VAR(b) replacement


(*
   There exists a set such that any set is not a member of it. It is called
   the empty set. This empty set is rather mysterious : it exists so it is
   something, however there is nothing in it, so by extensionality it should
   be nothing too.

   Besides, we will see with the axiom of foundation that this empty set is
   the atom, the elementary building block for all sets, ie all mathematics.
*)
{} == CHOOSE b : \A x : x \notin b
emptySetExists == \A x : x \notin {}

equivFalse(a,b,t) == t => ((a <=> (b /\ ~t)) => ~a)   PROPO_TAUTO equivFalse

THEOREM emptySetExists
PROOF
VARIABLES x, a, b;
(\A x : x \notin {}) <=> \E b : \A x : x \notin b   BECAUSE CHOOSE;

\* Construct the empty by the separation axiom with a contradictory formula
\A a : \E b : \A x : x \in b <=> (x \in a /\ ~(x = x))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in a /\ ~(x = x))   BECAUSE \A(a <- a);

\* Prove that this set b has no elements, because x \neq x is always false
x = x   BECAUSE E_SCHEME;
(x \in b <=> (x \in a /\ ~(x = x))) => x \notin b   BECAUSE equivFalse;
(\A x : x \in b <=> (x \in a /\ ~(x = x))) => \A x : x \notin b   BECAUSE Q_SCHEME;

(\E b : \A x : x \in b <=> (x \in a /\ ~(x = x))) => (\E b : \A x : x \notin b)   BECAUSE Q_SCHEME;
\E b : \A x : x \notin b   BECAUSE MODUS_PONENS;
emptySetExists   BECAUSE MODUS_PONENS;
QED

equivImpossible(a,b) == ~b => (~a => (a <=> b))
PROPO_TAUTO equivImpossible

emptySetUnique == \A a : (\A x : x \notin a) => a = {}
THEOREM emptySetUnique
PROOF
VARIABLES a,b,x;
emptySetExists BECAUSE THEOREM;
x \notin {} BECAUSE \A(x <- x);
(x \notin {}) => ((x \notin a) => (x \in a <=> x \in {}))   BECAUSE equivImpossible;
(x \notin a) => (x \in a <=> x \in {})  BECAUSE MODUS_PONENS;
(\A x : x \notin a) => (\A x : x \in a <=> x \in {})   BECAUSE Q_SCHEME;

extensionality   BECAUSE AXIOM;
(\A x : x \in a <=> x \in {}) => a = {}   BECAUSE \A(a <- a, b <- {});
(\A x : x \notin a) => a = {}   BECAUSE TransitImplication;
\A a : (\A x : x \notin a) => a = {}   BECAUSE GENERALIZATION;
QED

emptyIncludedInAny == \A x : {} \subseteq x
THEOREM emptyIncludedInAny
PROOF
VARIABLES x,z;
emptySetExists   BECAUSE THEOREM;
z \notin {}   BECAUSE \A(x <- z);
z \in {} => z \in x   BECAUSE Explosion;
{} \subseteq x   BECAUSE GENERALIZATION;
emptyIncludedInAny   BECAUSE GENERALIZATION;
QED

includedInEmpty == \A x : x \subseteq {} => x = {}
THEOREM includedInEmpty
PROOF
VARIABLES a,b,x;
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq x   BECAUSE \A(x <- x);
bothInclusions BECAUSE THEOREM;
(x \subseteq {} /\ {} \subseteq x) => x = {}   BECAUSE \A(a <- x, b <- {});
x \subseteq {} => ({} \subseteq x /\ x \subseteq {})   BECAUSE IntroAnd;
({} \subseteq x /\ x \subseteq {}) => (x \subseteq {} /\ {} \subseteq x)   BECAUSE AndSymmetry;
x \subseteq {} => (x \subseteq {} /\ {} \subseteq x)   BECAUSE TransitImplication;
x \subseteq {} => x = {}   BECAUSE TransitImplication;
includedInEmpty   BECAUSE GENERALIZATION;
QED

notEmpty == \A x : x # {} => \E z : z \in x
THEOREM notEmpty
PROOF
VARIABLES a,x,z;
emptySetUnique BECAUSE THEOREM;
(\A x : x \notin a) => a = {} BECAUSE \A(a <- a);
(\A z : z \notin a) => x \notin a   BECAUSE \A(z <- x);
\A x : (\A z : z \notin a) => x \notin a   BECAUSE GENERALIZATION;
(\A z : z \notin a) => \A x : x \notin a   BECAUSE Q_SCHEME;
(\A z : z \notin a) => a = {} BECAUSE TransitImplication;
(\E z : z \in a) <=> ~(\A z : z \notin a)   BECAUSE Q_SCHEME;
~(\A z : z \notin a) => (\E z : z \in a)   BECAUSE EquivToImplReverse;
a # {} => ~(\A z : z \notin a) BECAUSE Contraposition;
a # {} => \E z : z \in a   BECAUSE TransitImplication;
\A a : a # {} => \E z : z \in a   BECAUSE GENERALIZATION;
x # {} => \E z : z \in x   BECAUSE \A(a <- x);
notEmpty   BECAUSE GENERALIZATION;
QED

pullHypo(a,b,c) == (a <=> (b /\ c)) => (b => (a <=> c))
PROPO_TAUTO pullHypo

\* All sets together are too big to form a set. We say instead the class of sets.
noSetOfSets == ~\E a : \A y : y \in a
THEOREM noSetOfSets
PROOF
VARIABLES a,b,x,y;
\* If such a set existed, by separation we would create the forbidden set of the Russell's paradox
\A a : \E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))   BECAUSE \A(a <- a);

\* Rename bound variable x -> y
(\A x : x \in b <=> (x \in a /\ ~(x \in x))) => (y \in b <=> (y \in a /\ ~(y \in y)))   BECAUSE \A(x <- y);
\A y : (\A x : x \in b <=> (x \in a /\ ~(x \in x))) => (y \in b <=> (y \in a /\ ~(y \in y)))   BECAUSE GENERALIZATION;
(\A x : x \in b <=> (x \in a /\ ~(x \in x))) => (\A y : y \in b <=> (y \in a /\ ~(y \in y)))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in a /\ ~(x \in x))) => \E b : \A y : y \in b <=> (y \in a /\ ~(y \in y))   BECAUSE Q_SCHEME;
\E b : \A y : y \in b <=> (y \in a /\ ~(y \in y))   BECAUSE MODUS_PONENS;

\* Force the hypothesis that a is the set of all sets
(y \in b <=> (y \in a /\ ~(y \in y))) => ((y \in a) => (y \in b <=> ~(y \in y)))   BECAUSE pullHypo;
(\A y : y \in b <=> (y \in a /\ ~(y \in y))) => (\A y : (y \in a) => (y \in b <=> ~(y \in y)))   BECAUSE Q_SCHEME;
(\A y : (y \in a) => (y \in b <=> ~(y \in y))) => ((\A y : y \in a) => (\A y : y \in b <=> ~(y \in y)))   BECAUSE Q_SCHEME;
(\A y : y \in b <=> (y \in a /\ ~(y \in y))) => ((\A y : y \in a) => (\A y : y \in b <=> ~(y \in y)))   BECAUSE TransitImplication;
(\E b : \A y : y \in b <=> (y \in a /\ ~(y \in y))) => (\E b : (\A y : y \in a) => (\A y : y \in b <=> ~(y \in y)))   BECAUSE Q_SCHEME;
\E b : (\A y : y \in a) => (\A y : y \in b <=> ~(y \in y))   BECAUSE MODUS_PONENS;
(\A y : y \in a) => (\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E a : \A y : y \in a) => (\E a : \E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E a : \E b : \A y : y \in b <=> ~(y \in y)) => (\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E a : \A y : y \in a) => \E b : \A y : y \in b <=> ~(y \in y)   BECAUSE TransitImplication;

~(\E b : \A y : y \in b <=> ~(y \in y)) => noSetOfSets   BECAUSE Contraposition;

\* Rename bound variables of russelParadox to prove the previous hypothesis
russellParadox   BECAUSE THEOREM;
(\E x : \A y : y \in x <=> ~(y \in y)) <=> ~(\A x : ~\A y : y \in x <=> ~(y \in y))   BECAUSE Q_SCHEME;
~(\A x : ~\A y : y \in x <=> ~(y \in y)) => (\E x : \A y : y \in x <=> ~(y \in y))   BECAUSE EquivToImplReverse;
russellParadox => ~~(\A x : ~\A y : y \in x <=> ~(y \in y))   BECAUSE Contraposition;
~~(\A x : ~\A y : y \in x <=> ~(y \in y))   BECAUSE MODUS_PONENS;
\A x : ~\A y : y \in x <=> ~(y \in y)   BECAUSE DropNotNot;
~\A y : y \in b <=> ~(y \in y)   BECAUSE \A(x <- b);
\A b : ~\A y : y \in b <=> ~(y \in y)   BECAUSE GENERALIZATION;
(\E b : \A y : y \in b <=> ~(y \in y)) <=> ~(\A b : ~\A y : y \in b <=> ~(y \in y))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> ~(y \in y)) => ~(\A b : ~\A y : y \in b <=> ~(y \in y))   BECAUSE EquivToImpl;
~~(\A b : ~\A y : y \in b <=> ~(y \in y)) => ~(\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE Contraposition;
~~(\A b : ~\A y : y \in b <=> ~(y \in y))   BECAUSE IntroNotNot;
~(\E b : \A y : y \in b <=> ~(y \in y))   BECAUSE MODUS_PONENS;
noSetOfSets  BECAUSE MODUS_PONENS;
QED

\* The union of a set x is the set of elements of elements of x.
UNION b == CHOOSE u : \A z : (z \in u <=> \E t : (t \in b /\ z \in t))
unionExists == \A b : \A z : (z \in UNION b <=> \E t : t \in b /\ z \in t)
AXIOM unionExists

inInUnion == \A a : \A b : \A c : (a \in b /\ b \in c) => a \in UNION c
THEOREM inInUnion
PROOF
VARIABLES a,b,c,t,z;
unionExists   BECAUSE AXIOM;
a \in UNION c <=> \E t : (t \in c /\ a \in t)   BECAUSE \A(b <- c, z <- a);
(\E t : t \in c /\ a \in t) => a \in UNION c   BECAUSE EquivToImplReverse;
(b \in c /\ a \in b) => \E t : t \in c /\ a \in t   BECAUSE \E(t <- b);
(b \in c /\ a \in b) => a \in UNION c   BECAUSE TransitImplication;
(a \in b /\ b \in c) => (b \in c /\ a \in b)   BECAUSE AndSymmetry;
(a \in b /\ b \in c) => a \in UNION c   BECAUSE TransitImplication;
inInUnion   BECAUSE GENERALIZATION;
QED

\* The intersection of two sets is the set of common elements
u \intersect v == CHOOSE b : \A x : x \in b <=> (x \in u /\ x \in v)

LOCAL dropRedundantAnd(a,b) == (a /\ b) <=> (a /\ (a /\ b))
PROPO_TAUTO dropRedundantAnd

intersectionExists == \A u : \A v : \A x :
   x \in (u \intersect v) <=> (x \in u /\ x \in v)
THEOREM intersectionExists
PROOF
VARIABLES a,b,u,v,x;
\* By separation in u
(\A x : x \in (u \intersect v) <=> (x \in u /\ x \in v)) <=> \E b : (\A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE CHOOSE;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (x \in u /\ x \in v))   BECAUSE AXIOM_SCHEME; \* separation
\E b : \A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))   BECAUSE \A(a <- u);
(x \in u /\ x \in v) <=> (x \in u /\ (x \in u /\ x \in v))   BECAUSE dropRedundantAnd;
(x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (x \in b <=> (x \in u /\ x \in v))   BECAUSE TransitEquiv2;
(\A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (\A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in u /\ (x \in u /\ x \in v))) => (\E b : \A x : x \in b <=> (x \in u /\ x \in v))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (x \in u /\ x \in v)   BECAUSE MODUS_PONENS;
\A x : x \in (u \intersect v) <=> (x \in u /\ x \in v)   BECAUSE MODUS_PONENS;
intersectionExists   BECAUSE GENERALIZATION;
QED


SUBSET x == CHOOSE y : \A z : z \in y <=> z \subseteq x

powersetExists == \A x : \A z : z \in SUBSET x <=> z \subseteq x
AXIOM powersetExists

\* Representation of number 1 as a set
ordinalOne == SUBSET {}
elemOfOne == \A x : x \in ordinalOne <=> x = {}

THEOREM elemOfOne
PROOF
VARIABLES x,z;
powersetExists   BECAUSE AXIOM;
x \in ordinalOne <=> x \subseteq {}   BECAUSE \A(x <- {}, z <- x);

includedInEmpty   BECAUSE THEOREM;
x \subseteq {} => x = {}   BECAUSE \A(x <- x);
x \in ordinalOne => x \subseteq {}   BECAUSE EquivToImpl;
x \in ordinalOne => x = {}   BECAUSE TransitImplication;

\* Proof that {} \in ordinalOne
{} \in ordinalOne <=> {} \subseteq {}   BECAUSE \A(x <- {}, z <- {});
inclusionInOneself   BECAUSE THEOREM;
{} \subseteq {}   BECAUSE \A(x <- {});
{} \in ordinalOne   BECAUSE MODUS_PONENS;

x = {} => (x \in ordinalOne <=> {} \in ordinalOne)   BECAUSE E_SCHEME;
x = {} => x \in ordinalOne   BECAUSE ImplyEquivTrue;

x \in ordinalOne <=> x = {}   BECAUSE IntroEquiv;
elemOfOne   BECAUSE GENERALIZATION;
QED

ordinalTwo == SUBSET ordinalOne
elemOfTwo == \A x : x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)

THEOREM elemOfTwo
PROOF
VARIABLES a,b,x,z;
powersetExists   BECAUSE AXIOM;
x \in ordinalTwo <=> x \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne, z <- x);
x \in ordinalTwo => x \subseteq ordinalOne   BECAUSE EquivToImpl;

\* Proof of (x \subseteq ordinalOne /\ x # {}) => {} \in x
elemOfOne   BECAUSE THEOREM;
z \in ordinalOne <=> z = {}   BECAUSE \A(x <- z);
z \in ordinalOne => z = {}   BECAUSE EquivToImpl;
(z \in x => z \in ordinalOne) => (z \in x => z = {})   BECAUSE AddHypothesis;
z \in x => z \in x   BECAUSE ImplyOneself;
(z \in x => z = {}) => (z \in x => (z \in x /\ z = {}))   BECAUSE CombineImplicationsEnd;
(z \in x => z \in ordinalOne) => (z \in x => (z \in x /\ z = {}))   BECAUSE TransitImplication;
x \subseteq ordinalOne => (\A z : z \in x => (z \in x /\ z = {}))   BECAUSE Q_SCHEME;

notEmpty   BECAUSE THEOREM;
x # {} => \E z : z \in x   BECAUSE \A(x <- x);
(x \subseteq ordinalOne /\ x # {}) => ((\A z : z \in x => (z \in x /\ z = {})) /\ \E z : z \in x)   BECAUSE MergeImplicationsAnd;

(\A z : z \in x => (z \in x /\ z = {})) => ((\E z : z \in x) => \E z : z \in x /\ z = {})   BECAUSE Q_SCHEME;
((\A z : z \in x => (z \in x /\ z = {})) /\ (\E z : z \in x)) => \E z : z \in x /\ z = {}   BECAUSE HypoImplToAnd;
(x \subseteq ordinalOne /\ x # {}) => \E z : z \in x /\ z = {}   BECAUSE TransitImplication;

z = {} => (z \in x <=> {} \in x)   BECAUSE E_SCHEME;
(z \in x <=> {} \in x) => (z \in x => {} \in x)   BECAUSE EquivToImpl;
z = {} => (z \in x => {} \in x)   BECAUSE TransitImplication;
(z = {} /\ z \in x) => {} \in x   BECAUSE HypoImplToAnd;
(z \in x /\ z = {}) => (z = {} /\ z \in x)   BECAUSE AndSymmetry;
(z \in x /\ z = {}) => {} \in x   BECAUSE TransitImplication;
(\E z : z \in x /\ z = {}) => \E z : {} \in x   BECAUSE Q_SCHEME;
(\E z : {} \in x) => {} \in x   BECAUSE Q_SCHEME;
(x \subseteq ordinalOne /\ x # {}) => \E z : z \in x /\ z = {}   BECAUSE TransitImplication;
(x \subseteq ordinalOne /\ x # {}) => \E z : {} \in x   BECAUSE TransitImplication;
(x \subseteq ordinalOne /\ x # {}) => {} \in x   BECAUSE TransitImplication;

\* Proof of {} \in x => ordinalOne \subseteq x
z \in ordinalOne => (z \in x <=> {} \in x)   BECAUSE TransitImplication;
(z \in x <=> {} \in x) => ({} \in x => z \in x)   BECAUSE EquivToImplReverse;
z \in ordinalOne => ({} \in x => z \in x)   BECAUSE TransitImplication;
{} \in x => (z \in ordinalOne => z \in x)   BECAUSE SwitchHypos;
\A z : {} \in x => (z \in ordinalOne => z \in x)   BECAUSE GENERALIZATION;
{} \in x => ordinalOne \subseteq x   BECAUSE Q_SCHEME;
(x \subseteq ordinalOne /\ x # {}) => ordinalOne \subseteq x   BECAUSE TransitImplication;

(x \subseteq ordinalOne /\ x # {}) => x \subseteq ordinalOne   BECAUSE DropAndRight;
(x \subseteq ordinalOne /\ x # {}) => (x \subseteq ordinalOne /\ ordinalOne \subseteq x)   BECAUSE CombineImplicationsEnd;
bothInclusions BECAUSE THEOREM;
(x \subseteq ordinalOne /\ ordinalOne \subseteq x) => x = ordinalOne   BECAUSE \A(a <- x, b <- ordinalOne);
(x \subseteq ordinalOne /\ x # {}) => x = ordinalOne   BECAUSE TransitImplication;

x \subseteq ordinalOne => (x # {} => x = ordinalOne)   BECAUSE HypoAndToImpl;
x \in ordinalTwo => (x # {} => x = ordinalOne)   BECAUSE TransitImplication;
x \in ordinalTwo => (x = {} \/ x = ordinalOne)   BECAUSE ImplyExcludedMiddle;

\* Reverse proof
inclusionInOneself   BECAUSE THEOREM;
ordinalOne \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne);
x \subseteq ordinalOne => x \in ordinalTwo   BECAUSE EquivToImplReverse;
x = ordinalOne => (x \subseteq ordinalOne <=> ordinalOne \subseteq ordinalOne)   BECAUSE E_SCHEME;
x = ordinalOne => x \subseteq ordinalOne   BECAUSE ImplyEquivTrue;
x = ordinalOne => x \in ordinalTwo   BECAUSE TransitImplication;

x \in ordinalOne <=> x = {}   BECAUSE \A(x <- x);
x = {} => (x \subseteq ordinalOne <=> {} \subseteq ordinalOne)   BECAUSE E_SCHEME;
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq ordinalOne   BECAUSE \A(x <- ordinalOne);
x = {} => x \subseteq ordinalOne   BECAUSE ImplyEquivTrue;
x = {} => x \in ordinalTwo   BECAUSE TransitImplication;

(x = {} \/ x = ordinalOne) => x \in ordinalTwo   BECAUSE CombineImplicationsStart;
x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)   BECAUSE IntroEquiv;
elemOfTwo   BECAUSE GENERALIZATION;
QED

(* Singleton and pair operators *)
{ a } == CHOOSE b : \A x : x \in b <=> x = a

singletonExists == \A a : \A x : x \in { a } <=> x = a
THEOREM singletonExists
PROOF
VARIABLES a,b,c,x,z;
\* Proof by separation in the powerset of a
(\A x : x \in { a } <=> x = a) <=> \E b : \A x : x \in b <=> x = a   BECAUSE CHOOSE;
\A a : \E b : \A x : x \in b <=> (x \in a /\ x = c)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = c)   BECAUSE \A(a <- SUBSET a);
\A c : \E b : \A x : x \in b <=> (x \in SUBSET a /\ x = c)   BECAUSE GENERALIZATION;
\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = a)   BECAUSE \A(c <- a);

\* Proof that (x \in SUBSET a /\ x = a) <=> x = a
(x \in SUBSET a /\ x = a) => x = a   BECAUSE DropAndLeft;
x = a => (x \in SUBSET a <=> a \in SUBSET a)   BECAUSE E_SCHEME;
inclusionInOneself   BECAUSE THEOREM;
a \subseteq a   BECAUSE \A(x <- a);
powersetExists   BECAUSE AXIOM;
a \in SUBSET a <=> a \subseteq a   BECAUSE \A(x <- a, z <- a);
a \in SUBSET a   BECAUSE MODUS_PONENS;
x = a => x \in SUBSET a   BECAUSE ImplyEquivTrue;
x = a => x = a   BECAUSE ImplyOneself;
x = a => (x \in SUBSET a /\ x = a)   BECAUSE CombineImplicationsEnd;
x = a <=> (x \in SUBSET a /\ x = a)   BECAUSE IntroEquiv;

(x \in b <=> (x \in SUBSET a /\ x = a)) => (x \in b <=> x = a)   BECAUSE TransitEquiv2;
(\A x : x \in b <=> (x \in SUBSET a /\ x = a)) => (\A x : x \in b <=> x = a)   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in SUBSET a /\ x = a)) => (\E b : \A x : x \in b <=> x = a)   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> x = a)   BECAUSE MODUS_PONENS;
(\A x : x \in { a } <=> x = a)   BECAUSE MODUS_PONENS;
singletonExists   BECAUSE GENERALIZATION;
QED

{ c, d } == CHOOSE b : \A y : y \in b <=> (y = c \/ y = d)

pairExists == \A c : \A d : \A y : y \in { c, d } <=> (y = c \/ y = d)
THEOREM pairExists
PROOF
VARIABLES a,b,c,d,i,j,x,y,z;
\* Proof by replacement of ordinalTwo with the functional {} -> c, ordinalOne -> d
(\A y : y \in { c, d } <=> (y = c \/ y = d)) <=> \E b : \A y : y \in b <=> (y = c \/ y = d)   BECAUSE CHOOSE;
F == (x = {} /\ y = c) \/ (x = ordinalOne /\ y = d);
(\A x : \A y : \A z : (((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d))
      	       	        /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE AXIOM_SCHEME;

   \* Proof that F is functional
(F /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d)))
   => ((F /\ (x = {} /\ z = c)) \/ (F /\ (x = ordinalOne /\ z = d)))   BECAUSE DistribAndOrLeft;
\* Case x = {}
(F /\ (x = {} /\ z = c))
   => (((x = {} /\ y = c) /\ (x = {} /\ z = c)) \/ ((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)))   BECAUSE DistribAndOrRight;
(x = {} /\ z = c) => x = {}   BECAUSE DropAndRight;
(x = ordinalOne /\ y = d) => x = ordinalOne   BECAUSE DropAndRight;
((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)) => (x = ordinalOne /\ x = {})   BECAUSE MergeImplicationsAnd;
(x = ordinalOne /\ x = {}) => ordinalOne = {}   BECAUSE E_SCHEME;
((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c)) => ordinalOne = {}   BECAUSE TransitImplication;
(x = {} /\ y = c) => y = c   BECAUSE DropAndLeft;
(x = {} /\ z = c) => z = c   BECAUSE DropAndLeft;
((x = {} /\ y = c) /\ (x = {} /\ z = c)) => (y = c /\ z = c)   BECAUSE MergeImplicationsAnd;
(y = c /\ z = c) => y = z   BECAUSE E_SCHEME;
((x = {} /\ y = c) /\ (x = {} /\ z = c)) => y = z   BECAUSE TransitImplication;
(((x = {} /\ y = c) /\ (x = {} /\ z = c)) \/ ((x = ordinalOne /\ y = d) /\ (x = {} /\ z = c))) => ((y = z) \/ (ordinalOne = {}))   BECAUSE MergeImplicationsOr;
(F /\ (x = {} /\ z = c)) => (y = z \/ ordinalOne = {})   BECAUSE TransitImplication;

\* Proof that ordinalOne # {}
powersetExists   BECAUSE AXIOM;
{} \in ordinalOne <=> {} \subseteq {}   BECAUSE \A(x <- {}, z <- {});
inclusionInOneself   BECAUSE THEOREM;
{} \subseteq {}   BECAUSE \A(x <- {});
{} \in ordinalOne   BECAUSE MODUS_PONENS;
emptySetExists   BECAUSE THEOREM;
\A i : \A j : i = j => ((\A x : x \notin i) <=> (\A x : x \notin j))   BECAUSE E_SCHEME;
ordinalOne = {} => ((\A x : x \notin ordinalOne) <=> emptySetExists)   BECAUSE \A(i <- ordinalOne, j <- {});
ordinalOne = {} => (\A x : x \notin ordinalOne)   BECAUSE ImplyEquivTrue;
(\A x : x \notin ordinalOne) => {} \notin ordinalOne   BECAUSE \A(x <- {});
ordinalOne = {} => {} \notin ordinalOne   BECAUSE TransitImplication;
~({} \notin ordinalOne) => ordinalOne # {}   BECAUSE Contraposition;
{} \in ordinalOne => ~({} \notin ordinalOne)   BECAUSE IntroNotNot;
{} \in ordinalOne => ordinalOne # {}   BECAUSE TransitImplication;
ordinalOne # {}   BECAUSE MODUS_PONENS;

(y = z \/ ordinalOne = {}) => y = z   BECAUSE OrFalseStart;
(F /\ (x = {} /\ z = c)) => y = z   BECAUSE TransitImplication;

\* Case x = ordinalOne
(F /\ (x = ordinalOne /\ z = d))
   => (((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) \/ ((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)))   BECAUSE DistribAndOrRight;
(x = {} /\ y = c) => x = {}   BECAUSE DropAndRight;
(x = ordinalOne /\ z = d) => x = ordinalOne   BECAUSE DropAndRight;
((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) => (x = {} /\ x = ordinalOne)   BECAUSE MergeImplicationsAnd;
(x = {} /\ x = ordinalOne) => {} = ordinalOne   BECAUSE E_SCHEME;
((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) => {} = ordinalOne   BECAUSE TransitImplication;
(x = ordinalOne /\ y = d) => y = d   BECAUSE DropAndLeft;
(x = ordinalOne /\ z = d) => z = d   BECAUSE DropAndLeft;
((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)) => (y = d /\ z = d)   BECAUSE MergeImplicationsAnd;
(y = d /\ z = d) => y = z   BECAUSE E_SCHEME;
((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d)) => y = z   BECAUSE TransitImplication;
(((x = {} /\ y = c) /\ (x = ordinalOne /\ z = d)) \/ ((x = ordinalOne /\ y = d) /\ (x = ordinalOne /\ z = d))) => ({} = ordinalOne \/ y = z)   BECAUSE MergeImplicationsOr;
(F /\ (x = ordinalOne /\ z = d)) => ({} = ordinalOne \/ y = z)   BECAUSE TransitImplication;
{} = ordinalOne => ordinalOne = {}   BECAUSE E_SCHEME;
ordinalOne # {} => {} # ordinalOne   BECAUSE Contraposition;
{} # ordinalOne   BECAUSE MODUS_PONENS;
({} = ordinalOne \/ y = z) => y = z   BECAUSE FalseOrStart;
(F /\ (x = ordinalOne /\ z = d)) => y = z   BECAUSE TransitImplication;

((F /\ (x = {} /\ z = c)) \/ (F /\ (x = ordinalOne /\ z = d))) => y = z   BECAUSE CombineImplicationsStart;
(F /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z   BECAUSE TransitImplication;
\A x : \A y : \A z : (F /\ ((x = {} /\ z = c) \/ (x = ordinalOne /\ z = d))) => y = z   BECAUSE GENERALIZATION;
\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ F   BECAUSE MODUS_PONENS;
\E b : \A y : y \in b <=> \E x : x \in ordinalTwo /\ F   BECAUSE \A(a <- ordinalTwo);

   \* Proof that b works, ie that (\E x : x \in ordinalTwo /\ F) <=> (y = c \/ y = d)
elemOfTwo   BECAUSE THEOREM;
x \in ordinalTwo <=> (x = {} \/ x = ordinalOne)   BECAUSE \A(x <- x);
x \in ordinalTwo => (x = {} \/ x = ordinalOne)   BECAUSE EquivToImpl;
(x = {} \/ x = ordinalOne) => x \in ordinalTwo   BECAUSE EquivToImplReverse;

F => (y = c \/ y = d)   BECAUSE MergeImplicationsOr;
(x \in ordinalTwo /\ F) => F   BECAUSE DropAndLeft;
(x \in ordinalTwo /\ F) => (y = c \/ y = d)   BECAUSE TransitImplication;
(\E x : x \in ordinalTwo /\ F) => (\E x : y = c \/ y = d)   BECAUSE Q_SCHEME;
(\E x : y = c \/ y = d) => (y = c \/ y = d)   BECAUSE Q_SCHEME;
(\E x : x \in ordinalTwo /\ F) => (y = c \/ y = d)   BECAUSE TransitImplication;

\* Case y = c
({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))) => (\E x : x \in ordinalTwo /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE \E(x <- {});
{} = {}   BECAUSE E_SCHEME;
y = c => ({} = {} /\ y = c)   BECAUSE TrueAndEnd;
({} = {} /\ y = c) => (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))   BECAUSE PT9;
y = c => (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))   BECAUSE TransitImplication;
x = {} => (x = {} \/ x = ordinalOne)   BECAUSE PT9;
x = {} => x \in ordinalTwo   BECAUSE TransitImplication;
\A x : x = {} => x \in ordinalTwo   BECAUSE GENERALIZATION;
{} = {} => {} \in ordinalTwo   BECAUSE \A(x <- {});
{} \in ordinalTwo   BECAUSE MODUS_PONENS;
(({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d))
   => ({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d)))   BECAUSE TrueAndEnd;
y = c => ({} \in ordinalTwo /\ (({} = {} /\ y = c) \/ ({} = ordinalOne /\ y = d)))   BECAUSE TransitImplication;
y = c => (\E x : x \in ordinalTwo /\ F)   BECAUSE TransitImplication;

\* Case y = d
(ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))) => (\E x : x \in ordinalTwo /\ ((x = {} /\ y = c) \/ (x = ordinalOne /\ y = d)))   BECAUSE \E(x <- ordinalOne);
ordinalOne = ordinalOne   BECAUSE E_SCHEME;
y = d => (ordinalOne = ordinalOne /\ y = d)   BECAUSE TrueAndEnd;
(ordinalOne = ordinalOne /\ y = d) => ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))   BECAUSE PT10;
y = d => ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))   BECAUSE TransitImplication;
x = ordinalOne => (x = {} \/ x = ordinalOne)   BECAUSE PT10;
x = ordinalOne => x \in ordinalTwo   BECAUSE TransitImplication;
\A x : x = ordinalOne => x \in ordinalTwo   BECAUSE GENERALIZATION;
ordinalOne = ordinalOne => ordinalOne \in ordinalTwo   BECAUSE \A(x <- ordinalOne);
ordinalOne \in ordinalTwo   BECAUSE MODUS_PONENS;
((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d))
   => (ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d)))   BECAUSE TrueAndEnd;
y = d => (ordinalOne \in ordinalTwo /\ ((ordinalOne = {} /\ y = c) \/ (ordinalOne = ordinalOne /\ y = d)))   BECAUSE TransitImplication;
y = d => (\E x : x \in ordinalTwo /\ F)   BECAUSE TransitImplication;

(y = c \/ y = d) => (\E x : x \in ordinalTwo /\ F)   BECAUSE CombineImplicationsStart;
(y = c \/ y = d) <=> (\E x : x \in ordinalTwo /\ F)   BECAUSE IntroEquiv;
(y \in b <=> (\E x : x \in ordinalTwo /\ F)) => (y \in b <=> (y = c \/ y = d))   BECAUSE TransitEquiv2;
(\A y : y \in b <=> (\E x : x \in ordinalTwo /\ F)) => (\A y : y \in b <=> (y = c \/ y = d))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> (\E x : x \in ordinalTwo /\ F)) => (\E b : \A y : y \in b <=> (y = c \/ y = d))   BECAUSE Q_SCHEME;
(\E b : \A y : y \in b <=> (y = c \/ y = d))   BECAUSE MODUS_PONENS;
\A y : y \in { c, d } <=> (y = c \/ y = d)   BECAUSE MODUS_PONENS;
pairExists   BECAUSE GENERALIZATION;
QED

pairSymmetry == \A a : \A b : {a, b} = {b, a}
THEOREM pairSymmetry
PROOF
VARIABLES a,b,c,d,x,y;
pairExists   BECAUSE THEOREM;
x \in { a, b } <=> (x = a \/ x = b)   BECAUSE \A(c <- a, d <- b, y <- x);
x \in { b, a } <=> (x = b \/ x = a)   BECAUSE \A(c <- b, d <- a, y <- x);
(x = a \/ x = b) => (x = b \/ x = a)   BECAUSE OrSymmetry;
(x = b \/ x = a) => (x = a \/ x = b)   BECAUSE OrSymmetry;
(x = a \/ x = b) <=> (x = b \/ x = a)   BECAUSE IntroEquiv;
x \in { a, b } <=> (x = b \/ x = a)   BECAUSE   TransitEquiv;
x \in { a, b } <=> x \in { b, a }   BECAUSE   TransitEquiv2;
\A x : x \in { a, b } <=> x \in { b, a }   BECAUSE   GENERALIZATION;
extensionality   BECAUSE AXIOM;
(\A x : x \in {a,b} <=> x \in {b,a}) => {a,b} = {b,a}   BECAUSE \A(a <- {a,b}, b <- {b,a});
{a,b} = {b,a}   BECAUSE MODUS_PONENS;
pairSymmetry   BECAUSE GENERALIZATION;
QED

sameFirstPairs == \A a : \A b : \A c : {a,b} = {a,c} => b = c
THEOREM sameFirstPairs
PROOF
VARIABLES a,b,c,d,x,y;
pairExists   BECAUSE THEOREM;
b \in { a, b } <=> (b = a \/ b = b)   BECAUSE \A(c <- a, d <- b, y <- b);
b = b   BECAUSE E_SCHEME;
b = a \/ b = b   BECAUSE PT10;
b \in {a,b}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (b \in x <=> b \in y)   BECAUSE E_SCHEME;
{a,b} = {a,c} => (b \in {a,b} <=> b \in {a,c})   BECAUSE \A(x <- {a,b}, y <- {a,c});
{a,b} = {a,c} => b \in {a,c}   BECAUSE ImplyTrueEquiv;
b \in { a,c } <=> (b = a \/ b = c)   BECAUSE \A(c <- a, d <- c, y <- b);
b \in { a,c } => (b = a \/ b = c)   BECAUSE EquivToImpl;
{a,b} = {a,c} => (b = a \/ b = c)   BECAUSE TransitImplication;

c \in { a, c } <=> (c = a \/ c = c)   BECAUSE \A(c <- a, d <- c, y <- c);
c = c   BECAUSE E_SCHEME;
c = a \/ c = c   BECAUSE PT10;
c \in {a,c}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (c \in x <=> c \in y)   BECAUSE E_SCHEME;
{a,b} = {a,c} => (c \in {a,b} <=> c \in {a,c})   BECAUSE \A(x <- {a,b}, y <- {a,c});
{a,b} = {a,c} => c \in {a,b}   BECAUSE ImplyEquivTrue;
c \in { a,b } <=> (c = a \/ c = b)   BECAUSE \A(c <- a, d <- b, y <- c);
c \in { a,b } => (c = a \/ c = b)   BECAUSE EquivToImpl;
{a,b} = {a,c} => (c = a \/ c = b)   BECAUSE TransitImplication;
c = b => b = c   BECAUSE E_SCHEME;
c = a => c = a   BECAUSE ImplyOneself;
(c = a \/ c = b) => (c = a \/ b = c)  BECAUSE MergeImplicationsOr;
{a,b} = {a,c} => (c = a \/ b = c)  BECAUSE TransitImplication;

{a,b} = {a,c} => ((b = a \/ b = c) /\ (c = a \/ b = c))   BECAUSE CombineImplicationsEnd;
((b = a \/ b = c) /\ (c = a \/ b = c)) => ((b = a /\ c = a) \/ b = c)  BECAUSE FactorOrAndRight;
{a,b} = {a,c} => ((b = a /\ c = a) \/ b = c)  BECAUSE TransitImplication;
(b = a /\ c = a) => b = c   BECAUSE E_SCHEME;
b = c => b = c   BECAUSE ImplyOneself;
((b = a /\ c = a) \/ b = c) => (b = c \/ b = c)   BECAUSE MergeImplicationsOr;
{a,b} = {a,c} => (b = c \/ b = c)  BECAUSE TransitImplication;
(b = c \/ b = c) => b = c   BECAUSE OrSelf;
{a,b} = {a,c} => b = c  BECAUSE TransitImplication;
sameFirstPairs   BECAUSE GENERALIZATION;
QED

pairInclusion == \A x : \A y : \A t : (x \in t /\ y \in t) => {x,y} \subseteq t
THEOREM pairInclusion
PROOF
VARIABLES a,c,d,t,x,y,z;
z = x => (z \in t <=> x \in t)   BECAUSE E_SCHEME;
(z \in t <=> x \in t) => (x \in t => z \in t)   BECAUSE EquivToImplReverse;
z = x => (x \in t => z \in t)   BECAUSE TransitImplication;
(z = x /\ x \in t) => z \in t   BECAUSE HypoImplToAnd;
(x \in t /\ z = x) => (z = x /\ x \in t)   BECAUSE AndSymmetry;
(x \in t /\ z = x) => z \in t   BECAUSE TransitImplication;
x \in t => (z = x => z \in t)   BECAUSE HypoAndToImpl;
z = y => (z \in t <=> y \in t)   BECAUSE E_SCHEME;
(z \in t <=> y \in t) => (y \in t => z \in t)   BECAUSE EquivToImplReverse;
z = y => (y \in t => z \in t)   BECAUSE TransitImplication;
(z = y /\ y \in t) => z \in t   BECAUSE HypoImplToAnd;
(y \in t /\ z = y) => (z = y /\ y \in t)   BECAUSE AndSymmetry;
(y \in t /\ z = y) => z \in t   BECAUSE TransitImplication;
y \in t => (z = y => z \in t)   BECAUSE HypoAndToImpl;

(x \in t /\ y \in t) => ((z = x => z \in t) /\ (z = y => z \in t))   BECAUSE MergeImplicationsAnd;
((z = x => z \in t) /\ (z = y => z \in t)) => ((z=x \/ z=y) => z \in t)   BECAUSE FactorAndImpl;
(x \in t /\ y \in t) => ((z = x \/ z = y) => z \in t)   BECAUSE TransitImplication;
pairExists   BECAUSE THEOREM;
z \in { x, y } <=> (z = x \/ z = y)   BECAUSE \A(c <- x, d <- y, y <- z);
z \in { x, y } => (z = x \/ z = y)   BECAUSE EquivToImpl;
((z = x \/ z = y) => z \in t) => (z \in {x,y} => z \in t)   BECAUSE TransitImplication;
(x \in t /\ y \in t) => (z \in {x,y} => z \in t)   BECAUSE TransitImplication;
\A z : (x \in t /\ y \in t) => (z \in {x,y} => z \in t)   BECAUSE GENERALIZATION;
(x \in t /\ y \in t) => {x,y} \subseteq t   BECAUSE Q_SCHEME;
pairInclusion   BECAUSE GENERALIZATION;
QED

\* The pair allows to define the union of two sets
x \union y == UNION { x, y }

unionBigger == \A x : \A y : x \subseteq (x \union y)
THEOREM unionBigger
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
x \in { x, y } <=> (x = x \/ x = y)   BECAUSE \A(c <- x, d <- y, y <- x);
x = x   BECAUSE E_SCHEME;
x = x \/ x = y   BECAUSE PT9;
x \in {x,y}   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
(z \in x /\ x \in {x,y}) => z \in (x \union y)   BECAUSE \A(a <- z, b <- x, c <- {x,y});
z \in x => (z \in x /\ x \in {x,y})   BECAUSE AndTrueEnd;
z \in x => z \in (x \union y)   BECAUSE TransitImplication;
unionBigger   BECAUSE GENERALIZATION;
QED

unionSymmetry == \A x : \A y : (x \union y) = (y \union x)
THEOREM unionSymmetry
PROOF
VARIABLES a,b,x,y;
pairSymmetry   BECAUSE THEOREM;
{x, y} = {y, x}   BECAUSE \A(a <- x, b <- y);
\A x : \A y : x = y => (UNION x = UNION y)   BECAUSE E_SCHEME;
{x, y} = {y, x} => (UNION {x,y} = UNION {y,x})   BECAUSE \A(x <- {x,y}, y <- {y,x});
(x \union y) = (y \union x)   BECAUSE MODUS_PONENS;
unionSymmetry   BECAUSE GENERALIZATION;
QED

(* Tuples *)
<< c, d >> == { { c } , {c,d} }

\* This definition of binary tuples is a bit cryptic at first glance ;
\* it does yield the usual decomposition theorem :
tupleDecomposition == \A a : \A b : \A c : \A d : <<a, b>> = <<c, d>>  =>  (a = c /\ b = d)

THEOREM tupleDecomposition
PROOF
VARIABLES a,b,c,d,x,y,z;
pairExists   BECAUSE THEOREM;
y \in { { a } , {a,b} } <=> (y = {a} \/ y = {a,b})   BECAUSE \A(c <- {a}, d <- {a,b}, y <- y);
y \in { { c } , {c,d} } <=> (y = {c} \/ y = {c,d})   BECAUSE \A(c <- {c}, d <- {c,d}, y <- y);
\A x : \A z : x = z => (y \in x <=> y \in z)   BECAUSE E_SCHEME;
<<a,b>> = <<c,d>>  =>  (y \in <<a,b>> <=> y \in <<c,d>>)   BECAUSE \A(x <- <<a,b>>, z <- <<c,d>>);
(y = {a} \/ y = {a,b}) <=> y \in <<a,b>>   BECAUSE EquivSymmetry;
(y \in <<a,b>> <=> y \in <<c,d>>) => ((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>)   BECAUSE TransitEquiv;
<<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>)   BECAUSE TransitImplication;
(y = {c} \/ y = {c,d}) <=> y \in <<c,d>>   BECAUSE EquivSymmetry;
((y = {a} \/ y = {a,b}) <=> y \in <<c,d>>) => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE TransitEquiv2;
<<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE TransitImplication;
\A y : <<a,b>> = <<c,d>> => ((y = {a} \/ y = {a,b}) <=> (y = {c} \/ y = {c,d}))   BECAUSE GENERALIZATION;

\* Proof of <<a,b>> = <<c,d>> => a = c
<<a,b>> = <<c,d>> => (({c} = {a} \/ {c} = {a,b}) <=> ({c} = {c} \/ {c} = {c,d}))   BECAUSE \A(y <- {c});
{c} = {c}   BECAUSE E_SCHEME;
{c} = {c} \/ {c} = {c,d}   BECAUSE PT9;
<<a,b>> = <<c,d>> => ({c} = {a} \/ {c} = {a,b})   BECAUSE ImplyEquivTrue;

singletonExists   BECAUSE THEOREM;
c \in { a } <=> c = a   BECAUSE \A(a <- a, x <- c);
c \in { a } => c = a   BECAUSE EquivToImpl;
c \in { c } <=> c = c   BECAUSE \A(a <- c, x <- c);
c = c   BECAUSE E_SCHEME;
c \in { c }   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (c \in x <=> c \in y)   BECAUSE E_SCHEME;
{c} = {a} => (c \in {c} <=> c \in {a})   BECAUSE \A(x <- {c}, y <- {a});
(c \in {c} <=> c \in {a}) => c \in {a}   BECAUSE TrueEquiv;
{c} = {a} => c \in {a}   BECAUSE TransitImplication;
{c} = {a} => c = a   BECAUSE TransitImplication;
c = a => a = c   BECAUSE E_SCHEME;
{c} = {a} => a = c   BECAUSE TransitImplication;

a \in {a,b} <=> (a = a \/ a = b)   BECAUSE \A(c <- a, d <- b, y <- a);
a = a   BECAUSE E_SCHEME;
a = a \/ a = b   BECAUSE PT9;
a \in {a,b}   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
{c} = {a,b} => (a \in {c} <=> a \in {a,b})   BECAUSE \A(x <- {c}, y <- {a,b});
(a \in {c} <=> a \in {a,b}) => a \in {c}   BECAUSE EquivTrue;
{c} = {a,b} => a \in {c}   BECAUSE TransitImplication;
a \in { c } <=> a = c   BECAUSE \A(a <- c, x <- a);
a \in { c } => a = c   BECAUSE EquivToImpl;
{c} = {a,b} => a = c   BECAUSE TransitImplication;

({c} = {a} \/ {c} = {a,b}) => a = c   BECAUSE CombineImplicationsStart;
<<a,b>> = <<c,d>> => a = c   BECAUSE TransitImplication;

\* Replace c by a
\A x : \A y : x = y => (<<a,b>> = <<x,d>> <=> <<a,b>> = <<y,d>>)   BECAUSE E_SCHEME;
a = c => (<<a,b>> = <<a,d>> <=> <<a,b>> = <<c,d>>)   BECAUSE \A(x <- a, y <- c);
<<a,b>> = <<c,d>> => (<<a,b>> = <<a,d>> <=> <<a,b>> = <<c,d>>)   BECAUSE TransitImplication;
<<a,b>> = <<c,d>> => <<a,b>> = <<a,d>>   BECAUSE ImplyEquivSelf;

\* Proof of <<a,b>> = <<a,d>> => b = d
sameFirstPairs   BECAUSE THEOREM;
{ {a},{a,b} } = {{a},{a,d}} => {a,b} = {a,d}   BECAUSE \A(a <- {a}, b <- {a,b}, c <- {a,d});
<<a,b>> = <<c,d>> => {a,b} = {a,d}   BECAUSE TransitImplication;
{ a,b } = {a,d} => b = d   BECAUSE \A(a <- a, b <- b, c <- d);
<<a,b>> = <<c,d>> => b = d   BECAUSE TransitImplication;
<<a,b>> = <<c,d>> => (a = c /\ b = d)   BECAUSE CombineImplicationsEnd;
tupleDecomposition   BECAUSE GENERALIZATION;
QED

\* The class of oriented graphs, ie sets of couples.
IsGraph(g) == \A x : x \in g => \E a : \E b : x = <<a, b>>

IsDefinedOn(g,x) == \E y : <<x,y>> \in g
Domain(g) == CHOOSE b : \A x : x \in b <=> IsDefinedOn(g,x)

domainExists == \A g : \A x : x \in Domain(g) <=> IsDefinedOn(g,x)
THEOREM domainExists
PROOF
VARIABLES a,b,c,d,g,t,x,y,z;
\* By separation in UNION UNION g
(\A x : x \in Domain(g) <=> IsDefinedOn(g,x)) <=> \E b : \A x : x \in b <=> IsDefinedOn(g,x)   BECAUSE CHOOSE;
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsDefinedOn(g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))   BECAUSE \A(a <- UNION UNION g);
(x \in UNION UNION g /\ IsDefinedOn(g,x)) => IsDefinedOn(g,x)   BECAUSE DropAndLeft;
pairExists   BECAUSE THEOREM;
{x} \in <<x,y>> <=> ({x} = {x} \/ {x} = {x,y})   BECAUSE \A(c <- {x}, d <- {x,y}, y <- {x});
{x} = {x}   BECAUSE E_SCHEME;
{x} = {x} \/ {x} = {x,y}   BECAUSE PT9;
{x} \in <<x,y>>   BECAUSE MODUS_PONENS;
inInUnion   BECAUSE THEOREM;
({x} \in <<x,y>> /\ <<x,y>> \in g) => {x} \in UNION g   BECAUSE \A(a <- {x}, b <- <<x,y>>, c <- g);
<<x,y>> \in g => ({x} \in <<x,y>> /\ <<x,y>> \in g)   BECAUSE IntroAnd;
<<x,y>> \in g => {x} \in UNION g   BECAUSE TransitImplication;
IsDefinedOn(g,x) => \E y : {x} \in UNION g   BECAUSE Q_SCHEME;
(\E y : {x} \in UNION g) => {x} \in UNION g   BECAUSE Q_SCHEME;
IsDefinedOn(g,x) => {x} \in UNION g   BECAUSE TransitImplication;
singletonExists   BECAUSE THEOREM;
x \in { x } <=> x = x   BECAUSE \A(a <- x, x <- x);
x = x   BECAUSE E_SCHEME;
x \in { x }   BECAUSE MODUS_PONENS;
(x \in {x} /\ {x} \in UNION g) => x \in UNION UNION g   BECAUSE \A(a <- x, b <- {x}, c <- UNION g);
{x} \in UNION g => (x \in {x} /\ {x} \in UNION g)   BECAUSE IntroAnd;
{x} \in UNION g => x \in UNION UNION g   BECAUSE TransitImplication;
IsDefinedOn(g,x) => x \in UNION UNION g   BECAUSE TransitImplication;
IsDefinedOn(g,x) => IsDefinedOn(g,x)   BECAUSE ImplyOneself;
IsDefinedOn(g,x) => (x \in UNION UNION g /\ IsDefinedOn(g,x))   BECAUSE CombineImplicationsEnd;
IsDefinedOn(g,x) <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))   BECAUSE IntroEquiv;
(x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (x \in b <=> IsDefinedOn(g,x))   BECAUSE TransitEquiv2;
(\A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (\A x : x \in b <=> IsDefinedOn(g,x))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in UNION UNION g /\ IsDefinedOn(g,x))) => (\E b : \A x : x \in b <=> IsDefinedOn(g,x))   BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> IsDefinedOn(g,x)   BECAUSE MODUS_PONENS;
\A x : x \in Domain(g) <=> IsDefinedOn(g,x)   BECAUSE MODUS_PONENS;
domainExists   BECAUSE GENERALIZATION;
QED

(*
   The class of functions : graphs that have at most one output for each
   input. A function as a set represents a computation, like addition
   or multiplication, something that always produces the same output
   when given the same input.
*)
IsFunction(f) == IsGraph(f)
   /\ \A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c

\* The application of functions :
f[x] == CHOOSE y : <<x,y>> \in f

(*
   The class of orders : graphs that are reflexive, symmetric and transitive.
*)
IsOrder(o) == IsGraph(o)
   \* reflexivity
   /\ (\A x : \A y : <<x,y>> \in o => (<<x,x>> \in o /\ <<y,y>> \in o))
   \* transitivity
   /\ (\A x : \A y : \A z : (<<x,y>> \in o /\ <<y,z>> \in o) => <<x,z>> \in o)
   \* symmetry
   /\ (\A x : \A y : (<<x,y>> \in o /\ <<y,x>> \in o) => x = y)

(*
   Definition of the cartesian product, the set of couples between two sets.
*)
i \X j == CHOOSE b : \A x : x \in b
   <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>

cartesianProductExists == \A i : \A j : \A x :
   x \in (i \X j) <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>

THEOREM cartesianProductExists
PROOF
VARIABLES a,b,c,d,i,j,t,u,v,x,y,z;
\* By separation in SUBSET SUBSET (x \union y)
(\A x : x \in (i \X j) <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)
   <=> (\E b : \A x : x \in b <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)   BECAUSE CHOOSE;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))   BECAUSE \A(a <- SUBSET SUBSET (i \union j));
\* Proof that <<u,v>> \subseteq SUBSET (i \union j), ie that {u} \in SUBSET (i \union j),
\* ie that {u} \subseteq (i \union j)
unionBigger   BECAUSE THEOREM;
i \subseteq (i \union j)   BECAUSE \A(x <- i, y <- j);
u \in i => u \in (i \union j)   BECAUSE \A(z <- u);
singletonExists   BECAUSE THEOREM;
z \in { u } <=> z = u   BECAUSE \A(a <-u, x <- z);
z \in { u } => z = u   BECAUSE EquivToImpl;
(u \in i /\ z \in {u}) => (u \in (i \union j) /\ z = u)   BECAUSE MergeImplicationsAnd;
z = u => (z \in (i \union j) <=> u \in (i \union j))   BECAUSE E_SCHEME;
(z \in (i \union j) <=> u \in (i \union j)) => (u \in (i \union j) => z \in (i \union j))   BECAUSE EquivToImplReverse;
z = u => (u \in (i \union j) => z \in (i \union j))   BECAUSE TransitImplication;
(z = u /\ u \in (i \union j)) => z \in (i \union j)   BECAUSE HypoImplToAnd;
(u \in (i \union j) /\ z = u) => (z = u /\ u \in (i \union j))   BECAUSE AndSymmetry;
(u \in (i \union j) /\ z = u) => z \in (i \union j)   BECAUSE TransitImplication;
(u \in i /\ z \in {u}) => z \in (i \union j)   BECAUSE TransitImplication;
u \in i => (z \in {u} => z \in (i \union j))   BECAUSE HypoAndToImpl;
\A z : u \in i => (z \in {u} => z \in (i \union j))   BECAUSE GENERALIZATION;
u \in i => {u} \subseteq (i \union j)   BECAUSE Q_SCHEME;
powersetExists   BECAUSE AXIOM;
{u} \in SUBSET (i \union j) <=> {u} \subseteq (i \union j)   BECAUSE \A(x <- i \union j, z <- {u});
{u} \subseteq (i \union j) => {u} \in SUBSET (i \union j)   BECAUSE EquivToImplReverse;
u \in i => {u} \in SUBSET (i \union j)   BECAUSE TransitImplication;

\* Proof of {u,v} \in SUBSET (i \union j)
j \subseteq (j \union i)   BECAUSE \A(x <- j, y <- i);
unionSymmetry   BECAUSE THEOREM;
(i \union j) = (j \union i)   BECAUSE \A(x <- i, y <- j);
\A x : \A y : x = y => (j \subseteq x <=> j \subseteq y)   BECAUSE E_SCHEME;
(i \union j) = (j \union i) => (j \subseteq (i \union j) <=> j \subseteq (j \union i))  BECAUSE \A(x <- i \union j, y <- j \union i);
j \subseteq (i \union j) <=> j \subseteq (j \union i)  BECAUSE MODUS_PONENS;
j \subseteq (i \union j)   BECAUSE MODUS_PONENS;
v \in j => v \in (i \union j)   BECAUSE \A(z <- v);
(u \in i /\ v \in j) => (u \in (i \union j) /\ v \in (i \union j))   BECAUSE MergeImplicationsAnd;
pairInclusion   BECAUSE THEOREM;
(u \in (i \union j) /\ v \in (i \union j)) => {u,v} \subseteq (i \union j)   BECAUSE \A(x <- u, y <- v, t <- i \union j);
(u \in i /\ v \in j) => {u,v} \subseteq (i \union j)   BECAUSE TransitImplication;
{u,v} \in SUBSET (i \union j) <=> {u,v} \subseteq (i \union j)   BECAUSE \A(x <- i \union j, z <- {u,v});
{u,v} \subseteq (i \union j) => {u,v} \in SUBSET (i \union j)   BECAUSE EquivToImplReverse;
(u \in i /\ v \in j) => {u,v} \in SUBSET (i \union j)   BECAUSE TransitImplication;

\* Proof of (u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)
(u \in i /\ v \in j) => u \in i   BECAUSE DropAndRight;
(u \in i /\ v \in j) => {u} \in SUBSET (i \union j)   BECAUSE TransitImplication;
(u \in i /\ v \in j) => ({u} \in SUBSET (i \union j) /\ {u,v} \in SUBSET (i \union j))   BECAUSE CombineImplicationsEnd;
({u} \in SUBSET (i \union j) /\ {u,v} \in SUBSET (i \union j))
   => <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE \A(x <- {u}, y <- {u,v}, t <- SUBSET (i \union j));
(u \in i /\ v \in j) => <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE TransitImplication;
<<u,v>> \in SUBSET SUBSET (i \union j)
   <=> <<u,v>> \subseteq SUBSET (i \union j)   BECAUSE \A(x <- SUBSET (i \union j), z <- <<u,v>>);
<<u,v>> \subseteq SUBSET (i \union j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE EquivToImplReverse;
(u \in i /\ v \in j) => <<u,v>> \in SUBSET SUBSET (i \union j)   BECAUSE TransitImplication;

x = <<u,v>> => (x \in SUBSET SUBSET (i \union j) <=> <<u,v>> \in SUBSET SUBSET (i \union j))   BECAUSE E_SCHEME;
(x \in SUBSET SUBSET (i \union j) <=> <<u,v>> \in SUBSET SUBSET (i \union j))
   => (<<u,v>> \in SUBSET SUBSET (i \union j) => x \in SUBSET SUBSET (i \union j))   BECAUSE EquivToImplReverse;
x = <<u,v>> => (<<u,v>> \in SUBSET SUBSET (i \union j) => x \in SUBSET SUBSET (i \union j))   BECAUSE TransitImplication;
<<u,v>> \in SUBSET SUBSET (i \union j) => (x = <<u,v>> => x \in SUBSET SUBSET (i \union j))   BECAUSE SwitchHypos;
(u \in i /\ v \in j) => (x = <<u,v>> => x \in SUBSET SUBSET (i \union j))   BECAUSE TransitImplication;
(u \in i /\ v \in j /\ x = <<u,v>>) => x \in SUBSET SUBSET (i \union j)   BECAUSE HypoImplToAnd;
(\E v : u \in i /\ v \in j /\ x = <<u,v>>) => \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => \E u : \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : x \in SUBSET SUBSET (i \union j)) => \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => \E v : x \in SUBSET SUBSET (i \union j)   BECAUSE TransitImplication;
(\E v : x \in SUBSET SUBSET (i \union j)) => x \in SUBSET SUBSET (i \union j)   BECAUSE Q_SCHEME;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => x \in SUBSET SUBSET (i \union j)   BECAUSE TransitImplication;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) => (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)   BECAUSE ImplyOneself;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)
   => (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))   BECAUSE CombineImplicationsEnd;
(x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))
   => (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)   BECAUSE DropAndLeft;
(\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)
   <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>))   BECAUSE IntroEquiv;
(x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)))
   => (x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)) BECAUSE TransitEquiv2;
(\A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)))
   => (\A x : x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)) BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in SUBSET SUBSET (i \union j) /\ (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)))
   => (\E b : \A x : x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>)) BECAUSE Q_SCHEME;
\E b : \A x : x \in b <=> (\E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>) BECAUSE MODUS_PONENS;
\A x : x \in (i \X j) <=> \E u : \E v : u \in i /\ v \in j /\ x = <<u,v>>   BECAUSE MODUS_PONENS;
cartesianProductExists   BECAUSE GENERALIZATION;
QED

(*
   Definition of the disjoint union : the union of 2 sets where the common
   elements are copied so that they are different in the union. The disjoint
   union of natural number is very close to their addition, this will be
   made rigorous in the Ordinals module.
*)
disjointUnion(x,y) == (x \X {{}}) \union (y \X {ordinalOne})

Infinity == \E a : {} \in a /\ \A x : x \in a => x \union {x} \in a
AXIOM Infinity