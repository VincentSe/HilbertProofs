(*
   Functions between cartesian products.
*)

EXTENDS ZFC

\* Two functions called in parallel
IsParallelApply(f,g,x) == IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
   /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g
parallelFunc(f,g) == CHOOSE h : \A x : x \in h <=> \* x = << <<a, b>>, <<f[a], g[b]>> >>
  IsParallelApply(f,g,x)

parallelFuncExists == \A f : \A g : (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x))
\*   /\ parallelFunc(f,g) \subseteq ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
THEOREM parallelFuncExists
PROOF
VARIABLES a,b,c,f,g,h,x,y;
\* By separation in (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsParallelApply(f,g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(a <- (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)));

\* Take one such b
chooseB(f,g) == CHOOSE b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x));
(\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))) <=> \E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE CHOOSE chooseB(f,g);
\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE MODUS_PONENS;
x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(x <- x);

\* Stage x
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
x = <<fst(x), snd(x)>> => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE E_SCHEME;
IsCouple(x) => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE TransitImplication;
(IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))   BECAUSE HypoEquivToAndReverse;
cartesianProductInc   BECAUSE THEOREM;
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   => <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE \A(x <- (Domain(f) \X Domain(g)), y <- (Image(f) \X Image(g)), a <- fst(x), b <- snd(x));
IsCouple(x) => IsCouple(x)   BECAUSE ImplyOneself;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => (IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE MergeImplicationsAnd;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TransitImplication;

x = <<fst(x), snd(x)>> => (IsParallelApply(f,g,x) <=> IsParallelApply(f,g, <<fst(x), snd(x)>>))   BECAUSE E_SCHEME;

\* Stage fst(x)
IsCouple(fst(x)) => fst(x) = <<fst(fst(x)), snd(fst(x))>>   BECAUSE \A(c <- fst(x));
\A x : \A y : x = y => (x \in (Domain(f) \X Domain(g)) <=> y \in (Domain(f) \X Domain(g)))   BECAUSE E_SCHEME;
fst(x) = <<fst(fst(x)), snd(fst(x))>> => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE \A(x <- fst(x), y <- <<fst(fst(x)), snd(fst(x))>>);
IsCouple(fst(x)) => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE TransitImplication;
(IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE HypoEquivToAndReverse;
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   => <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE \A(x <- Domain(f), y <- Domain(g), a <- fst(fst(x)), b <- snd(fst(x)));
IsCouple(fst(x)) => IsCouple(fst(x))   BECAUSE ImplyOneself;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => (IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TransitImplication;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)))   BECAUSE DropAndRight3;
(IsCouple(x) /\ IsCouple(fst(x))) => IsCouple(fst(x))   BECAUSE DropAndLeft;
IsParallelApply(f,g,x) => IsCouple(fst(x))   BECAUSE TransitImplication;
IsParallelApply(f,g,x) => <<fst(fst(x)), fst(snd(x)) >> \in f   BECAUSE DropAndBoth;
domainInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(fst(x)) \in Domain(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(fst(x)) \in Domain(f)   BECAUSE TransitImplication;
IsParallelApply(f,g,x) => <<snd(fst(x)), snd(snd(x)) >> \in g   BECAUSE DropAndLeft;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(fst(x)) \in Domain(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(fst(x)) \in Domain(g)   BECAUSE TransitImplication;
IsParallelApply(f,g,x) => (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))   BECAUSE CombineImplicationsEnd;
IsParallelApply(f,g,x) => (IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))   BECAUSE CombineImplicationsEnd;
IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TransitImplication;

\* Stage snd(x)
IsCouple(snd(x)) => snd(x) = <<fst(snd(x)), snd(snd(x))>>   BECAUSE \A(c <- snd(x));
\A x : \A y : x = y => (x \in (Image(f) \X Image(g)) <=> y \in (Image(f) \X Image(g)))   BECAUSE E_SCHEME;
snd(x) = <<fst(snd(x)), snd(snd(x))>> => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE \A(x <- snd(x), y <- <<fst(snd(x)), snd(snd(x))>>);
IsCouple(snd(x)) => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE TransitImplication;
(IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE HypoEquivToAndReverse;
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   => <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE \A(x <- Image(f), y <- Image(g), a <- fst(snd(x)), b <- snd(snd(x)));
IsCouple(snd(x)) => IsCouple(snd(x))   BECAUSE ImplyOneself;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => (IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE TransitImplication;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x)))   BECAUSE DropAndRight2;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(snd(x))   BECAUSE DropAndLeft;
IsParallelApply(f,g,x) => IsCouple(snd(x))   BECAUSE TransitImplication;
imageInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(snd(x)) \in Image(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(snd(x)) \in Image(f)   BECAUSE TransitImplication;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(snd(x)) \in Image(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(snd(x)) \in Image(g)   BECAUSE TransitImplication;
IsParallelApply(f,g,x) => (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))   BECAUSE CombineImplicationsEnd;
IsParallelApply(f,g,x) => (IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))   BECAUSE CombineImplicationsEnd;
IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))   BECAUSE TransitImplication;

IsParallelApply(f,g,x) => (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   BECAUSE CombineImplicationsEnd;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(x)   BECAUSE DropAndRight2;
IsParallelApply(f,g,x) => IsCouple(x)   BECAUSE TransitImplication;
IsParallelApply(f,g,x) => (IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))   BECAUSE CombineImplicationsEnd;
IsParallelApply(f,g,x) => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TransitImplication;

x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE SeparationTauto;
\A x : x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE GENERALIZATION;
\E h : \A x : x \in h <=> IsParallelApply(f,g,x)   BECAUSE \E(h <- chooseB(f,g));
(\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)) <=> \E h : \A x : x \in h <=> IsParallelApply(f,g,x)
   BECAUSE CHOOSE parallelFunc(f,g);
\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)   BECAUSE MODUS_PONENS;
parallelFuncExists   BECAUSE GENERALIZATION;
QED
