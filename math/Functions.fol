(*
   The class of functions : graphs that have at most one output for each
   input. A function as a set represents a computation, like addition
   or multiplication, something that always produces the same output
   when given the same input.

   The function application operator f[x] is defined, as well as its
   reverse operator pre(f,x).
*)

EXTENDS ZFC

IsFunction(f) == IsGraph(f)  /\  \A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c
IsInjection(f) == IsFunction(f)  /\  \A a : \A b : <<a,b>> \in f => a = pre(f,b)

funcVal == \A f : \A x : \A y : IsFunction(f) /\ <<x,y>> \in f => y = f[x]
THEOREM funcVal
PROOF
VARIABLES a,b,c,f,x,y,z;
h(f,x,y) == IsFunction(f) /\ <<x,y>> \in f;
h(f,x,y) => <<x,y>> \in f   BECAUSE S22;
\A z : \A y : z = y => (<<x,z>> \in f <=> <<x,y>> \in f)   BECAUSE E_SCHEME;
z = y => (<<x,z>> \in f <=> <<x,y>> \in f)   BECAUSE \A(z <- z, y <- y);
cycleHypos(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
<<x,y>> \in f /\ z = y => <<x,z>> \in f   BECAUSE cycleHypos;
z = y => z = y   BECAUSE ImplySelf;
h(f,x,y) /\ z = y => <<x,y>> \in f /\ z = y   BECAUSE MergeImplicationsAnd;
h(f,x,y) /\ z = y => <<x,z>> \in f   BECAUSE TI;

h(f,x,y) /\ <<x,z>> \in f => h(f,x,y)   BECAUSE S12;
h(f,x,y) /\ <<x,z>> \in f => <<x,z>> \in f   BECAUSE S22;
h(f,x,y) /\ <<x,z>> \in f => <<x,y>> \in f   BECAUSE TI;
h(f,x,y) /\ <<x,z>> \in f => <<x,y>> \in f /\ <<x,z>> \in f   BECAUSE CIA;
h(f,x,y) => IsFunction(f)   BECAUSE S12;
IsFunction(f) => \A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c   BECAUSE S22;
(\A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c) => (<<x,y>> \in f /\ <<x,z>> \in f => y = z)
   BECAUSE \A(a <- x, b <- y, c <- z);
h(f,x,y) => (<<x,y>> \in f /\ <<x,z>> \in f => y = z)   BECAUSE TI2;
h(f,x,y) /\ <<x,z>> \in f => (<<x,y>> \in f /\ <<x,z>> \in f => y = z)   BECAUSE TI;
h(f,x,y) /\ <<x,z>> \in f => y = z   BECAUSE KillMiddleHypo;
y = z => z = y   BECAUSE E_SCHEME;
h(f,x,y) /\ <<x,z>> \in f => z = y   BECAUSE TI;
h(f,x,y) => (z = y <=> <<x,z>> \in f)   BECAUSE HIE;
\A z : h(f,x,y) => (z = y <=> <<x,z>> \in f)   BECAUSE GENERALIZATION;
h(f,x,y) => (\A z : z = y <=> <<x,z>> \in f)   BECAUSE Q_SCHEME;
(\A z : z = y <=> <<x,z>> \in f) => (\E y : \A z : z = y <=> <<x,z>> \in f)   BECAUSE \E(y <- y);
(\E y : \A z : z = y <=> <<x,z>> \in f) => (\A z : z = f[x] <=> <<x,z>> \in f)   BECAUSE CHOOSE f[x];
h(f,x,y) => (\A z : z = f[x] <=> <<x,z>> \in f)   BECAUSE TI2;
(\A z : z = f[x] <=> <<x,z>> \in f) => (y = f[x] <=> <<x,y>> \in f)   BECAUSE \A(z <- y);
h(f,x,y) => (y = f[x] <=> <<x,y>> \in f)   BECAUSE TI;
implyEquivTrue(t,h,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
h(f,x,y) => y = f[x]   BECAUSE implyEquivTrue;
funcVal   BECAUSE GENERALIZATION;
QED

funcImageExists == \A f : \A x : IsFunction(f) /\ x \in Domain(f) => <<x, f[x]>> \in f
THEOREM funcImageExists
PROOF
VARIABLES a,b,f,g,x,y,z;
h(f,x,y) == IsFunction(f) /\ <<x,y>> \in f;
funcVal   BECAUSE THEOREM;
h(f,x,y) => y = f[x]   BECAUSE \A(f <- f, x <- x, y <- y);
\A y : \A z : y = z => (<<x,y>> \in f <=> <<x,z>> \in f)   BECAUSE E_SCHEME;
y = f[x] => (<<x,y>> \in f <=> <<x,f[x]>> \in f)   BECAUSE \A(y <- y, z <- f[x]);
h(f,x,y) => (<<x,y>> \in f <=> <<x,f[x]>> \in f)   BECAUSE TI;
implyTrueEquiv(h,t,a) == (h => t) => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
h(f,x,y) => <<x,y>> \in f   BECAUSE S22;
h(f,x,y) => <<x,f[x]>> \in f   BECAUSE implyTrueEquiv;
\* Discharge y
IsFunction(f) => (<<x,y>> \in f => <<x,f[x]>> \in f)   BECAUSE HypoAndToImpl;
\A y : IsFunction(f) => (<<x,y>> \in f => <<x,f[x]>> \in f)   BECAUSE GENERALIZATION;
IsFunction(f) => (\A y : <<x,y>> \in f => <<x,f[x]>> \in f)   BECAUSE Q_SCHEME;
(\A y : <<x,y>> \in f => <<x,f[x]>> \in f) => ((\E y : <<x,y>> \in f) => \E y : <<x,f[x]>> \in f)   BECAUSE Q_SCHEME;
IsFunction(f) => ((\E y : <<x,y>> \in f) => \E y : <<x,f[x]>> \in f)   BECAUSE TI;

domainExists   BECAUSE THEOREM;
x \in Domain(f) <=> IsDefinedOn(f,x)   BECAUSE \A(g <- f, x <- x);
x \in Domain(f) => \E y : <<x,y>> \in f   BECAUSE EquivToImpl;
IsFunction(f) /\ x \in Domain(f) => x \in Domain(f)   BECAUSE S22;
IsFunction(f) /\ x \in Domain(f) => IsFunction(f)   BECAUSE S12;
IsFunction(f) /\ x \in Domain(f) => ((\E y : <<x,y>> \in f) => \E y : <<x,f[x]>> \in f)   BECAUSE TI;
IsFunction(f) /\ x \in Domain(f) => \E y : <<x,y>> \in f   BECAUSE TI;
IsFunction(f) /\ x \in Domain(f) => \E y : <<x,f[x]>> \in f   BECAUSE KillMiddleHypo;
(\E y : <<x,f[x]>> \in f) => <<x,f[x]>> \in f   BECAUSE Q_SCHEME;
IsFunction(f) /\ x \in Domain(f) => <<x,f[x]>> \in f   BECAUSE TI;
funcImageExists   BECAUSE GENERALIZATION;
QED

(*
   A bijection is an equivalence between two sets, a one-to-one correspondence
   between elements of each set.
*)
Bijections(d, i) == CHOOSE b : \A f : f \in b <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i
bijectionsExists == \A d : \A i : \A f : f \in Bijections(d,i) <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i
THEOREM bijectionsExists
PROOF
\* By separation in SUBSET (d \X i)
VARIABLES a,b,c,d,f,g,i,x,y,z;
\A a : \E b : \A x : x \in b <=> x \in a /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i)   BECAUSE \A(a <- SUBSET (d \X i));
powersetExists   BECAUSE AXIOM;
x \in SUBSET (d \X i) <=> x \subseteq (d \X i)   BECAUSE \A(x <- d \X i, z <- x);
x \subseteq (d \X i) => x \in SUBSET (d \X i)   BECAUSE EquivToImplReverse;

h(d,i,x,z) == IsInjection(x) /\ Domain(x) = d /\ Image(x) = i /\ z \in x; \* Prove that z \in d \X i
h(d,i,x,z) => h(d,i,x,z)   BECAUSE ImplySelf;
h(d,i,x,z) => IsInjection(x)   BECAUSE S14;
IsInjection(x) => IsFunction(x)   BECAUSE S12;
IsFunction(x) => IsGraph(x)   BECAUSE S12;
h(d,i,x,z) => IsFunction(x)   BECAUSE TI;
h(d,i,x,z) => IsGraph(x)   BECAUSE TI;
IsGraph(a) => (z \in a => IsCouple(z))   BECAUSE \A(x <- z);
\A a : IsGraph(a) => (z \in a => IsCouple(z))   BECAUSE GENERALIZATION;
IsGraph(x) => (z \in x => IsCouple(z))   BECAUSE \A(a <- x);
IsGraph(x) /\ z \in x => IsCouple(z)   BECAUSE HypoImplToAnd;
h(d,i,x,z) => z \in x   BECAUSE S22;
h(d,i,x,z) => IsGraph(x) /\ z \in x   BECAUSE CIA;
h(d,i,x,z) => IsCouple(z)   BECAUSE TI;
domainExists   BECAUSE THEOREM;
fst(z) \in Domain(x) <=> IsDefinedOn(x,fst(z))   BECAUSE \A(g <- x, x <- fst(z));
(\E y : <<fst(z),y>> \in x) => fst(z) \in Domain(x)   BECAUSE EquivToImplReverse;
tupleComposition   BECAUSE THEOREM;
IsCouple(z) => z = <<fst(z), snd(z)>>   BECAUSE \A(c <- z);
h(d,i,x,z) => z = <<fst(z), snd(z)>>   BECAUSE TI;
<<fst(z), snd(z)>> \in x => (\E y : <<fst(z),y>> \in x)   BECAUSE \E(y <- snd(z));
<<fst(z), snd(z)>> \in x => fst(z) \in Domain(x)   BECAUSE TI;
<<fst(z), snd(z)>> \in x => fst(z) \in Domain(x)   BECAUSE TI;
\A z : \A y : z = y => (z \in x <=> y \in x)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in x <=> <<fst(z), snd(z)>> \in x)   BECAUSE \A(z <- z, y <- <<fst(z), snd(z)>>);
h(d,i,x,z) => (z \in x <=> <<fst(z), snd(z)>> \in x)   BECAUSE TI;
h(d,i,x,z) /\ z \in x => <<fst(z), snd(z)>> \in x   BECAUSE HypoEquivToAnd;
h(d,i,x,z) => h(d,i,x,z) /\ z \in x   BECAUSE CIA;
h(d,i,x,z) => <<fst(z), snd(z)>> \in x   BECAUSE TI;
h(d,i,x,z) => fst(z) \in Domain(x)   BECAUSE TI;

imageExists   BECAUSE THEOREM;
snd(z) \in Image(a) <=> Reaches(a,snd(z))   BECAUSE \A(g <- a, y <- snd(z));
(\E x : <<x,snd(z)>> \in a) => snd(z) \in Image(a)   BECAUSE EquivToImplReverse;
<<fst(z), snd(z)>> \in a => (\E x : <<x,snd(z)>> \in a)   BECAUSE \E(x <- fst(z));
<<fst(z), snd(z)>> \in a => snd(z) \in Image(a)   BECAUSE TI;
\A a : <<fst(z), snd(z)>> \in a => snd(z) \in Image(a)   BECAUSE GENERALIZATION;
<<fst(z), snd(z)>> \in x => snd(z) \in Image(x)   BECAUSE \A(a <- x);
h(d,i,x,z) => snd(z) \in Image(x)   BECAUSE TI;
h(d,i,x,z) => fst(z) \in Domain(x) /\ snd(z) \in Image(x)   BECAUSE CIA;
cartesianProductCouples   BECAUSE THEOREM;
(fst(z) \in Domain(x) /\ snd(z) \in Image(x)) <=> <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))
   BECAUSE \A(x <- Domain(x), y <- Image(x), a <- fst(z), b <- snd(z));
(fst(z) \in Domain(x) /\ snd(z) \in Image(x)) => <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE EquivToImpl;
h(d,i,x,z) => <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE TI;
\A a : \A x : \A b : \A y : \A c : \A z : a = x /\ b = y /\ c = z => (a \in (b \X c) <=> x \in (y \X z))   BECAUSE E_SCHEME;
<<fst(z), snd(z)>> = z /\ Domain(x) = d /\ Image(x) = i => (<<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) <=> z \in (d \X i))
   BECAUSE \A(a <- <<fst(z),snd(z)>>, x <- z, b <- Domain(x), y <- d, c <- Image(x), z <- i);
z = <<fst(z), snd(z)>> => <<fst(z), snd(z)>> = z   BECAUSE E_SCHEME;
h(d,i,x,z) => <<fst(z), snd(z)>> = z   BECAUSE TI;
h(d,i,x,z) => IsInjection(x) /\ Domain(x) = d   BECAUSE S13;
IsInjection(x) /\ Domain(x) = d => Domain(x) = d   BECAUSE S22;
h(d,i,x,z) => Domain(x) = d   BECAUSE TI;
h(d,i,x,z) => <<fst(z), snd(z)>> = z /\ Domain(x) = d   BECAUSE CIA;
h(d,i,x,z) => Image(x) = i   BECAUSE S23;
h(d,i,x,z) => <<fst(z), snd(z)>> = z /\ Domain(x) = d /\ Image(x) = i   BECAUSE CIA;
h(d,i,x,z) => (<<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) <=> z \in (d \X i))   BECAUSE TI;
h(d,i,x,z) /\ <<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) => z \in (d \X i)   BECAUSE HypoEquivToAnd;
h(d,i,x,z) => h(d,i,x,z) /\ <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE CIA;
h(d,i,x,z) => z \in (d \X i)   BECAUSE TI;

IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => (z \in x => z \in (d \X i))   BECAUSE HypoAndToImpl;
\A z : IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => (z \in x => z \in (d \X i))   BECAUSE GENERALIZATION;
IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => x \subseteq (d \X i)   BECAUSE Q_SCHEME;
IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => x \in SUBSET (d \X i)   BECAUSE TI;
(x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))   BECAUSE SeparationTauto;
(\A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))   BECAUSE Q_SCHEME;
(\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE \A(x <- f);
\A f : (\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE GENERALIZATION;
(\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE Q_SCHEME;
(\A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE TI;
(\E b : \A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\E b : \A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE Q_SCHEME;
\E b : \A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i)   BECAUSE MODUS_PONENS;
\A f : f \in Bijections(d,i) <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i   BECAUSE CHOOSE Bijections(d,i);
bijectionsExists   BECAUSE GENERALIZATION;
QED

funcInversePre == \A f : \A y : IsFunction(f) /\ y \in Image(f) => f[pre(f,y)] = y
THEOREM funcInversePre
PROOF
VARIABLES a,b,f,g,x,y;
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
y \in Image(f) => \E x : <<x,y>> \in f   BECAUSE EquivToImpl;
(\E x : <<x,y>> \in f) => <<pre(f,y),y>> \in f   BECAUSE CHOOSE pre(f,y);
y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE TI;
funcVal   BECAUSE THEOREM;
IsFunction(f) /\ <<pre(f,y),y>> \in f => y = f[pre(f,y)]   BECAUSE \A(f <- f, x <- pre(f,y), y <- y);
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
IsFunction(f) /\ y \in Image(f) => IsFunction(f) /\ <<pre(f,y),y>> \in f   BECAUSE MergeImplicationsAnd;
IsFunction(f) /\ y \in Image(f) => y = f[pre(f,y)]   BECAUSE TI;
y = f[pre(f,y)] => f[pre(f,y)] = y   BECAUSE E_SCHEME;
IsFunction(f) /\ y \in Image(f) => f[pre(f,y)] = y   BECAUSE TI;
funcInversePre   BECAUSE GENERALIZATION;
QED

funcEqual == \A f : \A g : IsFunction(f) /\ IsFunction(g) /\ Domain(f) = Domain(g)
   /\ (\A x : x \in Domain(f) => f[x] = g[x])
   => f = g
THEOREM funcEqual
PROOF
VARIABLES a,b,c,f,g,x,y,z;
mainHypo(f,g) == IsFunction(f) /\ IsFunction(g) /\ Domain(f) = Domain(g)
   /\ (\A x : x \in Domain(f) => f[x] = g[x]);
mainHypo(f,g) => IsFunction(f)   BECAUSE S14;
mainHypo(f,g) => IsFunction(g)   BECAUSE S24;
h(f,g,x,y) == mainHypo(f,g) /\ <<x,y>> \in f;
\* Prove that h(f,g,x,y) => <<x,y>> \in g
domainExists   BECAUSE THEOREM;
x \in Domain(f) <=> IsDefinedOn(f,x)   BECAUSE \A(g <- f, x <- x);
IsDefinedOn(f,x) => x \in Domain(f)   BECAUSE EquivToImplReverse;
<<x,y>> \in f => IsDefinedOn(f,x)   BECAUSE \E(y <- y);
h(f,g,x,y) => <<x,y>> \in f   BECAUSE S22;
h(f,g,x,y) => x \in Domain(f)   BECAUSE TI2;
h(f,g,x,y) => mainHypo(f,g)   BECAUSE S12;
funcVal   BECAUSE THEOREM;
IsFunction(f) /\ <<x,y>> \in f => y = f[x]   BECAUSE \A(f <- f, x <- x, y <- y);
IsFunction(f) => (<<x,y>> \in f => y = f[x])   BECAUSE HypoAndToImpl;
h(f,g,x,y) => (<<x,y>> \in f => y = f[x])   BECAUSE TI2;
h(f,g,x,y) => y = f[x]   BECAUSE KillMiddleHypo;
mainHypo(f,g) => (\A x : x \in Domain(f) => f[x] = g[x])   BECAUSE S22;
(\A x : x \in Domain(f) => f[x] = g[x]) => (x \in Domain(f) => f[x] = g[x])   BECAUSE \A(x <- x);
h(f,g,x,y) => (x \in Domain(f) => f[x] = g[x])   BECAUSE TI2;
h(f,g,x,y) => f[x] = g[x]   BECAUSE KillMiddleHypo;
f[x] = g[x] => g[x] = f[x]   BECAUSE E_SCHEME;
h(f,g,x,y) => g[x] = f[x]   BECAUSE TI;
h(f,g,x,y) => y = f[x] /\ g[x] = f[x]   BECAUSE CIA;
y = f[x] /\ g[x] = f[x] => y = g[x]   BECAUSE E_SCHEME;
h(f,g,x,y) => y = g[x]   BECAUSE TI;
domainExists   BECAUSE THEOREM;
funcImageExists   BECAUSE THEOREM;
IsFunction(g) /\ x \in Domain(g) => <<x, g[x]>> \in g   BECAUSE \A(f <- g, x <- x);
\A a : \A b : a = b => (x \in a <=> x \in b)   BECAUSE E_SCHEME;
Domain(f) = Domain(g) => (x \in Domain(f) <=> x \in Domain(g))   BECAUSE \A(a <- Domain(f), b <- Domain(g));
h(f,g,x,y) => Domain(f) = Domain(g)   BECAUSE S24;
(x \in Domain(f) <=> x \in Domain(g)) => (x \in Domain(f) => x \in Domain(g))   BECAUSE EquivToImpl;
h(f,g,x,y) => (x \in Domain(f) => x \in Domain(g))   BECAUSE TI2;
h(f,g,x,y) => x \in Domain(g)   BECAUSE KillMiddleHypo;
h(f,g,x,y) => IsFunction(g)   BECAUSE TI;
h(f,g,x,y) => IsFunction(g) /\ x \in Domain(g)   BECAUSE CIA;
h(f,g,x,y) => <<x,g[x]>> \in g   BECAUSE TI;
\A a : \A b : a = b => (<<x,a>> \in g <=> <<x,b>> \in g)   BECAUSE E_SCHEME;
y = g[x] => (<<x,y>> \in g <=> <<x,g[x]>> \in g)   BECAUSE \A(a <- y, b <- g[x]);
(<<x,y>> \in g <=> <<x,g[x]>> \in g) => (<<x,g[x]>> \in g => <<x,y>> \in g)   BECAUSE EquivToImplReverse;
h(f,g,x,y) => (<<x,g[x]>> \in g => <<x,y>> \in g)   BECAUSE TI2;
h(f,g,x,y) => <<x,y>> \in g   BECAUSE KillMiddleHypo;

\A x : \A y : h(f,g,x,y) => <<x,y>> \in g   BECAUSE GENERALIZATION;
h(f,g,fst(z),snd(z)) => <<fst(z),snd(z)>> \in g   BECAUSE \A(x <- fst(z), y <- snd(z));
hh(f,g,z) == mainHypo(f,g) /\ z \in f;
hh(f,g,z) => mainHypo(f,g)   BECAUSE S12;
IsFunction(f) => IsGraph(f)   BECAUSE S12;
IsGraph(f) => (z \in f => IsCouple(z))   BECAUSE \A(x <- z);
hh(f,g,z) => IsGraph(f)   BECAUSE TI2;
hh(f,g,z) => (z \in f => IsCouple(z))   BECAUSE TI;
hh(f,g,z) => z \in f   BECAUSE S22;
hh(f,g,z) => IsCouple(z)   BECAUSE KillMiddleHypo;
tupleComposition   BECAUSE THEOREM;
IsCouple(z) => z = <<fst(z), snd(z)>>   BECAUSE \A(c <- z);
hh(f,g,z) => z = <<fst(z), snd(z)>>   BECAUSE TI;
\A a : \A b : a = b => (a \in f <=> b \in f)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in f <=> <<fst(z), snd(z)>> \in f)  BECAUSE \A(a <- z, b <- <<fst(z), snd(z)>>);
(z \in f <=> <<fst(z), snd(z)>> \in f) => (z \in f => <<fst(z), snd(z)>> \in f)   BECAUSE EquivToImpl;
hh(f,g,z) => (z \in f => <<fst(z), snd(z)>> \in f)  BECAUSE TI2;
hh(f,g,z) => <<fst(z), snd(z)>> \in f  BECAUSE KillMiddleHypo;
hh(f,g,z) => h(f,g,fst(z),snd(z))  BECAUSE CIA;
hh(f,g,z) => <<fst(z),snd(z)>> \in g  BECAUSE TI;
\A a : \A b : a = b => (a \in g <=> b \in g)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in g <=> <<fst(z), snd(z)>> \in g)  BECAUSE \A(a <- z, b <- <<fst(z), snd(z)>>);
(z \in g <=> <<fst(z), snd(z)>> \in g) => (<<fst(z), snd(z)>> \in g => z \in g)   BECAUSE EquivToImplReverse;
hh(f,g,z) => (<<fst(z), snd(z)>> \in g => z \in g)  BECAUSE TI2;
hh(f,g,z) => z \in g  BECAUSE KillMiddleHypo;
mainHypo(f,g) => (z \in f => z \in g)  BECAUSE HypoAndToImpl;
\A z : mainHypo(f,g) => (z \in f => z \in g)  BECAUSE GENERALIZATION;
mainHypo(f,g) => f \subseteq g  BECAUSE Q_SCHEME;

\* Prove g \subseteq f by variable swapping
\A f : \A g : mainHypo(f,g) => f \subseteq g  BECAUSE GENERALIZATION;
mainHypo(g,f) => g \subseteq f  BECAUSE \A(f <- g, g <- f);
Domain(f) = Domain(g) => Domain(g) = Domain(f)   BECAUSE E_SCHEME;
mainHypo(f,g) => Domain(f) = Domain(g)   BECAUSE S23;
mainHypo(f,g) => Domain(g) = Domain(f)   BECAUSE TI;
mainHypo(f,g) => IsFunction(g) /\ IsFunction(f)   BECAUSE CIA;
mainHypo(f,g) => IsFunction(g) /\ IsFunction(f) /\ Domain(g) = Domain(f)   BECAUSE CIA;
f[x] = g[x] => g[x] = f[x]   BECAUSE E_SCHEME;
introHypo(a,b,h) == (a => b) => ((h => a) => (h => b))   PROPO_TAUTO;
(x \in Domain(f) => f[x] = g[x]) => (x \in Domain(f) => g[x] = f[x])   BECAUSE introHypo;
mainHypo(f,g) => (x \in Domain(f) => g[x] = f[x])   BECAUSE TI2;
\A a : \A b : a = b => ((x \in a => g[x] = f[x]) <=> (x \in b => g[x] = f[x]))   BECAUSE E_SCHEME;
Domain(f) = Domain(g) => ((x \in Domain(f) => g[x] = f[x]) <=> (x \in Domain(g) => g[x] = f[x]))   BECAUSE \A(a <- Domain(f), b <- Domain(g));
((x \in Domain(f) => g[x] = f[x]) <=> (x \in Domain(g) => g[x] = f[x])) => ((x \in Domain(f) => g[x] = f[x]) => (x \in Domain(g) => g[x] = f[x]))  BECAUSE EquivToImpl;
mainHypo(f,g) => ((x \in Domain(f) => g[x] = f[x]) => (x \in Domain(g) => g[x] = f[x]))   BECAUSE TI2;
mainHypo(f,g) => (x \in Domain(g) => g[x] = f[x])   BECAUSE KillMiddleHypo;
\A x : mainHypo(f,g) => (x \in Domain(g) => g[x] = f[x])   BECAUSE GENERALIZATION;
mainHypo(f,g) => (\A x : x \in Domain(g) => g[x] = f[x])   BECAUSE Q_SCHEME;
mainHypo(f,g) => mainHypo(g,f)   BECAUSE CIA;
mainHypo(f,g) => g \subseteq f   BECAUSE TI;
mainHypo(f,g) => f \subseteq g /\ g \subseteq f   BECAUSE CIA;
bothInclusions   BECAUSE THEOREM;
(f \subseteq g /\ g \subseteq f) => f = g   BECAUSE \A(a <- f, b <- g);
mainHypo(f,g) => f = g   BECAUSE TI;
funcEqual   BECAUSE GENERALIZATION;
QED

(*
   F should be a term with free variable x, which defines a function.

   For example, separationFunc(x, d) defines the identity function.
*)
MACRO separationFunc
PROOF
\* No variables declared, a macro is copy-pasted in other proofs. Or add these variables to the other proof's variables ?
\* Do not declare operators h(a,b) == ...F... because F might have other free variables.
\A a : \E b : \A x : x \in b <=> x \in a /\ snd(x) = F(x <- fst(x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))   BECAUSE \A(a <- d \X i);
\* Transform it as <<x,y>> \in b <=> y = F ?

\* Prove b is a graph
x \in d \X i /\ snd(x) = F(x <- fst(x)) => x \in d \X i   BECAUSE S12;
cartesianProductExists   BECAUSE THEOREM;
x \in (d \X i) <=> IsCouple(x) /\ fst(x) \in d /\ snd(x) \in i   BECAUSE \A(i <- d, j <- i, x <- x);
x \in (d \X i) => IsCouple(x) /\ fst(x) \in d /\ snd(x) \in i   BECAUSE EquivToImpl;
IsCouple(x) /\ fst(x) \in d /\ snd(x) \in i => IsCouple(x)   BECAUSE S13;
x \in d \X i /\ snd(x) = F(x <- fst(x)) => IsCouple(x)   BECAUSE TI2;

(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) =>
   (x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))   BECAUSE \A(x <- x);
(x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in b => x \in d \X i /\ snd(x) = F(x <- fst(x)))   BECAUSE EquivToImpl;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) =>
   (x \in b => x \in d \X i /\ snd(x) = F(x <- fst(x)))   BECAUSE TI;
sepFuncTauto1(a,b,c,d) == (a => (b => c)) => ((c => d) => (a => (b => d)))   PROPO_TAUTO;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in b => IsCouple(x))   BECAUSE sepFuncTauto1;
\A x : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => (x \in b => IsCouple(x))   BECAUSE GENERALIZATION;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => IsGraph(b)   BECAUSE Q_SCHEME;

\* Prove b is a function
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (<<a,b>> \in f <=> <<a,b>> \in d \X i /\ snd(<<a,b>>) = F(x <- fst(<<a,b>>)))   BECAUSE \A(x <- <<a,b>>);
sepFuncTauto2(h,a,b) == (h => (a <=> b)) => (h /\ a => b)   PROPO_TAUTO;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ <<a,b>> \in f
   => <<a,b>> \in d \X i /\ snd(<<a,b>>) = F(x <- fst(<<a,b>>))   BECAUSE sepFuncTauto2;
<<a,b>> \in d \X i /\ snd(<<a,b>>) = F(x <- fst(<<a,b>>)) => snd(<<a,b>>) = F(x <- fst(<<a,b>>))   BECAUSE S22;
sndExists   BECAUSE THEOREM;
b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
fstExists   BECAUSE THEOREM;
a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
\A a : \A b : \A x : \A y : a = b /\ x = y => (a = F(x <- x) <=> b = F(x <- y))   BECAUSE E_SCHEME;
b = snd(<<a,b>>) /\ a = fst(<<a,b>>) => (b = F(x <- a) <=> snd(<<a,b>>) = F(x <- fst(<<a,b>>)))
   BECAUSE \A(a <- b, b <- snd(<<a,b>>), x <- a, y <- fst(<<a,b>>));
b = snd(<<a,b>>) /\ a = fst(<<a,b>>)   BECAUSE IntroAndRight;
b = F(x <- a) <=> snd(<<a,b>>) = F(x <- fst(<<a,b>>))   BECAUSE MODUS_PONENS;
snd(<<a,b>>) = F(x <- fst(<<a,b>>)) => b = F(x <- a)   BECAUSE EquivToImplReverse;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ <<a,b>> \in f => b = F(x <- a)   BECAUSE TI2;
\A b : (\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ <<a,b>> \in f => b = F(x <- a)   BECAUSE GENERALIZATION;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ <<a,c>> \in f => c = F(x <- a)   BECAUSE \A(b <- c);
sepFuncTauto3(h,a,b,c,d) == (h /\ a => b) => ((h /\ c => d) => (h /\ (a /\ c) => b /\ d))   PROPO_TAUTO;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (<<a,b>> \in f /\ <<a,c>> \in f)
   => b = F(x <- a) /\ c = F(x <- a)   BECAUSE sepFuncTauto3;
b = F(x <- a) /\ c = F(x <- a) => b = c   BECAUSE E_SCHEME;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (<<a,b>> \in f /\ <<a,c>> \in f)
   => b = c   BECAUSE TI;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (<<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE HypoAndToImpl;
\A c : (\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (<<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE GENERALIZATION;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A c : <<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE Q_SCHEME;
\A b : (\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A c : <<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE GENERALIZATION;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A b : \A c : <<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE Q_SCHEME;
\A a : (\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A b : \A c : <<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE GENERALIZATION;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A a : \A b : \A c : <<a,b>> \in f /\ <<a,c>> \in f => b = c)   BECAUSE Q_SCHEME;
\A b : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => IsGraph(b)   BECAUSE GENERALIZATION;
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => IsGraph(f)   BECAUSE \A(b <- f);
(\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => IsFunction(f)   BECAUSE CIA;
\A f : (\A x : x \in f <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => IsFunction(f)   BECAUSE GENERALIZATION;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => IsFunction(b)   BECAUSE \A(f <- b);

\* Prove that Domain(b) = d when F \in i

\* Domain(b) \subseteq d
domainIncProd   BECAUSE THEOREM;
b \subseteq d \X i => Domain(b) \subseteq d   BECAUSE \A(g <- b, d <- d, i <- i);
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in b => x \in d \X i)   BECAUSE sepFuncTauto1;
\A x : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in b => x \in d \X i)   BECAUSE GENERALIZATION;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (z \in b => z \in d \X i)   BECAUSE \A(x <- z);
\A z : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (z \in b => z \in d \X i)   BECAUSE GENERALIZATION;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => b \subseteq d \X i   BECAUSE Q_SCHEME;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => Domain(b) \subseteq d   BECAUSE TI;

(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))   BECAUSE S22;
(\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (<<x,F>> \in b <=> <<x,F>> \in d \X i /\ snd(<<x,F>>) = F(x <- fst(<<x,F>>)))   BECAUSE \A(x <- <<x,F>>);
(<<x,F>> \in b <=> <<x,F>> \in d \X i /\ snd(<<x,F>>) = F(x <- fst(<<x,F>>)))
   => (<<x,F>> \in d \X i /\ snd(<<x,F>>) = F(x <- fst(<<x,F>>)) => <<x,F>> \in b)   BECAUSE EquivToImplReverse;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (<<x,F>> \in d \X i /\ snd(<<x,F>>) = F(x <- fst(<<x,F>>)) => <<x,F>> \in b)   BECAUSE TI2;
(\A x : x \in d => F \in i) => (x \in d => F \in i)   BECAUSE \A(x <- x);
cartesianProductCouples   BECAUSE THEOREM;
(x \in d /\ F \in i) <=> <<x,F>> \in (d \X i)   BECAUSE \A(x <- d, y <- i, a <- x, b <- F);
mergeImpl(a,b,c,d) == (a => (b => c)) => ((b /\ c <=> d) => (a /\ b => d))   PROPO_TAUTO;
(\A x : x \in d => F \in i) /\ x \in d => <<x,F>> \in d \X i   BECAUSE mergeImpl;
sndExists   BECAUSE THEOREM;
F = snd(<<x,F>>)   BECAUSE \A(a <- x, b <- F);
fstExists   BECAUSE THEOREM;
x = fst(<<x,F>>)   BECAUSE \A(a <- x, b <- F);
\A x : \A y : x = y => F = F(x <- y)   BECAUSE E_SCHEME;
x = fst(<<x,F>>) => F = F(x <- fst(<<x,F>>))   BECAUSE \A(x <- x, y <- fst(<<x,F>>));
F = F(x <- fst(<<x,F>>))   BECAUSE MODUS_PONENS;
F = snd(<<x,F>>) /\ F = F(x <- fst(<<x,F>>)) => snd(<<x,F>>) = F(x <- fst(<<x,F>>))   BECAUSE E_SCHEME;
F = snd(<<x,F>>) /\ F = F(x <- fst(<<x,F>>))   BECAUSE IntroAndRight;
snd(<<x,F>>) = F(x <- fst(<<x,F>>))   BECAUSE MODUS_PONENS;
<<x,F>> \in d \X i => <<x,F>> \in d \X i /\ snd(<<x,F>>) = F(x <- fst(<<x,F>>))   BECAUSE IntroAndLeft;
(\A x : x \in d => F \in i) /\ x \in d
   => <<x,F>> \in d \X i /\ snd(<<x,F>>) = F(x <- fst(<<x,F>>))   BECAUSE TI;
mergeImpl2(a,b,c,d,e) == (c /\ d => (a => b)) => ((c /\ e => a) => (c /\ d /\ e => b))   PROPO_TAUTO;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ x \in d
   => <<x,F>> \in b   BECAUSE mergeImpl2;
domainExists   BECAUSE THEOREM;
x \in Domain(b) <=> IsDefinedOn(b,x)   BECAUSE \A(g <- b, x <- x);
IsDefinedOn(b,x) => x \in Domain(b)   BECAUSE EquivToImplReverse;
<<x,F>> \in b => IsDefinedOn(b,x)   BECAUSE \E(y <- F);
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ x \in d
   => x \in Domain(b)   BECAUSE TI2;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in d => x \in Domain(b))   BECAUSE HypoAndToImpl;
\A x : (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in d => x \in Domain(b))   BECAUSE GENERALIZATION;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (z \in d => z \in Domain(b))   BECAUSE \A(x <- z);
\A z : (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (z \in d => z \in Domain(b))   BECAUSE GENERALIZATION;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => d \subseteq Domain(b)   BECAUSE Q_SCHEME;
bothInclusions   BECAUSE THEOREM;
(Domain(b) \subseteq d /\ d \subseteq Domain(b)) => Domain(b) = d   BECAUSE \A(a <- Domain(b), b <- d);
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => Domain(b) \subseteq d   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => Domain(b) \subseteq d /\ d \subseteq Domain(b)   BECAUSE CIA;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => Domain(b) = d   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => IsFunction(b)   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => IsFunction(b) /\ Domain(b) = d   BECAUSE CIA;

\* Prove b[x] = F
funcVal   BECAUSE THEOREM;
IsFunction(b) /\ <<x,F>> \in b => F = b[x]   BECAUSE \A(f <- b, x <- x, y <- F);
F = b[x] => b[x] = F   BECAUSE E_SCHEME;
IsFunction(b) /\ <<x,F>> \in b => b[x] = F   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ x \in d
   => (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   BECAUSE S12;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ x \in d
   => IsFunction(b)   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ x \in d
   => IsFunction(b) /\ <<x,F>> \in b   BECAUSE CIA;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ x \in d
   => b[x] = F   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in d => b[x] = F)   BECAUSE HypoAndToImpl;
\A x : (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (x \in d => b[x] = F)   BECAUSE GENERALIZATION;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A x : x \in d => b[x] = F)   BECAUSE Q_SCHEME;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => IsFunction(b) /\ Domain(b) = d /\ (\A x : x \in d => b[x] = F)   BECAUSE CIA;

\* Unicity of b
\A z : \A b : z = b => (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F) <=> IsFunction(b) /\ Domain(b) = d /\ (\A x : x \in d => b[x] = F))   BECAUSE E_SCHEME;
z = b => (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F) <=> IsFunction(b) /\ Domain(b) = d /\ (\A x : x \in d => b[x] = F))   BECAUSE \A(z <- z, b <- b);
implyEquivTrueB(h,t,a,b) == (h => t) => ((a => (b <=> t)) => (h /\ a => b))   PROPO_TAUTO;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ z = b
   => (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))   BECAUSE implyEquivTrueB;

funcEqual   BECAUSE THEOREM;
IsFunction(z) /\ IsFunction(b) /\ Domain(z) = Domain(b) /\ (\A x : x \in Domain(z) => z[x] = b[x])
   => z = b    BECAUSE \A(f <- z, g <- b);
\* hh(a,b,z) == (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in d => z[x] = F));
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))
   => (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))   BECAUSE S12;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))
   => IsFunction(b)   BECAUSE TI;
(\A x : x \in d => F \in i)
   /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => Domain(b) = d   BECAUSE TI;
(\A x : x \in d => b[x] = F) => (x \in d => b[x] = F)   BECAUSE \A(x <- x);
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (x \in d => b[x] = F)   BECAUSE TI2;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))   BECAUSE S22;
(IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => IsFunction(z)   BECAUSE S13;
(IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => Domain(z) = d   BECAUSE S23;
(IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (\A x : x \in d => z[x] = F)   BECAUSE S22;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => IsFunction(z)   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => Domain(z) = d   BECAUSE TI;
(\A x : x \in d => z[x] = F) => (x \in d => z[x] = F)   BECAUSE \A(x <- x);
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (x \in d => z[x] = F)   BECAUSE TI2;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => Domain(z) = d /\ Domain(b) = d   BECAUSE CIA;
Domain(z) = d /\ Domain(b) = d => Domain(z) = Domain(b)   BECAUSE E_SCHEME;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => Domain(z) = Domain(b)   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (x \in d => z[x] = F) /\ (x \in d => b[x] = F)   BECAUSE CIA;
pullHypo(h,a,b,c) == (h => (a => b) /\ (a => c)) => (h /\ a => b /\ c)   PROPO_TAUTO;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) /\ x \in d => z[x] = F /\ b[x] = F   BECAUSE pullHypo;
z[x] = F /\ b[x] = F => z[x] = b[x]   BECAUSE E_SCHEME;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) /\ x \in d => z[x] = b[x]   BECAUSE TI;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (x \in d => z[x] = b[x])   BECAUSE HypoAndToImpl;
\A i : \A j : i = j => ((x \in i => z[x] = b[x]) <=> (x \in j => z[x] = b[x]))   BECAUSE E_SCHEME;
Domain(z) = d => ((x \in Domain(z) => z[x] = b[x]) <=> (x \in d => z[x] = b[x]))   BECAUSE \A(i <- Domain(z), j <- d);
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => ((x \in Domain(z) => z[x] = b[x]) <=> (x \in d => z[x] = b[x]))   BECAUSE TI;
implyEquivTrue(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (x \in Domain(z) => z[x] = b[x])   BECAUSE implyEquivTrue;
\A x : (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => (x \in Domain(z) => z[x] = b[x])   BECAUSE GENERALIZATION;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))
   => (\A x : x \in Domain(z) => z[x] = b[x])   BECAUSE Q_SCHEME;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))
   => IsFunction(z) /\ IsFunction(b)   BECAUSE CIA;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))
   => IsFunction(z) /\ IsFunction(b) /\ Domain(z) = Domain(b)   BECAUSE CIA;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))
   => IsFunction(z) /\ IsFunction(b) /\ Domain(z) = Domain(b) /\ (\A x : x \in Domain(z) => z[x] = b[x])   BECAUSE CIA;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) /\ (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)) => z = b   BECAUSE TI;

(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)))   BECAUSE HIE;
\A z : (\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)))   BECAUSE GENERALIZATION;
(\A x : x \in d => F \in i) /\ (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F)))   BECAUSE Q_SCHEME;

\* Discharge b
(\A x : x \in d => F \in i) => ((\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE HypoAndToImpl;
\A b : (\A x : x \in d => F \in i) => ((\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE GENERALIZATION;
(\A x : x \in d => F \in i) => (\A b : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))
   => (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))) => (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))
   => ((\E b : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))) => \E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE Q_SCHEME;
(\A x : x \in d => F \in i) => ((\E b : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x)))) => \E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE TI;
(\A x : x \in d => F \in i)
   => (\E b : (\A x : x \in b <=> x \in d \X i /\ snd(x) = F(x <- fst(x))))   BECAUSE PT1;
(\A x : x \in d => F \in i) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE KillMiddleHypo;
\A d : \A i : (\A x : x \in d => F \in i) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = F))))   BECAUSE GENERALIZATION;
QED

(*
   The identity function on a domain d. It takes each element
   of the domain and simply returns it.
*)
identity(d) == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsFunction(z) /\ Domain(z) = d /\ \A x : x \in d => z[x] = x

identityIsFunc == \A d : IsFunction(identity(d)) /\ Domain(identity(d)) = d
   /\ \A x : x \in d => identity(d)[x] = x
THEOREM identityIsFunc
PROOF
VARIABLES a,b,c,d,f,i,j,x,y,z;
\A d : \A i : (\A x : x \in d => x \in i) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = x))))
   BECAUSE MACRO separationFunc(F <- x);
(\A x : x \in d => x \in d) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = x))))
   BECAUSE \A(d <- d, i <- d);
x \in d => x \in d   BECAUSE ImplySelf;
\A x : x \in d => x \in d   BECAUSE GENERALIZATION;
\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = x)))   BECAUSE MODUS_PONENS;
\A z : z = identity(d) <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = x))   BECAUSE CHOOSE identity(d);
identity(d) = identity(d) <=> (IsFunction(identity(d)) /\ Domain(identity(d)) = d /\ (\A x : x \in d => identity(d)[x] = x))   BECAUSE \A(z <- identity(d));
equalSelf   BECAUSE THEOREM;
identity(d) = identity(d)   BECAUSE \A(a <- identity(d));
(IsFunction(identity(d)) /\ Domain(identity(d)) = d /\ (\A x : x \in d => identity(d)[x] = x))   BECAUSE MODUS_PONENS;
identityIsFunc   BECAUSE GENERALIZATION;
QED

identityBiject == \A d : identity(d) \in Bijections(d,d)
THEOREM identityBiject
PROOF
VARIABLES a,b,c,d,f,g,i,j,x,y,z;
\* Prove IsInjection(identity(d))
identityIsFunc   BECAUSE THEOREM;
IsFunction(identity(d)) /\ Domain(identity(d)) = d /\ \A x : x \in d => identity(d)[x] = x
   BECAUSE \A(d <- d);
IsFunction(identity(d))   BECAUSE S13;
Domain(identity(d)) = d   BECAUSE S23;
\A x : x \in d => identity(d)[x] = x   BECAUSE S22;
a \in d => identity(d)[a] = a   BECAUSE \A(x <- a);
funcVal   BECAUSE THEOREM;
IsFunction(identity(d)) /\ <<a,b>> \in identity(d) => b = identity(d)[a]
   BECAUSE \A(f <- identity(d), x <- a, y <- b);
<<a,b>> \in identity(d) => IsFunction(identity(d)) /\ <<a,b>> \in identity(d)   BECAUSE IntroAndRight;
<<a,b>> \in identity(d) => b = identity(d)[a]   BECAUSE TI;
domainExists   BECAUSE THEOREM;
a \in Domain(identity(d)) <=> IsDefinedOn(identity(d),a)   BECAUSE \A(g <- identity(d), x <- a);
IsDefinedOn(identity(d),a) => a \in Domain(identity(d))   BECAUSE EquivToImplReverse;
<<a,b>> \in identity(d) => IsDefinedOn(identity(d),a)   BECAUSE \E(y <- b);
\A c : \A d : c = d => (a \in c <=> a \in d)   BECAUSE E_SCHEME;
Domain(identity(d)) = d => (a \in Domain(identity(d)) <=> a \in d)   BECAUSE \A(c <- Domain(identity(d)), d <- d);
a \in Domain(identity(d)) <=> a \in d   BECAUSE MODUS_PONENS;
a \in Domain(identity(d)) => a \in d   BECAUSE EquivToImpl;
<<a,b>> \in identity(d) => a \in d   BECAUSE TI2;
identity(d)[a] = a => a = identity(d)[a]   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => a = identity(d)[a]   BECAUSE TI2;
<<a,b>> \in identity(d) => b = identity(d)[a] /\ a = identity(d)[a]   BECAUSE CIA;
b = identity(d)[a] /\ a = identity(d)[a] => b = a   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => b = a   BECAUSE TI;

(\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE CHOOSE pre(f,y);
\A f : \A y : (\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE GENERALIZATION;
(\E x : <<x,b>> \in identity(d)) => <<pre(identity(d),b), b>> \in identity(d)   BECAUSE \A(f <- identity(d), y <- b);
<<a,b>> \in identity(d) => (\E x : <<x,b>> \in identity(d))   BECAUSE \E(x <- a);
\A a : <<a,b>> \in identity(d) => b = a   BECAUSE GENERALIZATION;
<<pre(identity(d),b), b>> \in identity(d) => b = pre(identity(d), b)   BECAUSE \A(a <- pre(identity(d), b));
<<a,b>> \in identity(d) => b = pre(identity(d),b)   BECAUSE TI2;
<<a,b>> \in identity(d) => b = a /\ b = pre(identity(d),b)   BECAUSE CIA;
b = a /\ b = pre(identity(d),b) => a = pre(identity(d),b)   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => a = pre(identity(d),b)   BECAUSE TI;
\A a : \A b : <<a,b>> \in identity(d) => a = pre(identity(d),b)   BECAUSE GENERALIZATION;
IsInjection(identity(d))   BECAUSE IntroAndRight;

\* Prove domain and image are d
Domain(identity(d)) = d   BECAUSE S23;

imageExists   BECAUSE THEOREM;
z \in Image(identity(d)) <=> Reaches(identity(d),z)   BECAUSE \A(g <- identity(d), y <- z);
z \in Image(identity(d)) => \E x : <<x,z>> \in identity(d)   BECAUSE EquivToImpl;
\A a : \A b : <<a,b>> \in identity(d) => b = a   BECAUSE GENERALIZATION;
<<x,z>> \in identity(d) => z = x   BECAUSE \A(a <- x, b <- z);
\A a : \A b : <<a,b>> \in identity(d) => a \in d   BECAUSE GENERALIZATION;
<<x,z>> \in identity(d) => x \in d   BECAUSE \A(a <- x, b <- z);
\A z : \A x : z = x => (z \in d <=> x \in d)   BECAUSE E_SCHEME;
z = x => (z \in d <=> x \in d)   BECAUSE \A(z <- z, x <- x);
<<x,z>> \in identity(d) => (z \in d <=> x \in d)   BECAUSE TI;
implyEquivTrue(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
<<x,z>> \in identity(d) => z \in d   BECAUSE implyEquivTrue;
(\E x : <<x,z>> \in identity(d)) => \E x : z \in d   BECAUSE Q_SCHEME;
(\E x : z \in d) => z \in d   BECAUSE Q_SCHEME;
z \in Image(identity(d)) => z \in d   BECAUSE TI2;
Image(identity(d)) \subseteq d   BECAUSE GENERALIZATION;
funcImageExists   BECAUSE THEOREM;
IsFunction(identity(d)) /\ z \in Domain(identity(d))
   => <<z, identity(d)[z]>> \in identity(d)   BECAUSE \A(f <- identity(d), x <- z);
z \in Domain(identity(d)) => IsFunction(identity(d)) /\ z \in Domain(identity(d))   BECAUSE IntroAndRight;
z \in Domain(identity(d)) => <<z, identity(d)[z]>> \in identity(d)   BECAUSE TI;
\A a : a \in Domain(identity(d)) <=> a \in d   BECAUSE GENERALIZATION;
z \in Domain(identity(d)) <=> z \in d   BECAUSE \A(a <- z);
z \in d => z \in Domain(identity(d))   BECAUSE EquivToImplReverse;
z \in d => <<z, identity(d)[z]>> \in identity(d)   BECAUSE TI;
z \in d => identity(d)[z] = z   BECAUSE \A(x <- z);
identity(d)[z] = z => z = identity(d)[z]   BECAUSE E_SCHEME;
z \in d => z = identity(d)[z]   BECAUSE TI;
\A a : \A b : a = b => (<<z, a>> \in identity(d) <=> <<z, b>> \in identity(d))   BECAUSE E_SCHEME;
z = identity(d)[z] => (<<z, z>> \in identity(d) <=> <<z, identity(d)[z]>> \in identity(d))   BECAUSE \A(a <- z, b <- identity(d)[z]);
z \in d => (<<z, z>> \in identity(d) <=> <<z, identity(d)[z]>> \in identity(d))   BECAUSE TI;
z \in d => <<z, z>> \in identity(d)   BECAUSE implyEquivTrue;
(\E x : <<x,z>> \in identity(d)) => z \in Image(identity(d))   BECAUSE EquivToImplReverse;
<<z, z>> \in identity(d) => (\E x : <<x,z>> \in identity(d))   BECAUSE \E(x <- z);
z \in d => z \in Image(identity(d))   BECAUSE TI2;
d \subseteq Image(identity(d))   BECAUSE GENERALIZATION;
bothInclusions   BECAUSE THEOREM;
(Image(identity(d)) \subseteq d /\ d \subseteq Image(identity(d))) => Image(identity(d)) = d
   BECAUSE \A(a <- Image(identity(d)), b <- d);
Image(identity(d)) \subseteq d /\ d \subseteq Image(identity(d))   BECAUSE IntroAndRight;
Image(identity(d)) = d   BECAUSE MODUS_PONENS;

IsInjection(identity(d)) /\ Domain(identity(d)) = d   BECAUSE IntroAndRight;
IsInjection(identity(d)) /\ Domain(identity(d)) = d /\ Image(identity(d)) = d   BECAUSE IntroAndRight;
bijectionsExists   BECAUSE THEOREM;
identity(d) \in Bijections(d,d) <=> IsInjection(identity(d)) /\ Domain(identity(d)) = d /\ Image(identity(d)) = d   BECAUSE \A(d <- d, i <- d, f <- identity(d));
identity(d) \in Bijections(d,d)   BECAUSE MODUS_PONENS;
identityBiject   BECAUSE GENERALIZATION;
QED

(*
   The constant function on a domain d, that returns c.
*)
const(d,k) == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsFunction(z) /\ Domain(z) = d /\ \A x : x \in d => z[x] = k

constExists == \A d : \A k : IsFunction(const(d,k)) /\ Domain(const(d,k)) = d
   /\ \A x : x \in d => const(d,k)[x] = k
THEOREM constExists
PROOF
VARIABLES a,b,c,d,f,i,k,x,z;
\A d : \A i : (\A x : x \in d => k \in i) =>
   (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = k))))
   BECAUSE MACRO separationFunc(F <- k);
(\A x : x \in d => k \in {k}) =>
   (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = k))))   BECAUSE \A(d <- d, i <- {k});
singletonExists   BECAUSE THEOREM;
k \in { k } <=> k = k   BECAUSE \A(a <- k, x <- k);
k = k => k \in { k }   BECAUSE EquivToImplReverse;
equalSelf   BECAUSE THEOREM;
k = k   BECAUSE \A(a <- k);
k \in { k }   BECAUSE MODUS_PONENS;
x \in d => k \in { k }   BECAUSE PT1;
\A x : x \in d => k \in { k }   BECAUSE GENERALIZATION;
\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = k)))   BECAUSE MODUS_PONENS;
\A z : z = const(d,k) <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = k))   BECAUSE CHOOSE const(d,k);
const(d,k) = const(d,k) <=> (IsFunction(const(d,k)) /\ Domain(const(d,k)) = d /\ (\A x : x \in d => const(d,k)[x] = k))   BECAUSE \A(z <- const(d,k));
equalSelf   BECAUSE THEOREM;
const(d,k) = const(d,k)   BECAUSE \A(a <- const(d,k));
(IsFunction(const(d,k)) /\ Domain(const(d,k)) = d /\ (\A x : x \in d => const(d,k)[x] = k))   BECAUSE MODUS_PONENS;
constExists   BECAUSE GENERALIZATION;
QED

(*
   We have not finished with the strange properties of the empty set :
   it is a function, something dynamic that receives input and
   produces output. Except it receives nothing and produces nothing.
   It is even an injection.   
*)
emptyFunction == IsInjection({})
THEOREM emptyFunction
PROOF
VARIABLES a,b,c,x;
emptySetExists   BECAUSE THEOREM;
x \notin {}   BECAUSE \A(x <- x);
x \in {} => IsCouple(x)   BECAUSE Explosion;
IsGraph({})   BECAUSE GENERALIZATION;
<<a,b>> \notin {}   BECAUSE \A(x <- <<a,b>>);
<<a,b>> \in {} /\ <<a,c>> \in {} => <<a,b>> \in {}   BECAUSE S12;
<<a,b>> \in {} => b = c   BECAUSE Explosion;
<<a,b>> \in {} /\ <<a,c>> \in {} => b = c   BECAUSE TI;
\A a : \A b : \A c : <<a,b>> \in {} /\ <<a,c>> \in {} => b = c   BECAUSE GENERALIZATION;
IsFunction({})   BECAUSE IntroAndRight;
<<a,b>> \in {} => a = pre({},b)   BECAUSE Explosion;
\A a : \A b : <<a,b>> \in {} => a = pre({},b)   BECAUSE GENERALIZATION;
emptyFunction   BECAUSE IntroAndRight;
QED

(*
singletonFunc(a,b) == { <<a,b>> }
singletonFuncIsFunction == \A a : \A b :
   IsFunction(singletonFunc(a,b)) /\ Domain(singletonFunc(a,b)) = {a}
   /\ singletonFunc(a,b)[a] = b
THEOREM singletonFuncIsFunction
PROOF
\* TODO
singletonFuncIsFunction   BECAUSE GENERALIZATION;
QED

(*
   This theorem allows to define functions by cases. For example the absolute
   value on the real numbers is x when x >= 0 and -x when x < 0.
* )
unionFunc == \A f : \A g : IsFunction(f) /\ IsFunction(g) /\ AreDisjoint(Domain(f),Domain(g))
   => IsFunction(f \union g) /\ Domain(f \union g) = Domain(f) \union Domain(g)
      /\ (\A x : x \in Domain(f) => (f \union g)[x] = f[x])
      /\ (\A x : x \in Domain(g) => (f \union g)[x] = g[x])
THEOREM unionFunc
PROOF
\* TODO
unionFunc   BECAUSE GENERALIZATION;
QED
*)

funcUniqueImage == \A f : \A x : \A y :
   (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y
THEOREM funcUniqueImage
PROOF
VARIABLES a,b,f,g,x,y;
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
(\E x : <<x,y>> \in f) => <<pre(f,y),y>> \in f   BECAUSE CHOOSE pre(f,y);
y \in Image(f) => Reaches(f,y)   BECAUSE EquivToImpl;
y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE TI;
\A y : y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE GENERALIZATION;
x \in Image(f) => <<pre(f,x),x>> \in f   BECAUSE \A(y <- x);
(x \in Image(f) /\ y \in Image(f)) => (<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE MergeImplicationsAnd;
pre(f,x) = pre(f,y) => pre(f,x) = pre(f,y)   BECAUSE ImplySelf;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f /\ pre(f,x) = pre(f,y))   BECAUSE MergeImplicationsAnd;
\A a : \A b : a = b => (<<a,x>> \in f <=> <<b,x>> \in f)   BECAUSE E_SCHEME;
pre(f,x) = pre(f,y) => (<<pre(f,x),x>> \in f <=> <<pre(f,y),x>> \in f)   BECAUSE \A(a <- pre(f,x), b <- pre(f,y));
(pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f) => <<pre(f,y),x>> \in f   BECAUSE HypoEquivToAnd;
(<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f /\ pre(f,x) = pre(f,y))
   => (pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE AndCycle;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE TI;
<<pre(f,y),y>> \in f => <<pre(f,y),y>> \in f   BECAUSE ImplySelf;
(pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f) => (<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE MergeImplicationsAnd;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE TI;

funcVal   BECAUSE THEOREM;
IsFunction(f) /\ <<pre(f,y),y>> \in f => y = f[pre(f,y)]   BECAUSE \A(f <- f, x <- pre(f,y), y <- y);
IsFunction(f) => (<<pre(f,y),y>> \in f => y = f[pre(f,y)])   BECAUSE HypoAndToImpl;
IsFunction(f) /\ <<pre(f,y),x>> \in f => x = f[pre(f,y)]   BECAUSE \A(f <- f, x <- pre(f,y), y <- x);
IsFunction(f) => (<<pre(f,y),x>> \in f => x = f[pre(f,y)])   BECAUSE HypoAndToImpl;
IsFunction(f) => ((<<pre(f,y),x>> \in f => x = f[pre(f,y)]) /\ (<<pre(f,y),y>> \in f => y = f[pre(f,y)]))
   BECAUSE CIA;
((<<pre(f,y),x>> \in f => x = f[pre(f,y)]) /\ (<<pre(f,y),y>> \in f => y = f[pre(f,y)]))
   => ((<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE MergeImplicationsAnd2;
IsFunction(f) => ((<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE TI;
(<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (IsFunction(f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE SwitchHypos;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (IsFunction(f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))
   => (x = f[pre(f,y)] /\ y = f[pre(f,y)])   BECAUSE HypoImplToAnd;
(x = f[pre(f,y)] /\ y = f[pre(f,y)]) => x = y   BECAUSE E_SCHEME;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE TI;
funcUniqueImage   BECAUSE GENERALIZATION;
QED

multiInjection == \A f : \A multiX : \A y :
   IsInjection(f) => (y \in multiApply(f, multiX) <=> (y \in Image(f) /\ pre(f,y) \in multiX))
THEOREM multiInjection
PROOF
VARIABLES a,b,f,g,u,x,y,multiX;
multiApplyExists   BECAUSE THEOREM;
y \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,y>> \in f
   BECAUSE \A(f <- f, multiX <- multiX, x <- y);

\* Proof of (y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX) 
(\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE CHOOSE pre(f,y);
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
y \in Image(f) => Reaches(f,y)   BECAUSE EquivToImpl;
y \in Image(f) => <<pre(f,y), y>> \in f   BECAUSE TI;
pre(f,y) \in multiX => pre(f,y) \in multiX   BECAUSE ImplySelf;
(y \in Image(f) /\ pre(f,y) \in multiX) => (<<pre(f,y), y>> \in f /\ pre(f,y) \in multiX)
   BECAUSE MergeImplicationsAnd;
(<<pre(f,y), y>> \in f /\ pre(f,y) \in multiX) => (pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f)   BECAUSE AndSymmetry;
(y \in Image(f) /\ pre(f,y) \in multiX) => (pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f)   BECAUSE TI;
(pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f) => \E u : u \in multiX /\ <<u,y>> \in f   BECAUSE \E(u <- pre(f,y));
(\E u : u \in multiX /\ <<u,y>> \in f) => y \in multiApply(f,multiX)   BECAUSE EquivToImplReverse;
(pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f) => y \in multiApply(f,multiX)   BECAUSE TI;
(y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX)   BECAUSE TI;
IsInjection(f) => ((y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX))   BECAUSE PT1;

\* Converse
chooseU(f,y,multiX) == CHOOSE u : u \in multiX /\ <<u,y>> \in f;
(\E u : u \in multiX /\ <<u,y>> \in f)
   => (chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)   BECAUSE CHOOSE chooseU(f,y,multiX);
y \in multiApply(f,multiX) => (\E u : u \in multiX /\ <<u,y>> \in f)
   BECAUSE EquivToImpl;
y \in multiApply(f,multiX) => (chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)   BECAUSE TI;
(chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f) => <<chooseU(f,y,multiX),y>> \in f   BECAUSE S22;
y \in multiApply(f,multiX) => <<chooseU(f,y,multiX),y>> \in f   BECAUSE TI;
imageInc   BECAUSE THEOREM;
<<chooseU(f,y,multiX),y>> \in f => y \in Image(f)   BECAUSE \A(g <- f, x <- chooseU(f,y,multiX), y <- y);
y \in multiApply(f,multiX) => y \in Image(f)   BECAUSE TI;

IsInjection(f) => \A a : \A b : <<a,b>> \in f => a = pre(f,b)   BECAUSE S22;
(\A a : \A b : <<a,b>> \in f => a = pre(f,b)) => (<<chooseU(f,y,multiX),y>> \in f => chooseU(f,y,multiX) = pre(f,y))
   BECAUSE \A(a <- chooseU(f,y,multiX), b <- y);
IsInjection(f) => (<<chooseU(f,y,multiX),y>> \in f => chooseU(f,y,multiX) = pre(f,y))    BECAUSE TI;
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f) => chooseU(f,y,multiX) = pre(f,y)    BECAUSE HypoImplToAnd;
\A x : \A y : x = y => (x \in multiX <=> y \in multiX)    BECAUSE E_SCHEME;
(chooseU(f,y,multiX) = pre(f,y)) => (chooseU(f,y,multiX) \in multiX <=> pre(f,y) \in multiX)    BECAUSE \A(x <- chooseU(f,y,multiX), y <- pre(f,y));
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f) => (chooseU(f,y,multiX) \in multiX <=> pre(f,y) \in multiX)    BECAUSE TI;
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)
   => pre(f,y) \in multiX   BECAUSE HypoEquivToAnd;
(IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))
   => (IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE AssocAndLeft;
(IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))
   => pre(f,y) \in multiX   BECAUSE TI;
(chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)
   => (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE AndSymmetry;
y \in multiApply(f,multiX) => (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE TI;
IsInjection(f) => IsInjection(f)   BECAUSE ImplySelf;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => (IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))   BECAUSE MergeImplicationsAnd;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => pre(f,y) \in multiX   BECAUSE TI;
IsInjection(f) => (y \in multiApply(f,multiX) => y \in Image(f))   BECAUSE PT1;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => y \in Image(f)   BECAUSE HypoImplToAnd;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => (y \in Image(f) /\ pre(f,y) \in multiX)   BECAUSE CIA;
IsInjection(f) => (y \in multiApply(f,multiX) => (y \in Image(f) /\ pre(f,y) \in multiX))   BECAUSE HypoAndToImpl;
IsInjection(f) => (y \in multiApply(f,multiX) <=> (y \in Image(f) /\ pre(f,y) \in multiX))   BECAUSE HypoIntroEquiv;
multiInjection   BECAUSE GENERALIZATION;
QED

bijApply == \A f : \A a : \A b : \A x : (f \in Bijections(a,b) /\ x \in a) => f[x] \in b
THEOREM bijApply
PROOF
VARIABLES a,b,c,d,f,g,i,x,y;
funcImageExists   BECAUSE THEOREM;
IsFunction(f) /\ x \in Domain(f) => <<x, f[x]>> \in f   BECAUSE \A(f <- f, x <- x);
<<x, y>> \in f => Reaches(f,y)   BECAUSE \E(x <- x);
\A y : <<x, y>> \in f => Reaches(f,y)   BECAUSE GENERALIZATION;
<<x, f[x]>> \in f => Reaches(f,f[x])   BECAUSE \A(y <- f[x]);
imageExists   BECAUSE THEOREM;
f[x] \in Image(f) <=> Reaches(f,f[x])   BECAUSE \A(g <- f, y <- f[x]);
Reaches(f,f[x]) => f[x] \in Image(f)   BECAUSE EquivToImplReverse;
IsFunction(f) /\ x \in Domain(f) => f[x] \in Image(f)   BECAUSE TI2;
\A a : \A b : \A c : \A d : a = b /\ c = d
   => ((IsFunction(f) /\ x \in a => f[x] \in c) <=> (IsFunction(f) /\ x \in b => f[x] \in d))   BECAUSE E_SCHEME;
Domain(f) = a /\ Image(f) = b => ((IsFunction(f) /\ x \in Domain(f) => f[x] \in Image(f)) <=> (IsFunction(f) /\ x \in a => f[x] \in b))
   BECAUSE \A(a <- Domain(f), b <- a, c <- Image(f), d <- b);
   implyTrueEquiv(h,t,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
Domain(f) = a /\ Image(f) = b => (IsFunction(f) /\ x \in a => f[x] \in b)   BECAUSE implyTrueEquiv;
bijectionsExists   BECAUSE THEOREM;
f \in Bijections(a,b) <=> IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE \A(d <- a, i <- b, f <- f);
f \in Bijections(a,b) => IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE EquivToImpl;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => IsInjection(f)   BECAUSE S13;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Domain(f) = a   BECAUSE S23;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Image(f) = b   BECAUSE S22;
f \in Bijections(a,b) => Domain(f) = a   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b   BECAUSE TI;
f \in Bijections(a,b) => Domain(f) = a /\ Image(f) = b   BECAUSE CIA;
f \in Bijections(a,b) => (IsFunction(f) /\ x \in a => f[x] \in b)   BECAUSE TI;
IsInjection(f) => IsFunction(f)   BECAUSE S12;
f \in Bijections(a,b) => IsFunction(f)   BECAUSE TI2;
f \in Bijections(a,b) /\ x \in a => f \in Bijections(a,b)   BECAUSE S12;
f \in Bijections(a,b) /\ x \in a => IsFunction(f)   BECAUSE TI;
f \in Bijections(a,b) /\ x \in a => x \in a   BECAUSE S22;
f \in Bijections(a,b) /\ x \in a => (IsFunction(f) /\ x \in a => f[x] \in b)   BECAUSE TI;
f \in Bijections(a,b) /\ x \in a => IsFunction(f) /\ x \in a   BECAUSE CIA;
f \in Bijections(a,b) /\ x \in a => f[x] \in b   BECAUSE KillMiddleHypo;
bijApply   BECAUSE GENERALIZATION;
QED

bijPreApply == \A f : \A a : \A b : \A y : (f \in Bijections(a,b) /\ y \in b) => pre(f,y) \in a
THEOREM bijPreApply
PROOF
VARIABLES a,b,c,d,f,i,x,y;
domainInc2   BECAUSE THEOREM;
y \in Image(f) => pre(f,y) \in Domain(f)   BECAUSE \A(f <- f, y <- y);
\A a : \A b : \A c : \A d : a = b /\ c = d => ((y \in a => pre(f,y) \in c) <=> (y \in b => pre(f,y) \in d))   BECAUSE E_SCHEME;
Image(f) = b /\ Domain(f) = a => ((y \in Image(f) => pre(f,y) \in Domain(f)) <=> (y \in b => pre(f,y) \in a))
   BECAUSE \A(a <- Image(f), b <- b, c <- Domain(f), d <- a);
implyTrueEquiv(h,t,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
Image(f) = b /\ Domain(f) = a => (y \in b => pre(f,y) \in a)   BECAUSE implyTrueEquiv;
bijectionsExists   BECAUSE THEOREM;
f \in Bijections(a,b) <=> IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE \A(d <- a, i <- b, f <- f);
f \in Bijections(a,b) => IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE EquivToImpl;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Domain(f) = a   BECAUSE S23;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Image(f) = b   BECAUSE S22;
f \in Bijections(a,b) => Domain(f) = a   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b /\ Domain(f) = a   BECAUSE CIA;
f \in Bijections(a,b) => (y \in b => pre(f,y) \in a)   BECAUSE TI;
f \in Bijections(a,b) /\ y \in b => pre(f,y) \in a   BECAUSE HypoImplToAnd;
bijPreApply   BECAUSE GENERALIZATION;
QED


(*
   Functions between cartesian products.
*)

\* Two functions called in parallel
IsParallelApply(f,g,x) == IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
   /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g
parallelFunc(f,g) == CHOOSE h : \A x : x \in h <=> \* x = << <<a, b>>, <<f[a], g[b]>> >>
  IsParallelApply(f,g,x)

parallelFuncExists == \A f : \A g : (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x))
THEOREM parallelFuncExists
PROOF
VARIABLES a,b,c,f,g,h,x,y;
\* By separation in (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsParallelApply(f,g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(a <- (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)));

\* Take one such b
chooseB(f,g) == CHOOSE b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x));
(\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x)))
   => (\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x)))   BECAUSE CHOOSE chooseB(f,g);
\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE MODUS_PONENS;
x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(x <- x);

\* Stage x
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
\A x : \A y : x = y => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> y \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE E_SCHEME;
x = <<fst(x), snd(x)>> => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE \A(x <- x, y <- <<fst(x), snd(x)>>);
IsCouple(x) => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE TI;
(IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))   BECAUSE HypoEquivToAndReverse;
cartesianProductCouples   BECAUSE THEOREM;
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE \A(x <- (Domain(f) \X Domain(g)), y <- (Image(f) \X Image(g)), a <- fst(x), b <- snd(x));
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   => <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE EquivToImpl;
IsCouple(x) => IsCouple(x)   BECAUSE ImplySelf;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => (IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE MergeImplicationsAnd;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TI;

\* Prove that IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))
IsCouple(fst(x)) => fst(x) = <<fst(fst(x)), snd(fst(x))>>   BECAUSE \A(c <- fst(x));
\A x : \A y : x = y => (x \in (Domain(f) \X Domain(g)) <=> y \in (Domain(f) \X Domain(g)))   BECAUSE E_SCHEME;
fst(x) = <<fst(fst(x)), snd(fst(x))>> => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE \A(x <- fst(x), y <- <<fst(fst(x)), snd(fst(x))>>);
IsCouple(fst(x)) => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE TI;
(IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE HypoEquivToAndReverse;
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE \A(x <- Domain(f), y <- Domain(g), a <- fst(fst(x)), b <- snd(fst(x)));
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   => <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE EquivToImpl;
IsCouple(fst(x)) => IsCouple(fst(x))   BECAUSE ImplySelf;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => (IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)))   BECAUSE S14;
(IsCouple(x) /\ IsCouple(fst(x))) => IsCouple(fst(x))   BECAUSE S22;
IsParallelApply(f,g,x) => IsCouple(fst(x))   BECAUSE TI;
IsParallelApply(f,g,x) => <<fst(fst(x)), fst(snd(x)) >> \in f   BECAUSE S23;
domainInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(fst(x)) \in Domain(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(fst(x)) \in Domain(f)   BECAUSE TI;
IsParallelApply(f,g,x) => <<snd(fst(x)), snd(snd(x)) >> \in g   BECAUSE S22;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(fst(x)) \in Domain(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(fst(x)) \in Domain(g)   BECAUSE TI;
IsParallelApply(f,g,x) => (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))   BECAUSE CIA;
IsParallelApply(f,g,x) => (IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))   BECAUSE CIA;
IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TI;

\* Prove that IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))
IsCouple(snd(x)) => snd(x) = <<fst(snd(x)), snd(snd(x))>>   BECAUSE \A(c <- snd(x));
\A x : \A y : x = y => (x \in (Image(f) \X Image(g)) <=> y \in (Image(f) \X Image(g)))   BECAUSE E_SCHEME;
snd(x) = <<fst(snd(x)), snd(snd(x))>> => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE \A(x <- snd(x), y <- <<fst(snd(x)), snd(snd(x))>>);
IsCouple(snd(x)) => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE TI;
(IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE HypoEquivToAndReverse;
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE \A(x <- Image(f), y <- Image(g), a <- fst(snd(x)), b <- snd(snd(x)));
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   => <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE EquivToImpl;
IsCouple(snd(x)) => IsCouple(snd(x))   BECAUSE ImplySelf;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => (IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x)))   BECAUSE S13;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(snd(x))   BECAUSE S22;
IsParallelApply(f,g,x) => IsCouple(snd(x))   BECAUSE TI;
imageInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(snd(x)) \in Image(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(snd(x)) \in Image(f)   BECAUSE TI;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(snd(x)) \in Image(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(snd(x)) \in Image(g)   BECAUSE TI;
IsParallelApply(f,g,x) => (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))   BECAUSE CIA;
IsParallelApply(f,g,x) => (IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))   BECAUSE CIA;
IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   BECAUSE CIA;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(x)   BECAUSE S13;
IsParallelApply(f,g,x) => IsCouple(x)   BECAUSE TI;
IsParallelApply(f,g,x) => (IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))   BECAUSE CIA;
IsParallelApply(f,g,x) => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TI;

x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE SeparationTauto;
\A x : x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE GENERALIZATION;
\E h : \A x : x \in h <=> IsParallelApply(f,g,x)   BECAUSE \E(h <- chooseB(f,g));
(\E h : \A x : x \in h <=> IsParallelApply(f,g,x)) => (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)) 
   BECAUSE CHOOSE parallelFunc(f,g);
\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)   BECAUSE MODUS_PONENS;
parallelFuncExists   BECAUSE GENERALIZATION;
QED


\* The function x \in d |-> <<x, x>>
clone(d) == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsFunction(z) /\ Domain(z) = d /\ \A x : x \in d => z[x] = <<x,x>>
cloneExists == \A d : IsFunction(clone(d)) /\ Domain(clone(d)) = d /\ (\A x : x \in d => clone(d)[x] = <<x,x>>)
THEOREM cloneExists
PROOF
VARIABLES a,b,c,d,f,i,j,x,y,z;
\A d : \A i : (\A x : x \in d => <<x,x>> \in i) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<x,x>>))))
   BECAUSE MACRO separationFunc(F <- <<x,x>>);
(\A x : x \in d => <<x,x>> \in d \X d) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<x,x>>))))
   BECAUSE \A(d <- d, i <- d \X d);
cartesianProductCouples   BECAUSE THEOREM;
(x \in d /\ x \in d) <=> <<x,x>> \in d \X d   BECAUSE \A(x <- d, y <- d, a <- x, b <- x);
(x \in d /\ x \in d) => <<x,x>> \in d \X d   BECAUSE EquivToImpl;
x \in d => x \in d /\ x \in d   BECAUSE AndSelf;
x \in d => <<x,x>> \in d \X d   BECAUSE TI;
\A x : x \in d => <<x,x>> \in d \X d   BECAUSE GENERALIZATION;
\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<x,x>>)))   BECAUSE MODUS_PONENS;
\A z : z = clone(d) <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<x,x>>))   BECAUSE CHOOSE clone(d);
clone(d) = clone(d) <=> (IsFunction(clone(d)) /\ Domain(clone(d)) = d /\ (\A x : x \in d => clone(d)[x] = <<x,x>>))   BECAUSE \A(z <- clone(d));
equalSelf   BECAUSE THEOREM;
clone(d) = clone(d)   BECAUSE \A(a <- clone(d));
IsFunction(clone(d)) /\ Domain(clone(d)) = d /\ (\A x : x \in d => clone(d)[x] = <<x,x>>)   BECAUSE MODUS_PONENS;
cloneExists   BECAUSE GENERALIZATION;
QED

\* Cartesian product of two functions
productFunc(g,h) == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h)
   /\ \A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>

productFuncIsFunc == \A g : \A h : IsFunction(g) /\ IsFunction(h) =>
   IsFunction(productFunc(g,h)) /\ Domain(productFunc(g,h)) = Domain(g) \intersect Domain(h)
   /\ \A x : x \in Domain(g) \intersect Domain(h) => productFunc(g,h)[x] = <<g[x],h[x]>>
THEOREM productFuncIsFunc
PROOF
VARIABLES a,b,c,d,f,g,h,i,j,x,y,z;
\A d : \A i : (\A x : x \in d => <<g[x],h[x]>> \in i)
   => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<g[x],h[x]>>))))
   BECAUSE MACRO separationFunc(F <- <<g[x],h[x]>>);
(\A x : x \in Domain(g) \intersect Domain(h) => <<g[x],h[x]>> \in Image(g) \X Image(h))
   => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>))))
   BECAUSE \A(d <- Domain(g) \intersect Domain(h), i <- Image(g) \X Image(h));
cartesianProductCouples   BECAUSE THEOREM;
(g[x] \in Image(g) /\ h[x] \in Image(h)) <=> <<g[x],h[x]>> \in Image(g) \X Image(h)   BECAUSE \A(x <- Image(g), y <- Image(h), a <- g[x], b <- h[x]);
(g[x] \in Image(g) /\ h[x] \in Image(h)) => <<g[x],h[x]>> \in Image(g) \X Image(h)   BECAUSE EquivToImpl;
funcImageExists   BECAUSE THEOREM;
IsFunction(g) /\ x \in Domain(g) => <<x, g[x]>> \in g   BECAUSE \A(f <- g, x <- x);
imageExists   BECAUSE THEOREM;
g[x] \in Image(g) <=> Reaches(g,g[x])   BECAUSE \A(g <- g, y <- g[x]);
Reaches(g,g[x]) => g[x] \in Image(g)   BECAUSE EquivToImplReverse;
<<x, y>> \in g => Reaches(g,y)   BECAUSE \E(x <- x);
\A y : <<x, y>> \in g => Reaches(g,y)   BECAUSE GENERALIZATION;
<<x, g[x]>> \in g => Reaches(g,g[x])   BECAUSE \A(y <- g[x]);
IsFunction(g) /\ x \in Domain(g) => g[x] \in Image(g)   BECAUSE TI2;
\A g : IsFunction(g) /\ x \in Domain(g) => g[x] \in Image(g)   BECAUSE GENERALIZATION;
IsFunction(h) /\ x \in Domain(h) => h[x] \in Image(h)   BECAUSE \A(g <- h);
(IsFunction(g) /\ x \in Domain(g)) /\ (IsFunction(h) /\ x \in Domain(h))
   => g[x] \in Image(g) /\ h[x] \in Image(h)   BECAUSE MergeImplicationsAnd;
(IsFunction(g) /\ x \in Domain(g)) /\ (IsFunction(h) /\ x \in Domain(h))
   => <<g[x],h[x]>> \in Image(g) \X Image(h)   BECAUSE TI;
intersectionExists   BECAUSE THEOREM;
x \in (Domain(g) \intersect Domain(h))
   <=> (x \in Domain(g) /\ x \in Domain(h))   BECAUSE \A(u <- Domain(g), v <- Domain(h), x <- x);
x \in (Domain(g) \intersect Domain(h)) => x \in Domain(g) /\ x \in Domain(h)   BECAUSE EquivToImpl;
hyp(g,h,x) == IsFunction(g) /\ IsFunction(h) /\ x \in (Domain(g) \intersect Domain(h));
hyp(g,h,x) => x \in (Domain(g) \intersect Domain(h))   BECAUSE S22;
hyp(g,h,x) => x \in Domain(g) /\ x \in Domain(h)   BECAUSE TI;
x \in Domain(g) /\ x \in Domain(h) => x \in Domain(g)   BECAUSE S12;
x \in Domain(g) /\ x \in Domain(h) => x \in Domain(h)   BECAUSE S22;
hyp(g,h,x) => x \in Domain(g)   BECAUSE TI;
hyp(g,h,x) => x \in Domain(h)   BECAUSE TI;
hyp(g,h,x) => IsFunction(g)   BECAUSE S13;
hyp(g,h,x) => IsFunction(h)   BECAUSE S23;
hyp(g,h,x) => IsFunction(g) /\ x \in Domain(g)   BECAUSE CIA;
hyp(g,h,x) => IsFunction(h) /\ x \in Domain(h)   BECAUSE CIA;
hyp(g,h,x) => (IsFunction(g) /\ x \in Domain(g)) /\ (IsFunction(h) /\ x \in Domain(h))   BECAUSE CIA;
hyp(g,h,x) => <<g[x],h[x]>> \in Image(g) \X Image(h)   BECAUSE TI;
IsFunction(g) /\ IsFunction(h)
   => (x \in (Domain(g) \intersect Domain(h)) => <<g[x],h[x]>> \in Image(g) \X Image(h))   BECAUSE HypoAndToImpl;
\A x : IsFunction(g) /\ IsFunction(h)
   => (x \in (Domain(g) \intersect Domain(h)) => <<g[x],h[x]>> \in Image(g) \X Image(h))   BECAUSE GENERALIZATION;
IsFunction(g) /\ IsFunction(h)
   => (\A x : x \in (Domain(g) \intersect Domain(h)) => <<g[x],h[x]>> \in Image(g) \X Image(h))   BECAUSE Q_SCHEME;
IsFunction(g) /\ IsFunction(h) => (\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>))))   BECAUSE TI;
(\E b : (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>)))) => ((\A z : z = productFunc(g,h) <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>))))   BECAUSE CHOOSE productFunc(g,h);

(\A z : z = productFunc(g,h) <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>))) => (productFunc(g,h) = productFunc(g,h) <=> (IsFunction(productFunc(g,h)) /\ Domain(productFunc(g,h)) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => productFunc(g,h)[x] = <<g[x],h[x]>>)))
   BECAUSE \A(z <- productFunc(g,h));
IsFunction(g) /\ IsFunction(h) => (productFunc(g,h) = productFunc(g,h) <=> (IsFunction(productFunc(g,h)) /\ Domain(productFunc(g,h)) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => productFunc(g,h)[x] = <<g[x],h[x]>>)))
   BECAUSE TI2;
equalSelf   BECAUSE THEOREM;
productFunc(g,h) = productFunc(g,h)   BECAUSE \A(a <- productFunc(g,h));
killMiddleHypo(h,a,t) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
IsFunction(g) /\ IsFunction(h) => IsFunction(productFunc(g,h)) /\ Domain(productFunc(g,h)) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => productFunc(g,h)[x] = <<g[x],h[x]>>)   BECAUSE killMiddleHypo;
productFuncIsFunc   BECAUSE GENERALIZATION;
QED

(*
   Proof that CHOOSE combined with axiom schemes is not always a conservative extension.
   This proof introduces the symbol Choice(p) == CHOOSE z : z \in p
   and uses it inside the separation axiom scheme, to prove the axiom of choice.
   
   For this reason CHOOSE symbols are forbidden in axiom schemes, CHOOSE_UNIQUE
   must be used instead.
*)
choiceFunctionsExist == \A a : \E f : IsFunction(f)
  /\ \A p : p \subseteq a /\ p # {} => f[p] \in p
THEOREM choiceFunctionsExist
PROOF
VARIABLES a,b,c,f,i,j,p,x,y,z;
\* By separation in (SUBSET a \ {}) \X a, prove cf(a) is a graph
Choice(p) == CHOOSE z : z \in p;
\A a : \E b : \A x : x \in b <=> x \in a /\ snd(x) = Choice(fst(x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE \A(a <- (SUBSET a) \X a);
cf(a) == CHOOSE b : \A x : x \in b <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x));
\A x : x \in cf(a) <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE CHOOSE cf(a);
x \in cf(a) <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE \A(x <- x);
x \in cf(a) => x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE EquivToImpl;
x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x)) => x \in (SUBSET a) \X a   BECAUSE S12;
x \in cf(a) => x \in (SUBSET a) \X a   BECAUSE TI;
cartesianProductExists   BECAUSE THEOREM;
x \in (SUBSET a) \X a <=> (IsCouple(x) /\ fst(x) \in (SUBSET a) /\ snd(x) \in a)   BECAUSE \A(i <- SUBSET a, j <- a, x <- x);
x \in (SUBSET a) \X a => (IsCouple(x) /\ fst(x) \in (SUBSET a) /\ snd(x) \in a)   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in (SUBSET a) /\ snd(x) \in a) => IsCouple(x)   BECAUSE S13;
x \in cf(a) => IsCouple(x)   BECAUSE TI2;
IsGraph(cf(a))   BECAUSE GENERALIZATION;

\* Prove cf(a) is a function
x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x)) => snd(x) = Choice(fst(x))   BECAUSE S22;
x \in cf(a) => snd(x) = Choice(fst(x))   BECAUSE TI;
\A x : \A a : x \in cf(a) => snd(x) = Choice(fst(x))   BECAUSE GENERALIZATION;
<<a,b>> \in cf(z) => snd(<<a,b>>) = Choice(fst(<<a,b>>))   BECAUSE \A(x <- <<a,b>>, a <- z);
\A x : \A a : \A z : \A b : x = a /\ z = b => (x = Choice(z) <=> a = Choice(b))   BECAUSE E_SCHEME;
b = snd(<<a,b>>) /\ a = fst(<<a,b>>) => (b = Choice(a) <=> snd(<<a,b>>) = Choice(fst(<<a,b>>)))   BECAUSE \A(x <- b, a <- snd(<<a,b>>), z <- a, b <- fst(<<a,b>>));
fstExists   BECAUSE THEOREM;
a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
sndExists   BECAUSE THEOREM;
b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
b = snd(<<a,b>>) /\ a = fst(<<a,b>>)   BECAUSE IntroAndRight;
b = Choice(a) <=> snd(<<a,b>>) = Choice(fst(<<a,b>>))   BECAUSE MODUS_PONENS;
snd(<<a,b>>) = Choice(fst(<<a,b>>)) => b = Choice(a)   BECAUSE EquivToImplReverse;
<<a,b>> \in cf(z) => b = Choice(a)   BECAUSE TI;
\A b : <<a,b>> \in cf(z) => b = Choice(a)   BECAUSE GENERALIZATION;
<<a,c>> \in cf(z) => c = Choice(a)   BECAUSE \A(b <- c);
<<a,b>> \in cf(z) /\ <<a,c>> \in cf(z) => b = Choice(a) /\ c = Choice(a)   BECAUSE MergeImplicationsAnd;
b = Choice(a) /\ c = Choice(a) => b = c   BECAUSE E_SCHEME;
<<a,b>> \in cf(z) /\ <<a,c>> \in cf(z) => b = c   BECAUSE TI;
\A a : \A b : \A c : <<a,b>> \in cf(z) /\ <<a,c>> \in cf(z) => b = c   BECAUSE GENERALIZATION;
\A a : IsGraph(cf(a))   BECAUSE GENERALIZATION;
IsGraph(cf(z))   BECAUSE \A(a <- z);
IsFunction(cf(z))   BECAUSE IntroAndRight;
\A z : IsFunction(cf(z))   BECAUSE GENERALIZATION;
IsFunction(cf(a))   BECAUSE \A(z <- a);

\* Prove cf(a)[p] \in p
h(a,p) == p \subseteq a /\ p # {};
<<p,Choice(p)>> \in cf(a) <=> <<p,Choice(p)>> \in (SUBSET a) \X a /\ snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE \A(x <- <<p,Choice(p)>>);
<<p,Choice(p)>> \in (SUBSET a) \X a /\ snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>)) => <<p,Choice(p)>> \in cf(a)   BECAUSE EquivToImplReverse;
h(a,p) => p # {}   BECAUSE S22;
notEmpty   BECAUSE THEOREM;
p # {} => \E z : z \in p   BECAUSE \A(x <- p);
(\E z : z \in p) => Choice(p) \in p   BECAUSE CHOOSE Choice(p);
h(a,p) => Choice(p) \in p   BECAUSE TI2;
h(a,p) => p \subseteq a   BECAUSE S12;
p \subseteq a => (Choice(p) \in p => Choice(p) \in a)   BECAUSE \A(z <- Choice(p));
h(a,p) => (Choice(p) \in p => Choice(p) \in a)   BECAUSE TI;
h(a,p) => Choice(p) \in a   BECAUSE KillMiddleHypo;
powersetExists   BECAUSE AXIOM;
p \in SUBSET a <=> p \subseteq a   BECAUSE \A(x <- a, z <- p);
p \subseteq a => p \in SUBSET a   BECAUSE EquivToImplReverse;
h(a,p) => p \in SUBSET a   BECAUSE TI;
h(a,p) => p \in SUBSET a /\ Choice(p) \in a   BECAUSE CIA;
cartesianProductCouples   BECAUSE THEOREM;
(p \in SUBSET a /\ Choice(p) \in a) <=> <<p,Choice(p)>> \in (SUBSET a) \X a   BECAUSE \A(x <- SUBSET a, y <- a, a <- p, b <- Choice(p));
p \in SUBSET a /\ Choice(p) \in a => <<p,Choice(p)>> \in (SUBSET a) \X a   BECAUSE EquivToImpl;
h(a,p) => <<p,Choice(p)>> \in (SUBSET a) \X a   BECAUSE TI;
\A a : \A b : b = Choice(a) <=> snd(<<a,b>>) = Choice(fst(<<a,b>>))   BECAUSE GENERALIZATION;
Choice(p) = Choice(p) <=> snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE \A(a <- p, b <- Choice(p));
equalSelf   BECAUSE THEOREM;
Choice(p) = Choice(p)   BECAUSE \A(a <- Choice(p));
snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE MODUS_PONENS;
<<p,Choice(p)>> \in (SUBSET a) \X a => <<p,Choice(p)>> \in (SUBSET a) \X a /\ snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE IntroAndLeft;
h(a,p) => <<p,Choice(p)>> \in cf(a)   BECAUSE TI2;
funcVal   BECAUSE THEOREM;
IsFunction(cf(z)) /\ <<p,Choice(p)>> \in cf(z) => Choice(p) = cf(z)[p]   BECAUSE \A(f <- cf(z), x <- p, y <- Choice(p));
<<p,Choice(p)>> \in cf(z) => IsFunction(cf(z)) /\ <<p,Choice(p)>> \in cf(z)   BECAUSE IntroAndRight;
<<p,Choice(p)>> \in cf(z) => Choice(p) = cf(z)[p]   BECAUSE TI;
\A z : <<p,Choice(p)>> \in cf(z) => Choice(p) = cf(z)[p]   BECAUSE GENERALIZATION;
<<p,Choice(p)>> \in cf(a) => Choice(p) = cf(a)[p]   BECAUSE \A(z <- a);
h(a,p) => Choice(p) = cf(a)[p]   BECAUSE TI;
\A x : \A y : x = y => (x \in p <=> y \in p)   BECAUSE E_SCHEME;
Choice(p) = cf(a)[p] => (Choice(p) \in p <=> cf(a)[p] \in p)   BECAUSE \A(x <- Choice(p), y <- cf(a)[p]);
h(a,p) => (Choice(p) \in p <=> cf(a)[p] \in p)   BECAUSE TI;
(Choice(p) \in p <=> cf(a)[p] \in p) => (Choice(p) \in p => cf(a)[p] \in p)   BECAUSE EquivToImpl;
h(a,p) => (Choice(p) \in p => cf(a)[p] \in p)   BECAUSE TI;
h(a,p) => cf(a)[p] \in p   BECAUSE KillMiddleHypo;
\A p : h(a,p) => cf(a)[p] \in p   BECAUSE GENERALIZATION;
IsFunction(cf(a)) /\ \A p : h(a,p) => cf(a)[p] \in p   BECAUSE IntroAndRight;
\E f : IsFunction(f) /\ \A p : p \subseteq a /\ p # {} => f[p] \in p   BECAUSE \E(f <- cf(a));
choiceFunctionsExist   BECAUSE GENERALIZATION;
QED