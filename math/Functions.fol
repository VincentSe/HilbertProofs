(*
   The class of functions : graphs that have at most one output for each
   input. A function as a set represents a computation, like addition
   or multiplication, something that always produces the same output
   when given the same input.

   The function application operator f[x] is defined, as well as its
   reverse operator pre(f,x).
*)

EXTENDS ZFC

IsFunction(f) == IsGraph(f)  /\  \A a : \A b : <<a,b>> \in f => b = f[a]
IsInjection(f) == IsFunction(f)  /\  \A a : \A b : <<a,b>> \in f => a = pre(f,b)

(*
   A bijection is an equivalence between two sets, a one-to-one correspondence
   between elements of each set.
*)
Bijections(d, i) == CHOOSE b : \A f : f \in b <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i
bijectionsExists == \A d : \A i : \A f : f \in Bijections(d,i) <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i
THEOREM bijectionsExists
PROOF
\* By separation in SUBSET (d \X i)
VARIABLES a,b,c,d,f,g,i,x,y,z;
\A a : \E b : \A x : x \in b <=> x \in a /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i)   BECAUSE \A(a <- SUBSET (d \X i));
powersetExists   BECAUSE AXIOM;
x \in SUBSET (d \X i) <=> x \subseteq (d \X i)   BECAUSE \A(x <- d \X i, z <- x);
x \subseteq (d \X i) => x \in SUBSET (d \X i)   BECAUSE EquivToImplReverse;

h(d,i,x,z) == IsInjection(x) /\ Domain(x) = d /\ Image(x) = i /\ z \in x; \* Prove that z \in d \X i
h(d,i,x,z) => h(d,i,x,z)   BECAUSE ImplySelf;
h(d,i,x,z) => IsInjection(x)   BECAUSE DropAndRight3;
IsInjection(x) => IsFunction(x)   BECAUSE DropAndRight;
IsFunction(x) => IsGraph(x)   BECAUSE DropAndRight;
h(d,i,x,z) => IsFunction(x)   BECAUSE TI;
h(d,i,x,z) => IsGraph(x)   BECAUSE TI;
IsGraph(a) => (z \in a => IsCouple(z))   BECAUSE \A(x <- z);
\A a : IsGraph(a) => (z \in a => IsCouple(z))   BECAUSE GENERALIZATION;
IsGraph(x) => (z \in x => IsCouple(z))   BECAUSE \A(a <- x);
IsGraph(x) /\ z \in x => IsCouple(z)   BECAUSE HypoImplToAnd;
h(d,i,x,z) => z \in x   BECAUSE DropAndLeft;
h(d,i,x,z) => IsGraph(x) /\ z \in x   BECAUSE CIA;
h(d,i,x,z) => IsCouple(z)   BECAUSE TI;
domainExists   BECAUSE THEOREM;
fst(z) \in Domain(x) <=> IsDefinedOn(x,fst(z))   BECAUSE \A(g <- x, x <- fst(z));
(\E y : <<fst(z),y>> \in x) => fst(z) \in Domain(x)   BECAUSE EquivToImplReverse;
tupleComposition   BECAUSE THEOREM;
IsCouple(z) => z = <<fst(z), snd(z)>>   BECAUSE \A(c <- z);
h(d,i,x,z) => z = <<fst(z), snd(z)>>   BECAUSE TI;
<<fst(z), snd(z)>> \in x => (\E y : <<fst(z),y>> \in x)   BECAUSE \E(y <- snd(z));
<<fst(z), snd(z)>> \in x => fst(z) \in Domain(x)   BECAUSE TI;
<<fst(z), snd(z)>> \in x => fst(z) \in Domain(x)   BECAUSE TI;
\A z : \A y : z = y => (z \in x <=> y \in x)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in x <=> <<fst(z), snd(z)>> \in x)   BECAUSE \A(z <- z, y <- <<fst(z), snd(z)>>);
h(d,i,x,z) => (z \in x <=> <<fst(z), snd(z)>> \in x)   BECAUSE TI;
h(d,i,x,z) /\ z \in x => <<fst(z), snd(z)>> \in x   BECAUSE HypoEquivToAnd;
h(d,i,x,z) => h(d,i,x,z) /\ z \in x   BECAUSE CIA;
h(d,i,x,z) => <<fst(z), snd(z)>> \in x   BECAUSE TI;
h(d,i,x,z) => fst(z) \in Domain(x)   BECAUSE TI;

imageExists   BECAUSE THEOREM;
snd(z) \in Image(a) <=> Reaches(a,snd(z))   BECAUSE \A(g <- a, y <- snd(z));
(\E x : <<x,snd(z)>> \in a) => snd(z) \in Image(a)   BECAUSE EquivToImplReverse;
<<fst(z), snd(z)>> \in a => (\E x : <<x,snd(z)>> \in a)   BECAUSE \E(x <- fst(z));
<<fst(z), snd(z)>> \in a => snd(z) \in Image(a)   BECAUSE TI;
\A a : <<fst(z), snd(z)>> \in a => snd(z) \in Image(a)   BECAUSE GENERALIZATION;
<<fst(z), snd(z)>> \in x => snd(z) \in Image(x)   BECAUSE \A(a <- x);
h(d,i,x,z) => snd(z) \in Image(x)   BECAUSE TI;
h(d,i,x,z) => fst(z) \in Domain(x) /\ snd(z) \in Image(x)   BECAUSE CIA;
cartesianProductCouples   BECAUSE THEOREM;
(fst(z) \in Domain(x) /\ snd(z) \in Image(x)) <=> <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))
   BECAUSE \A(x <- Domain(x), y <- Image(x), a <- fst(z), b <- snd(z));
(fst(z) \in Domain(x) /\ snd(z) \in Image(x)) => <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE EquivToImpl;
h(d,i,x,z) => <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE TI;
\A a : \A x : \A b : \A y : \A c : \A z : a = x /\ b = y /\ c = z => (a \in (b \X c) <=> x \in (y \X z))   BECAUSE E_SCHEME;
<<fst(z), snd(z)>> = z /\ Domain(x) = d /\ Image(x) = i => (<<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) <=> z \in (d \X i))
   BECAUSE \A(a <- <<fst(z),snd(z)>>, x <- z, b <- Domain(x), y <- d, c <- Image(x), z <- i);
z = <<fst(z), snd(z)>> => <<fst(z), snd(z)>> = z   BECAUSE E_SCHEME;
h(d,i,x,z) => <<fst(z), snd(z)>> = z   BECAUSE TI;
h(d,i,x,z) => IsInjection(x) /\ Domain(x) = d   BECAUSE DropAndRight2;
IsInjection(x) /\ Domain(x) = d => Domain(x) = d   BECAUSE DropAndLeft;
h(d,i,x,z) => Domain(x) = d   BECAUSE TI;
h(d,i,x,z) => <<fst(z), snd(z)>> = z /\ Domain(x) = d   BECAUSE CIA;
h(d,i,x,z) => Image(x) = i   BECAUSE DropAndBoth;
h(d,i,x,z) => <<fst(z), snd(z)>> = z /\ Domain(x) = d /\ Image(x) = i   BECAUSE CIA;
h(d,i,x,z) => (<<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) <=> z \in (d \X i))   BECAUSE TI;
h(d,i,x,z) /\ <<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) => z \in (d \X i)   BECAUSE HypoEquivToAnd;
h(d,i,x,z) => h(d,i,x,z) /\ <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE CIA;
h(d,i,x,z) => z \in (d \X i)   BECAUSE TI;

IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => (z \in x => z \in (d \X i))   BECAUSE HypoAndToImpl;
\A z : IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => (z \in x => z \in (d \X i))   BECAUSE GENERALIZATION;
IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => x \subseteq (d \X i)   BECAUSE Q_SCHEME;
IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => x \in SUBSET (d \X i)   BECAUSE TI;
(x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))   BECAUSE SeparationTauto;
(\A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))   BECAUSE Q_SCHEME;
(\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE \A(x <- f);
\A f : (\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE GENERALIZATION;
(\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE Q_SCHEME;
(\A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE TI;
(\E b : \A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\E b : \A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE Q_SCHEME;
\E b : \A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i)   BECAUSE MODUS_PONENS;
\A f : f \in Bijections(d,i) <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i   BECAUSE CHOOSE Bijections(d,i);
bijectionsExists   BECAUSE GENERALIZATION;
QED

funcInversePre == \A f : \A y : IsFunction(f) /\ y \in Image(f) => f[pre(f,y)] = y
THEOREM funcInversePre
PROOF
VARIABLES a,b,f,g,y;
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
y \in Image(f) => \E x : <<x,y>> \in f   BECAUSE EquivToImpl;
(\E x : <<x,y>> \in f) => <<pre(f,y),y>> \in f   BECAUSE CHOOSE pre(f,y);
y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE TI;
IsFunction(f) => \A a : \A b : <<a,b>> \in f => b = f[a]   BECAUSE DropAndLeft;
(\A a : \A b : <<a,b>> \in f => b = f[a]) => (<<pre(f,y),y>> \in f => y = f[pre(f,y)])
   BECAUSE \A(a <- pre(f,y), b <- y);
IsFunction(f) => (<<pre(f,y),y>> \in f => y = f[pre(f,y)])   BECAUSE TI;
IsFunction(f) /\ <<pre(f,y),y>> \in f => y = f[pre(f,y)]   BECAUSE HypoImplToAnd;
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
IsFunction(f) /\ y \in Image(f) => IsFunction(f) /\ <<pre(f,y),y>> \in f   BECAUSE MergeImplicationsAnd;
IsFunction(f) /\ y \in Image(f) => y = f[pre(f,y)]   BECAUSE TI;
y = f[pre(f,y)] => f[pre(f,y)] = y   BECAUSE E_SCHEME;
IsFunction(f) /\ y \in Image(f) => f[pre(f,y)] = y   BECAUSE TI;
funcInversePre   BECAUSE GENERALIZATION;
QED

funcEqual == \A f : \A g : IsFunction(f) /\ IsFunction(g) /\ Domain(f) = Domain(g)
   /\ (\A x : x \in Domain(f) => f[x] = g[x])
   => f = g
THEOREM funcEqual
PROOF
funcEqual   BECAUSE GENERALIZATION;
QED

(*
   The identity function on a domain d. It takes each element
   of the domain and simply returns it.
*)
identity(d) == CHOOSE b : \A x : x \in b <=>
   x \in d \X d /\ fst(x) = snd(x)

identityExists == \A d : \A x : x \in identity(d) <=>
   x \in d \X d /\ fst(x) = snd(x)
THEOREM identityExists
PROOF
\* By separation in d \X d
VARIABLES a,b,d,x,y;
\A a : \E b : \A x : x \in b <=> x \in a /\ fst(x) = snd(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in d \X d /\ fst(x) = snd(x)   BECAUSE \A(a <- d \X d);
\A x : x \in identity(d) <=> x \in d \X d /\ fst(x) = snd(x)   BECAUSE CHOOSE identity(d);
identityExists   BECAUSE GENERALIZATION;
QED

identityVal == \A d : \A x : x \in d => (identity(d)[x] = x /\ pre(identity(d),x) = x)
THEOREM identityVal
PROOF
VARIABLES a,b,d,x,y;
\* Proof that \A x : x \in d => <<x,x>> \in identity(d)
identityExists   BECAUSE THEOREM;
<<x,x>> \in identity(d) <=> <<x,x>> \in d \X d /\ fst(<<x,x>>) = snd(<<x,x>>)
   BECAUSE \A(d <- d, x <- <<x,x>>);
<<x,x>> \in d \X d /\ fst(<<x,x>>) = snd(<<x,x>>) => <<x,x>> \in identity(d)
   BECAUSE EquivToImplReverse;
fstExists   BECAUSE THEOREM;
x = fst(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
sndExists   BECAUSE THEOREM;
x = snd(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
x = fst(<<x,x>>) /\ x = snd(<<x,x>>) => fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE E_SCHEME;
x = fst(<<x,x>>) /\ x = snd(<<x,x>>)   BECAUSE IntroAndRight;
fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE MODUS_PONENS;
cartesianProductCouples   BECAUSE THEOREM;
x \in d /\ x \in d <=> <<x,x>> \in d \X d   BECAUSE \A(x <- d, y <- d, a <- x, b <- x);
x \in d /\ x \in d => <<x,x>> \in d \X d   BECAUSE EquivToImpl;
x \in d => x \in d /\ x \in d   BECAUSE AndSelf;
x \in d => <<x,x>> \in d \X d   BECAUSE TI;
<<x,x>> \in d \X d => <<x,x>> \in d \X d /\ fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE IntroAndLeft;
x \in d => <<x,x>> \in d \X d /\ fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE TI;
x \in d => <<x,x>> \in identity(d)   BECAUSE TI;

\* Proof that x = identity(d)[x]
<<x,x>> \in identity(d) => \E y : <<x,y>> \in identity(d)   BECAUSE \E(y <- x);
x \in d => \E y : <<x,y>> \in identity(d)   BECAUSE TI;
(\E y : <<x,y>> \in identity(d)) => <<x,identity(d)[x]>> \in identity(d)   BECAUSE CHOOSE identity(d)[x];
x \in d => <<x,identity(d)[x]>> \in identity(d)   BECAUSE TI;
<<x,identity(d)[x]>> \in identity(d) <=> <<x,identity(d)[x]>> \in d \X d /\ fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)
   BECAUSE \A(d <- d, x <- <<x,identity(d)[x]>>);
<<x,identity(d)[x]>> \in identity(d) => <<x,identity(d)[x]>> \in d \X d /\ fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)
   BECAUSE EquivToImpl;
<<x,identity(d)[x]>> \in d \X d /\ fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)
 => fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)   BECAUSE DropAndLeft;
<<x,identity(d)[x]>> \in identity(d) => fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)   BECAUSE TI;
x \in d => fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)   BECAUSE TI;
x = fst(<<x,identity(d)[x]>>)   BECAUSE \A(a <- x, b <- identity(d)[x]);
identity(d)[x] = snd(<<x,identity(d)[x]>>)   BECAUSE \A(a <- x, b <- identity(d)[x]);
\A x : \A y : \A a : \A b : (x = y /\ a = b) => (x = a <=> y = b)   BECAUSE E_SCHEME;
(x = fst(<<x,identity(d)[x]>>) /\ identity(d)[x] = snd(<<x,identity(d)[x]>>))
   => (x = identity(d)[x] <=> fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>))
   BECAUSE \A(x <- x, y <- fst(<<x,identity(d)[x]>>), a <- identity(d)[x], b <- snd(<<x,identity(d)[x]>>));
x = fst(<<x,identity(d)[x]>>) /\ identity(d)[x] = snd(<<x,identity(d)[x]>>)   BECAUSE IntroAndRight;
x = identity(d)[x] <=> fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>)   BECAUSE MODUS_PONENS;
fst(<<x,identity(d)[x]>>) = snd(<<x,identity(d)[x]>>) => x = identity(d)[x]   BECAUSE EquivToImplReverse;
x \in d => x = identity(d)[x]   BECAUSE TI;
x = identity(d)[x] => identity(d)[x] = x   BECAUSE E_SCHEME;
x \in d => identity(d)[x] = x   BECAUSE TI;

\* Proof that x = pre(identity(d),x)
<<y,y>> \in identity(d) => \E x : <<x,y>> \in identity(d)   BECAUSE \E(x <- y);
\A x : x \in d => <<x,x>> \in identity(d)   BECAUSE GENERALIZATION;
y \in d => <<y,y>> \in identity(d)   BECAUSE \A(x <- y);
y \in d => \E x : <<x,y>> \in identity(d)   BECAUSE TI;
(\E x : <<x,y>> \in identity(d)) => <<pre(identity(d),y), y>> \in identity(d)   BECAUSE CHOOSE pre(identity(d),y);
y \in d => <<pre(identity(d),y),y>> \in identity(d)   BECAUSE TI;
<<pre(identity(d),y),y>> \in identity(d) <=> <<pre(identity(d),y),y>> \in d \X d /\ fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>)
   BECAUSE \A(d <- d, x <- <<pre(identity(d),y),y>>);
<<pre(identity(d),y),y>> \in identity(d) => <<pre(identity(d),y),y>> \in d \X d /\ fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>)
   BECAUSE EquivToImpl;
<<pre(identity(d),y),y>> \in d \X d /\ fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>) => fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>)   BECAUSE DropAndLeft;
<<pre(identity(d),y),y>> \in identity(d) => fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>)   BECAUSE TI;
y \in d => fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>)   BECAUSE TI;
y = snd(<<pre(identity(d),y),y>>)   BECAUSE \A(a <- pre(identity(d),y), b <- y);
pre(identity(d),y) = fst(<<pre(identity(d),y),y>>)   BECAUSE \A(a <- pre(identity(d),y), b <- y);
(pre(identity(d),y) = fst(<<pre(identity(d),y),y>>) /\ y = snd(<<pre(identity(d),y),y>>))
   => (pre(identity(d),y) = y <=> fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>))
   BECAUSE \A(x <- pre(identity(d),y), y <- fst(<<pre(identity(d),y),y>>), a <- y, b <- snd(<<pre(identity(d),y),y>>));
pre(identity(d),y) = fst(<<pre(identity(d),y),y>>) /\ y = snd(<<pre(identity(d),y),y>>)   BECAUSE IntroAndLeft;
pre(identity(d),y) = y <=> fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>)   BECAUSE MODUS_PONENS;
fst(<<pre(identity(d),y),y>>) = snd(<<pre(identity(d),y),y>>) => pre(identity(d),y) = y   BECAUSE EquivToImplReverse;
y \in d => pre(identity(d),y) = y   BECAUSE TI;
\A y : y \in d => pre(identity(d),y) = y   BECAUSE GENERALIZATION;
x \in d => pre(identity(d),x) = x   BECAUSE \A(y <- x);
x \in d => (identity(d)[x] = x /\ pre(identity(d),x) = x)   BECAUSE CIA;
identityVal   BECAUSE GENERALIZATION;
QED

identityBiject == \A d : identity(d) \in Bijections(d,d)
THEOREM identityBiject
PROOF
VARIABLES a,b,d,f,g,i,j,x,y;
identityExists   BECAUSE THEOREM;
x \in identity(d) <=> x \in (d \X d) /\ fst(x) = snd(x)   BECAUSE \A(d <- d, x <- x);
x \in identity(d) => x \in (d \X d) /\ fst(x) = snd(x)   BECAUSE EquivToImpl;
x \in (d \X d) /\ fst(x) = snd(x) => x \in (d \X d)   BECAUSE DropAndRight;
x \in identity(d) => x \in (d \X d)   BECAUSE TI;
cartesianProductExists   BECAUSE THEOREM;
x \in (d \X d) <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) \in d)   BECAUSE \A(i <- d, j <- d, x <- x);
x \in (d \X d) => (IsCouple(x) /\ fst(x) \in d /\ snd(x) \in d)   BECAUSE EquivToImpl;
IsCouple(x) /\ fst(x) \in d /\ snd(x) \in d => IsCouple(x)   BECAUSE DropAndRight2;
x \in (d \X d) => IsCouple(x)   BECAUSE TI;
x \in identity(d) => IsCouple(x)   BECAUSE TI;
IsGraph(identity(d))   BECAUSE GENERALIZATION;

\* Prove IsFunction(identity(d))
<<a,b>> \in identity(d) <=> (<<a,b>> \in (d \X d) /\ fst(<<a,b>>) = snd(<<a,b>>))   BECAUSE \A(d <- d, x <- <<a,b>>);
<<a,b>> \in identity(d) => (<<a,b>> \in (d \X d) /\ fst(<<a,b>>) = snd(<<a,b>>))   BECAUSE EquivToImpl;
(<<a,b>> \in (d \X d) /\ fst(<<a,b>>) = snd(<<a,b>>)) => fst(<<a,b>>) = snd(<<a,b>>)   BECAUSE DropAndLeft;
<<a,b>> \in identity(d) => fst(<<a,b>>) = snd(<<a,b>>)   BECAUSE TI;
fstExists   BECAUSE THEOREM;
a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
sndExists   BECAUSE THEOREM;
b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
\A a : \A x : \A b : \A y : (a = x /\ b = y) => (a = b <=> x = y)   BECAUSE E_SCHEME;
(a = fst(<<a,b>>) /\ b = snd(<<a,b>>)) => (a = b <=> fst(<<a,b>>) = snd(<<a,b>>))
   BECAUSE \A(a <- a, x <- fst(<<a,b>>), b <- b, y <- snd(<<a,b>>));
a = fst(<<a,b>>) /\ b = snd(<<a,b>>)   BECAUSE IntroAndRight;
a = b <=> fst(<<a,b>>) = snd(<<a,b>>)   BECAUSE MODUS_PONENS;
fst(<<a,b>>) = snd(<<a,b>>) => a = b   BECAUSE EquivToImplReverse;
<<a,b>> \in identity(d) => a = b   BECAUSE TI;
identityVal   BECAUSE THEOREM;
a \in d => (identity(d)[a] = a /\ pre(identity(d),a) = a)   BECAUSE \A(d <- d, x <- a);
(identity(d)[a] = a /\ pre(identity(d),a) = a) => identity(d)[a] = a   BECAUSE DropAndRight;
a \in d => identity(d)[a] = a   BECAUSE TI;
identity(d)[a] = a => a = identity(d)[a]   BECAUSE E_SCHEME;
a \in d => a = identity(d)[a]   BECAUSE TI;
(<<a,b>> \in (d \X d) /\ fst(<<a,b>>) = snd(<<a,b>>)) => <<a,b>> \in (d \X d)   BECAUSE DropAndRight;
<<a,b>> \in identity(d) => <<a,b>> \in (d \X d)   BECAUSE TI;
cartesianProductCouples   BECAUSE THEOREM;
(a \in d /\ b \in d) <=> <<a,b>> \in (d \X d)   BECAUSE \A(x <- d, y <- d, a <- a, b <- b);
<<a,b>> \in (d \X d) => (a \in d /\ b \in d)   BECAUSE EquivToImplReverse;
<<a,b>> \in identity(d) => (a \in d /\ b \in d)   BECAUSE TI;
(a \in d /\ b \in d) => a \in d   BECAUSE DropAndRight;
<<a,b>> \in identity(d) => a \in d   BECAUSE TI;
<<a,b>> \in identity(d) => a = identity(d)[a]   BECAUSE TI;
<<a,b>> \in identity(d) => (a = b /\ a = identity(d)[a])   BECAUSE CIA;
(a = b /\ a = identity(d)[a]) => b = identity(d)[a]   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => b = identity(d)[a]   BECAUSE TI;
\A a : \A b : <<a,b>> \in identity(d) => b = identity(d)[a]   BECAUSE GENERALIZATION;
IsFunction(identity(d))   BECAUSE IntroAndRight;

\* Prove IsInjection(identity(d))
(identity(d)[a] = a /\ pre(identity(d),a) = a) => pre(identity(d),a) = a   BECAUSE DropAndLeft;
a \in d => pre(identity(d),a) = a   BECAUSE TI;
\A a : \A b : a = b => pre(identity(d),a) = pre(identity(d),b)   BECAUSE E_SCHEME;
a = b => pre(identity(d),a) = pre(identity(d),b)   BECAUSE \A(a <- a, b <- b);
<<a,b>> \in identity(d) => pre(identity(d),a) = pre(identity(d),b)   BECAUSE TI;
<<a,b>> \in identity(d) => pre(identity(d),a) = a   BECAUSE TI;
<<a,b>> \in identity(d) => (pre(identity(d),a) = pre(identity(d),b) /\ pre(identity(d),a) = a)   BECAUSE CIA;
(pre(identity(d),a) = pre(identity(d),b) /\ pre(identity(d),a) = a) => pre(identity(d),b) = a   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => pre(identity(d),b) = a   BECAUSE TI;
pre(identity(d),b) = a => a = pre(identity(d),b)   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => a = pre(identity(d),b)   BECAUSE TI;
\A a : \A b : <<a,b>> \in identity(d) => a = pre(identity(d),b)   BECAUSE GENERALIZATION;
IsInjection(identity(d))   BECAUSE IntroAndRight;

\* Prove domain and image are d
domainExists   BECAUSE THEOREM;
x \in Domain(identity(d)) <=> IsDefinedOn(identity(d),x)   BECAUSE \A(g <- identity(d), x <- x);
\A a : \A b : <<a,b>> \in identity(d) => a \in d   BECAUSE GENERALIZATION;
<<x,y>> \in identity(d) => x \in d   BECAUSE \A(a <- x, b <- y);
IsDefinedOn(identity(d),x) => \E y : x \in d   BECAUSE Q_SCHEME;
(\E y : x \in d) => x \in d   BECAUSE Q_SCHEME;
IsDefinedOn(identity(d),x) => x \in d   BECAUSE TI;
(x \in d /\ x \in d) <=> <<x,x>> \in (d \X d)   BECAUSE \A(x <- d, y <- d, a <- x, b <- x);
(x \in d /\ x \in d) => <<x,x>> \in (d \X d)   BECAUSE EquivToImpl;
x \in d => (x \in d /\ x \in d)   BECAUSE AndSelf;
x \in d => <<x,x>> \in (d \X d)   BECAUSE TI;
\A a : \A b : a = b <=> fst(<<a,b>>) = snd(<<a,b>>)   BECAUSE GENERALIZATION;
x = x <=> fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
x = x => fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE EquivToImpl;
equalSelf   BECAUSE THEOREM;
x = x   BECAUSE \A(a <- x);
fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE MODUS_PONENS;
<<x,x>> \in (d \X d) => <<x,x>> \in (d \X d) /\ fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE IntroAndLeft;
x \in d => <<x,x>> \in (d \X d) /\ fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE TI;
<<x,x>> \in identity(d) <=> <<x,x>> \in (d \X d) /\ fst(<<x,x>>) = snd(<<x,x>>)   BECAUSE \A(d <- d, x <- <<x,x>>);
<<x,x>> \in (d \X d) /\ fst(<<x,x>>) = snd(<<x,x>>) => <<x,x>> \in identity(d)   BECAUSE EquivToImplReverse;
x \in d => <<x,x>> \in identity(d)   BECAUSE TI;
<<x,x>> \in identity(d) => \E y : <<x,y>> \in identity(d)   BECAUSE \E(y <- x);
x \in d => IsDefinedOn(identity(d),x)   BECAUSE TI;
x \in d <=> IsDefinedOn(identity(d),x)   BECAUSE IntroEquiv;
x \in Domain(identity(d)) <=> x \in d   BECAUSE TransitEquiv2;
\A x : x \in Domain(identity(d)) <=> x \in d   BECAUSE GENERALIZATION;
extensionality   BECAUSE AXIOM;
(\A x : x \in Domain(identity(d)) <=> x \in d) => Domain(identity(d)) = d   BECAUSE \A(a <- Domain(identity(d)), b <- d);
Domain(identity(d)) = d   BECAUSE MODUS_PONENS;

imageExists   BECAUSE THEOREM;
y \in Image(identity(d)) <=> Reaches(identity(d),y)   BECAUSE \A(g <- identity(d), y <- y);
\A a : \A b : <<a,b>> \in identity(d) => (a \in d /\ b \in d)   BECAUSE GENERALIZATION;
<<x,y>> \in identity(d) => (x \in d /\ y \in d)   BECAUSE \A(a <- x, b <- y);
(x \in d /\ y \in d) => y \in d   BECAUSE DropAndLeft;
<<x,y>> \in identity(d) => y \in d   BECAUSE TI;
Reaches(identity(d),y) => \E x : y \in d   BECAUSE Q_SCHEME;
(\E x : y \in d) => y \in d   BECAUSE Q_SCHEME;
Reaches(identity(d),y) => y \in d   BECAUSE TI;
\A x : x \in d => <<x,x>> \in identity(d)   BECAUSE GENERALIZATION;
y \in d => <<y,y>> \in identity(d)   BECAUSE \A(x <- y);
<<y,y>> \in identity(d) => \E x : <<x,y>> \in identity(d)   BECAUSE \E(x <- y);
y \in d => Reaches(identity(d),y)   BECAUSE TI;
y \in d <=> Reaches(identity(d),y)   BECAUSE IntroEquiv;
y \in Image(identity(d)) <=> y \in d   BECAUSE TransitEquiv2;
\A y : y \in Image(identity(d)) <=> y \in d   BECAUSE GENERALIZATION;
x \in Image(identity(d)) <=> x \in d   BECAUSE \A(y <- x);
\A x : x \in Image(identity(d)) <=> x \in d   BECAUSE GENERALIZATION;
(\A x : x \in Image(identity(d)) <=> x \in d) => Image(identity(d)) = d   BECAUSE \A(a <- Image(identity(d)), b <- d);
Image(identity(d)) = d   BECAUSE MODUS_PONENS;
IsInjection(identity(d)) /\ Domain(identity(d)) = d   BECAUSE IntroAndRight;
IsInjection(identity(d)) /\ Domain(identity(d)) = d /\ Image(identity(d)) = d   BECAUSE IntroAndRight;
bijectionsExists   BECAUSE THEOREM;
identity(d) \in Bijections(d,d) <=> IsInjection(identity(d)) /\ Domain(identity(d)) = d /\ Image(identity(d)) = d   BECAUSE \A(d <- d, i <- d, f <- identity(d));
identity(d) \in Bijections(d,d)   BECAUSE MODUS_PONENS;
identityBiject   BECAUSE GENERALIZATION;
QED

(*
   The constant function on a domain d, that returns c.
*)
const(d,c) == CHOOSE b : \A x : x \in b <=>
   (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)

constExists == \A d : \A c : \A x : x \in const(d,c) <=>
   (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)
THEOREM constExists
PROOF
\* By separation in d \X {c}
VARIABLES a,b,c,d,i,j,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))
   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in (d \X {c}) /\ (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))
   BECAUSE \A(a <- d \X {c});
cartesianProductExists   BECAUSE THEOREM;
x \in (d \X {c}) <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) \in {c})
   BECAUSE \A(i <- d, j <- {c}, x <- x);
(IsCouple(x) /\ fst(x) \in d /\ snd(x) \in {c}) => x \in (d \X {c})   BECAUSE EquivToImplReverse;
singletonExists   BECAUSE THEOREM;
snd(x) \in { c } <=> snd(x) = c   BECAUSE \A(a <- c, x <- snd(x));
snd(x) = c => snd(x) \in { c }   BECAUSE EquivToImplReverse;
(IsCouple(x) /\ fst(x) \in d) => (IsCouple(x) /\ fst(x) \in d)   BECAUSE ImplySelf;
(IsCouple(x) /\ fst(x) \in d /\ snd(x) = c) => (IsCouple(x) /\ fst(x) \in d /\ snd(x) \in {c})
   BECAUSE MergeImplicationsAnd;
(IsCouple(x) /\ fst(x) \in d /\ snd(x) = c) => x \in (d \X {c})   BECAUSE TI;
(x \in b <=> (x \in (d \X {c}) /\ (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)))
   => (x \in b <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))   BECAUSE SeparationTauto;
(\A x : x \in b <=> (x \in (d \X {c}) /\ (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)))
   => (\A x : x \in b <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (x \in (d \X {c}) /\ (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)))
   => (\E b : \A x : x \in b <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))   BECAUSE Q_SCHEME;
(\E b : \A x : x \in b <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))   BECAUSE MODUS_PONENS;
(\E b : \A x : x \in b <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))
   => (\A x : x \in const(d,c) <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c))   BECAUSE CHOOSE const(d,c);
\A x : x \in const(d,c) <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)   BECAUSE MODUS_PONENS;
constExists   BECAUSE GENERALIZATION;
QED


constVal == \A d : \A c : \A x : x \in d => const(d,c)[x] = c
THEOREM constVal
PROOF
VARIABLES a,b,c,d,x,y;
\* Proof that \A x : x \in d => <<x,c>> \in const(d,c)
constExists   BECAUSE THEOREM;
<<x,c>> \in const(d,c) <=> (IsCouple(<<x,c>>) /\ fst(<<x,c>>) \in d /\ snd(<<x,c>>) = c)
   BECAUSE \A(d <- d, c <- c, x <- <<x,c>>);
(IsCouple(<<x,c>>) /\ fst(<<x,c>>) \in d /\ snd(<<x,c>>) = c) => <<x,c>> \in const(d,c)
   BECAUSE EquivToImplReverse;
fstExists   BECAUSE THEOREM;
x = fst(<<x,c>>)   BECAUSE \A(a <- x, b <- c);
sndExists   BECAUSE THEOREM;
c = snd(<<x,c>>)   BECAUSE \A(a <- x, b <- c);
c = snd(<<x,c>>) => snd(<<x,c>>) = c   BECAUSE E_SCHEME;
snd(<<x,c>>) = c   BECAUSE MODUS_PONENS;
(IsCouple(<<x,c>>) /\ fst(<<x,c>>) \in d)
   => (IsCouple(<<x,c>>) /\ fst(<<x,c>>) \in d /\ snd(<<x,c>>) = c)   BECAUSE IntroAndLeft;
(IsCouple(<<x,c>>) /\ fst(<<x,c>>) \in d) => <<x,c>> \in const(d,c)   BECAUSE TI;
equalSelf   BECAUSE THEOREM;
<<a,b>> = <<a,b>>   BECAUSE \A(a <- <<a,b>>);
IsCouple(<<a,b>>)   BECAUSE \E(x <- a, y <- b);
\A a : \A b : IsCouple(<<a,b>>)   BECAUSE GENERALIZATION;
IsCouple(<<x,c>>)   BECAUSE \A(a <- x, b <- c);
fst(<<x,c>>) \in d => (IsCouple(<<x,c>>) /\ fst(<<x,c>>) \in d)   BECAUSE IntroAndRight;
fst(<<x,c>>) \in d => <<x,c>> \in const(d,c)   BECAUSE TI;
\A x : \A y : x = y => (x \in d <=> y \in d)   BECAUSE E_SCHEME;
x = fst(<<x,c>>) => (x \in d <=> fst(<<x,c>>) \in d)   BECAUSE \A(x <- x, y <- fst(<<x,c>>));
x \in d <=> fst(<<x,c>>) \in d   BECAUSE MODUS_PONENS;
x \in d => fst(<<x,c>>) \in d   BECAUSE EquivToImpl;
x \in d => <<x,c>> \in const(d,c)   BECAUSE TI;

<<x,c>> \in const(d,c) => \E y : <<x,y>> \in const(d,c)   BECAUSE \E(y <- c);
x \in d => \E y : <<x,y>> \in const(d,c)   BECAUSE TI;
(\E y : <<x,y>> \in const(d,c)) => <<x,const(d,c)[x]>> \in const(d,c)   BECAUSE CHOOSE const(d,c)[x];
x \in d => <<x,const(d,c)[x]>> \in const(d,c)   BECAUSE TI;
<<x,const(d,c)[x]>> \in const(d,c) <=> (IsCouple(<<x,const(d,c)[x]>>) /\ fst(<<x,const(d,c)[x]>>) \in d /\ snd(<<x,const(d,c)[x]>>) = c)
   BECAUSE \A(d <- d, c <- c, x <- <<x,const(d,c)[x]>>);
<<x,const(d,c)[x]>> \in const(d,c) => (IsCouple(<<x,const(d,c)[x]>>) /\ fst(<<x,const(d,c)[x]>>) \in d /\ snd(<<x,const(d,c)[x]>>) = c)
   BECAUSE EquivToImpl;
(IsCouple(<<x,const(d,c)[x]>>) /\ fst(<<x,const(d,c)[x]>>) \in d /\ snd(<<x,const(d,c)[x]>>) = c) => snd(<<x,const(d,c)[x]>>) = c   BECAUSE DropAndLeft;
<<x,const(d,c)[x]>> \in const(d,c) => snd(<<x,const(d,c)[x]>>) = c   BECAUSE TI;
x \in d => snd(<<x,const(d,c)[x]>>) = c   BECAUSE TI;
const(d,c)[x] = snd(<<x,const(d,c)[x]>>)   BECAUSE \A(a <- x, b <- const(d,c)[x]);
const(d,c)[x] = snd(<<x,const(d,c)[x]>>) => snd(<<x,const(d,c)[x]>>) = const(d,c)[x]   BECAUSE E_SCHEME;
snd(<<x,const(d,c)[x]>>) = const(d,c)[x]   BECAUSE MODUS_PONENS;
snd(<<x,const(d,c)[x]>>) = c => (snd(<<x,const(d,c)[x]>>) = const(d,c)[x] /\ snd(<<x,const(d,c)[x]>>) = c)  BECAUSE IntroAndRight;
(snd(<<x,const(d,c)[x]>>) = const(d,c)[x] /\ snd(<<x,const(d,c)[x]>>) = c) => const(d,c)[x] = c   BECAUSE E_SCHEME;
snd(<<x,const(d,c)[x]>>) = c => const(d,c)[x] = c  BECAUSE TI;
x \in d => const(d,c)[x] = c   BECAUSE TI;
constVal   BECAUSE GENERALIZATION;
QED

constFunc == \A d : \A c : IsFunction(const(d,c))
THEOREM constFunc
PROOF
VARIABLES a,b,c,d,x,y;
constExists   BECAUSE THEOREM;
x \in const(d,c) <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)   BECAUSE \A(d <- d, c <- c, x <- x);
x \in const(d,c) => (IsCouple(x) /\ fst(x) \in d /\ snd(x) = c)   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in d /\ snd(x) = c) => IsCouple(x)   BECAUSE DropAndRight2;
x \in const(d,c) => IsCouple(x)   BECAUSE TI;
IsGraph(const(d,c))   BECAUSE GENERALIZATION;

<<a,b>> \in const(d,c) <=> (IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in d /\ snd(<<a,b>>) = c)
   BECAUSE \A(d <- d, c <- c, x <- <<a,b>>);
<<a,b>> \in const(d,c) => (IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in d /\ snd(<<a,b>>) = c)
   BECAUSE EquivToImpl;
(IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in d /\ snd(<<a,b>>) = c) => snd(<<a,b>>) = c   BECAUSE DropAndLeft;
<<a,b>> \in const(d,c) => snd(<<a,b>>) = c   BECAUSE TI;
sndExists   BECAUSE THEOREM;
b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
b = snd(<<a,b>>) => snd(<<a,b>>) = b   BECAUSE E_SCHEME;
snd(<<a,b>>) = b   BECAUSE MODUS_PONENS;
(snd(<<a,b>>) = b /\ snd(<<a,b>>) = c) => b = c   BECAUSE E_SCHEME;
snd(<<a,b>>) = c => (snd(<<a,b>>) = b /\ snd(<<a,b>>) = c)   BECAUSE IntroAndRight;
snd(<<a,b>>) = c => b = c   BECAUSE TI;
<<a,b>> \in const(d,c) => b = c   BECAUSE TI;
constVal   BECAUSE THEOREM;
a \in d => const(d,c)[a] = c   BECAUSE \A(d <- d, c <- c, x <- a);
(IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in d /\ snd(<<a,b>>) = c) => fst(<<a,b>>) \in d   BECAUSE DropAndBoth;
\A a : \A b : a = b => (a \in d <=> b \in d)   BECAUSE E_SCHEME;
a = fst(<<a,b>>) => (a \in d <=> fst(<<a,b>>) \in d)   BECAUSE \A(a <- a, b <- fst(<<a,b>>));
fstExists   BECAUSE THEOREM;
a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
(a \in d <=> fst(<<a,b>>) \in d)   BECAUSE MODUS_PONENS;
fst(<<a,b>>) \in d => a \in d   BECAUSE EquivToImplReverse;
(IsCouple(<<a,b>>) /\ fst(<<a,b>>) \in d /\ snd(<<a,b>>) = c) => a \in d   BECAUSE TI;
<<a,b>> \in const(d,c) => a \in d   BECAUSE TI;
<<a,b>> \in const(d,c) => const(d,c)[a] = c   BECAUSE TI;
<<a,b>> \in const(d,c) => (b = c /\ const(d,c)[a] = c)   BECAUSE CIA;
(b = c /\ const(d,c)[a] = c) => b = const(d,c)[a]   BECAUSE E_SCHEME;
<<a,b>> \in const(d,c) => b = const(d,c)[a]   BECAUSE TI;
\A a : \A b : <<a,b>> \in const(d,c) => b = const(d,c)[a]   BECAUSE GENERALIZATION;
IsFunction(const(d,c))   BECAUSE IntroAndRight;
constFunc   BECAUSE GENERALIZATION;
QED

(*
   We have not finished with the strange properties of the empty set :
   it is a function, something dynamic that receives input and
   produces output. Except it receives nothing and produces nothing.
   It is even an injection.   
*)
emptyFunction == IsInjection({})
THEOREM emptyFunction
PROOF
VARIABLES a,b,x;
emptySetExists   BECAUSE THEOREM;
x \notin {}   BECAUSE \A(x <- x);
x \in {} => IsCouple(x)   BECAUSE Explosion;
IsGraph({})   BECAUSE GENERALIZATION;
<<a,b>> \notin {}   BECAUSE \A(x <- <<a,b>>);
<<a,b>> \in {} => b = {}[a]   BECAUSE Explosion;
\A a : \A b : <<a,b>> \in {} => b = {}[a]   BECAUSE GENERALIZATION;
IsFunction({})   BECAUSE IntroAndRight;
<<a,b>> \in {} => a = pre({},b)   BECAUSE Explosion;
\A a : \A b : <<a,b>> \in {} => a = pre({},b)   BECAUSE GENERALIZATION;
emptyFunction   BECAUSE IntroAndRight;
QED

funcUniqueImage == \A f : \A x : \A y :
   (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y
THEOREM funcUniqueImage
PROOF
VARIABLES a,b,f,g,x,y;
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
(\E x : <<x,y>> \in f) => <<pre(f,y),y>> \in f   BECAUSE CHOOSE pre(f,y);
y \in Image(f) => Reaches(f,y)   BECAUSE EquivToImpl;
y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE TI;
\A y : y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE GENERALIZATION;
x \in Image(f) => <<pre(f,x),x>> \in f   BECAUSE \A(y <- x);
(x \in Image(f) /\ y \in Image(f)) => (<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE MergeImplicationsAnd;
pre(f,x) = pre(f,y) => pre(f,x) = pre(f,y)   BECAUSE ImplySelf;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f /\ pre(f,x) = pre(f,y))   BECAUSE MergeImplicationsAnd;
\A a : \A b : a = b => (<<a,x>> \in f <=> <<b,x>> \in f)   BECAUSE E_SCHEME;
pre(f,x) = pre(f,y) => (<<pre(f,x),x>> \in f <=> <<pre(f,y),x>> \in f)   BECAUSE \A(a <- pre(f,x), b <- pre(f,y));
(pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f) => <<pre(f,y),x>> \in f   BECAUSE HypoEquivToAnd;
(<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f /\ pre(f,x) = pre(f,y))
   => (pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE AndCycle;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE TI;
<<pre(f,y),y>> \in f => <<pre(f,y),y>> \in f   BECAUSE ImplySelf;
(pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f) => (<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE MergeImplicationsAnd;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE TI;

IsFunction(f) => \A a : \A b : <<a,b>> \in f => b = f[a]   BECAUSE DropAndLeft;
(\A a : \A b : <<a,b>> \in f => b = f[a]) => (<<pre(f,y),y>> \in f => y = f[pre(f,y)])   BECAUSE \A(a <- pre(f,y), b <- y);
IsFunction(f) => (<<pre(f,y),y>> \in f => y = f[pre(f,y)])   BECAUSE TI;
(\A a : \A b : <<a,b>> \in f => b = f[a]) => (<<pre(f,y),x>> \in f => x = f[pre(f,y)])   BECAUSE \A(a <- pre(f,y), b <- x);
IsFunction(f) => (<<pre(f,y),x>> \in f => x = f[pre(f,y)])   BECAUSE TI;
IsFunction(f) => ((<<pre(f,y),x>> \in f => x = f[pre(f,y)]) /\ (<<pre(f,y),y>> \in f => y = f[pre(f,y)]))
   BECAUSE CIA;
((<<pre(f,y),x>> \in f => x = f[pre(f,y)]) /\ (<<pre(f,y),y>> \in f => y = f[pre(f,y)]))
   => ((<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE MergeImplicationsAnd2;
IsFunction(f) => ((<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE TI;
(<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (IsFunction(f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE SwitchHypos;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (IsFunction(f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))
   => (x = f[pre(f,y)] /\ y = f[pre(f,y)])   BECAUSE HypoImplToAnd;
(x = f[pre(f,y)] /\ y = f[pre(f,y)]) => x = y   BECAUSE E_SCHEME;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE TI;
funcUniqueImage   BECAUSE GENERALIZATION;
QED

multiInjection == \A f : \A multiX : \A y :
   IsInjection(f) => (y \in multiApply(f, multiX) <=> (y \in Image(f) /\ pre(f,y) \in multiX))
THEOREM multiInjection
PROOF
VARIABLES a,b,f,g,u,x,y,multiX;
multiApplyExists   BECAUSE THEOREM;
y \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,y>> \in f
   BECAUSE \A(f <- f, multiX <- multiX, x <- y);

\* Proof of (y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX) 
(\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE CHOOSE pre(f,y);
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
y \in Image(f) => Reaches(f,y)   BECAUSE EquivToImpl;
y \in Image(f) => <<pre(f,y), y>> \in f   BECAUSE TI;
pre(f,y) \in multiX => pre(f,y) \in multiX   BECAUSE ImplySelf;
(y \in Image(f) /\ pre(f,y) \in multiX) => (<<pre(f,y), y>> \in f /\ pre(f,y) \in multiX)
   BECAUSE MergeImplicationsAnd;
(<<pre(f,y), y>> \in f /\ pre(f,y) \in multiX) => (pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f)   BECAUSE AndSymmetry;
(y \in Image(f) /\ pre(f,y) \in multiX) => (pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f)   BECAUSE TI;
(pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f) => \E u : u \in multiX /\ <<u,y>> \in f   BECAUSE \E(u <- pre(f,y));
(\E u : u \in multiX /\ <<u,y>> \in f) => y \in multiApply(f,multiX)   BECAUSE EquivToImplReverse;
(pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f) => y \in multiApply(f,multiX)   BECAUSE TI;
(y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX)   BECAUSE TI;
IsInjection(f) => ((y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX))   BECAUSE PT1;

\* Converse
chooseU(f,y,multiX) == CHOOSE u : u \in multiX /\ <<u,y>> \in f;
(\E u : u \in multiX /\ <<u,y>> \in f)
   => (chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)   BECAUSE CHOOSE chooseU(f,y,multiX);
y \in multiApply(f,multiX) => (\E u : u \in multiX /\ <<u,y>> \in f)
   BECAUSE EquivToImpl;
y \in multiApply(f,multiX) => (chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)   BECAUSE TI;
(chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f) => <<chooseU(f,y,multiX),y>> \in f   BECAUSE DropAndLeft;
y \in multiApply(f,multiX) => <<chooseU(f,y,multiX),y>> \in f   BECAUSE TI;
imageInc   BECAUSE THEOREM;
<<chooseU(f,y,multiX),y>> \in f => y \in Image(f)   BECAUSE \A(g <- f, x <- chooseU(f,y,multiX), y <- y);
y \in multiApply(f,multiX) => y \in Image(f)   BECAUSE TI;

IsInjection(f) => \A a : \A b : <<a,b>> \in f => a = pre(f,b)   BECAUSE DropAndLeft;
(\A a : \A b : <<a,b>> \in f => a = pre(f,b)) => (<<chooseU(f,y,multiX),y>> \in f => chooseU(f,y,multiX) = pre(f,y))
   BECAUSE \A(a <- chooseU(f,y,multiX), b <- y);
IsInjection(f) => (<<chooseU(f,y,multiX),y>> \in f => chooseU(f,y,multiX) = pre(f,y))    BECAUSE TI;
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f) => chooseU(f,y,multiX) = pre(f,y)    BECAUSE HypoImplToAnd;
\A x : \A y : x = y => (x \in multiX <=> y \in multiX)    BECAUSE E_SCHEME;
(chooseU(f,y,multiX) = pre(f,y)) => (chooseU(f,y,multiX) \in multiX <=> pre(f,y) \in multiX)    BECAUSE \A(x <- chooseU(f,y,multiX), y <- pre(f,y));
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f) => (chooseU(f,y,multiX) \in multiX <=> pre(f,y) \in multiX)    BECAUSE TI;
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)
   => pre(f,y) \in multiX   BECAUSE HypoEquivToAnd;
(IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))
   => (IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE AssocAndLeft;
(IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))
   => pre(f,y) \in multiX   BECAUSE TI;
(chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)
   => (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE AndSymmetry;
y \in multiApply(f,multiX) => (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE TI;
IsInjection(f) => IsInjection(f)   BECAUSE ImplySelf;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => (IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))   BECAUSE MergeImplicationsAnd;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => pre(f,y) \in multiX   BECAUSE TI;
IsInjection(f) => (y \in multiApply(f,multiX) => y \in Image(f))   BECAUSE PT1;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => y \in Image(f)   BECAUSE HypoImplToAnd;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => (y \in Image(f) /\ pre(f,y) \in multiX)   BECAUSE CIA;
IsInjection(f) => (y \in multiApply(f,multiX) => (y \in Image(f) /\ pre(f,y) \in multiX))   BECAUSE HypoAndToImpl;
IsInjection(f) => (y \in multiApply(f,multiX) <=> (y \in Image(f) /\ pre(f,y) \in multiX))   BECAUSE HypoIntroEquiv;
multiInjection   BECAUSE GENERALIZATION;
QED

bijApply == \A f : \A a : \A b : \A x : (f \in Bijections(a,b) /\ x \in a) => f[x] \in b
THEOREM bijApply
PROOF
VARIABLES a,b,c,d,f,g,i,x,y;
imageInc2   BECAUSE THEOREM;
x \in Domain(f) => f[x] \in Image(f)   BECAUSE \A(f <- f, x <- x);
\A a : \A b : \A c : \A d : a = b /\ c = d => ((x \in a => f[x] \in c) <=> (x \in b => f[x] \in d))   BECAUSE E_SCHEME;
Domain(f) = a /\ Image(f) = b => ((x \in Domain(f) => f[x] \in Image(f)) <=> (x \in a => f[x] \in b))
   BECAUSE \A(a <- Domain(f), b <- a, c <- Image(f), d <- b);
implyTrueEquiv(h,t,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
Domain(f) = a /\ Image(f) = b => (x \in a => f[x] \in b)   BECAUSE implyTrueEquiv;
bijectionsExists   BECAUSE THEOREM;
f \in Bijections(a,b) <=> IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE \A(d <- a, i <- b, f <- f);
f \in Bijections(a,b) => IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE EquivToImpl;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Domain(f) = a   BECAUSE DropAndBoth;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Image(f) = b   BECAUSE DropAndLeft;
f \in Bijections(a,b) => Domain(f) = a   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b   BECAUSE TI;
f \in Bijections(a,b) => Domain(f) = a /\ Image(f) = b   BECAUSE CIA;
f \in Bijections(a,b) => (x \in a => f[x] \in b)   BECAUSE TI;
f \in Bijections(a,b) /\ x \in a => f[x] \in b   BECAUSE HypoImplToAnd;
bijApply   BECAUSE GENERALIZATION;
QED

bijPreApply == \A f : \A a : \A b : \A y : (f \in Bijections(a,b) /\ y \in b) => pre(f,y) \in a
THEOREM bijPreApply
PROOF
VARIABLES a,b,c,d,f,i,x,y;
domainInc2   BECAUSE THEOREM;
y \in Image(f) => pre(f,y) \in Domain(f)   BECAUSE \A(f <- f, y <- y);
\A a : \A b : \A c : \A d : a = b /\ c = d => ((y \in a => pre(f,y) \in c) <=> (y \in b => pre(f,y) \in d))   BECAUSE E_SCHEME;
Image(f) = b /\ Domain(f) = a => ((y \in Image(f) => pre(f,y) \in Domain(f)) <=> (y \in b => pre(f,y) \in a))
   BECAUSE \A(a <- Image(f), b <- b, c <- Domain(f), d <- a);
implyTrueEquiv(h,t,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
Image(f) = b /\ Domain(f) = a => (y \in b => pre(f,y) \in a)   BECAUSE implyTrueEquiv;
bijectionsExists   BECAUSE THEOREM;
f \in Bijections(a,b) <=> IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE \A(d <- a, i <- b, f <- f);
f \in Bijections(a,b) => IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE EquivToImpl;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Domain(f) = a   BECAUSE DropAndBoth;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Image(f) = b   BECAUSE DropAndLeft;
f \in Bijections(a,b) => Domain(f) = a   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b /\ Domain(f) = a   BECAUSE CIA;
f \in Bijections(a,b) => (y \in b => pre(f,y) \in a)   BECAUSE TI;
f \in Bijections(a,b) /\ y \in b => pre(f,y) \in a   BECAUSE HypoImplToAnd;
bijPreApply   BECAUSE GENERALIZATION;
QED


(*
   Functions between cartesian products.
*)

\* Two functions called in parallel
IsParallelApply(f,g,x) == IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
   /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g
parallelFunc(f,g) == CHOOSE h : \A x : x \in h <=> \* x = << <<a, b>>, <<f[a], g[b]>> >>
  IsParallelApply(f,g,x)

parallelFuncExists == \A f : \A g : (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x))
THEOREM parallelFuncExists
PROOF
VARIABLES a,b,c,f,g,h,x,y;
\* By separation in (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsParallelApply(f,g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(a <- (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)));

\* Take one such b
chooseB(f,g) == CHOOSE b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x));
(\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x)))
   => (\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x)))   BECAUSE CHOOSE chooseB(f,g);
\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE MODUS_PONENS;
x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(x <- x);

\* Stage x
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
\A x : \A y : x = y => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> y \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE E_SCHEME;
x = <<fst(x), snd(x)>> => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE \A(x <- x, y <- <<fst(x), snd(x)>>);
IsCouple(x) => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE TI;
(IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))   BECAUSE HypoEquivToAndReverse;
cartesianProductCouples   BECAUSE THEOREM;
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE \A(x <- (Domain(f) \X Domain(g)), y <- (Image(f) \X Image(g)), a <- fst(x), b <- snd(x));
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   => <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE EquivToImpl;
IsCouple(x) => IsCouple(x)   BECAUSE ImplySelf;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => (IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE MergeImplicationsAnd;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TI;

\* Prove that IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))
IsCouple(fst(x)) => fst(x) = <<fst(fst(x)), snd(fst(x))>>   BECAUSE \A(c <- fst(x));
\A x : \A y : x = y => (x \in (Domain(f) \X Domain(g)) <=> y \in (Domain(f) \X Domain(g)))   BECAUSE E_SCHEME;
fst(x) = <<fst(fst(x)), snd(fst(x))>> => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE \A(x <- fst(x), y <- <<fst(fst(x)), snd(fst(x))>>);
IsCouple(fst(x)) => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE TI;
(IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE HypoEquivToAndReverse;
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE \A(x <- Domain(f), y <- Domain(g), a <- fst(fst(x)), b <- snd(fst(x)));
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   => <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE EquivToImpl;
IsCouple(fst(x)) => IsCouple(fst(x))   BECAUSE ImplySelf;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => (IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)))   BECAUSE DropAndRight3;
(IsCouple(x) /\ IsCouple(fst(x))) => IsCouple(fst(x))   BECAUSE DropAndLeft;
IsParallelApply(f,g,x) => IsCouple(fst(x))   BECAUSE TI;
IsParallelApply(f,g,x) => <<fst(fst(x)), fst(snd(x)) >> \in f   BECAUSE DropAndBoth;
domainInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(fst(x)) \in Domain(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(fst(x)) \in Domain(f)   BECAUSE TI;
IsParallelApply(f,g,x) => <<snd(fst(x)), snd(snd(x)) >> \in g   BECAUSE DropAndLeft;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(fst(x)) \in Domain(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(fst(x)) \in Domain(g)   BECAUSE TI;
IsParallelApply(f,g,x) => (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))   BECAUSE CIA;
IsParallelApply(f,g,x) => (IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))   BECAUSE CIA;
IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TI;

\* Prove that IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))
IsCouple(snd(x)) => snd(x) = <<fst(snd(x)), snd(snd(x))>>   BECAUSE \A(c <- snd(x));
\A x : \A y : x = y => (x \in (Image(f) \X Image(g)) <=> y \in (Image(f) \X Image(g)))   BECAUSE E_SCHEME;
snd(x) = <<fst(snd(x)), snd(snd(x))>> => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE \A(x <- snd(x), y <- <<fst(snd(x)), snd(snd(x))>>);
IsCouple(snd(x)) => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE TI;
(IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE HypoEquivToAndReverse;
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE \A(x <- Image(f), y <- Image(g), a <- fst(snd(x)), b <- snd(snd(x)));
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   => <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE EquivToImpl;
IsCouple(snd(x)) => IsCouple(snd(x))   BECAUSE ImplySelf;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => (IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x)))   BECAUSE DropAndRight2;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(snd(x))   BECAUSE DropAndLeft;
IsParallelApply(f,g,x) => IsCouple(snd(x))   BECAUSE TI;
imageInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(snd(x)) \in Image(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(snd(x)) \in Image(f)   BECAUSE TI;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(snd(x)) \in Image(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(snd(x)) \in Image(g)   BECAUSE TI;
IsParallelApply(f,g,x) => (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))   BECAUSE CIA;
IsParallelApply(f,g,x) => (IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))   BECAUSE CIA;
IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   BECAUSE CIA;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(x)   BECAUSE DropAndRight2;
IsParallelApply(f,g,x) => IsCouple(x)   BECAUSE TI;
IsParallelApply(f,g,x) => (IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))   BECAUSE CIA;
IsParallelApply(f,g,x) => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TI;

x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE SeparationTauto;
\A x : x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE GENERALIZATION;
\E h : \A x : x \in h <=> IsParallelApply(f,g,x)   BECAUSE \E(h <- chooseB(f,g));
(\E h : \A x : x \in h <=> IsParallelApply(f,g,x)) => (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)) 
   BECAUSE CHOOSE parallelFunc(f,g);
\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)   BECAUSE MODUS_PONENS;
parallelFuncExists   BECAUSE GENERALIZATION;
QED


clone(d) == CHOOSE f : IsFunction(f) /\ \A x : \A y : <<x,y>> \in f <=> (x \in d /\ y = <<x,x>>)
cloneExists == \A d : IsFunction(clone(d)) /\ \A x : \A y : <<x,y>> \in clone(d) <=> (x \in d /\ y = <<x,x>>)
THEOREM cloneExists
PROOF
\* By separation in d \X (d \X d)
VARIABLES a,b,c,d,f,i,j,x,y;
\A a : \E b : \A x : x \in b <=> (x \in a /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x))))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x))))   BECAUSE \A(a <- (d \X (d \X d)));
cloneGraph(d) == CHOOSE b : \A x : x \in b <=> (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x))));
(\E b : \A x : x \in b <=> (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x)))))
   => (\A x : x \in cloneGraph(d) <=> (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x)))))
   BECAUSE CHOOSE cloneGraph(d);
\A x : x \in cloneGraph(d) <=> (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x))))   BECAUSE MODUS_PONENS;

\* Prove that clone(d) = cloneGraph(d)
x \in cloneGraph(d) <=> (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x))))   BECAUSE \A(x <- x);
x \in cloneGraph(d) => (x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x))))   BECAUSE EquivToImpl;
(x \in (d \X (d \X d)) /\ (fst(x) = fst(snd(x)) /\ fst(x) = snd(snd(x)))) => x \in (d \X (d \X d))   BECAUSE DropAndRight;
x \in cloneGraph(d) => x \in (d \X (d \X d))   BECAUSE TI;
cartesianProductExists   BECAUSE THEOREM;
x \in (d \X (d \X d)) <=> (IsCouple(x) /\ fst(x) \in d /\ snd(x) \in (d \X d))   BECAUSE \A(i <- d, j <- d \X d, x <- x);
x \in (d \X (d \X d)) => (IsCouple(x) /\ fst(x) \in d /\ snd(x) \in (d \X d))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in d /\ snd(x) \in (d \X d)) => IsCouple(x)   BECAUSE DropAndRight2;
x \in (d \X (d \X d)) => IsCouple(x)   BECAUSE TI;
x \in cloneGraph(d) => IsCouple(x)   BECAUSE TI;
IsGraph(cloneGraph(d))   BECAUSE GENERALIZATION;

\* Prove that <<x,y>> \in cloneGraph(d) => y = <<x,x>>
<<x,y>> \in cloneGraph(d) <=> (<<x,y>> \in (d \X (d \X d)) /\ (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>))))   BECAUSE \A(x <- <<x,y>>);
<<x,y>> \in cloneGraph(d) => (<<x,y>> \in (d \X (d \X d)) /\ (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>))))   BECAUSE EquivToImpl;
(<<x,y>> \in (d \X (d \X d)) /\ (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>))))
   => (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>)))
   BECAUSE DropAndLeft;
<<x,y>> \in cloneGraph(d) => (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>)))   BECAUSE TI;
\A x : \A y : \A a : \A b : (x = y /\ a = b) => ((x = fst(a) /\ x = snd(a)) <=> (y = fst(b) /\ y = snd(b)))   BECAUSE E_SCHEME;
(x = fst(<<x,y>>) /\ y = snd(<<x,y>>)) => ((x = fst(y) /\ x = snd(y)) <=> (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>))))
   BECAUSE \A(x <- x, y <- fst(<<x,y>>), a <- y, b <- snd(<<x,y>>));
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
(x = fst(y) /\ x = snd(y)) <=> (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>)))   BECAUSE MODUS_PONENS;
(fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>))) => (x = fst(y) /\ x = snd(y))   BECAUSE EquivToImplReverse;
<<x,y>> \in cloneGraph(d) => (x = fst(y) /\ x = snd(y))   BECAUSE TI;
<<x,y>> \in (d \X (d \X d)) <=> (IsCouple(<<x,y>>) /\ fst(<<x,y>>) \in d /\ snd(<<x,y>>) \in (d \X d))   BECAUSE \A(i <- d, j <- d \X d, x <- <<x,y>>);
<<x,y>> \in (d \X (d \X d)) => (IsCouple(<<x,y>>) /\ fst(<<x,y>>) \in d /\ snd(<<x,y>>) \in (d \X d))   BECAUSE EquivToImpl;
(IsCouple(<<x,y>>) /\ fst(<<x,y>>) \in d /\ snd(<<x,y>>) \in (d \X d)) => snd(<<x,y>>) \in (d \X d)   BECAUSE DropAndLeft;
<<x,y>> \in (d \X (d \X d)) => snd(<<x,y>>) \in (d \X d)   BECAUSE TI;
(<<x,y>> \in (d \X (d \X d)) /\ (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>)))) => <<x,y>> \in (d \X (d \X d))   BECAUSE DropAndRight;
<<x,y>> \in cloneGraph(d) => <<x,y>> \in (d \X (d \X d))   BECAUSE TI;
<<x,y>> \in cloneGraph(d) => snd(<<x,y>>) \in (d \X d)   BECAUSE TI;
\A y : \A x : y = x => (y \in (d \X d) <=> x \in (d \X d))   BECAUSE E_SCHEME;
y = snd(<<x,y>>) => (y \in (d \X d) <=> snd(<<x,y>>) \in (d \X d))   BECAUSE \A(y <- y, x <- snd(<<x,y>>));
y \in (d \X d) <=> snd(<<x,y>>) \in (d \X d)   BECAUSE MODUS_PONENS;
snd(<<x,y>>) \in (d \X d) => y \in (d \X d)   BECAUSE EquivToImplReverse;
<<x,y>> \in cloneGraph(d) => y \in (d \X d)   BECAUSE TI;
y \in (d \X d) <=> (IsCouple(y) /\ fst(y) \in d /\ snd(y) \in d)   BECAUSE \A(i <- d, j <- d, x <- y);
y \in (d \X d) => (IsCouple(y) /\ fst(y) \in d /\ snd(y) \in d)   BECAUSE EquivToImpl;
(IsCouple(y) /\ fst(y) \in d /\ snd(y) \in d) => IsCouple(y)   BECAUSE DropAndRight2;
y \in (d \X d) => IsCouple(y)   BECAUSE TI;
<<x,y>> \in cloneGraph(d) => IsCouple(y)   BECAUSE TI;
tupleComposition   BECAUSE THEOREM;
IsCouple(y) => y = <<fst(y), snd(y)>>   BECAUSE \A(c <- y);
<<x,y>> \in cloneGraph(d) => y = <<fst(y), snd(y)>>   BECAUSE TI;
\A a : \A b : \A i : \A j : (a = b /\ i = j) => (y = <<a,i>> <=> y = <<b,j>>)   BECAUSE E_SCHEME;
(x = fst(y) /\ x = snd(y)) => (y = <<x,x>> <=> y = <<fst(y),snd(y)>>)
   BECAUSE \A(a <- x, b <- fst(y), i <- x, j <- snd(y));
<<x,y>> \in cloneGraph(d) => (y = <<x,x>> <=> y = <<fst(y),snd(y)>>)   BECAUSE TI;
(<<x,y>> \in cloneGraph(d) /\ y = <<fst(y),snd(y)>>) => y = <<x,x>>   BECAUSE HypoEquivToAndReverse;
<<x,y>> \in cloneGraph(d) => <<x,y>> \in cloneGraph(d)   BECAUSE ImplySelf;
<<x,y>> \in cloneGraph(d) => (<<x,y>> \in cloneGraph(d) /\ y = <<fst(y),snd(y)>>)   BECAUSE CIA;
<<x,y>> \in cloneGraph(d) => y = <<x,x>>   BECAUSE TI;
(IsCouple(<<x,y>>) /\ fst(<<x,y>>) \in d /\ snd(<<x,y>>) \in (d \X d)) => fst(<<x,y>>) \in d   BECAUSE DropAndBoth;
<<x,y>> \in (d \X (d \X d)) => fst(<<x,y>>) \in d   BECAUSE TI;
<<x,y>> \in cloneGraph(d) => fst(<<x,y>>) \in d   BECAUSE TI;
\A y : \A x : y = x => (y \in d <=> x \in d)   BECAUSE E_SCHEME;
x = fst(<<x,y>>) => (x \in d <=> fst(<<x,y>>) \in d)   BECAUSE \A(y <- x, x <- fst(<<x,y>>));
x \in d <=> fst(<<x,y>>) \in d   BECAUSE MODUS_PONENS;
fst(<<x,y>>) \in d => x \in d   BECAUSE EquivToImplReverse;
<<x,y>> \in cloneGraph(d) => x \in d   BECAUSE TI;
<<x,y>> \in cloneGraph(d) => (x \in d /\ y = <<x,x>>)  BECAUSE CIA;

\* Prove that IsFunction(cloneGraph(d))
\A y : <<x,y>> \in cloneGraph(d) => y = <<x,x>>   BECAUSE GENERALIZATION;
<<x,cloneGraph(d)[x]>> \in cloneGraph(d) => cloneGraph(d)[x] = <<x,x>>   BECAUSE \A(y <- cloneGraph(d)[x]);
(\E y : <<x,y>> \in cloneGraph(d)) => <<x,cloneGraph(d)[x]>> \in cloneGraph(d)   BECAUSE CHOOSE cloneGraph(d)[x];
<<x,y>> \in cloneGraph(d) => \E y : <<x,y>> \in cloneGraph(d)   BECAUSE \E(y <- y);
<<x,y>> \in cloneGraph(d) => <<x,cloneGraph(d)[x]>> \in cloneGraph(d)   BECAUSE TI;
<<x,y>> \in cloneGraph(d) => cloneGraph(d)[x] = <<x,x>>   BECAUSE TI;
<<x,y>> \in cloneGraph(d) => (y = <<x,x>> /\ cloneGraph(d)[x] = <<x,x>>)   BECAUSE CIA;
(y = <<x,x>> /\ cloneGraph(d)[x] = <<x,x>>) => y = cloneGraph(d)[x]   BECAUSE E_SCHEME;
<<x,y>> \in cloneGraph(d) => y = cloneGraph(d)[x]   BECAUSE TI;
\A x : \A y : <<x,y>> \in cloneGraph(d) => y = cloneGraph(d)[x]   BECAUSE GENERALIZATION;
<<a,b>> \in cloneGraph(d) => b = cloneGraph(d)[a]   BECAUSE \A(x <- a, y <- b);
\A a : \A b : <<a,b>> \in cloneGraph(d) => b = cloneGraph(d)[a]   BECAUSE GENERALIZATION;
IsFunction(cloneGraph(d))   BECAUSE IntroAndRight;

\* Prove that x \in d => <<x, <<x,x>> >> \in cloneGraph(d)
\A y : <<x,y>> \in cloneGraph(d) => cloneGraph(d)[x] = <<x,x>>   BECAUSE GENERALIZATION;
<<x, <<x,x>> >> \in cloneGraph(d) => cloneGraph(d)[x] = <<x,x>>   BECAUSE \A(y <- <<x,x>>);
<<x, <<x,x>> >> \in cloneGraph(d) <=> (<<x, <<x,x>> >> \in (d \X (d \X d)) /\ (fst(<<x, <<x,x>> >>) = fst(snd(<<x, <<x,x>> >>)) /\ fst(<<x, <<x,x>> >>) = snd(snd(<<x, <<x,x>> >>))))   BECAUSE \A(x <- <<x, <<x,x>> >>);
(<<x, <<x,x>> >> \in (d \X (d \X d)) /\ (fst(<<x, <<x,x>> >>) = fst(snd(<<x, <<x,x>> >>)) /\ fst(<<x, <<x,x>> >>) = snd(snd(<<x, <<x,x>> >>)))) => <<x, <<x,x>> >> \in cloneGraph(d)   BECAUSE EquivToImplReverse;
\A y : (x = fst(y) /\ x = snd(y)) <=> (fst(<<x,y>>) = fst(snd(<<x,y>>)) /\ fst(<<x,y>>) = snd(snd(<<x,y>>)))   BECAUSE GENERALIZATION;
(x = fst( <<x,x>> ) /\ x = snd( <<x,x>> )) <=> (fst(<<x, <<x,x>> >>) = fst(snd(<<x, <<x,x>> >>)) /\ fst(<<x, <<x,x>> >>) = snd(snd(<<x, <<x,x>> >>)))   BECAUSE \A(y <- <<x,x>>);
x = fst(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
x = snd(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
x = fst( <<x,x>> ) /\ x = snd( <<x,x>> )   BECAUSE IntroAndRight;
fst(<<x, <<x,x>> >>) = fst(snd(<<x, <<x,x>> >>)) /\ fst(<<x, <<x,x>> >>) = snd(snd(<<x, <<x,x>> >>))   BECAUSE MODUS_PONENS;
x \in d => (x \in d /\ x \in d)   BECAUSE AndSelf;
cartesianProductCouples   BECAUSE THEOREM;
(x \in d /\ x \in d) <=> <<x,x>> \in (d \X d)   BECAUSE \A(x <- d, y <- d, a <- x, b <- x);
(x \in d /\ x \in d) => <<x,x>> \in (d \X d)   BECAUSE EquivToImpl;
x \in d => <<x,x>> \in (d \X d)   BECAUSE TI;
(x \in d /\ <<x,x>> \in (d \X d)) <=> <<x,<<x,x>> >> \in (d \X (d \X d))   BECAUSE \A(x <- d, y <- d \X d, a <- x, b <- <<x,x>>);
(x \in d /\ <<x,x>> \in (d \X d)) => <<x,<<x,x>> >> \in (d \X (d \X d))   BECAUSE EquivToImpl;
x \in d => x \in d   BECAUSE ImplySelf;
x \in d => (x \in d /\ <<x,x>> \in (d \X d))   BECAUSE CIA;
x \in d => <<x,<<x,x>> >> \in (d \X (d \X d))   BECAUSE TI;
<<x, <<x,x>> >> \in (d \X (d \X d)) => (<<x, <<x,x>> >> \in (d \X (d \X d)) /\ (fst(<<x, <<x,x>> >>) = fst(snd(<<x, <<x,x>> >>)) /\ fst(<<x, <<x,x>> >>) = snd(snd(<<x, <<x,x>> >>))))   BECAUSE IntroAndLeft;
<<x, <<x,x>> >> \in (d \X (d \X d)) => <<x, <<x,x>> >> \in cloneGraph(d)   BECAUSE TI;
x \in d => <<x, <<x,x>> >> \in cloneGraph(d)   BECAUSE TI;
\A a : \A b : a = b => (<<x,a>> \in cloneGraph(d) <=> <<x,b>> \in cloneGraph(d))   BECAUSE E_SCHEME;
y = <<x,x>> => (<<x,y>> \in cloneGraph(d) <=> <<x,<<x,x>> >> \in cloneGraph(d))   BECAUSE \A(a <- y, b <- <<x,x>>);
(y = <<x,x>> /\ <<x,<<x,x>> >> \in cloneGraph(d)) => <<x,y>> \in cloneGraph(d)   BECAUSE HypoEquivToAndReverse;
y = <<x,x>> => y = <<x,x>>   BECAUSE ImplySelf;
(x \in d /\ y = <<x,x>>) => (<<x,<<x,x>> >> \in cloneGraph(d) /\ y = <<x,x>>)   BECAUSE MergeImplicationsAnd; 
(<<x,<<x,x>> >> \in cloneGraph(d) /\ y = <<x,x>>) => (y = <<x,x>> /\ <<x,<<x,x>> >> \in cloneGraph(d))   BECAUSE AndSymmetry;
(<<x,<<x,x>> >> \in cloneGraph(d) /\ y = <<x,x>>) => <<x,y>> \in cloneGraph(d)   BECAUSE TI;
(x \in d /\ y = <<x,x>>) => <<x,y>> \in cloneGraph(d)   BECAUSE TI;
<<x,y>> \in cloneGraph(d) <=> (x \in d /\ y = <<x,x>>)   BECAUSE IntroEquiv;
\A x : \A y : <<x,y>> \in cloneGraph(d) <=> (x \in d /\ y = <<x,x>>)   BECAUSE GENERALIZATION;
IsFunction(cloneGraph(d)) /\ \A x : \A y : <<x,y>> \in cloneGraph(d) <=> (x \in d /\ y = <<x,x>>)   BECAUSE IntroAndRight;
\E f : IsFunction(f) /\ \A x : \A y : <<x,y>> \in f <=> (x \in d /\ y = <<x,x>>)   BECAUSE \E(f <- cloneGraph(d));
(\E f : IsFunction(f) /\ \A x : \A y : <<x,y>> \in f <=> (x \in d /\ y = <<x,x>>))
   => (IsFunction(clone(d)) /\ \A x : \A y : <<x,y>> \in clone(d) <=> (x \in d /\ y = <<x,x>>))   BECAUSE CHOOSE clone(d);
IsFunction(clone(d)) /\ \A x : \A y : <<x,y>> \in clone(d) <=> (x \in d /\ y = <<x,x>>)   BECAUSE MODUS_PONENS;
cloneExists   BECAUSE GENERALIZATION;
QED

\* Cartesian product of two functions
productFunc(f,g) == compose(parallelFunc(f,g), clone(Domain(f) \intersect Domain(g)))

productFuncVal == \A f : \A g : \A x : \A y : <<x,y>> \in productFunc(f,g)
   => (IsCouple(y) /\ <<x,fst(y)>> \in f /\ <<x,snd(y)>> \in g)
THEOREM productFuncVal
PROOF
VARIABLES a,b,d,f,g,h,x,y;
composeExists   BECAUSE THEOREM;
<<x,y>> \in productFunc(f,g) <=> (IsCouple(<<x,y>>) /\ \E t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g))
   BECAUSE \A(g <- parallelFunc(f,g), h <- clone(Domain(f) \intersect Domain(g)), x <- <<x,y>>);
<<x,y>> \in productFunc(f,g) => (IsCouple(<<x,y>>) /\ \E t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g))
   BECAUSE EquivToImpl;
(IsCouple(<<x,y>>) /\ \E t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g)) => \E t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g)
   BECAUSE DropAndLeft;
<<x,y>> \in productFunc(f,g) => \E t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g))
                                        /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g)
   BECAUSE TI;
chooseT(f,g,x,y) == CHOOSE t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g))
   /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g); \* we'll show that chooseT = <<x,x>> and <<x,fst(y)>> \in f
(\E t : <<fst(<<x,y>>),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(<<x,y>>)>> \in parallelFunc(f,g)) => (<<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) /\ <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g))
   BECAUSE CHOOSE chooseT(f,g,x,y);
<<x,y>> \in productFunc(f,g) => (<<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) /\ <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g))   BECAUSE TI;
(<<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) /\ <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g)) => <<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g))   BECAUSE DropAndRight;
<<x,y>> \in productFunc(f,g) => <<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g))   BECAUSE TI;
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
\A a : \A b : a = b => (<<a,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) <=> <<b,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)))   BECAUSE E_SCHEME;
x = fst(<<x,y>>) => (<<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) <=> <<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)))   BECAUSE \A(a <- x, b <- fst(<<x,y>>));
<<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) <=> <<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g))   BECAUSE MODUS_PONENS;
<<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) => <<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g))   BECAUSE EquivToImplReverse;
<<x,y>> \in productFunc(f,g) => <<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g))   BECAUSE TI;
cloneExists   BECAUSE THEOREM;
IsFunction(clone(Domain(f) \intersect Domain(g))) /\ \A x : \A y : <<x,y>> \in clone(Domain(f) \intersect Domain(g)) <=> (x \in (Domain(f) \intersect Domain(g)) /\ y = <<x,x>>)
   BECAUSE \A(d <- Domain(f) \intersect Domain(g));
\A x : \A y : <<x,y>> \in clone(Domain(f) \intersect Domain(g)) <=> (x \in (Domain(f) \intersect Domain(g)) /\ y = <<x,x>>)
   BECAUSE DropAndLeft;
<<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) <=> (x \in (Domain(f) \intersect Domain(g)) /\ chooseT(f,g,x,y) = <<x,x>>)
   BECAUSE \A(x <- x, y <- chooseT(f,g,x,y));
<<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) => (x \in (Domain(f) \intersect Domain(g)) /\ chooseT(f,g,x,y) = <<x,x>>)   BECAUSE EquivToImpl;
(x \in (Domain(f) \intersect Domain(g)) /\ chooseT(f,g,x,y) = <<x,x>>) => chooseT(f,g,x,y) = <<x,x>>   BECAUSE DropAndLeft;
<<x,chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) => chooseT(f,g,x,y) = <<x,x>>   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => chooseT(f,g,x,y) = <<x,x>>   BECAUSE TI;

\* Now the y part
(<<fst(<<x,y>>),chooseT(f,g,x,y)>> \in clone(Domain(f) \intersect Domain(g)) /\ <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g)) => <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g)   BECAUSE DropAndLeft;
<<x,y>> \in productFunc(f,g) => <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g)   BECAUSE TI;
\* Replace snd(<<x,y>>) by y and chooseT by <<x,x>>
\A a : \A b : \A x : \A y : (a = b /\ x = y)
   => (<<a,x>> \in parallelFunc(f,g) <=> <<b,y>> \in parallelFunc(f,g))   BECAUSE E_SCHEME;
(<<x,x>> = chooseT(f,g,x,y) /\ y = snd(<<x,y>>))
   => (<< <<x,x>>,y>> \in parallelFunc(f,g) <=> <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g))
   BECAUSE \A(a <- <<x,x>>, b <- chooseT(f,g,x,y), x <- y, y <- snd(<<x,y>>));
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
chooseT(f,g,x,y) = <<x,x>> => <<x,x>> = chooseT(f,g,x,y)   BECAUSE E_SCHEME;
<<x,y>> \in productFunc(f,g) => <<x,x>> = chooseT(f,g,x,y)   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => y = snd(<<x,y>>)   BECAUSE PT1;
<<x,y>> \in productFunc(f,g) => (<<x,x>> = chooseT(f,g,x,y) /\ y = snd(<<x,y>>))   BECAUSE CIA;
<<x,y>> \in productFunc(f,g) => (<< <<x,x>>,y>> \in parallelFunc(f,g) <=> <<chooseT(f,g,x,y),snd(<<x,y>>)>> \in parallelFunc(f,g))   BECAUSE TI;
dropRedundantEquiv(a,b,c) == (a => b) => ((a => (c <=> b)) => (a => c))   PROPO_TAUTO;
<<x,y>> \in productFunc(f,g) => << <<x,x>>,y>> \in parallelFunc(f,g)   BECAUSE dropRedundantEquiv;

\* Finish by resolving tuples
parallelFuncExists   BECAUSE THEOREM;
<< <<x,x>>,y>> \in parallelFunc(f,g) <=> IsParallelApply(f,g,<< <<x,x>>,y>>)   BECAUSE \A(f <- f, g <- g, x <- << <<x,x>>,y>>);
<< <<x,x>>,y>> \in parallelFunc(f,g) => IsParallelApply(f,g,<< <<x,x>>,y>>)   BECAUSE EquivToImpl;
<<x,y>> \in productFunc(f,g) => IsParallelApply(f,g,<< <<x,x>>,y>>)   BECAUSE TI;
selectMiddle(a,b,c) == (a /\ b /\ c) => b   PROPO_TAUTO;
IsParallelApply(f,g,<< <<x,x>>,y>>) => <<fst(fst(<< <<x,x>>,y>>)), fst(snd(<< <<x,x>>,y>>)) >> \in f   BECAUSE selectMiddle;
IsParallelApply(f,g,<< <<x,x>>,y>>) => <<snd(fst(<< <<x,x>>,y>>)), snd(snd(<< <<x,x>>,y>>)) >> \in g   BECAUSE DropAndLeft;
<<x,y>> \in productFunc(f,g) => <<fst(fst(<< <<x,x>>,y>>)), fst(snd(<< <<x,x>>,y>>)) >> \in f   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => <<snd(fst(<< <<x,x>>,y>>)), snd(snd(<< <<x,x>>,y>>)) >> \in g   BECAUSE TI;

\A a : \A b : \A x : \A y : (a = b /\ x = y)
   => (<<fst(a),fst(x)>> \in f <=> <<fst(b),fst(y)>> \in f)   BECAUSE E_SCHEME;
(<<x,x>> = fst(<< <<x,x>>,y>>) /\ y = snd(<< <<x,x>>,y>>))
   => (<<fst(<<x,x>>),fst(y)>> \in f <=> <<fst(fst(<< <<x,x>>,y>>)),fst(snd(<< <<x,x>>,y>>))>> \in f)
   BECAUSE \A(a <- <<x,x>>, b <- fst(<< <<x,x>>,y>>), x <- y, y <- snd(<< <<x,x>>,y>>));
y = snd(<< <<x,x>>,y>>)   BECAUSE \A(a <- <<x,x>>, b <- y);
<<x,x>> = fst(<< <<x,x>>,y>>)   BECAUSE \A(a <- <<x,x>>, b <- y);
<<x,x>> = fst(<< <<x,x>>,y>>) /\ y = snd(<< <<x,x>>,y>>)   BECAUSE IntroAndRight;
<<fst(<<x,x>>),fst(y)>> \in f <=> <<fst(fst(<< <<x,x>>,y>>)),fst(snd(<< <<x,x>>,y>>))>> \in f   BECAUSE MODUS_PONENS;
<<fst(fst(<< <<x,x>>,y>>)),fst(snd(<< <<x,x>>,y>>))>> \in f  => <<fst(<<x,x>>),fst(y)>> \in f   BECAUSE EquivToImplReverse;
<<x,y>> \in productFunc(f,g) => <<fst(<<x,x>>),fst(y)>> \in f   BECAUSE TI;
\A a : \A b : a = b => (<<a,fst(y)>> \in f <=> <<b,fst(y)>> \in f)   BECAUSE E_SCHEME;
x = fst(<<x,x>>) => (<<x,fst(y)>> \in f <=> <<fst(<<x,x>>),fst(y)>> \in f)   BECAUSE \A(a <- x, b <- fst(<<x,x>>));
x = fst(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
<<x,fst(y)>> \in f <=> <<fst(<<x,x>>),fst(y)>> \in f   BECAUSE MODUS_PONENS;
<<fst(<<x,x>>),fst(y)>> \in f => <<x,fst(y)>> \in f   BECAUSE EquivToImplReverse;
<<x,y>> \in productFunc(f,g) => <<x,fst(y)>> \in f   BECAUSE TI;

\A a : \A b : \A x : \A y : (a = b /\ x = y)
   => (<<snd(a),snd(x)>> \in g <=> <<snd(b),snd(y)>> \in g)   BECAUSE E_SCHEME;
(<<x,x>> = fst(<< <<x,x>>,y>>) /\ y = snd(<< <<x,x>>,y>>))
   => (<<snd(<<x,x>>),snd(y)>> \in g <=> <<snd(fst(<< <<x,x>>,y>>)),snd(snd(<< <<x,x>>,y>>))>> \in g)
   BECAUSE \A(a <- <<x,x>>, b <- fst(<< <<x,x>>,y>>), x <- y, y <- snd(<< <<x,x>>,y>>));
y = snd(<< <<x,x>>,y>>)   BECAUSE \A(a <- <<x,x>>, b <- y);
<<x,x>> = fst(<< <<x,x>>,y>>)   BECAUSE \A(a <- <<x,x>>, b <- y);
<<x,x>> = fst(<< <<x,x>>,y>>) /\ y = snd(<< <<x,x>>,y>>)   BECAUSE IntroAndRight;
<<snd(<<x,x>>),snd(y)>> \in g <=> <<snd(fst(<< <<x,x>>,y>>)),snd(snd(<< <<x,x>>,y>>))>> \in g   BECAUSE MODUS_PONENS;
<<snd(fst(<< <<x,x>>,y>>)),snd(snd(<< <<x,x>>,y>>))>> \in g  => <<snd(<<x,x>>),snd(y)>> \in g   BECAUSE EquivToImplReverse;
<<x,y>> \in productFunc(f,g) => <<snd(<<x,x>>),snd(y)>> \in g   BECAUSE TI;
\A a : \A b : a = b => (<<a,snd(y)>> \in g <=> <<b,snd(y)>> \in g)   BECAUSE E_SCHEME;
x = snd(<<x,x>>) => (<<x,snd(y)>> \in g <=> <<snd(<<x,x>>),snd(y)>> \in g)   BECAUSE \A(a <- x, b <- snd(<<x,x>>));
x = snd(<<x,x>>)   BECAUSE \A(a <- x, b <- x);
<<x,snd(y)>> \in g <=> <<snd(<<x,x>>),snd(y)>> \in g   BECAUSE MODUS_PONENS;
<<snd(<<x,x>>),snd(y)>> \in g => <<x,snd(y)>> \in g   BECAUSE EquivToImplReverse;
<<x,y>> \in productFunc(f,g) => <<x,snd(y)>> \in g   BECAUSE TI;

IsParallelApply(f,g,<< <<x,x>>,y>>) => (IsCouple(<< <<x,x>>,y>>) /\ IsCouple(fst(<< <<x,x>>,y>>)) /\ IsCouple(snd(<< <<x,x>>,y>>)))   BECAUSE DropAndRight2;
(IsCouple(<< <<x,x>>,y>>) /\ IsCouple(fst(<< <<x,x>>,y>>)) /\ IsCouple(snd(<< <<x,x>>,y>>))) => IsCouple(snd(<< <<x,x>>,y>>))   BECAUSE DropAndLeft;
IsParallelApply(f,g,<< <<x,x>>,y>>) => IsCouple(snd(<< <<x,x>>,y>>))   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => IsCouple(snd(<< <<x,x>>,y>>))   BECAUSE TI;
\A a : \A b : a = b => (IsCouple(a) <=> IsCouple(b))   BECAUSE E_SCHEME;
y = snd(<< <<x,x>>,y>>) => (IsCouple(y) <=> IsCouple(snd(<< <<x,x>>,y>>)))   BECAUSE \A(a <- y, b <- snd(<< <<x,x>>,y>>));
IsCouple(y) <=> IsCouple(snd(<< <<x,x>>,y>>))   BECAUSE MODUS_PONENS;
IsCouple(snd(<< <<x,x>>,y>>)) => IsCouple(y)   BECAUSE EquivToImplReverse;
<<x,y>> \in productFunc(f,g) => IsCouple(y)   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => (IsCouple(y) /\ <<x,fst(y)>> \in f)   BECAUSE CIA;
<<x,y>> \in productFunc(f,g) => (IsCouple(y) /\ <<x,fst(y)>> \in f /\ <<x,snd(y)>> \in g)   BECAUSE CIA;
productFuncVal   BECAUSE GENERALIZATION;
QED

productFuncIsFunc == \A f : \A g : (IsFunction(f) /\ IsFunction(g)) => IsFunction(productFunc(f,g))
THEOREM productFuncIsFunc
PROOF
VARIABLES a,b,c,f,g,h,x,y;
productFuncVal   BECAUSE THEOREM;
<<x,y>> \in productFunc(f,g) => (IsCouple(y) /\ <<x,fst(y)>> \in f /\ <<x,snd(y)>> \in g)
   BECAUSE \A(f <- f, g <- g, x <- x, y <- y);
IsFunction(f) => \A a : \A b : <<a,b>> \in f => b = f[a]   BECAUSE DropAndLeft;
(\A a : \A b : <<a,b>> \in f => b = f[a]) => (<<x,fst(y)>> \in f => fst(y) = f[x])   BECAUSE \A(a <- x, b <- fst(y));
IsFunction(f) => (<<x,fst(y)>> \in f => fst(y) = f[x])   BECAUSE TI;
<<x,fst(y)>> \in f => (IsFunction(f) => fst(y) = f[x])   BECAUSE SwitchHypos;
(IsCouple(y) /\ <<x,fst(y)>> \in f /\ <<x,snd(y)>> \in g) => <<x,fst(y)>> \in f   BECAUSE DropAndBoth;
<<x,y>> \in productFunc(f,g) => <<x,fst(y)>> \in f   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => (IsFunction(f) => fst(y) = f[x])   BECAUSE TI;

IsFunction(g) => \A a : \A b : <<a,b>> \in g => b = g[a]   BECAUSE DropAndLeft;
(\A a : \A b : <<a,b>> \in g => b = g[a]) => (<<x,snd(y)>> \in g => snd(y) = g[x])   BECAUSE \A(a <- x, b <- snd(y));
IsFunction(g) => (<<x,snd(y)>> \in g => snd(y) = g[x])   BECAUSE TI;
<<x,snd(y)>> \in g => (IsFunction(g) => snd(y) = g[x])   BECAUSE SwitchHypos;
(IsCouple(y) /\ <<x,fst(y)>> \in f /\ <<x,snd(y)>> \in g) => <<x,snd(y)>> \in g   BECAUSE DropAndLeft;
<<x,y>> \in productFunc(f,g) => <<x,snd(y)>> \in g   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => (IsFunction(g) => snd(y) = g[x])   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => ((IsFunction(f) => fst(y) = f[x]) /\ (IsFunction(g) => snd(y) = g[x]))
   BECAUSE CIA;
mergeHypos(a,b,c,d) == ((a => b) /\ (c => d)) => ((a /\ c) => (b /\ d))   PROPO_TAUTO;
((IsFunction(f) => fst(y) = f[x]) /\ (IsFunction(g) => snd(y) = g[x])) => ((IsFunction(f) /\ IsFunction(g)) => (fst(y) = f[x] /\ snd(y) = g[x]))   BECAUSE mergeHypos;
<<x,y>> \in productFunc(f,g) => ((IsFunction(f) /\ IsFunction(g)) => (fst(y) = f[x] /\ snd(y) = g[x]))   BECAUSE TI;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => (fst(y) = f[x] /\ snd(y) = g[x])   BECAUSE HypoImplToAnd;
(IsCouple(y) /\ <<x,fst(y)>> \in f /\ <<x,snd(y)>> \in g) => IsCouple(y)   BECAUSE DropAndRight2;
<<x,y>> \in productFunc(f,g) => IsCouple(y)   BECAUSE TI;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => <<x,y>> \in productFunc(f,g)   BECAUSE DropAndRight;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => IsCouple(y)   BECAUSE TI;
tupleComposition   BECAUSE THEOREM;
IsCouple(y) => y = <<fst(y), snd(y)>>   BECAUSE \A(c <- y);
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => y = <<fst(y), snd(y)>>   BECAUSE TI;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g)))
   => (fst(y) = f[x] /\ snd(y) = g[x] /\ y = <<fst(y),snd(y)>>)   BECAUSE CIA;
\A a : \A b : \A f : \A g : (a = b /\ f = g) => (y = <<a,f>> <=> y = <<b,g>>)   BECAUSE E_SCHEME;
(fst(y) = f[x] /\ snd(y) = g[x]) => (y = <<fst(y),snd(y)>> <=> y = <<f[x],g[x]>>)   BECAUSE \A(a <- fst(y), b <- f[x], f <- snd(y), g <- g[x]);
(fst(y) = f[x] /\ snd(y) = g[x] /\ y = <<fst(y),snd(y)>>) => y = <<f[x],g[x]>>   BECAUSE HypoEquivToAnd;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => y = <<f[x],g[x]>>   BECAUSE TI;
\A y : (<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => y = <<f[x],g[x]>>   BECAUSE GENERALIZATION;
(<<x,productFunc(f,g)[x]>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => productFunc(f,g)[x] = <<f[x],g[x]>>   BECAUSE \A(y <- productFunc(f,g)[x]);

(\E y : <<x,y>> \in productFunc(f,g)) => <<x,productFunc(f,g)[x]>> \in productFunc(f,g)   BECAUSE CHOOSE productFunc(f,g)[x];
<<x,y>> \in productFunc(f,g) => \E y : <<x,y>> \in productFunc(f,g)   BECAUSE \E(y <- y);
<<x,y>> \in productFunc(f,g) => <<x,productFunc(f,g)[x]>> \in productFunc(f,g)   BECAUSE TI;

(IsFunction(f) /\ IsFunction(g)) => (IsFunction(f) /\ IsFunction(g))   BECAUSE ImplySelf;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g)))
   => (<<x,productFunc(f,g)[x]>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g)))
   BECAUSE MergeImplicationsAnd;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => productFunc(f,g)[x] = <<f[x],g[x]>>   BECAUSE TI;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => (y = <<f[x],g[x]>> /\ productFunc(f,g)[x] = <<f[x],g[x]>>)   BECAUSE CIA;
(y = <<f[x],g[x]>> /\ productFunc(f,g)[x] = <<f[x],g[x]>>) => y = productFunc(f,g)[x]   BECAUSE E_SCHEME;
(<<x,y>> \in productFunc(f,g) /\ (IsFunction(f) /\ IsFunction(g))) => y = productFunc(f,g)[x]   BECAUSE TI;
<<x,y>> \in productFunc(f,g) => ((IsFunction(f) /\ IsFunction(g)) => y = productFunc(f,g)[x])   BECAUSE HypoAndToImpl;
(IsFunction(f) /\ IsFunction(g)) => (<<x,y>> \in productFunc(f,g) => y = productFunc(f,g)[x])   BECAUSE SwitchHypos;
\A x : \A y : (IsFunction(f) /\ IsFunction(g)) => (<<x,y>> \in productFunc(f,g) => y = productFunc(f,g)[x])   BECAUSE GENERALIZATION;
(IsFunction(f) /\ IsFunction(g)) => (<<a,b>> \in productFunc(f,g) => b = productFunc(f,g)[a])   BECAUSE \A(x <- a, y <- b);
\A b : (IsFunction(f) /\ IsFunction(g)) => (<<a,b>> \in productFunc(f,g) => b = productFunc(f,g)[a])   BECAUSE GENERALIZATION;
(IsFunction(f) /\ IsFunction(g)) => (\A b : <<a,b>> \in productFunc(f,g) => b = productFunc(f,g)[a])   BECAUSE Q_SCHEME;
\A a : (IsFunction(f) /\ IsFunction(g)) => (\A b : <<a,b>> \in productFunc(f,g) => b = productFunc(f,g)[a])   BECAUSE GENERALIZATION;
(IsFunction(f) /\ IsFunction(g)) => (\A a : \A b : <<a,b>> \in productFunc(f,g) => b = productFunc(f,g)[a])   BECAUSE Q_SCHEME;

composeExists   BECAUSE THEOREM;
x \in productFunc(f,g) <=> (IsCouple(x) /\ \E t : <<fst(x),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(x)>> \in parallelFunc(f,g))
   BECAUSE \A(g <- parallelFunc(f,g), h <- clone(Domain(f) \intersect Domain(g)), x <- x);
x \in productFunc(f,g) => (IsCouple(x) /\ \E t : <<fst(x),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(x)>> \in parallelFunc(f,g))   BECAUSE EquivToImpl;
(IsCouple(x) /\ \E t : <<fst(x),t>> \in clone(Domain(f) \intersect Domain(g)) /\ <<t,snd(x)>> \in parallelFunc(f,g)) => IsCouple(x)   BECAUSE DropAndRight;
x \in productFunc(f,g) => IsCouple(x)   BECAUSE TI;
IsGraph(productFunc(f,g))   BECAUSE GENERALIZATION;
(IsFunction(f) /\ IsFunction(g)) => IsGraph(productFunc(f,g))   BECAUSE PT1;
(IsFunction(f) /\ IsFunction(g)) => IsFunction(productFunc(f,g))   BECAUSE CIA;
productFuncIsFunc   BECAUSE GENERALIZATION;
QED