(*
   The class of functions : graphs that have at most one output for each
   input. A function as a set represents a computation, like addition
   or multiplication, something that always produces the same output
   when given the same input.

   The function application operator f[x] is defined, as well as its
   reverse operator pre(f,x).
*)

EXTENDS ZFC

IsFunction(f) == IsGraph(f)  /\  \A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c
IsInjection(f) == IsFunction(f)  /\  \A a : \A b : <<a,b>> \in f => a = pre(f,b)

funcVal == \A f : \A x : \A y : IsFunction(f) /\ <<x,y>> \in f => y = f[x]
THEOREM funcVal
PROOF
VARIABLES a,b,c,f,x,y,z;
h(f,x,y) == IsFunction(f) /\ <<x,y>> \in f;
h(f,x,y) => <<x,y>> \in f   BECAUSE S22;
\A z : \A y : z = y => (<<x,z>> \in f <=> <<x,y>> \in f)   BECAUSE E_SCHEME;
z = y => (<<x,z>> \in f <=> <<x,y>> \in f)   BECAUSE \A(z <- z, y <- y);
cycleHypos(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
<<x,y>> \in f /\ z = y => <<x,z>> \in f   BECAUSE cycleHypos;
z = y => z = y   BECAUSE ImplySelf;
h(f,x,y) /\ z = y => <<x,y>> \in f /\ z = y   BECAUSE MergeImplicationsAnd;
h(f,x,y) /\ z = y => <<x,z>> \in f   BECAUSE TI;

h(f,x,y) /\ <<x,z>> \in f => h(f,x,y)   BECAUSE S12;
h(f,x,y) /\ <<x,z>> \in f => <<x,z>> \in f   BECAUSE S22;
h(f,x,y) /\ <<x,z>> \in f => <<x,y>> \in f   BECAUSE TI;
h(f,x,y) /\ <<x,z>> \in f => <<x,y>> \in f /\ <<x,z>> \in f   BECAUSE CIA;
h(f,x,y) => IsFunction(f)   BECAUSE S12;
IsFunction(f) => \A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c   BECAUSE S22;
(\A a : \A b : \A c : (<<a,b>> \in f /\ <<a,c>> \in f) => b = c) => (<<x,y>> \in f /\ <<x,z>> \in f => y = z)
   BECAUSE \A(a <- x, b <- y, c <- z);
h(f,x,y) => (<<x,y>> \in f /\ <<x,z>> \in f => y = z)   BECAUSE TI2;
h(f,x,y) /\ <<x,z>> \in f => (<<x,y>> \in f /\ <<x,z>> \in f => y = z)   BECAUSE TI;
h(f,x,y) /\ <<x,z>> \in f => y = z   BECAUSE KillMiddleHypo;
y = z => z = y   BECAUSE E_SCHEME;
h(f,x,y) /\ <<x,z>> \in f => z = y   BECAUSE TI;
h(f,x,y) => (z = y <=> <<x,z>> \in f)   BECAUSE HIE;
\A z : h(f,x,y) => (z = y <=> <<x,z>> \in f)   BECAUSE GENERALIZATION;
h(f,x,y) => (\A z : z = y <=> <<x,z>> \in f)   BECAUSE Q_SCHEME;
(\A z : z = y <=> <<x,z>> \in f) => (\E y : \A z : z = y <=> <<x,z>> \in f)   BECAUSE \E(y <- y);
(\E y : \A z : z = y <=> <<x,z>> \in f) => (\A z : z = f[x] <=> <<x,z>> \in f)   BECAUSE CHOOSE f[x];
h(f,x,y) => (\A z : z = f[x] <=> <<x,z>> \in f)   BECAUSE TI2;
(\A z : z = f[x] <=> <<x,z>> \in f) => (y = f[x] <=> <<x,y>> \in f)   BECAUSE \A(z <- y);
h(f,x,y) => (y = f[x] <=> <<x,y>> \in f)   BECAUSE TI;
implyEquivTrue(t,h,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
h(f,x,y) => y = f[x]   BECAUSE implyEquivTrue;
funcVal   BECAUSE GENERALIZATION;
QED

funcImageExists == \A f : \A x : IsFunction(f) /\ x \in Domain(f) => <<x, f[x]>> \in f
THEOREM funcImageExists
PROOF
VARIABLES a,b,f,g,x,y,z;
h(f,x,y) == IsFunction(f) /\ <<x,y>> \in f;
funcVal   BECAUSE THEOREM;
h(f,x,y) => y = f[x]   BECAUSE \A(f <- f, x <- x, y <- y);
\A y : \A z : y = z => (<<x,y>> \in f <=> <<x,z>> \in f)   BECAUSE E_SCHEME;
y = f[x] => (<<x,y>> \in f <=> <<x,f[x]>> \in f)   BECAUSE \A(y <- y, z <- f[x]);
h(f,x,y) => (<<x,y>> \in f <=> <<x,f[x]>> \in f)   BECAUSE TI;
implyTrueEquiv(h,t,a) == (h => t) => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
h(f,x,y) => <<x,y>> \in f   BECAUSE S22;
h(f,x,y) => <<x,f[x]>> \in f   BECAUSE implyTrueEquiv;
\* Discharge y
IsFunction(f) => (<<x,y>> \in f => <<x,f[x]>> \in f)   BECAUSE HypoAndToImpl;
\A y : IsFunction(f) => (<<x,y>> \in f => <<x,f[x]>> \in f)   BECAUSE GENERALIZATION;
IsFunction(f) => (\A y : <<x,y>> \in f => <<x,f[x]>> \in f)   BECAUSE Q_SCHEME;
(\A y : <<x,y>> \in f => <<x,f[x]>> \in f) => ((\E y : <<x,y>> \in f) => \E y : <<x,f[x]>> \in f)   BECAUSE Q_SCHEME;
IsFunction(f) => ((\E y : <<x,y>> \in f) => \E y : <<x,f[x]>> \in f)   BECAUSE TI;

domainExists   BECAUSE THEOREM;
x \in Domain(f) <=> IsDefinedOn(f,x)   BECAUSE \A(g <- f, x <- x);
x \in Domain(f) => \E y : <<x,y>> \in f   BECAUSE EquivToImpl;
IsFunction(f) /\ x \in Domain(f) => x \in Domain(f)   BECAUSE S22;
IsFunction(f) /\ x \in Domain(f) => IsFunction(f)   BECAUSE S12;
IsFunction(f) /\ x \in Domain(f) => ((\E y : <<x,y>> \in f) => \E y : <<x,f[x]>> \in f)   BECAUSE TI;
IsFunction(f) /\ x \in Domain(f) => \E y : <<x,y>> \in f   BECAUSE TI;
IsFunction(f) /\ x \in Domain(f) => \E y : <<x,f[x]>> \in f   BECAUSE KillMiddleHypo;
(\E y : <<x,f[x]>> \in f) => <<x,f[x]>> \in f   BECAUSE Q_SCHEME;
IsFunction(f) /\ x \in Domain(f) => <<x,f[x]>> \in f   BECAUSE TI;
funcImageExists   BECAUSE GENERALIZATION;
QED

(*
   A bijection is an equivalence between two sets, a one-to-one correspondence
   between elements of each set.
*)
Bijections(d, i) == CHOOSE b : \A f : f \in b <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i
bijectionsExists == \A d : \A i : \A f : f \in Bijections(d,i) <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i
THEOREM bijectionsExists
PROOF
\* By separation in SUBSET (d \X i)
VARIABLES a,b,c,d,f,g,i,x,y,z;
\A a : \E b : \A x : x \in b <=> x \in a /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i)   BECAUSE \A(a <- SUBSET (d \X i));
powersetExists   BECAUSE AXIOM;
x \in SUBSET (d \X i) <=> x \subseteq (d \X i)   BECAUSE \A(x <- d \X i, z <- x);
x \subseteq (d \X i) => x \in SUBSET (d \X i)   BECAUSE EquivToImplReverse;

h(d,i,x,z) == IsInjection(x) /\ Domain(x) = d /\ Image(x) = i /\ z \in x; \* Prove that z \in d \X i
h(d,i,x,z) => h(d,i,x,z)   BECAUSE ImplySelf;
h(d,i,x,z) => IsInjection(x)   BECAUSE S14;
IsInjection(x) => IsFunction(x)   BECAUSE S12;
IsFunction(x) => IsGraph(x)   BECAUSE S12;
h(d,i,x,z) => IsFunction(x)   BECAUSE TI;
h(d,i,x,z) => IsGraph(x)   BECAUSE TI;
IsGraph(a) => (z \in a => IsCouple(z))   BECAUSE \A(x <- z);
\A a : IsGraph(a) => (z \in a => IsCouple(z))   BECAUSE GENERALIZATION;
IsGraph(x) => (z \in x => IsCouple(z))   BECAUSE \A(a <- x);
IsGraph(x) /\ z \in x => IsCouple(z)   BECAUSE HypoImplToAnd;
h(d,i,x,z) => z \in x   BECAUSE S22;
h(d,i,x,z) => IsGraph(x) /\ z \in x   BECAUSE CIA;
h(d,i,x,z) => IsCouple(z)   BECAUSE TI;
domainExists   BECAUSE THEOREM;
fst(z) \in Domain(x) <=> IsDefinedOn(x,fst(z))   BECAUSE \A(g <- x, x <- fst(z));
(\E y : <<fst(z),y>> \in x) => fst(z) \in Domain(x)   BECAUSE EquivToImplReverse;
tupleComposition   BECAUSE THEOREM;
IsCouple(z) => z = <<fst(z), snd(z)>>   BECAUSE \A(c <- z);
h(d,i,x,z) => z = <<fst(z), snd(z)>>   BECAUSE TI;
<<fst(z), snd(z)>> \in x => (\E y : <<fst(z),y>> \in x)   BECAUSE \E(y <- snd(z));
<<fst(z), snd(z)>> \in x => fst(z) \in Domain(x)   BECAUSE TI;
<<fst(z), snd(z)>> \in x => fst(z) \in Domain(x)   BECAUSE TI;
\A z : \A y : z = y => (z \in x <=> y \in x)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in x <=> <<fst(z), snd(z)>> \in x)   BECAUSE \A(z <- z, y <- <<fst(z), snd(z)>>);
h(d,i,x,z) => (z \in x <=> <<fst(z), snd(z)>> \in x)   BECAUSE TI;
h(d,i,x,z) /\ z \in x => <<fst(z), snd(z)>> \in x   BECAUSE HypoEquivToAnd;
h(d,i,x,z) => h(d,i,x,z) /\ z \in x   BECAUSE CIA;
h(d,i,x,z) => <<fst(z), snd(z)>> \in x   BECAUSE TI;
h(d,i,x,z) => fst(z) \in Domain(x)   BECAUSE TI;

imageExists   BECAUSE THEOREM;
snd(z) \in Image(a) <=> Reaches(a,snd(z))   BECAUSE \A(g <- a, y <- snd(z));
(\E x : <<x,snd(z)>> \in a) => snd(z) \in Image(a)   BECAUSE EquivToImplReverse;
<<fst(z), snd(z)>> \in a => (\E x : <<x,snd(z)>> \in a)   BECAUSE \E(x <- fst(z));
<<fst(z), snd(z)>> \in a => snd(z) \in Image(a)   BECAUSE TI;
\A a : <<fst(z), snd(z)>> \in a => snd(z) \in Image(a)   BECAUSE GENERALIZATION;
<<fst(z), snd(z)>> \in x => snd(z) \in Image(x)   BECAUSE \A(a <- x);
h(d,i,x,z) => snd(z) \in Image(x)   BECAUSE TI;
h(d,i,x,z) => fst(z) \in Domain(x) /\ snd(z) \in Image(x)   BECAUSE CIA;
cartesianProductCouples   BECAUSE THEOREM;
(fst(z) \in Domain(x) /\ snd(z) \in Image(x)) <=> <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))
   BECAUSE \A(x <- Domain(x), y <- Image(x), a <- fst(z), b <- snd(z));
(fst(z) \in Domain(x) /\ snd(z) \in Image(x)) => <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE EquivToImpl;
h(d,i,x,z) => <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE TI;
\A a : \A x : \A b : \A y : \A c : \A z : a = x /\ b = y /\ c = z => (a \in (b \X c) <=> x \in (y \X z))   BECAUSE E_SCHEME;
<<fst(z), snd(z)>> = z /\ Domain(x) = d /\ Image(x) = i => (<<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) <=> z \in (d \X i))
   BECAUSE \A(a <- <<fst(z),snd(z)>>, x <- z, b <- Domain(x), y <- d, c <- Image(x), z <- i);
z = <<fst(z), snd(z)>> => <<fst(z), snd(z)>> = z   BECAUSE E_SCHEME;
h(d,i,x,z) => <<fst(z), snd(z)>> = z   BECAUSE TI;
h(d,i,x,z) => IsInjection(x) /\ Domain(x) = d   BECAUSE S13;
IsInjection(x) /\ Domain(x) = d => Domain(x) = d   BECAUSE S22;
h(d,i,x,z) => Domain(x) = d   BECAUSE TI;
h(d,i,x,z) => <<fst(z), snd(z)>> = z /\ Domain(x) = d   BECAUSE CIA;
h(d,i,x,z) => Image(x) = i   BECAUSE S23;
h(d,i,x,z) => <<fst(z), snd(z)>> = z /\ Domain(x) = d /\ Image(x) = i   BECAUSE CIA;
h(d,i,x,z) => (<<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) <=> z \in (d \X i))   BECAUSE TI;
h(d,i,x,z) /\ <<fst(z), snd(z)>> \in (Domain(x) \X Image(x)) => z \in (d \X i)   BECAUSE HypoEquivToAnd;
h(d,i,x,z) => h(d,i,x,z) /\ <<fst(z), snd(z)>> \in (Domain(x) \X Image(x))   BECAUSE CIA;
h(d,i,x,z) => z \in (d \X i)   BECAUSE TI;

IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => (z \in x => z \in (d \X i))   BECAUSE HypoAndToImpl;
\A z : IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => (z \in x => z \in (d \X i))   BECAUSE GENERALIZATION;
IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => x \subseteq (d \X i)   BECAUSE Q_SCHEME;
IsInjection(x) /\ Domain(x) = d /\ Image(x) = i => x \in SUBSET (d \X i)   BECAUSE TI;
(x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))   BECAUSE SeparationTauto;
(\A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))   BECAUSE Q_SCHEME;
(\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE \A(x <- f);
\A f : (\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE GENERALIZATION;
(\A x : x \in b <=> (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE Q_SCHEME;
(\A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE TI;
(\E b : \A x : x \in b <=> x \in SUBSET (d \X i) /\ (IsInjection(x) /\ Domain(x) = d /\ Image(x) = i))
   => (\E b : \A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i))   BECAUSE Q_SCHEME;
\E b : \A f : f \in b <=> (IsInjection(f) /\ Domain(f) = d /\ Image(f) = i)   BECAUSE MODUS_PONENS;
\A f : f \in Bijections(d,i) <=> IsInjection(f) /\ Domain(f) = d /\ Image(f) = i   BECAUSE CHOOSE Bijections(d,i);
bijectionsExists   BECAUSE GENERALIZATION;
QED

funcInversePre == \A f : \A y : IsFunction(f) /\ y \in Image(f) => f[pre(f,y)] = y
THEOREM funcInversePre
PROOF
VARIABLES a,b,f,g,x,y;
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
y \in Image(f) => \E x : <<x,y>> \in f   BECAUSE EquivToImpl;
(\E x : <<x,y>> \in f) => <<pre(f,y),y>> \in f   BECAUSE CHOOSE pre(f,y);
y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE TI;
funcVal   BECAUSE THEOREM;
IsFunction(f) /\ <<pre(f,y),y>> \in f => y = f[pre(f,y)]   BECAUSE \A(f <- f, x <- pre(f,y), y <- y);
IsFunction(f) => IsFunction(f)   BECAUSE ImplySelf;
IsFunction(f) /\ y \in Image(f) => IsFunction(f) /\ <<pre(f,y),y>> \in f   BECAUSE MergeImplicationsAnd;
IsFunction(f) /\ y \in Image(f) => y = f[pre(f,y)]   BECAUSE TI;
y = f[pre(f,y)] => f[pre(f,y)] = y   BECAUSE E_SCHEME;
IsFunction(f) /\ y \in Image(f) => f[pre(f,y)] = y   BECAUSE TI;
funcInversePre   BECAUSE GENERALIZATION;
QED

funcEqual == \A f : \A g : IsFunction(f) /\ IsFunction(g) /\ Domain(f) = Domain(g)
   /\ (\A x : x \in Domain(f) => f[x] = g[x])
   => f = g
THEOREM funcEqual
PROOF
VARIABLES a,b,c,f,g,x,y,z;
mainHypo(f,g) == IsFunction(f) /\ IsFunction(g) /\ Domain(f) = Domain(g)
   /\ (\A x : x \in Domain(f) => f[x] = g[x]);
mainHypo(f,g) => IsFunction(f)   BECAUSE S14;
mainHypo(f,g) => IsFunction(g)   BECAUSE S24;
h(f,g,x,y) == mainHypo(f,g) /\ <<x,y>> \in f;
\* Prove that h(f,g,x,y) => <<x,y>> \in g
domainExists   BECAUSE THEOREM;
x \in Domain(f) <=> IsDefinedOn(f,x)   BECAUSE \A(g <- f, x <- x);
IsDefinedOn(f,x) => x \in Domain(f)   BECAUSE EquivToImplReverse;
<<x,y>> \in f => IsDefinedOn(f,x)   BECAUSE \E(y <- y);
h(f,g,x,y) => <<x,y>> \in f   BECAUSE S22;
h(f,g,x,y) => x \in Domain(f)   BECAUSE TI2;
h(f,g,x,y) => mainHypo(f,g)   BECAUSE S12;
funcVal   BECAUSE THEOREM;
IsFunction(f) /\ <<x,y>> \in f => y = f[x]   BECAUSE \A(f <- f, x <- x, y <- y);
IsFunction(f) => (<<x,y>> \in f => y = f[x])   BECAUSE HypoAndToImpl;
h(f,g,x,y) => (<<x,y>> \in f => y = f[x])   BECAUSE TI2;
h(f,g,x,y) => y = f[x]   BECAUSE KillMiddleHypo;
mainHypo(f,g) => (\A x : x \in Domain(f) => f[x] = g[x])   BECAUSE S22;
(\A x : x \in Domain(f) => f[x] = g[x]) => (x \in Domain(f) => f[x] = g[x])   BECAUSE \A(x <- x);
h(f,g,x,y) => (x \in Domain(f) => f[x] = g[x])   BECAUSE TI2;
h(f,g,x,y) => f[x] = g[x]   BECAUSE KillMiddleHypo;
f[x] = g[x] => g[x] = f[x]   BECAUSE E_SCHEME;
h(f,g,x,y) => g[x] = f[x]   BECAUSE TI;
h(f,g,x,y) => y = f[x] /\ g[x] = f[x]   BECAUSE CIA;
y = f[x] /\ g[x] = f[x] => y = g[x]   BECAUSE E_SCHEME;
h(f,g,x,y) => y = g[x]   BECAUSE TI;
domainExists   BECAUSE THEOREM;
funcImageExists   BECAUSE THEOREM;
IsFunction(g) /\ x \in Domain(g) => <<x, g[x]>> \in g   BECAUSE \A(f <- g, x <- x);
\A a : \A b : a = b => (x \in a <=> x \in b)   BECAUSE E_SCHEME;
Domain(f) = Domain(g) => (x \in Domain(f) <=> x \in Domain(g))   BECAUSE \A(a <- Domain(f), b <- Domain(g));
h(f,g,x,y) => Domain(f) = Domain(g)   BECAUSE S24;
(x \in Domain(f) <=> x \in Domain(g)) => (x \in Domain(f) => x \in Domain(g))   BECAUSE EquivToImpl;
h(f,g,x,y) => (x \in Domain(f) => x \in Domain(g))   BECAUSE TI2;
h(f,g,x,y) => x \in Domain(g)   BECAUSE KillMiddleHypo;
h(f,g,x,y) => IsFunction(g)   BECAUSE TI;
h(f,g,x,y) => IsFunction(g) /\ x \in Domain(g)   BECAUSE CIA;
h(f,g,x,y) => <<x,g[x]>> \in g   BECAUSE TI;
\A a : \A b : a = b => (<<x,a>> \in g <=> <<x,b>> \in g)   BECAUSE E_SCHEME;
y = g[x] => (<<x,y>> \in g <=> <<x,g[x]>> \in g)   BECAUSE \A(a <- y, b <- g[x]);
(<<x,y>> \in g <=> <<x,g[x]>> \in g) => (<<x,g[x]>> \in g => <<x,y>> \in g)   BECAUSE EquivToImplReverse;
h(f,g,x,y) => (<<x,g[x]>> \in g => <<x,y>> \in g)   BECAUSE TI2;
h(f,g,x,y) => <<x,y>> \in g   BECAUSE KillMiddleHypo;

\A x : \A y : h(f,g,x,y) => <<x,y>> \in g   BECAUSE GENERALIZATION;
h(f,g,fst(z),snd(z)) => <<fst(z),snd(z)>> \in g   BECAUSE \A(x <- fst(z), y <- snd(z));
hh(f,g,z) == mainHypo(f,g) /\ z \in f;
hh(f,g,z) => mainHypo(f,g)   BECAUSE S12;
IsFunction(f) => IsGraph(f)   BECAUSE S12;
IsGraph(f) => (z \in f => IsCouple(z))   BECAUSE \A(x <- z);
hh(f,g,z) => IsGraph(f)   BECAUSE TI2;
hh(f,g,z) => (z \in f => IsCouple(z))   BECAUSE TI;
hh(f,g,z) => z \in f   BECAUSE S22;
hh(f,g,z) => IsCouple(z)   BECAUSE KillMiddleHypo;
tupleComposition   BECAUSE THEOREM;
IsCouple(z) => z = <<fst(z), snd(z)>>   BECAUSE \A(c <- z);
hh(f,g,z) => z = <<fst(z), snd(z)>>   BECAUSE TI;
\A a : \A b : a = b => (a \in f <=> b \in f)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in f <=> <<fst(z), snd(z)>> \in f)  BECAUSE \A(a <- z, b <- <<fst(z), snd(z)>>);
(z \in f <=> <<fst(z), snd(z)>> \in f) => (z \in f => <<fst(z), snd(z)>> \in f)   BECAUSE EquivToImpl;
hh(f,g,z) => (z \in f => <<fst(z), snd(z)>> \in f)  BECAUSE TI2;
hh(f,g,z) => <<fst(z), snd(z)>> \in f  BECAUSE KillMiddleHypo;
hh(f,g,z) => h(f,g,fst(z),snd(z))  BECAUSE CIA;
hh(f,g,z) => <<fst(z),snd(z)>> \in g  BECAUSE TI;
\A a : \A b : a = b => (a \in g <=> b \in g)   BECAUSE E_SCHEME;
z = <<fst(z), snd(z)>> => (z \in g <=> <<fst(z), snd(z)>> \in g)  BECAUSE \A(a <- z, b <- <<fst(z), snd(z)>>);
(z \in g <=> <<fst(z), snd(z)>> \in g) => (<<fst(z), snd(z)>> \in g => z \in g)   BECAUSE EquivToImplReverse;
hh(f,g,z) => (<<fst(z), snd(z)>> \in g => z \in g)  BECAUSE TI2;
hh(f,g,z) => z \in g  BECAUSE KillMiddleHypo;
mainHypo(f,g) => (z \in f => z \in g)  BECAUSE HypoAndToImpl;
\A z : mainHypo(f,g) => (z \in f => z \in g)  BECAUSE GENERALIZATION;
mainHypo(f,g) => f \subseteq g  BECAUSE Q_SCHEME;

\* Prove g \subseteq f by variable swapping
\A f : \A g : mainHypo(f,g) => f \subseteq g  BECAUSE GENERALIZATION;
mainHypo(g,f) => g \subseteq f  BECAUSE \A(f <- g, g <- f);
Domain(f) = Domain(g) => Domain(g) = Domain(f)   BECAUSE E_SCHEME;
mainHypo(f,g) => Domain(f) = Domain(g)   BECAUSE S23;
mainHypo(f,g) => Domain(g) = Domain(f)   BECAUSE TI;
mainHypo(f,g) => IsFunction(g) /\ IsFunction(f)   BECAUSE CIA;
mainHypo(f,g) => IsFunction(g) /\ IsFunction(f) /\ Domain(g) = Domain(f)   BECAUSE CIA;
f[x] = g[x] => g[x] = f[x]   BECAUSE E_SCHEME;
introHypo(a,b,h) == (a => b) => ((h => a) => (h => b))   PROPO_TAUTO;
(x \in Domain(f) => f[x] = g[x]) => (x \in Domain(f) => g[x] = f[x])   BECAUSE introHypo;
mainHypo(f,g) => (x \in Domain(f) => g[x] = f[x])   BECAUSE TI2;
\A a : \A b : a = b => ((x \in a => g[x] = f[x]) <=> (x \in b => g[x] = f[x]))   BECAUSE E_SCHEME;
Domain(f) = Domain(g) => ((x \in Domain(f) => g[x] = f[x]) <=> (x \in Domain(g) => g[x] = f[x]))   BECAUSE \A(a <- Domain(f), b <- Domain(g));
((x \in Domain(f) => g[x] = f[x]) <=> (x \in Domain(g) => g[x] = f[x])) => ((x \in Domain(f) => g[x] = f[x]) => (x \in Domain(g) => g[x] = f[x]))  BECAUSE EquivToImpl;
mainHypo(f,g) => ((x \in Domain(f) => g[x] = f[x]) => (x \in Domain(g) => g[x] = f[x]))   BECAUSE TI2;
mainHypo(f,g) => (x \in Domain(g) => g[x] = f[x])   BECAUSE KillMiddleHypo;
\A x : mainHypo(f,g) => (x \in Domain(g) => g[x] = f[x])   BECAUSE GENERALIZATION;
mainHypo(f,g) => (\A x : x \in Domain(g) => g[x] = f[x])   BECAUSE Q_SCHEME;
mainHypo(f,g) => mainHypo(g,f)   BECAUSE CIA;
mainHypo(f,g) => g \subseteq f   BECAUSE TI;
mainHypo(f,g) => f \subseteq g /\ g \subseteq f   BECAUSE CIA;
bothInclusions   BECAUSE THEOREM;
(f \subseteq g /\ g \subseteq f) => f = g   BECAUSE \A(a <- f, b <- g);
mainHypo(f,g) => f = g   BECAUSE TI;
funcEqual   BECAUSE GENERALIZATION;
QED

(*
   Convenience axiom scheme for defining functions from term formulas.
   Can be weakened to the separation axiom scheme when we have a set containing
   F(a).

   Could be deduced as :

   \* replacement scheme with formula IsCouple(y) /\ fst(y) = x /\ y = F instead of F.
   \* This is a correct formula when F is a term.
   (\A x : \A y : \A z : ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F)
                           /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F)) => y = z)
      => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))
      BECAUSE AXIOM_SCHEME; \* F(y <- z) equals F, because by hypothesis, variable y has no free occurrences in F. Also, F does not have occurrences of b by hypothesis.

   \* Prove that y = F is functional. 
   IsCouple(y) /\ fst(y) = x /\ snd(y) = F => IsCouple(y)   BECAUSE S13;
   IsCouple(y) /\ fst(y) = x /\ snd(y) = F => fst(y) = x   BECAUSE S23;
   IsCouple(y) /\ fst(y) = x /\ snd(y) = F => snd(y) = F   BECAUSE S22;
   IsCouple(z) /\ fst(z) = x /\ snd(z) = F => IsCouple(z)   BECAUSE S13;
   IsCouple(z) /\ fst(z) = x /\ snd(z) = F => fst(z) = x   BECAUSE S23;
   IsCouple(z) /\ fst(z) = x /\ snd(z) = F => snd(z) = F   BECAUSE S22;
   tupleComposition   BECAUSE THEOREM;
   IsCouple(y) => y = <<fst(y), snd(y)>>   BECAUSE \A(c <- y);
   IsCouple(z) => z = <<fst(z), snd(z)>>   BECAUSE \A(c <- z);
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)   BECAUSE S12;
   IsCouple(y) /\ fst(y) = x /\ snd(y) = F => IsCouple(y)   BECAUSE S13;
   IsCouple(y) /\ fst(y) = x /\ snd(y) = F => fst(y) = x   BECAUSE S23;
   IsCouple(y) /\ fst(y) = x /\ snd(y) = F => snd(y) = F   BECAUSE S22;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => fst(y) = x   BECAUSE TI;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => snd(y) = F   BECAUSE TI;

   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => (IsCouple(z) /\ fst(z) = x /\ snd(z) = F)   BECAUSE S22;
   IsCouple(z) /\ fst(z) = x /\ snd(z) = F => IsCouple(z)   BECAUSE S13;
   IsCouple(z) /\ fst(z) = x /\ snd(z) = F => fst(z) = x   BECAUSE S23;
   IsCouple(z) /\ fst(z) = x /\ snd(z) = F => snd(z) = F   BECAUSE S22;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => fst(z) = x   BECAUSE TI;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => snd(z) = F   BECAUSE TI;

   fst(y) = x /\ fst(z) = x => fst(y) = fst(z)   BECAUSE E_SCHEME;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => fst(y) = x /\ fst(z) = x   BECAUSE CIA;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => fst(y) = fst(z)   BECAUSE TI;

   snd(y) = F /\ snd(z) = F => snd(y) = snd(z)   BECAUSE E_SCHEME;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => snd(y) = F /\ snd(z) = F   BECAUSE CIA;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => snd(y) = snd(z)   BECAUSE TI;

   \A x : \A y : \A a : \A b : x = y /\ a = b => (<<x,a>> = <<y,b>>)   BECAUSE E_SCHEME;
   fst(y) = fst(z) /\ snd(y) = snd(z) => (<<fst(y),snd(y)>> = <<fst(z),snd(z)>>)   BECAUSE \A(x <- fst(y), y <- fst(z), a <- snd(y), b <- snd(z));
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => fst(y) = fst(z) /\ snd(y) = snd(z)   BECAUSE CIA;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => <<fst(y),snd(y)>> = <<fst(z),snd(z)>>   BECAUSE TI;
   \A x : \A y : \A a : \A b : x = y /\ a = b => (x = a <=> y = b)   BECAUSE E_SCHEME;
   y = <<fst(y),snd(y)>> /\ z = <<fst(z),snd(z)>> => (y = z <=> <<fst(y),snd(y)>> = <<fst(z),snd(z)>>)
      BECAUSE \A(x <- y, y <- <<fst(y),snd(y)>>, a <- z, b <- <<fst(z),snd(z)>>);
   IsCouple(y) /\ IsCouple(z) => y = <<fst(y),snd(y)>> /\ z = <<fst(z),snd(z)>>   BECAUSE MergeImplicationsAnd;
   IsCouple(y) /\ IsCouple(z) => (y = z <=> <<fst(y),snd(y)>> = <<fst(z),snd(z)>>)   BECAUSE TI;
   (y = z <=> <<fst(y),snd(y)>> = <<fst(z),snd(z)>>) => (<<fst(y),snd(y)>> = <<fst(z),snd(z)>> => y = z)   BECAUSE EquivToImplReverse;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => IsCouple(y) /\ IsCouple(z)   BECAUSE MergeImplicationsAnd;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => (y = z <=> <<fst(y),snd(y)>> = <<fst(z),snd(z)>>)   BECAUSE TI;
   implyEquivTrue(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
   ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F))
      => y = z   BECAUSE implyEquivTrue;

   \A x : \A y : \A z : ((IsCouple(y) /\ fst(y) = x /\ snd(y) = F) /\ (IsCouple(z) /\ fst(z) = x /\ snd(z) = F)) => y = z   BECAUSE GENERALIZATION;
   \A a : \E b : \A y : y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)   BECAUSE MODUS_PONENS;
   \E b : \A y : y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)   BECAUSE \A(a <- a);

   \* Prove that b is a graph
   h(a,b) == \A y : y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F); \* h should also declare F's free variables
   h(a,b) => (y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))   BECAUSE \A(y <- y);
   (y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))
      => (y \in b => \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))   BECAUSE EquivToImpl;
   h(a,b) => (y \in b => \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))   BECAUSE TI;
   h(a,b) /\ y \in b => \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)   BECAUSE HypoImplToAnd;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)
      => (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)   BECAUSE S22;
   (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => IsCouple(y)   BECAUSE S13;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => IsCouple(y)   BECAUSE TI;
   (\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => \E x : IsCouple(y)   BECAUSE Q_SCHEME;
   h(a,b) /\ y \in b => \E x : IsCouple(y)   BECAUSE TI;
   (\E x : IsCouple(y)) => IsCouple(y)   BECAUSE Q_SCHEME;
   h(a,b) /\ y \in b => IsCouple(y)   BECAUSE TI;
   \A y : h(a,b) /\ y \in b => IsCouple(y)   BECAUSE GENERALIZATION;
   h(a,b) /\ x \in b => IsCouple(x)   BECAUSE \A(y <- x);
   h(a,b) => (x \in b => IsCouple(x))   BECAUSE HypoAndToImpl;
   \A x : h(a,b) => (x \in b => IsCouple(x))   BECAUSE GENERALIZATION;
   h(a,b) => IsGraph(b)   BECAUSE Q_SCHEME;

   \* Prove that b is a function
   (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => snd(y) = F   BECAUSE S22;
   (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => fst(y) = x   BECAUSE S23;
   \A x : \A y : x = y => (F = F(x <- y))   BECAUSE E_SCHEME;
   x = fst(y) => (F = F(x <- fst(y)))   BECAUSE \A(x <- x, y <- fst(y));
   fst(y) = x => x = fst(y)   BECAUSE E_SCHEME;
   (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => x = fst(y)   BECAUSE TI;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => F = F(x <- fst(y))   BECAUSE TI2;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => snd(y) = F   BECAUSE TI;
   snd(y) = F => F = snd(y)   BECAUSE E_SCHEME;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => F = snd(y)   BECAUSE TI;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => F = snd(y) /\ F = F(x <- fst(y))   BECAUSE CIA;
   F = snd(y) /\ F = F(x <- fst(y)) => snd(y) = F(x <- fst(y))   BECAUSE E_SCHEME;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => snd(y) = F(x <- fst(y))   BECAUSE TI;
   (\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))
      => \E x : snd(y) = F(x <- fst(y))   BECAUSE Q_SCHEME;
   h(a,b) /\ y \in b => \E x : snd(y) = F(x <- fst(y))   BECAUSE TI;
   (\E x : snd(y) = F(x <- fst(y))) => snd(y) = F(x <- fst(y))   BECAUSE Q_SCHEME; \* Ok, the free occurrences of x in F were replaced by fst(y)
   h(a,b) /\ y \in b => snd(y) = F(x <- fst(y))   BECAUSE TI;
   \A a : \A b : \A y : h(a,b) /\ y \in b => snd(y) = F(x <- fst(y))   BECAUSE GENERALIZATION;
   \* For variables i,j take any variables that have no free occurrences in F
   h(i,j) /\ <<a,b>> \in j => snd(<<a,b>>) = F(x <- fst(<<a,b>>))   BECAUSE \A(a <- i, b <- j, y <- <<a,b>>);
   fstExists   BECAUSE THEOREM;
   a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
   sndExists   BECAUSE THEOREM;
   b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
   \A i : \A j : \A a : \A b : i = j /\ a = b => (i = F(x <- a) <=> j = F(x <- b))   BECAUSE E_SCHEME;
   b = snd(<<a,b>>) /\ a = fst(<<a,b>>) => (b = F(x <- a) <=> snd(<<a,b>>) = F(x <- fst(<<a,b>>)))
      BECAUSE \A(i <- b, j <- snd(<<a,b>>), a <- a, b <- fst(<<a,b>>));
   b = snd(<<a,b>>) /\ a = fst(<<a,b>>)   BECAUSE IntroAndRight;
   b = F(x <- a) <=> snd(<<a,b>>) = F(x <- fst(<<a,b>>))   BECAUSE MODUS_PONENS;
   h(i,j) /\ <<a,b>> \in j => (b = F(x <- a) <=> snd(<<a,b>>) = F(x <- fst(<<a,b>>)))   BECAUSE PT1;
   h(i,j) /\ <<a,b>> \in j => b = F(x <- a)   BECAUSE implyEquivTrue;
   \A b : h(i,j) /\ <<a,b>> \in j => b = F(x <- a)   BECAUSE GENERALIZATION;
   h(i,j) /\ <<a,c>> \in j => c = F(x <- a)   BECAUSE \A(b <- c);
   b = F(x <- a) /\ c = F(x <- a) => b = c   BECAUSE E_SCHEME;
   mergeImpl(a,b,c,d,h) == (h /\ a => b) => ((h /\ c => d) => (h /\ (a /\ c) => b /\ d))   PROPO_TAUTO;
   h(i,j) /\ (<<a,b>> \in j /\ <<a,c>> \in j) => b = F(x <- a) /\ c = F(x <- a)   BECAUSE mergeImpl;
   h(i,j) /\ (<<a,b>> \in j /\ <<a,c>> \in j) => b = c   BECAUSE TI;
   h(i,j) => ((<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE HypoAndToImpl;
   \A c : h(i,j) => ((<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE GENERALIZATION;
   h(i,j) => (\A c : (<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE Q_SCHEME;
   \A b : h(i,j) => (\A c : (<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE GENERALIZATION;
   h(i,j) => (\A b : \A c : (<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE Q_SCHEME;
   \A a : h(i,j) => (\A b : \A c : (<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE GENERALIZATION;
   h(i,j) => (\A a : \A b : \A c : (<<a,b>> \in j /\ <<a,c>> \in j) => b = c)   BECAUSE Q_SCHEME;
   \A a : \A b : h(a,b) => IsGraph(b)   BECAUSE GENERALIZATION;
   h(i,j) => IsGraph(j)   BECAUSE \A(a <- i, b <- j);
   h(i,j) => IsFunction(j)   BECAUSE CIA;
   \A i : \A j : h(i,j) => IsFunction(j)   BECAUSE GENERALIZATION;
   h(a,b) => IsFunction(b)   BECAUSE \A(i <- a, j <- b);

   \* Prove that Domain(b) = a
   (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => fst(y) = x   BECAUSE S23;
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => x \in a   BECAUSE S12;
   \A y : \A x : y = x => (y \in a <=> x \in a)   BECAUSE E_SCHEME;
   fst(y) = x => (fst(y) \in a <=> x \in a)   BECAUSE \A(y <- fst(y), x <- x);
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => (fst(y) \in a <=> x \in a)   BECAUSE TI2; 
   x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F) => fst(y) \in a   BECAUSE implyEquivTrue;

   (\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => \E x : fst(y) \in a   BECAUSE Q_SCHEME;
   (\E x : fst(y) \in a) => fst(y) \in a   BECAUSE Q_SCHEME;
   (\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => fst(y) \in a   BECAUSE TI;
   h(a,b) /\ y \in b => fst(y) \in a   BECAUSE TI;

   \A y : h(a,b) /\ y \in b => fst(y) \in a   BECAUSE GENERALIZATION;
   h(a,b) /\ <<z,y>> \in b => fst(<<z,y>>) \in a   BECAUSE \A(y <- <<z,y>>);
   fst(<<z,y>>) = z => (fst(<<z,y>>) \in a <=> z \in a)   BECAUSE \A(y <- fst(<<z,y>>), x <- z);
   z = fst(<<z,y>>)   BECAUSE \A(a <- z, b <- y);
   z = fst(<<z,y>>) => fst(<<z,y>>) = z   BECAUSE E_SCHEME;
   fst(<<z,y>>) = z   BECAUSE MODUS_PONENS;
   (fst(<<z,y>>) \in a <=> z \in a)   BECAUSE MODUS_PONENS;
   (fst(<<z,y>>) \in a => z \in a)   BECAUSE EquivToImpl;
   h(a,b) /\ <<z,y>> \in b => z \in a   BECAUSE TI;

   h(a,b) => (<<z,y>> \in b => z \in a)   BECAUSE HypoAndToImpl;
   \A y : h(a,b) => (<<z,y>> \in b => z \in a)   BECAUSE GENERALIZATION;
   h(a,b) => (\A y : <<z,y>> \in b => z \in a)   BECAUSE Q_SCHEME;
   (\A y : <<z,y>> \in b => z \in a) => ((\E y : <<z,y>> \in b) => \E y : z \in a)   BECAUSE Q_SCHEME;
   h(a,b) => ((\E y : <<z,y>> \in b) => \E y : z \in a)   BECAUSE TI;
   domainExists   BECAUSE THEOREM;
   z \in Domain(b) <=> IsDefinedOn(b,z)   BECAUSE \A(g <- b, x <- z);
   z \in Domain(b) => IsDefinedOn(b,z)   BECAUSE EquivToImpl;
   injectHypo(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
   h(a,b) /\ z \in Domain(b) => \E y : z \in a   BECAUSE injectHypo;
   (\E y : z \in a) => z \in a   BECAUSE Q_SCHEME;
   h(a,b) /\ z \in Domain(b) => z \in a   BECAUSE TI;
   h(a,b) => (z \in Domain(b) => z \in a)   BECAUSE HypoAndToImpl;
   \A z : h(a,b) => (z \in Domain(b) => z \in a)   BECAUSE GENERALIZATION;
   h(a,b) => Domain(b) \subseteq a   BECAUSE Q_SCHEME;

   (y \in b <=> \E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))
      => ((\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => y \in b)   BECAUSE EquivToImplReverse;
   h(a,b) => ((\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => y \in b)   BECAUSE TI;
   (x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))
      => (\E x : x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F))   BECAUSE \E(x <- x);
   h(a,b) /\ (x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => y \in b   BECAUSE injectHypo;
   \A y : h(a,b) /\ (x \in a /\ (IsCouple(y) /\ fst(y) = x /\ snd(y) = F)) => y \in b   BECAUSE GENERALIZATION;
   h(a,b) /\ (x \in a /\ (IsCouple(<<x,F>>) /\ fst(<<x,F>>) = x /\ snd(<<x,F>>) = F)) => <<x,F>> \in b   BECAUSE \A(y <- <<x,F>>); \* Because F has no free occurrence of variable y
   h(a,b) => ((x \in a /\ (IsCouple(<<x,F>>) /\ fst(<<x,F>>) = x /\ snd(<<x,F>>) = F)) => <<x,F>> \in b)   BECAUSE HypoAndToImpl;
   \* Show that h(a,b) /\ x \in a => <<x,F>> \in b
   equalSelf   BECAUSE THEOREM;
   <<a,b>> = <<a,b>>   BECAUSE \A(a <- <<a,b>>);
   IsCouple(<<a,b>>)   BECAUSE \E(x <- a, y <- b);
   \A a : \A b : IsCouple(<<a,b>>)   BECAUSE GENERALIZATION;
   IsCouple(<<x,F>>)   BECAUSE \A(a <- x, b <- F);
   x = fst(<<x,F>>)   BECAUSE \A(a <- x, b <- F);
   x = fst(<<x,F>>) => fst(<<x,F>>) = x   BECAUSE E_SCHEME;
   fst(<<x,F>>) = x   BECAUSE MODUS_PONENS;
   F = snd(<<x,F>>)   BECAUSE \A(a <- x, b <- F);
   F = snd(<<x,F>>) => snd(<<x,F>>) = F   BECAUSE E_SCHEME;
   snd(<<x,F>>) = F   BECAUSE MODUS_PONENS;
   IsCouple(<<x,F>>) /\ fst(<<x,F>>) = x   BECAUSE IntroAndRight;
   IsCouple(<<x,F>>) /\ fst(<<x,F>>) = x /\ snd(<<x,F>>) = F   BECAUSE IntroAndRight;
   x \in a => x \in a /\ (IsCouple(<<x,F>>) /\ fst(<<x,F>>) = x /\ snd(<<x,F>>) = F)   BECAUSE IntroAndLeft;
   h(a,b) /\ x \in a => <<x,F>> \in b   BECAUSE injectHypo;
   <<x,F>> \in b => IsDefinedOn(b,x)   BECAUSE \E(y <- F);
   x \in Domain(b) <=> IsDefinedOn(b,x)   BECAUSE \A(g <- b, x <- x);
   IsDefinedOn(b,x) => x \in Domain(b)    BECAUSE EquivToImplReverse;
   h(a,b) /\ x \in a => x \in Domain(b)   BECAUSE TI2;
   h(a,b) => (x \in a => x \in Domain(b))   BECAUSE HypoAndToImpl;
   \A x : h(a,b) => (x \in a => x \in Domain(b))   BECAUSE GENERALIZATION;
   h(a,b) => (z \in a => z \in Domain(b))   BECAUSE \A(x <- z);
   \A z : h(a,b) => (z \in a => z \in Domain(b))   BECAUSE GENERALIZATION;
   h(a,b) => a \subseteq Domain(b)   BECAUSE Q_SCHEME;
   bothInclusions   BECAUSE THEOREM;
   (Domain(b) \subseteq a /\ a \subseteq Domain(b)) => Domain(b) = a   BECAUSE \A(a <- Domain(b), b <- a);
   h(a,b) => Domain(b) \subseteq a /\ a \subseteq Domain(b)   BECAUSE CIA;
   h(a,b) => Domain(b) = a   BECAUSE TI;

   \* Prove that \A x : x \in a => b[x] = F
   funcVal   BECAUSE THEOREM;
   IsFunction(b) /\ <<x,F>> \in b => F = b[x]   BECAUSE \A(f <- b, x <- x, y <- F);
   h(a,b) /\ x \in a => h(a,b)   BECAUSE S12;
   h(a,b) /\ x \in a => IsFunction(b)   BECAUSE TI;
   h(a,b) /\ x \in a => IsFunction(b) /\ <<x,F>> \in b   BECAUSE CIA;
   h(a,b) /\ x \in a => F = b[x]   BECAUSE TI;
   F = b[x] => b[x] = F   BECAUSE E_SCHEME;
   h(a,b) /\ x \in a => b[x] = F   BECAUSE TI;
   h(a,b) => (x \in a => b[x] = F)   BECAUSE HypoAndToImpl;
   \A x : h(a,b) => (x \in a => b[x] = F)   BECAUSE GENERALIZATION;
   h(a,b) => (\A x : x \in a => b[x] = F)   BECAUSE Q_SCHEME;

   \* Prove that b is unique
   h(a,b) => IsFunction(b) /\ Domain(b) = a   BECAUSE CIA;
   h(a,b) => IsFunction(b) /\ Domain(b) = a /\ (\A x : x \in a => b[x] = F)   BECAUSE CIA;
   \A z : \A b : z = b => (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F) <=> IsFunction(b) /\ Domain(b) = a /\ (\A x : x \in a => b[x] = F))   BECAUSE E_SCHEME;
   z = b => (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F) <=> IsFunction(b) /\ Domain(b) = a /\ (\A x : x \in a => b[x] = F))   BECAUSE \A(z <- z, b <- b);
   implyEquivTrueB(h,t,a,b) == (h => t) => ((a => (b <=> t)) => (h /\ a => b))   PROPO_TAUTO;
   h(a,b) /\ z = b => (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F))   BECAUSE implyEquivTrueB;
   funcEqual   BECAUSE THEOREM;
   IsFunction(z) /\ IsFunction(b) /\ Domain(z) = Domain(b) /\ (\A x : x \in Domain(z) => z[x] = b[x])
      => z = b    BECAUSE \A(f <- z, g <- b);
   hh(a,b,z) == h(a,b) /\ (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F));
   hh(a,b,z) => h(a,b)   BECAUSE S12;
   hh(a,b,z) => IsFunction(b)   BECAUSE TI;
   hh(a,b,z) => Domain(b) = a   BECAUSE TI;
   (\A x : x \in a => b[x] = F) => (x \in a => b[x] = F)   BECAUSE \A(x <- x);
   hh(a,b,z) => (x \in a => b[x] = F)   BECAUSE TI2;
   hh(a,b,z) => (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F))   BECAUSE S22;
   (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)) => IsFunction(z)   BECAUSE S13;
   (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)) => Domain(z) = a   BECAUSE S23;
   (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)) => (\A x : x \in a => z[x] = F)   BECAUSE S22;
   hh(a,b,z) => IsFunction(z)   BECAUSE TI;
   hh(a,b,z) => Domain(z) = a   BECAUSE TI;
   (\A x : x \in a => z[x] = F) => (x \in a => z[x] = F)   BECAUSE \A(x <- x);
   hh(a,b,z) => (x \in a => z[x] = F)   BECAUSE TI2;
   hh(a,b,z) => Domain(z) = a /\ Domain(b) = a   BECAUSE CIA;
   Domain(z) = a /\ Domain(b) = a => Domain(z) = Domain(b)   BECAUSE E_SCHEME;
   hh(a,b,z) => Domain(z) = Domain(b)   BECAUSE TI;
   hh(a,b,z) => (x \in a => z[x] = F) /\ (x \in a => b[x] = F)   BECAUSE CIA;
   pullHypo(h,a,b,c) == (h => (a => b) /\ (a => c)) => (h /\ a => b /\ c)   PROPO_TAUTO;
   hh(a,b,z) /\ x \in a => z[x] = F /\ b[x] = F   BECAUSE pullHypo;
   z[x] = F /\ b[x] = F => z[x] = b[x]   BECAUSE E_SCHEME;
   hh(a,b,z) /\ x \in a => z[x] = b[x]   BECAUSE TI;
   hh(a,b,z) => (x \in a => z[x] = b[x])   BECAUSE HypoAndToImpl;
   \A i : \A j : i = j => ((x \in i => z[x] = b[x]) <=> (x \in j => z[x] = b[x]))   BECAUSE E_SCHEME;
   Domain(z) = a => ((x \in Domain(z) => z[x] = b[x]) <=> (x \in a => z[x] = b[x]))   BECAUSE \A(i <- Domain(z), j <- a);
   hh(a,b,z) => ((x \in Domain(z) => z[x] = b[x]) <=> (x \in a => z[x] = b[x]))   BECAUSE TI;
   hh(a,b,z) => (x \in Domain(z) => z[x] = b[x])   BECAUSE implyEquivTrue;
   \A x : hh(a,b,z) => (x \in Domain(z) => z[x] = b[x])   BECAUSE GENERALIZATION;
   hh(a,b,z) => (\A x : x \in Domain(z) => z[x] = b[x])   BECAUSE Q_SCHEME;
   hh(a,b,z) => IsFunction(z) /\ IsFunction(b)   BECAUSE CIA;
   hh(a,b,z) => IsFunction(z) /\ IsFunction(b) /\ Domain(z) = Domain(b)   BECAUSE CIA;
   hh(a,b,z) => IsFunction(z) /\ IsFunction(b) /\ Domain(z) = Domain(b) /\ (\A x : x \in Domain(z) => z[x] = b[x])   BECAUSE CIA;
   hh(a,b,z) => z = b   BECAUSE TI;

   h(a,b) => (z = b <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)))   BECAUSE HIE;
   \A z : h(a,b) => (z = b <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)))   BECAUSE GENERALIZATION;
   h(a,b) => (\A z : z = b <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)))   BECAUSE Q_SCHEME;
   (\E b : h(a,b)) => (\E b : \A z : z = b <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F)))   BECAUSE Q_SCHEME;
   \E b : \A z : z = b <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F))   BECAUSE MODUS_PONENS;
   \A a : \E b : \A z : z = b <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = F))   BECAUSE GENERALIZATION;   
*)
replacementFunc(F) == \A a : \E f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = a /\ \A x : x \in a => z[x] = F
AXIOM_SCHEME BOUND_VAR(f,y,z) replacementFunc


(*
   The identity function on a domain d. It takes each element
   of the domain and simply returns it.
*)
identity(d) == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = d /\ \A x : x \in d => z[x] = x

identityIsFunc == \A d : IsFunction(identity(d)) /\ Domain(identity(d)) = d
   /\ \A x : x \in d => identity(d)[x] = x
THEOREM identityIsFunc
PROOF
\* By separation in d \X d
VARIABLES a,b,c,d,f,i,j,x,y,z;
\A a : \E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = x))   BECAUSE AXIOM_SCHEME;
\E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = x))   BECAUSE \A(a <- d);
\A z : z = identity(d) <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = x))   BECAUSE CHOOSE identity(d);
identity(d) = identity(d) <=> (IsFunction(identity(d)) /\ Domain(identity(d)) = d /\ (\A x : x \in d => identity(d)[x] = x))   BECAUSE \A(z <- identity(d));
equalSelf   BECAUSE THEOREM;
identity(d) = identity(d)   BECAUSE \A(a <- identity(d));
(IsFunction(identity(d)) /\ Domain(identity(d)) = d /\ (\A x : x \in d => identity(d)[x] = x))   BECAUSE MODUS_PONENS;
identityIsFunc   BECAUSE GENERALIZATION;
QED

identityBiject == \A d : identity(d) \in Bijections(d,d)
THEOREM identityBiject
PROOF
VARIABLES a,b,c,d,f,g,i,j,x,y,z;
\* Prove IsInjection(identity(d))
identityIsFunc   BECAUSE THEOREM;
IsFunction(identity(d)) /\ Domain(identity(d)) = d /\ \A x : x \in d => identity(d)[x] = x
   BECAUSE \A(d <- d);
IsFunction(identity(d))   BECAUSE S13;
Domain(identity(d)) = d   BECAUSE S23;
\A x : x \in d => identity(d)[x] = x   BECAUSE S22;
a \in d => identity(d)[a] = a   BECAUSE \A(x <- a);
funcVal   BECAUSE THEOREM;
IsFunction(identity(d)) /\ <<a,b>> \in identity(d) => b = identity(d)[a]
   BECAUSE \A(f <- identity(d), x <- a, y <- b);
<<a,b>> \in identity(d) => IsFunction(identity(d)) /\ <<a,b>> \in identity(d)   BECAUSE IntroAndRight;
<<a,b>> \in identity(d) => b = identity(d)[a]   BECAUSE TI;
domainExists   BECAUSE THEOREM;
a \in Domain(identity(d)) <=> IsDefinedOn(identity(d),a)   BECAUSE \A(g <- identity(d), x <- a);
IsDefinedOn(identity(d),a) => a \in Domain(identity(d))   BECAUSE EquivToImplReverse;
<<a,b>> \in identity(d) => IsDefinedOn(identity(d),a)   BECAUSE \E(y <- b);
\A c : \A d : c = d => (a \in c <=> a \in d)   BECAUSE E_SCHEME;
Domain(identity(d)) = d => (a \in Domain(identity(d)) <=> a \in d)   BECAUSE \A(c <- Domain(identity(d)), d <- d);
a \in Domain(identity(d)) <=> a \in d   BECAUSE MODUS_PONENS;
a \in Domain(identity(d)) => a \in d   BECAUSE EquivToImpl;
<<a,b>> \in identity(d) => a \in d   BECAUSE TI2;
identity(d)[a] = a => a = identity(d)[a]   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => a = identity(d)[a]   BECAUSE TI2;
<<a,b>> \in identity(d) => b = identity(d)[a] /\ a = identity(d)[a]   BECAUSE CIA;
b = identity(d)[a] /\ a = identity(d)[a] => b = a   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => b = a   BECAUSE TI;

(\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE CHOOSE pre(f,y);
\A f : \A y : (\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE GENERALIZATION;
(\E x : <<x,b>> \in identity(d)) => <<pre(identity(d),b), b>> \in identity(d)   BECAUSE \A(f <- identity(d), y <- b);
<<a,b>> \in identity(d) => (\E x : <<x,b>> \in identity(d))   BECAUSE \E(x <- a);
\A a : <<a,b>> \in identity(d) => b = a   BECAUSE GENERALIZATION;
<<pre(identity(d),b), b>> \in identity(d) => b = pre(identity(d), b)   BECAUSE \A(a <- pre(identity(d), b));
<<a,b>> \in identity(d) => b = pre(identity(d),b)   BECAUSE TI2;
<<a,b>> \in identity(d) => b = a /\ b = pre(identity(d),b)   BECAUSE CIA;
b = a /\ b = pre(identity(d),b) => a = pre(identity(d),b)   BECAUSE E_SCHEME;
<<a,b>> \in identity(d) => a = pre(identity(d),b)   BECAUSE TI;
\A a : \A b : <<a,b>> \in identity(d) => a = pre(identity(d),b)   BECAUSE GENERALIZATION;
IsInjection(identity(d))   BECAUSE IntroAndRight;

\* Prove domain and image are d
Domain(identity(d)) = d   BECAUSE S23;

imageExists   BECAUSE THEOREM;
z \in Image(identity(d)) <=> Reaches(identity(d),z)   BECAUSE \A(g <- identity(d), y <- z);
z \in Image(identity(d)) => \E x : <<x,z>> \in identity(d)   BECAUSE EquivToImpl;
\A a : \A b : <<a,b>> \in identity(d) => b = a   BECAUSE GENERALIZATION;
<<x,z>> \in identity(d) => z = x   BECAUSE \A(a <- x, b <- z);
\A a : \A b : <<a,b>> \in identity(d) => a \in d   BECAUSE GENERALIZATION;
<<x,z>> \in identity(d) => x \in d   BECAUSE \A(a <- x, b <- z);
\A z : \A x : z = x => (z \in d <=> x \in d)   BECAUSE E_SCHEME;
z = x => (z \in d <=> x \in d)   BECAUSE \A(z <- z, x <- x);
<<x,z>> \in identity(d) => (z \in d <=> x \in d)   BECAUSE TI;
implyEquivTrue(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
<<x,z>> \in identity(d) => z \in d   BECAUSE implyEquivTrue;
(\E x : <<x,z>> \in identity(d)) => \E x : z \in d   BECAUSE Q_SCHEME;
(\E x : z \in d) => z \in d   BECAUSE Q_SCHEME;
z \in Image(identity(d)) => z \in d   BECAUSE TI2;
Image(identity(d)) \subseteq d   BECAUSE GENERALIZATION;
funcImageExists   BECAUSE THEOREM;
IsFunction(identity(d)) /\ z \in Domain(identity(d))
   => <<z, identity(d)[z]>> \in identity(d)   BECAUSE \A(f <- identity(d), x <- z);
z \in Domain(identity(d)) => IsFunction(identity(d)) /\ z \in Domain(identity(d))   BECAUSE IntroAndRight;
z \in Domain(identity(d)) => <<z, identity(d)[z]>> \in identity(d)   BECAUSE TI;
\A a : a \in Domain(identity(d)) <=> a \in d   BECAUSE GENERALIZATION;
z \in Domain(identity(d)) <=> z \in d   BECAUSE \A(a <- z);
z \in d => z \in Domain(identity(d))   BECAUSE EquivToImplReverse;
z \in d => <<z, identity(d)[z]>> \in identity(d)   BECAUSE TI;
z \in d => identity(d)[z] = z   BECAUSE \A(x <- z);
identity(d)[z] = z => z = identity(d)[z]   BECAUSE E_SCHEME;
z \in d => z = identity(d)[z]   BECAUSE TI;
\A a : \A b : a = b => (<<z, a>> \in identity(d) <=> <<z, b>> \in identity(d))   BECAUSE E_SCHEME;
z = identity(d)[z] => (<<z, z>> \in identity(d) <=> <<z, identity(d)[z]>> \in identity(d))   BECAUSE \A(a <- z, b <- identity(d)[z]);
z \in d => (<<z, z>> \in identity(d) <=> <<z, identity(d)[z]>> \in identity(d))   BECAUSE TI;
z \in d => <<z, z>> \in identity(d)   BECAUSE implyEquivTrue;
(\E x : <<x,z>> \in identity(d)) => z \in Image(identity(d))   BECAUSE EquivToImplReverse;
<<z, z>> \in identity(d) => (\E x : <<x,z>> \in identity(d))   BECAUSE \E(x <- z);
z \in d => z \in Image(identity(d))   BECAUSE TI2;
d \subseteq Image(identity(d))   BECAUSE GENERALIZATION;
bothInclusions   BECAUSE THEOREM;
(Image(identity(d)) \subseteq d /\ d \subseteq Image(identity(d))) => Image(identity(d)) = d
   BECAUSE \A(a <- Image(identity(d)), b <- d);
Image(identity(d)) \subseteq d /\ d \subseteq Image(identity(d))   BECAUSE IntroAndRight;
Image(identity(d)) = d   BECAUSE MODUS_PONENS;

IsInjection(identity(d)) /\ Domain(identity(d)) = d   BECAUSE IntroAndRight;
IsInjection(identity(d)) /\ Domain(identity(d)) = d /\ Image(identity(d)) = d   BECAUSE IntroAndRight;
bijectionsExists   BECAUSE THEOREM;
identity(d) \in Bijections(d,d) <=> IsInjection(identity(d)) /\ Domain(identity(d)) = d /\ Image(identity(d)) = d   BECAUSE \A(d <- d, i <- d, f <- identity(d));
identity(d) \in Bijections(d,d)   BECAUSE MODUS_PONENS;
identityBiject   BECAUSE GENERALIZATION;
QED

(*
   The constant function on a domain d, that returns c.
*)
const(d,k) == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = d /\ \A x : x \in d => z[x] = k

constExists == \A d : \A k : IsFunction(const(d,k)) /\ Domain(const(d,k)) = d
   /\ \A x : x \in d => const(d,k)[x] = k
THEOREM constExists
PROOF
VARIABLES a,b,d,k,z;
\A a : \E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = k))   BECAUSE AXIOM_SCHEME;
\E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = k))   BECAUSE \A(a <- d);
\A z : z = const(d,k) <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = k))   BECAUSE CHOOSE const(d,k);
const(d,k) = const(d,k) <=> (IsFunction(const(d,k)) /\ Domain(const(d,k)) = d /\ (\A x : x \in d => const(d,k)[x] = k))   BECAUSE \A(z <- const(d,k));
equalSelf   BECAUSE THEOREM;
const(d,k) = const(d,k)   BECAUSE \A(a <- const(d,k));
(IsFunction(const(d,k)) /\ Domain(const(d,k)) = d /\ (\A x : x \in d => const(d,k)[x] = k))   BECAUSE MODUS_PONENS;
constExists   BECAUSE GENERALIZATION;
QED

(*
   We have not finished with the strange properties of the empty set :
   it is a function, something dynamic that receives input and
   produces output. Except it receives nothing and produces nothing.
   It is even an injection.   
*)
emptyFunction == IsInjection({})
THEOREM emptyFunction
PROOF
VARIABLES a,b,c,x;
emptySetExists   BECAUSE THEOREM;
x \notin {}   BECAUSE \A(x <- x);
x \in {} => IsCouple(x)   BECAUSE Explosion;
IsGraph({})   BECAUSE GENERALIZATION;
<<a,b>> \notin {}   BECAUSE \A(x <- <<a,b>>);
<<a,b>> \in {} /\ <<a,c>> \in {} => <<a,b>> \in {}   BECAUSE S12;
<<a,b>> \in {} => b = c   BECAUSE Explosion;
<<a,b>> \in {} /\ <<a,c>> \in {} => b = c   BECAUSE TI;
\A a : \A b : \A c : <<a,b>> \in {} /\ <<a,c>> \in {} => b = c   BECAUSE GENERALIZATION;
IsFunction({})   BECAUSE IntroAndRight;
<<a,b>> \in {} => a = pre({},b)   BECAUSE Explosion;
\A a : \A b : <<a,b>> \in {} => a = pre({},b)   BECAUSE GENERALIZATION;
emptyFunction   BECAUSE IntroAndRight;
QED

(*
singletonFunc(a,b) == { <<a,b>> }
singletonFuncIsFunction == \A a : \A b :
   IsFunction(singletonFunc(a,b)) /\ Domain(singletonFunc(a,b)) = {a}
   /\ singletonFunc(a,b)[a] = b
THEOREM singletonFuncIsFunction
PROOF
\* TODO
singletonFuncIsFunction   BECAUSE GENERALIZATION;
QED

(*
   This theorem allows to define functions by cases. For example the absolute
   value on the real numbers is x when x >= 0 and -x when x < 0.
* )
unionFunc == \A f : \A g : IsFunction(f) /\ IsFunction(g) /\ AreDisjoint(Domain(f),Domain(g))
   => IsFunction(f \union g) /\ Domain(f \union g) = Domain(f) \union Domain(g)
      /\ (\A x : x \in Domain(f) => (f \union g)[x] = f[x])
      /\ (\A x : x \in Domain(g) => (f \union g)[x] = g[x])
THEOREM unionFunc
PROOF
\* TODO
unionFunc   BECAUSE GENERALIZATION;
QED
*)

funcUniqueImage == \A f : \A x : \A y :
   (x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y
THEOREM funcUniqueImage
PROOF
VARIABLES a,b,f,g,x,y;
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
(\E x : <<x,y>> \in f) => <<pre(f,y),y>> \in f   BECAUSE CHOOSE pre(f,y);
y \in Image(f) => Reaches(f,y)   BECAUSE EquivToImpl;
y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE TI;
\A y : y \in Image(f) => <<pre(f,y),y>> \in f   BECAUSE GENERALIZATION;
x \in Image(f) => <<pre(f,x),x>> \in f   BECAUSE \A(y <- x);
(x \in Image(f) /\ y \in Image(f)) => (<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE MergeImplicationsAnd;
pre(f,x) = pre(f,y) => pre(f,x) = pre(f,y)   BECAUSE ImplySelf;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f /\ pre(f,x) = pre(f,y))   BECAUSE MergeImplicationsAnd;
\A a : \A b : a = b => (<<a,x>> \in f <=> <<b,x>> \in f)   BECAUSE E_SCHEME;
pre(f,x) = pre(f,y) => (<<pre(f,x),x>> \in f <=> <<pre(f,y),x>> \in f)   BECAUSE \A(a <- pre(f,x), b <- pre(f,y));
(pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f) => <<pre(f,y),x>> \in f   BECAUSE HypoEquivToAnd;
(<<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f /\ pre(f,x) = pre(f,y))
   => (pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE AndCycle;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE TI;
<<pre(f,y),y>> \in f => <<pre(f,y),y>> \in f   BECAUSE ImplySelf;
(pre(f,x) = pre(f,y) /\ <<pre(f,x),x>> \in f /\ <<pre(f,y),y>> \in f) => (<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE MergeImplicationsAnd;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f)   BECAUSE TI;

funcVal   BECAUSE THEOREM;
IsFunction(f) /\ <<pre(f,y),y>> \in f => y = f[pre(f,y)]   BECAUSE \A(f <- f, x <- pre(f,y), y <- y);
IsFunction(f) => (<<pre(f,y),y>> \in f => y = f[pre(f,y)])   BECAUSE HypoAndToImpl;
IsFunction(f) /\ <<pre(f,y),x>> \in f => x = f[pre(f,y)]   BECAUSE \A(f <- f, x <- pre(f,y), y <- x);
IsFunction(f) => (<<pre(f,y),x>> \in f => x = f[pre(f,y)])   BECAUSE HypoAndToImpl;
IsFunction(f) => ((<<pre(f,y),x>> \in f => x = f[pre(f,y)]) /\ (<<pre(f,y),y>> \in f => y = f[pre(f,y)]))
   BECAUSE CIA;
((<<pre(f,y),x>> \in f => x = f[pre(f,y)]) /\ (<<pre(f,y),y>> \in f => y = f[pre(f,y)]))
   => ((<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE MergeImplicationsAnd2;
IsFunction(f) => ((<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE TI;
(<<pre(f,y),x>> \in f /\ <<pre(f,y),y>> \in f) => (IsFunction(f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE SwitchHypos;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y))
   => (IsFunction(f) => (x = f[pre(f,y)] /\ y = f[pre(f,y)]))   BECAUSE TI;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f))
   => (x = f[pre(f,y)] /\ y = f[pre(f,y)])   BECAUSE HypoImplToAnd;
(x = f[pre(f,y)] /\ y = f[pre(f,y)]) => x = y   BECAUSE E_SCHEME;
(x \in Image(f) /\ y \in Image(f) /\ pre(f,x) = pre(f,y) /\ IsFunction(f)) => x = y   BECAUSE TI;
funcUniqueImage   BECAUSE GENERALIZATION;
QED

multiInjection == \A f : \A multiX : \A y :
   IsInjection(f) => (y \in multiApply(f, multiX) <=> (y \in Image(f) /\ pre(f,y) \in multiX))
THEOREM multiInjection
PROOF
VARIABLES a,b,f,g,u,x,y,multiX;
multiApplyExists   BECAUSE THEOREM;
y \in multiApply(f,multiX) <=> \E u : u \in multiX /\ <<u,y>> \in f
   BECAUSE \A(f <- f, multiX <- multiX, x <- y);

\* Proof of (y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX) 
(\E x : <<x,y>> \in f) => <<pre(f,y), y>> \in f   BECAUSE CHOOSE pre(f,y);
imageExists   BECAUSE THEOREM;
y \in Image(f) <=> Reaches(f,y)   BECAUSE \A(g <- f, y <- y);
y \in Image(f) => Reaches(f,y)   BECAUSE EquivToImpl;
y \in Image(f) => <<pre(f,y), y>> \in f   BECAUSE TI;
pre(f,y) \in multiX => pre(f,y) \in multiX   BECAUSE ImplySelf;
(y \in Image(f) /\ pre(f,y) \in multiX) => (<<pre(f,y), y>> \in f /\ pre(f,y) \in multiX)
   BECAUSE MergeImplicationsAnd;
(<<pre(f,y), y>> \in f /\ pre(f,y) \in multiX) => (pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f)   BECAUSE AndSymmetry;
(y \in Image(f) /\ pre(f,y) \in multiX) => (pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f)   BECAUSE TI;
(pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f) => \E u : u \in multiX /\ <<u,y>> \in f   BECAUSE \E(u <- pre(f,y));
(\E u : u \in multiX /\ <<u,y>> \in f) => y \in multiApply(f,multiX)   BECAUSE EquivToImplReverse;
(pre(f,y) \in multiX /\ <<pre(f,y), y>> \in f) => y \in multiApply(f,multiX)   BECAUSE TI;
(y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX)   BECAUSE TI;
IsInjection(f) => ((y \in Image(f) /\ pre(f,y) \in multiX) => y \in multiApply(f,multiX))   BECAUSE PT1;

\* Converse
chooseU(f,y,multiX) == CHOOSE u : u \in multiX /\ <<u,y>> \in f;
(\E u : u \in multiX /\ <<u,y>> \in f)
   => (chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)   BECAUSE CHOOSE chooseU(f,y,multiX);
y \in multiApply(f,multiX) => (\E u : u \in multiX /\ <<u,y>> \in f)
   BECAUSE EquivToImpl;
y \in multiApply(f,multiX) => (chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)   BECAUSE TI;
(chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f) => <<chooseU(f,y,multiX),y>> \in f   BECAUSE S22;
y \in multiApply(f,multiX) => <<chooseU(f,y,multiX),y>> \in f   BECAUSE TI;
imageInc   BECAUSE THEOREM;
<<chooseU(f,y,multiX),y>> \in f => y \in Image(f)   BECAUSE \A(g <- f, x <- chooseU(f,y,multiX), y <- y);
y \in multiApply(f,multiX) => y \in Image(f)   BECAUSE TI;

IsInjection(f) => \A a : \A b : <<a,b>> \in f => a = pre(f,b)   BECAUSE S22;
(\A a : \A b : <<a,b>> \in f => a = pre(f,b)) => (<<chooseU(f,y,multiX),y>> \in f => chooseU(f,y,multiX) = pre(f,y))
   BECAUSE \A(a <- chooseU(f,y,multiX), b <- y);
IsInjection(f) => (<<chooseU(f,y,multiX),y>> \in f => chooseU(f,y,multiX) = pre(f,y))    BECAUSE TI;
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f) => chooseU(f,y,multiX) = pre(f,y)    BECAUSE HypoImplToAnd;
\A x : \A y : x = y => (x \in multiX <=> y \in multiX)    BECAUSE E_SCHEME;
(chooseU(f,y,multiX) = pre(f,y)) => (chooseU(f,y,multiX) \in multiX <=> pre(f,y) \in multiX)    BECAUSE \A(x <- chooseU(f,y,multiX), y <- pre(f,y));
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f) => (chooseU(f,y,multiX) \in multiX <=> pre(f,y) \in multiX)    BECAUSE TI;
(IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)
   => pre(f,y) \in multiX   BECAUSE HypoEquivToAnd;
(IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))
   => (IsInjection(f) /\ <<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE AssocAndLeft;
(IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))
   => pre(f,y) \in multiX   BECAUSE TI;
(chooseU(f,y,multiX) \in multiX /\ <<chooseU(f,y,multiX),y>> \in f)
   => (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE AndSymmetry;
y \in multiApply(f,multiX) => (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX)   BECAUSE TI;
IsInjection(f) => IsInjection(f)   BECAUSE ImplySelf;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => (IsInjection(f) /\ (<<chooseU(f,y,multiX),y>> \in f /\ chooseU(f,y,multiX) \in multiX))   BECAUSE MergeImplicationsAnd;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => pre(f,y) \in multiX   BECAUSE TI;
IsInjection(f) => (y \in multiApply(f,multiX) => y \in Image(f))   BECAUSE PT1;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => y \in Image(f)   BECAUSE HypoImplToAnd;
(IsInjection(f) /\ y \in multiApply(f,multiX)) => (y \in Image(f) /\ pre(f,y) \in multiX)   BECAUSE CIA;
IsInjection(f) => (y \in multiApply(f,multiX) => (y \in Image(f) /\ pre(f,y) \in multiX))   BECAUSE HypoAndToImpl;
IsInjection(f) => (y \in multiApply(f,multiX) <=> (y \in Image(f) /\ pre(f,y) \in multiX))   BECAUSE HypoIntroEquiv;
multiInjection   BECAUSE GENERALIZATION;
QED

bijApply == \A f : \A a : \A b : \A x : (f \in Bijections(a,b) /\ x \in a) => f[x] \in b
THEOREM bijApply
PROOF
VARIABLES a,b,c,d,f,g,i,x,y;
funcImageExists   BECAUSE THEOREM;
IsFunction(f) /\ x \in Domain(f) => <<x, f[x]>> \in f   BECAUSE \A(f <- f, x <- x);
<<x, y>> \in f => Reaches(f,y)   BECAUSE \E(x <- x);
\A y : <<x, y>> \in f => Reaches(f,y)   BECAUSE GENERALIZATION;
<<x, f[x]>> \in f => Reaches(f,f[x])   BECAUSE \A(y <- f[x]);
imageExists   BECAUSE THEOREM;
f[x] \in Image(f) <=> Reaches(f,f[x])   BECAUSE \A(g <- f, y <- f[x]);
Reaches(f,f[x]) => f[x] \in Image(f)   BECAUSE EquivToImplReverse;
IsFunction(f) /\ x \in Domain(f) => f[x] \in Image(f)   BECAUSE TI2;
\A a : \A b : \A c : \A d : a = b /\ c = d
   => ((IsFunction(f) /\ x \in a => f[x] \in c) <=> (IsFunction(f) /\ x \in b => f[x] \in d))   BECAUSE E_SCHEME;
Domain(f) = a /\ Image(f) = b => ((IsFunction(f) /\ x \in Domain(f) => f[x] \in Image(f)) <=> (IsFunction(f) /\ x \in a => f[x] \in b))
   BECAUSE \A(a <- Domain(f), b <- a, c <- Image(f), d <- b);
   implyTrueEquiv(h,t,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
Domain(f) = a /\ Image(f) = b => (IsFunction(f) /\ x \in a => f[x] \in b)   BECAUSE implyTrueEquiv;
bijectionsExists   BECAUSE THEOREM;
f \in Bijections(a,b) <=> IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE \A(d <- a, i <- b, f <- f);
f \in Bijections(a,b) => IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE EquivToImpl;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => IsInjection(f)   BECAUSE S13;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Domain(f) = a   BECAUSE S23;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Image(f) = b   BECAUSE S22;
f \in Bijections(a,b) => Domain(f) = a   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b   BECAUSE TI;
f \in Bijections(a,b) => Domain(f) = a /\ Image(f) = b   BECAUSE CIA;
f \in Bijections(a,b) => (IsFunction(f) /\ x \in a => f[x] \in b)   BECAUSE TI;
IsInjection(f) => IsFunction(f)   BECAUSE S12;
f \in Bijections(a,b) => IsFunction(f)   BECAUSE TI2;
f \in Bijections(a,b) /\ x \in a => f \in Bijections(a,b)   BECAUSE S12;
f \in Bijections(a,b) /\ x \in a => IsFunction(f)   BECAUSE TI;
f \in Bijections(a,b) /\ x \in a => x \in a   BECAUSE S22;
f \in Bijections(a,b) /\ x \in a => (IsFunction(f) /\ x \in a => f[x] \in b)   BECAUSE TI;
f \in Bijections(a,b) /\ x \in a => IsFunction(f) /\ x \in a   BECAUSE CIA;
f \in Bijections(a,b) /\ x \in a => f[x] \in b   BECAUSE KillMiddleHypo;
bijApply   BECAUSE GENERALIZATION;
QED

bijPreApply == \A f : \A a : \A b : \A y : (f \in Bijections(a,b) /\ y \in b) => pre(f,y) \in a
THEOREM bijPreApply
PROOF
VARIABLES a,b,c,d,f,i,x,y;
domainInc2   BECAUSE THEOREM;
y \in Image(f) => pre(f,y) \in Domain(f)   BECAUSE \A(f <- f, y <- y);
\A a : \A b : \A c : \A d : a = b /\ c = d => ((y \in a => pre(f,y) \in c) <=> (y \in b => pre(f,y) \in d))   BECAUSE E_SCHEME;
Image(f) = b /\ Domain(f) = a => ((y \in Image(f) => pre(f,y) \in Domain(f)) <=> (y \in b => pre(f,y) \in a))
   BECAUSE \A(a <- Image(f), b <- b, c <- Domain(f), d <- a);
implyTrueEquiv(h,t,a) == t => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO;
Image(f) = b /\ Domain(f) = a => (y \in b => pre(f,y) \in a)   BECAUSE implyTrueEquiv;
bijectionsExists   BECAUSE THEOREM;
f \in Bijections(a,b) <=> IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE \A(d <- a, i <- b, f <- f);
f \in Bijections(a,b) => IsInjection(f) /\ Domain(f) = a /\ Image(f) = b   BECAUSE EquivToImpl;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Domain(f) = a   BECAUSE S23;
IsInjection(f) /\ Domain(f) = a /\ Image(f) = b => Image(f) = b   BECAUSE S22;
f \in Bijections(a,b) => Domain(f) = a   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b   BECAUSE TI;
f \in Bijections(a,b) => Image(f) = b /\ Domain(f) = a   BECAUSE CIA;
f \in Bijections(a,b) => (y \in b => pre(f,y) \in a)   BECAUSE TI;
f \in Bijections(a,b) /\ y \in b => pre(f,y) \in a   BECAUSE HypoImplToAnd;
bijPreApply   BECAUSE GENERALIZATION;
QED


(*
   Functions between cartesian products.
*)

\* Two functions called in parallel
IsParallelApply(f,g,x) == IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))
   /\ <<fst(fst(x)), fst(snd(x)) >> \in f /\ <<snd(fst(x)), snd(snd(x)) >> \in g
parallelFunc(f,g) == CHOOSE h : \A x : x \in h <=> \* x = << <<a, b>>, <<f[a], g[b]>> >>
  IsParallelApply(f,g,x)

parallelFuncExists == \A f : \A g : (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x))
THEOREM parallelFuncExists
PROOF
VARIABLES a,b,c,f,g,h,x,y;
\* By separation in (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))
\A a : \E b : \A x : x \in b <=> (x \in a /\ IsParallelApply(f,g,x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(a <- (Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)));

\* Take one such b
chooseB(f,g) == CHOOSE b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x));
(\E b : \A x : x \in b <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x)))
   => (\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x)))   BECAUSE CHOOSE chooseB(f,g);
\A x : x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE MODUS_PONENS;
x \in chooseB(f,g) <=> (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))) /\ IsParallelApply(f,g,x))   BECAUSE \A(x <- x);

\* Stage x
tupleComposition   BECAUSE THEOREM;
IsCouple(x) => x = <<fst(x), snd(x)>>   BECAUSE \A(c <- x);
\A x : \A y : x = y => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> y \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE E_SCHEME;
x = <<fst(x), snd(x)>> => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE \A(x <- x, y <- <<fst(x), snd(x)>>);
IsCouple(x) => (x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))   BECAUSE TI;
(IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))   BECAUSE HypoEquivToAndReverse;
cartesianProductCouples   BECAUSE THEOREM;
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   <=> <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE \A(x <- (Domain(f) \X Domain(g)), y <- (Image(f) \X Image(g)), a <- fst(x), b <- snd(x));
(fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   => <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE EquivToImpl;
IsCouple(x) => IsCouple(x)   BECAUSE ImplySelf;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => (IsCouple(x) /\ <<fst(x), snd(x)>> \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g))))
   BECAUSE MergeImplicationsAnd;
(IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))
   => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TI;

\* Prove that IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))
IsCouple(fst(x)) => fst(x) = <<fst(fst(x)), snd(fst(x))>>   BECAUSE \A(c <- fst(x));
\A x : \A y : x = y => (x \in (Domain(f) \X Domain(g)) <=> y \in (Domain(f) \X Domain(g)))   BECAUSE E_SCHEME;
fst(x) = <<fst(fst(x)), snd(fst(x))>> => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE \A(x <- fst(x), y <- <<fst(fst(x)), snd(fst(x))>>);
IsCouple(fst(x)) => (fst(x) \in (Domain(f) \X Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE TI;
(IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE HypoEquivToAndReverse;
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   <=> <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE \A(x <- Domain(f), y <- Domain(g), a <- fst(fst(x)), b <- snd(fst(x)));
(fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))
   => <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g))
   BECAUSE EquivToImpl;
IsCouple(fst(x)) => IsCouple(fst(x))   BECAUSE ImplySelf;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => (IsCouple(fst(x)) /\ <<fst(fst(x)), snd(fst(x))>> \in (Domain(f) \X Domain(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))
   => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)))   BECAUSE S14;
(IsCouple(x) /\ IsCouple(fst(x))) => IsCouple(fst(x))   BECAUSE S22;
IsParallelApply(f,g,x) => IsCouple(fst(x))   BECAUSE TI;
IsParallelApply(f,g,x) => <<fst(fst(x)), fst(snd(x)) >> \in f   BECAUSE S23;
domainInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(fst(x)) \in Domain(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(fst(x)) \in Domain(f)   BECAUSE TI;
IsParallelApply(f,g,x) => <<snd(fst(x)), snd(snd(x)) >> \in g   BECAUSE S22;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(fst(x)) \in Domain(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(fst(x)) \in Domain(g)   BECAUSE TI;
IsParallelApply(f,g,x) => (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g))   BECAUSE CIA;
IsParallelApply(f,g,x) => (IsCouple(fst(x)) /\ (fst(fst(x)) \in Domain(f) /\ snd(fst(x)) \in Domain(g)))   BECAUSE CIA;
IsParallelApply(f,g,x) => fst(x) \in (Domain(f) \X Domain(g))   BECAUSE TI;

\* Prove that IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))
IsCouple(snd(x)) => snd(x) = <<fst(snd(x)), snd(snd(x))>>   BECAUSE \A(c <- snd(x));
\A x : \A y : x = y => (x \in (Image(f) \X Image(g)) <=> y \in (Image(f) \X Image(g)))   BECAUSE E_SCHEME;
snd(x) = <<fst(snd(x)), snd(snd(x))>> => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE \A(x <- snd(x), y <- <<fst(snd(x)), snd(snd(x))>>);
IsCouple(snd(x)) => (snd(x) \in (Image(f) \X Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE TI;
(IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE HypoEquivToAndReverse;
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   <=> <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE \A(x <- Image(f), y <- Image(g), a <- fst(snd(x)), b <- snd(snd(x)));
(fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))
   => <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g))
   BECAUSE EquivToImpl;
IsCouple(snd(x)) => IsCouple(snd(x))   BECAUSE ImplySelf;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => (IsCouple(snd(x)) /\ <<fst(snd(x)), snd(snd(x))>> \in (Image(f) \X Image(g)))   BECAUSE MergeImplicationsAnd;
(IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))
   => snd(x) \in (Image(f) \X Image(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x)))   BECAUSE S13;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(snd(x))   BECAUSE S22;
IsParallelApply(f,g,x) => IsCouple(snd(x))   BECAUSE TI;
imageInc   BECAUSE THEOREM;
<<fst(fst(x)), fst(snd(x)) >> \in f => fst(snd(x)) \in Image(f)   BECAUSE \A(g <- f, x <- fst(fst(x)), y <- fst(snd(x)));
IsParallelApply(f,g,x) => fst(snd(x)) \in Image(f)   BECAUSE TI;
<<snd(fst(x)), snd(snd(x)) >> \in g => snd(snd(x)) \in Image(g)   BECAUSE \A(g <- g, x <- snd(fst(x)), y <- snd(snd(x)));
IsParallelApply(f,g,x) => snd(snd(x)) \in Image(g)   BECAUSE TI;
IsParallelApply(f,g,x) => (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g))   BECAUSE CIA;
IsParallelApply(f,g,x) => (IsCouple(snd(x)) /\ (fst(snd(x)) \in Image(f) /\ snd(snd(x)) \in Image(g)))   BECAUSE CIA;
IsParallelApply(f,g,x) => snd(x) \in (Image(f) \X Image(g))   BECAUSE TI;

IsParallelApply(f,g,x) => (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g)))
   BECAUSE CIA;
(IsCouple(x) /\ IsCouple(fst(x)) /\ IsCouple(snd(x))) => IsCouple(x)   BECAUSE S13;
IsParallelApply(f,g,x) => IsCouple(x)   BECAUSE TI;
IsParallelApply(f,g,x) => (IsCouple(x) /\ (fst(x) \in (Domain(f) \X Domain(g)) /\ snd(x) \in (Image(f) \X Image(g))))   BECAUSE CIA;
IsParallelApply(f,g,x) => x \in ((Domain(f) \X Domain(g)) \X (Image(f) \X Image(g)))
   BECAUSE TI;

x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE SeparationTauto;
\A x : x \in chooseB(f,g) <=> IsParallelApply(f,g,x)   BECAUSE GENERALIZATION;
\E h : \A x : x \in h <=> IsParallelApply(f,g,x)   BECAUSE \E(h <- chooseB(f,g));
(\E h : \A x : x \in h <=> IsParallelApply(f,g,x)) => (\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)) 
   BECAUSE CHOOSE parallelFunc(f,g);
\A x : x \in parallelFunc(f,g) <=> IsParallelApply(f,g,x)   BECAUSE MODUS_PONENS;
parallelFuncExists   BECAUSE GENERALIZATION;
QED


\* The function x \in d |-> <<x, x>>
clone(d) == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = d /\ \A x : x \in d => z[x] = <<x,x>>
cloneExists == \A d : IsFunction(clone(d)) /\ Domain(clone(d)) = d /\ (\A x : x \in d => clone(d)[x] = <<x,x>>)
THEOREM cloneExists
PROOF
VARIABLES a,b,c,d,f,i,j,x,y,z;
\A a : \E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = <<x,x>>))
   BECAUSE AXIOM_SCHEME;
\E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<x,x>>))   BECAUSE \A(a <- d);
\A z : z = clone(d) <=> (IsFunction(z) /\ Domain(z) = d /\ (\A x : x \in d => z[x] = <<x,x>>))   BECAUSE CHOOSE clone(d);
clone(d) = clone(d) <=> (IsFunction(clone(d)) /\ Domain(clone(d)) = d /\ (\A x : x \in d => clone(d)[x] = <<x,x>>))   BECAUSE \A(z <- clone(d));
equalSelf   BECAUSE THEOREM;
clone(d) = clone(d)   BECAUSE \A(a <- clone(d));
IsFunction(clone(d)) /\ Domain(clone(d)) = d /\ (\A x : x \in d => clone(d)[x] = <<x,x>>)   BECAUSE MODUS_PONENS;
cloneExists   BECAUSE GENERALIZATION;
QED

\* Cartesian product of two functions
productFunc(g,h) == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h)
   /\ \A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>

productFuncIsFunc == \A g : \A h : \A z : z = productFunc(g,h) <=>
   IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h)
   /\ \A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>
THEOREM productFuncIsFunc
PROOF
VARIABLES a,b,c,d,f,g,h,i,j,x,y,z;
\A a : \E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = a /\ (\A x : x \in a => z[x] = <<g[x],h[x]>>))   BECAUSE AXIOM_SCHEME;
\E f : \A z : z = f <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h)
   /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>))
   BECAUSE \A(a <- Domain(g) \intersect Domain(h));
\A z : z = productFunc(g,h) <=> (IsFunction(z) /\ Domain(z) = Domain(g) \intersect Domain(h)
   /\ (\A x : x \in Domain(g) \intersect Domain(h) => z[x] = <<g[x],h[x]>>))   BECAUSE CHOOSE productFunc(g,h);
productFunc(g,h) = productFunc(g,h) <=> (IsFunction(productFunc(g,h)) /\ Domain(productFunc(g,h)) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => productFunc(g,h)[x] = <<g[x],h[x]>>))
   BECAUSE \A(z <- productFunc(g,h));
equalSelf   BECAUSE THEOREM;
productFunc(g,h) = productFunc(g,h)   BECAUSE \A(a <- productFunc(g,h));
IsFunction(productFunc(g,h)) /\ Domain(productFunc(g,h)) = Domain(g) \intersect Domain(h) /\ (\A x : x \in Domain(g) \intersect Domain(h) => productFunc(g,h)[x] = <<g[x],h[x]>>)   BECAUSE MODUS_PONENS;
productFuncIsFunc   BECAUSE GENERALIZATION;
QED

(*
   Proof that CHOOSE combined with axiom schemes is not always a conservative extension.
   This proof introduces the symbol Choice(p) == CHOOSE z : z \in p
   and uses it inside the separation axiom scheme, to prove the axiom of choice.
   
   For this reason CHOOSE symbols are forbidden in axiom schemes, CHOOSE_UNIQUE
   must be used instead.
*)
choiceFunctionsExist == \A a : \E f : IsFunction(f)
  /\ \A p : p \subseteq a /\ p # {} => f[p] \in p
THEOREM choiceFunctionsExist
PROOF
VARIABLES a,b,c,f,i,j,p,x,y,z;
\* By separation in (SUBSET a \ {}) \X a, prove cf(a) is a graph
Choice(p) == CHOOSE z : z \in p;
\A a : \E b : \A x : x \in b <=> x \in a /\ snd(x) = Choice(fst(x))   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE \A(a <- (SUBSET a) \X a);
cf(a) == CHOOSE b : \A x : x \in b <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x));
\A x : x \in cf(a) <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE CHOOSE cf(a);
x \in cf(a) <=> x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE \A(x <- x);
x \in cf(a) => x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x))   BECAUSE EquivToImpl;
x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x)) => x \in (SUBSET a) \X a   BECAUSE S12;
x \in cf(a) => x \in (SUBSET a) \X a   BECAUSE TI;
cartesianProductExists   BECAUSE THEOREM;
x \in (SUBSET a) \X a <=> (IsCouple(x) /\ fst(x) \in (SUBSET a) /\ snd(x) \in a)   BECAUSE \A(i <- SUBSET a, j <- a, x <- x);
x \in (SUBSET a) \X a => (IsCouple(x) /\ fst(x) \in (SUBSET a) /\ snd(x) \in a)   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in (SUBSET a) /\ snd(x) \in a) => IsCouple(x)   BECAUSE S13;
x \in cf(a) => IsCouple(x)   BECAUSE TI2;
IsGraph(cf(a))   BECAUSE GENERALIZATION;

\* Prove cf(a) is a function
x \in (SUBSET a) \X a /\ snd(x) = Choice(fst(x)) => snd(x) = Choice(fst(x))   BECAUSE S22;
x \in cf(a) => snd(x) = Choice(fst(x))   BECAUSE TI;
\A x : \A a : x \in cf(a) => snd(x) = Choice(fst(x))   BECAUSE GENERALIZATION;
<<a,b>> \in cf(z) => snd(<<a,b>>) = Choice(fst(<<a,b>>))   BECAUSE \A(x <- <<a,b>>, a <- z);
\A x : \A a : \A z : \A b : x = a /\ z = b => (x = Choice(z) <=> a = Choice(b))   BECAUSE E_SCHEME;
b = snd(<<a,b>>) /\ a = fst(<<a,b>>) => (b = Choice(a) <=> snd(<<a,b>>) = Choice(fst(<<a,b>>)))   BECAUSE \A(x <- b, a <- snd(<<a,b>>), z <- a, b <- fst(<<a,b>>));
fstExists   BECAUSE THEOREM;
a = fst(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
sndExists   BECAUSE THEOREM;
b = snd(<<a,b>>)   BECAUSE \A(a <- a, b <- b);
b = snd(<<a,b>>) /\ a = fst(<<a,b>>)   BECAUSE IntroAndRight;
b = Choice(a) <=> snd(<<a,b>>) = Choice(fst(<<a,b>>))   BECAUSE MODUS_PONENS;
snd(<<a,b>>) = Choice(fst(<<a,b>>)) => b = Choice(a)   BECAUSE EquivToImplReverse;
<<a,b>> \in cf(z) => b = Choice(a)   BECAUSE TI;
\A b : <<a,b>> \in cf(z) => b = Choice(a)   BECAUSE GENERALIZATION;
<<a,c>> \in cf(z) => c = Choice(a)   BECAUSE \A(b <- c);
<<a,b>> \in cf(z) /\ <<a,c>> \in cf(z) => b = Choice(a) /\ c = Choice(a)   BECAUSE MergeImplicationsAnd;
b = Choice(a) /\ c = Choice(a) => b = c   BECAUSE E_SCHEME;
<<a,b>> \in cf(z) /\ <<a,c>> \in cf(z) => b = c   BECAUSE TI;
\A a : \A b : \A c : <<a,b>> \in cf(z) /\ <<a,c>> \in cf(z) => b = c   BECAUSE GENERALIZATION;
\A a : IsGraph(cf(a))   BECAUSE GENERALIZATION;
IsGraph(cf(z))   BECAUSE \A(a <- z);
IsFunction(cf(z))   BECAUSE IntroAndRight;
\A z : IsFunction(cf(z))   BECAUSE GENERALIZATION;
IsFunction(cf(a))   BECAUSE \A(z <- a);

\* Prove cf(a)[p] \in p
h(a,p) == p \subseteq a /\ p # {};
<<p,Choice(p)>> \in cf(a) <=> <<p,Choice(p)>> \in (SUBSET a) \X a /\ snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE \A(x <- <<p,Choice(p)>>);
<<p,Choice(p)>> \in (SUBSET a) \X a /\ snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>)) => <<p,Choice(p)>> \in cf(a)   BECAUSE EquivToImplReverse;
h(a,p) => p # {}   BECAUSE S22;
notEmpty   BECAUSE THEOREM;
p # {} => \E z : z \in p   BECAUSE \A(x <- p);
(\E z : z \in p) => Choice(p) \in p   BECAUSE CHOOSE Choice(p);
h(a,p) => Choice(p) \in p   BECAUSE TI2;
h(a,p) => p \subseteq a   BECAUSE S12;
p \subseteq a => (Choice(p) \in p => Choice(p) \in a)   BECAUSE \A(z <- Choice(p));
h(a,p) => (Choice(p) \in p => Choice(p) \in a)   BECAUSE TI;
h(a,p) => Choice(p) \in a   BECAUSE KillMiddleHypo;
powersetExists   BECAUSE AXIOM;
p \in SUBSET a <=> p \subseteq a   BECAUSE \A(x <- a, z <- p);
p \subseteq a => p \in SUBSET a   BECAUSE EquivToImplReverse;
h(a,p) => p \in SUBSET a   BECAUSE TI;
h(a,p) => p \in SUBSET a /\ Choice(p) \in a   BECAUSE CIA;
cartesianProductCouples   BECAUSE THEOREM;
(p \in SUBSET a /\ Choice(p) \in a) <=> <<p,Choice(p)>> \in (SUBSET a) \X a   BECAUSE \A(x <- SUBSET a, y <- a, a <- p, b <- Choice(p));
p \in SUBSET a /\ Choice(p) \in a => <<p,Choice(p)>> \in (SUBSET a) \X a   BECAUSE EquivToImpl;
h(a,p) => <<p,Choice(p)>> \in (SUBSET a) \X a   BECAUSE TI;
\A a : \A b : b = Choice(a) <=> snd(<<a,b>>) = Choice(fst(<<a,b>>))   BECAUSE GENERALIZATION;
Choice(p) = Choice(p) <=> snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE \A(a <- p, b <- Choice(p));
equalSelf   BECAUSE THEOREM;
Choice(p) = Choice(p)   BECAUSE \A(a <- Choice(p));
snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE MODUS_PONENS;
<<p,Choice(p)>> \in (SUBSET a) \X a => <<p,Choice(p)>> \in (SUBSET a) \X a /\ snd(<<p,Choice(p)>>) = Choice(fst(<<p,Choice(p)>>))   BECAUSE IntroAndLeft;
h(a,p) => <<p,Choice(p)>> \in cf(a)   BECAUSE TI2;
funcVal   BECAUSE THEOREM;
IsFunction(cf(z)) /\ <<p,Choice(p)>> \in cf(z) => Choice(p) = cf(z)[p]   BECAUSE \A(f <- cf(z), x <- p, y <- Choice(p));
<<p,Choice(p)>> \in cf(z) => IsFunction(cf(z)) /\ <<p,Choice(p)>> \in cf(z)   BECAUSE IntroAndRight;
<<p,Choice(p)>> \in cf(z) => Choice(p) = cf(z)[p]   BECAUSE TI;
\A z : <<p,Choice(p)>> \in cf(z) => Choice(p) = cf(z)[p]   BECAUSE GENERALIZATION;
<<p,Choice(p)>> \in cf(a) => Choice(p) = cf(a)[p]   BECAUSE \A(z <- a);
h(a,p) => Choice(p) = cf(a)[p]   BECAUSE TI;
\A x : \A y : x = y => (x \in p <=> y \in p)   BECAUSE E_SCHEME;
Choice(p) = cf(a)[p] => (Choice(p) \in p <=> cf(a)[p] \in p)   BECAUSE \A(x <- Choice(p), y <- cf(a)[p]);
h(a,p) => (Choice(p) \in p <=> cf(a)[p] \in p)   BECAUSE TI;
(Choice(p) \in p <=> cf(a)[p] \in p) => (Choice(p) \in p => cf(a)[p] \in p)   BECAUSE EquivToImpl;
h(a,p) => (Choice(p) \in p => cf(a)[p] \in p)   BECAUSE TI;
h(a,p) => cf(a)[p] \in p   BECAUSE KillMiddleHypo;
\A p : h(a,p) => cf(a)[p] \in p   BECAUSE GENERALIZATION;
IsFunction(cf(a)) /\ \A p : h(a,p) => cf(a)[p] \in p   BECAUSE IntroAndRight;
\E f : IsFunction(f) /\ \A p : p \subseteq a /\ p # {} => f[p] \in p   BECAUSE \E(f <- cf(a));
choiceFunctionsExist   BECAUSE GENERALIZATION;
QED