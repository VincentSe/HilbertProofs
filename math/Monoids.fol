EXTENDS Naturals

(*
   One of the most basic algebraic structures : a binary associative operation,
   with a neutral element.

   IsMonoid only has one argument, so that we can produce monoids.
*)
IsMonoid(op) == \E M : IsApplication(op, M \X M, M)
   \* Associativity
   /\ (\A a : \A b : \A c : a \in M /\ b \in M /\ c \in M => op[op[a,b],c] = op[a,op[b,c]] )
   \* Neutral element
   /\ (\E e : e \in M /\ \A a : a \in M => op[a,e] = a /\ op[e,a] = a)

BinopDomain(op) == CHOOSE_UNIQUE M : \A z : z = M <=> IsApplication(op, z \X z, z)

monoidDomainExists == \A op : IsMonoid(op) => IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op))
   /\ (\A a : \A b : \A c : a \in BinopDomain(op) /\ b \in BinopDomain(op) /\ c \in BinopDomain(op) => op[op[a,b],c] = op[a,op[b,c]] )
   /\ (\E e : e \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a)
THEOREM monoidDomainExists
PROOF
VARIABLES a,b,x,z,op,M;
hyp(M,op) == IsApplication(op, M \X M, M) /\ (\A a : \A b : \A c : a \in M /\ b \in M /\ c \in M => op[op[a,b],c] = op[a,op[b,c]] ) /\ (\E e : e \in M /\ \A a : a \in M => op[a,e] = a /\ op[e,a] = a);
hyp(M,op) => IsApplication(op, M \X M, M)   BECAUSE S13;
h(M,op) == IsApplication(op, M \X M, M);
IsMonoid(op) => \E M : h(M,op)   BECAUSE Q_SCHEME;
\A y : \A z : y = z => (h(y,op) <=> h(z,op))   BECAUSE E_SCHEME;
z = M => (h(z,op) <=> h(M,op))   BECAUSE \A(y <- z, z <- M);
pullEquiv(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
h(M,op) /\ z = M => h(z,op)   BECAUSE pullEquiv;
h(M,op) => Domain(op) = M \X M   BECAUSE S23;
h(z,op) => Domain(op) = z \X z   BECAUSE S23;
h(M,op) /\ h(z,op) => Domain(op) = M \X M /\ Domain(op) = z \X z   BECAUSE MergeImplicationsAnd;
Domain(op) = M \X M /\ Domain(op) = z \X z => M \X M = z \X z   BECAUSE E_SCHEME;
cartesianSquareInject   BECAUSE THEOREM;
M \X M = z \X z => M = z   BECAUSE \A(a <- M, b <- z);
h(M,op) /\ h(z,op) => M = z   BECAUSE TI2;
M = z => z = M   BECAUSE E_SCHEME;
h(M,op) /\ h(z,op) => z = M   BECAUSE TI;
h(M,op) => (z = M <=> h(z,op))   BECAUSE HIE;
\A z : h(M,op) => (z = M <=> h(z,op))   BECAUSE GENERALIZATION;
h(M,op) => (\A z : z = M <=> h(z,op))   BECAUSE Q_SCHEME;
(\E M : h(M,op)) => (\E M : \A z : z = M <=> h(z,op))   BECAUSE Q_SCHEME;
(\E M : \A z : z = M <=> IsApplication(op, z \X z, z))
   => (\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z))   BECAUSE CHOOSE BinopDomain(op);
IsMonoid(op) => (\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z))   BECAUSE TI2;
(\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z)) => (BinopDomain(op) = BinopDomain(op) <=> IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op)))   BECAUSE \A(z <- BinopDomain(op));
IsMonoid(op) => (BinopDomain(op) = BinopDomain(op) <=> IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op)))   BECAUSE TI;
equalSelf   BECAUSE THEOREM;
BinopDomain(op) = BinopDomain(op)   BECAUSE \A(a <- BinopDomain(op));
IsMonoid(op) => IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op))   BECAUSE ImplyTrueEquiv;
IsMonoid(op) /\ hyp(M,op) => IsMonoid(op)   BECAUSE S12;
IsMonoid(op) /\ hyp(M,op) => hyp(M,op)   BECAUSE S22;
IsMonoid(op) /\ hyp(M,op) => IsApplication(op, M \X M, M)   BECAUSE TI;
(\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z)) => (M = BinopDomain(op) <=> IsApplication(op, M \X M, M))   BECAUSE \A(z <- M);
IsMonoid(op) /\ hyp(M,op) => (M = BinopDomain(op) <=> IsApplication(op, M \X M, M))   BECAUSE TI2;
IsMonoid(op) /\ hyp(M,op) => M = BinopDomain(op)   BECAUSE HIET;
\A y : \A z : y = z => (hyp(y,op) <=> hyp(z,op))   BECAUSE E_SCHEME;
M = BinopDomain(op) => (hyp(M,op) <=> hyp(BinopDomain(op),op))   BECAUSE \A(y <- M, z <- BinopDomain(op));
IsMonoid(op) /\ hyp(M,op) => (hyp(M,op) <=> hyp(BinopDomain(op),op))   BECAUSE TI;
IsMonoid(op) /\ hyp(M,op) => hyp(BinopDomain(op),op)   BECAUSE HITE;
\* Discharge M
IsMonoid(op) => (hyp(M,op) => hyp(BinopDomain(op),op))   BECAUSE HypoAndToImpl;
\A M : IsMonoid(op) => (hyp(M,op) => hyp(BinopDomain(op),op))   BECAUSE GENERALIZATION;
IsMonoid(op) => (\A M : hyp(M,op) => hyp(BinopDomain(op),op))   BECAUSE Q_SCHEME;
(\A M : hyp(M,op) => hyp(BinopDomain(op),op)) => ((\E M : hyp(M,op)) => \E M : hyp(BinopDomain(op),op))   BECAUSE Q_SCHEME;
IsMonoid(op) => (IsMonoid(op) => \E M : hyp(BinopDomain(op),op))   BECAUSE TI;
IsMonoid(op) => IsMonoid(op)   BECAUSE ImplySelf;
IsMonoid(op) => \E M : hyp(BinopDomain(op),op)   BECAUSE KillMiddleHypo;
(\E M : hyp(BinopDomain(op),op)) => hyp(BinopDomain(op),op)   BECAUSE Q_SCHEME;
IsMonoid(op) => hyp(BinopDomain(op),op)   BECAUSE TI;
monoidDomainExists   BECAUSE GENERALIZATION;
QED

(*
   The unique neutral element of an operation, when it exists :
   the element that leaves all other elements unchanged,
   to the left and to the right.
*)
Neutral(op) == CHOOSE_UNIQUE e : \A z : z = e <=>
   z \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a

neutralMonoidExists == \A op : IsMonoid(op) =>
   Neutral(op) \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,Neutral(op)] = a /\ op[Neutral(op),a] = a
THEOREM neutralMonoidExists
PROOF
\* If there were 2 neutral elements e and e' in the monoid, then
\* op[e,e'] = e = e' by neutrality of both e and e'.
VARIABLES a,e,z,M,op;
hyp(e,op) == e \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a;
\A z : \A e : z = e => (hyp(z,op) <=> hyp(e,op))   BECAUSE E_SCHEME;
z = e => (hyp(z,op) <=> hyp(e,op))   BECAUSE \A(z <- z, e <- e);
cycleHypos(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
hyp(e,op) /\ z = e => hyp(z,op)   BECAUSE cycleHypos;
hyp(e,op) /\ hyp(z,op) => hyp(e,op)   BECAUSE S12;
hyp(e,op) /\ hyp(z,op) => hyp(z,op)   BECAUSE S22;
hyp(e,op) => e \in BinopDomain(op)   BECAUSE S12;
hyp(z,op) => z \in BinopDomain(op)   BECAUSE S12;
hyp(e,op) => \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a   BECAUSE S22;
hyp(z,op) => \A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a   BECAUSE S22;
(\A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a) => (z \in BinopDomain(op) => op[z,e] = z /\ op[e,z] = z)   BECAUSE \A(a <- z);
(\A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a) => (e \in BinopDomain(op) => op[e,z] = e /\ op[z,e] = e)   BECAUSE \A(a <- e);
hyp(e,op) /\ hyp(z,op) => (z \in BinopDomain(op) => op[z,e] = z /\ op[e,z] = z)   BECAUSE TI2;
hyp(e,op) /\ hyp(z,op) => (e \in BinopDomain(op) => op[e,z] = e /\ op[z,e] = e)   BECAUSE TI2;
hyp(e,op) /\ hyp(z,op) => e \in BinopDomain(op)   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => z \in BinopDomain(op)   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => op[z,e] = z /\ op[e,z] = z   BECAUSE KillMiddleHypo;
hyp(e,op) /\ hyp(z,op) => op[e,z] = e /\ op[z,e] = e   BECAUSE KillMiddleHypo;
op[z,e] = z /\ op[e,z] = z => op[e,z] = z   BECAUSE S22;
op[e,z] = e /\ op[z,e] = e => op[e,z] = e   BECAUSE S12;
hyp(e,op) /\ hyp(z,op) => op[e,z] = z   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => op[e,z] = e   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => op[e,z] = z /\ op[e,z] = e   BECAUSE CIA;
op[e,z] = z /\ op[e,z] = e => z = e   BECAUSE E_SCHEME;
hyp(e,op) /\ hyp(z,op) => z = e   BECAUSE TI;
hyp(e,op) => (z = e <=> hyp(z,op))   BECAUSE HIE;
\A z : hyp(e,op) => (z = e <=> hyp(z,op))   BECAUSE GENERALIZATION;
hyp(e,op) => (\A z : z = e <=> hyp(z,op))   BECAUSE Q_SCHEME;
(\E e : hyp(e,op)) => \E e : (\A z : z = e <=> hyp(z,op))   BECAUSE Q_SCHEME;
(\E e : (\A z : z = e <=> hyp(z,op))) => (\A z : z = Neutral(op) <=> hyp(z,op))   BECAUSE CHOOSE Neutral(op);

monoidDomainExists   BECAUSE THEOREM;
IsMonoid(op) => IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op))
   /\ (\A a : \A b : \A c : a \in BinopDomain(op) /\ b \in BinopDomain(op) /\ c \in BinopDomain(op) => op[op[a,b],c] = op[a,op[b,c]] )
   /\ (\E e : hyp(e,op))   BECAUSE \A(op <- op);
IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op)) /\ (\A a : \A b : \A c : a \in BinopDomain(op) /\ b \in BinopDomain(op) /\ c \in BinopDomain(op) => op[op[a,b],c] = op[a,op[b,c]] ) /\ (\E e : hyp(e,op))
   => (\E e : hyp(e,op))   BECAUSE S22;
IsMonoid(op) => (\E e : hyp(e,op))   BECAUSE TI;
IsMonoid(op) => (\A z : z = Neutral(op) <=> hyp(z,op))   BECAUSE TI2;
(\A z : z = Neutral(op) <=> hyp(z,op)) => (Neutral(op) = Neutral(op) <=> hyp(Neutral(op),op))   BECAUSE \A(z <- Neutral(op));
equalSelf   BECAUSE THEOREM;
Neutral(op) = Neutral(op)   BECAUSE \A(a <- Neutral(op));
IsMonoid(op) => Neutral(op) = Neutral(op)   BECAUSE PT1;
IsMonoid(op) => (Neutral(op) = Neutral(op) <=> hyp(Neutral(op),op))   BECAUSE TI;
IsMonoid(op) => hyp(Neutral(op),op)   BECAUSE HITE;
neutralMonoidExists   BECAUSE GENERALIZATION;
QED

subMonoid == \A f : \A M : M \subseteq BinopDomain(f) /\ Neutral(f) \in M
   /\ (\A a : \A b : a \in M /\ b \in M => f[a,b] \in M) \* stability
   => IsMonoid(DomainIntersect(f, M \X M))

(*
   Product of 2 monoids f and g. Its binop domain is the product
   of binop domains and <<a,b>> (f,g) <<c,d>> = <<f[a,c], g[b,d]>>.
*)
BinopProd(g,h) == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsApplication(z, (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)), BinopDomain(g) \X BinopDomain(h))
   /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))
        => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)
   
binopProdExists == \A g : \A h : IsMonoid(g) /\ IsMonoid(h)
   => IsApplication(BinopProd(g,h), (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)), BinopDomain(g) \X BinopDomain(h))
      /\ (\A x : \A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)
THEOREM binopProdExists
PROOF
VARIABLES a,b,c,d,f,g,h,i,x,y,z;
\A d : \A i : (\A x : x \in d => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in i)
   => (\E b : (\A z : z = b <=> (IsApplication(z,d,i) /\ (\A x : x \in d => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   BECAUSE MACRO separationFunc(F <- << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>);
(\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))
   => (\E b : (\A z : z = b <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))
      /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   BECAUSE \A(d <- (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)), i <- BinopDomain(g) \X BinopDomain(h));
cartesianProductExists   BECAUSE THEOREM;
x \in ((BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))) <=> IsCouple(x) /\ fst(x) \in (BinopDomain(g) \X BinopDomain(h)) /\ snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   BECAUSE \A(i <- (BinopDomain(g) \X BinopDomain(h)), j <- (BinopDomain(g) \X BinopDomain(h)), x <- x);
x \in ((BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)))
   => IsCouple(x) /\ fst(x) \in (BinopDomain(g) \X BinopDomain(h)) /\ snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   BECAUSE EquivToImpl;
hh(x,g,h) == IsCouple(x) /\ fst(x) \in (BinopDomain(g) \X BinopDomain(h)) /\ snd(x) \in (BinopDomain(g) \X BinopDomain(h));
hh(x,g,h) => fst(x) \in (BinopDomain(g) \X BinopDomain(h))   BECAUSE S23;
hh(x,g,h) => snd(x) \in (BinopDomain(g) \X BinopDomain(h))   BECAUSE S22;
fst(x) \in (BinopDomain(g) \X BinopDomain(h))
   <=> IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h)
   BECAUSE \A(i <- BinopDomain(g), j <- BinopDomain(h), x <- fst(x));
snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   <=> IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h)
   BECAUSE \A(i <- BinopDomain(g), j <- BinopDomain(h), x <- snd(x));
fst(x) \in (BinopDomain(g) \X BinopDomain(h))
   => IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h)
   BECAUSE EquivToImpl;
snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   => IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h)
   BECAUSE EquivToImpl;
IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h) => snd(fst(x)) \in BinopDomain(h)   BECAUSE S22;
IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h) => fst(fst(x)) \in BinopDomain(g)   BECAUSE S23;
IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h) => snd(snd(x)) \in BinopDomain(h)   BECAUSE S22;
IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h) => fst(snd(x)) \in BinopDomain(g)   BECAUSE S23;
hh(x,g,h) => snd(fst(x)) \in BinopDomain(h)   BECAUSE TI2;
hh(x,g,h) => fst(fst(x)) \in BinopDomain(g)   BECAUSE TI2;
hh(x,g,h) => snd(snd(x)) \in BinopDomain(h)   BECAUSE TI2;
hh(x,g,h) => fst(snd(x)) \in BinopDomain(g)   BECAUSE TI2;

monoidDomainExists   BECAUSE THEOREM;
IsMonoid(g) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))
   /\ (\A a : \A b : \A c : a \in BinopDomain(g) /\ b \in BinopDomain(g) /\ c \in BinopDomain(g) => g[g[a,b],c] = g[a,g[b,c]] )
   /\ (\E e : e \in BinopDomain(g) /\ \A a : a \in BinopDomain(g) => g[a,e] = a /\ g[e,a] = a)   BECAUSE \A(op <- g);
IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g)) /\ (\A a : \A b : \A c : a \in BinopDomain(g) /\ b \in BinopDomain(g) /\ c \in BinopDomain(g) => g[g[a,b],c] = g[a,g[b,c]] ) /\ (\E e : e \in BinopDomain(g) /\ \A a : a \in BinopDomain(g) => g[a,e] = a /\ g[e,a] = a) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE S13;
IsMonoid(g) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE TI;
\A g : IsMonoid(g) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE GENERALIZATION;
IsMonoid(h) => IsApplication(h, BinopDomain(h) \X BinopDomain(h), BinopDomain(h))   BECAUSE \A(g <- h);
appDomainToImage   BECAUSE THEOREM;
IsApplication(g,BinopDomain(g) \X BinopDomain(g),BinopDomain(g)) /\ <<fst(fst(x)),fst(snd(x))>> \in BinopDomain(g) \X BinopDomain(g)
   => g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g)
   BECAUSE \A(f <- g, d <- BinopDomain(g) \X BinopDomain(g), i <- BinopDomain(g), x <- <<fst(fst(x)),fst(snd(x))>>);
IsApplication(h,BinopDomain(h) \X BinopDomain(h),BinopDomain(h)) /\ <<snd(fst(x)),snd(snd(x))>> \in BinopDomain(h) \X BinopDomain(h)
   => h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)
   BECAUSE \A(f <- h, d <- BinopDomain(h) \X BinopDomain(h), i <- BinopDomain(h), x <- <<snd(fst(x)),snd(snd(x))>>);
cartesianProductCouples   BECAUSE THEOREM;
(fst(fst(x)) \in BinopDomain(g) /\ fst(snd(x)) \in BinopDomain(g))
   <=> << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)
   BECAUSE \A(x <- BinopDomain(g), y <- BinopDomain(g), a <- fst(fst(x)), b <- fst(snd(x)));
(fst(fst(x)) \in BinopDomain(g) /\ fst(snd(x)) \in BinopDomain(g))
   => << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)
   BECAUSE EquivToImpl;
hh(x,g,h) => (fst(fst(x)) \in BinopDomain(g) /\ fst(snd(x)) \in BinopDomain(g))   BECAUSE CIA;
hh(x,g,h) => << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsMonoid(g)   BECAUSE S13;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsMonoid(h)   BECAUSE S23;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => hh(x,g,h)   BECAUSE S22;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(h, BinopDomain(h) \X BinopDomain(h), BinopDomain(h))   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g)) /\ << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)   BECAUSE CIA;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g)   BECAUSE TI;

(snd(fst(x)) \in BinopDomain(h) /\ snd(snd(x)) \in BinopDomain(h))
   <=> << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)
   BECAUSE \A(x <- BinopDomain(h), y <- BinopDomain(h), a <- snd(fst(x)), b <- snd(snd(x)));
(snd(fst(x)) \in BinopDomain(h) /\ snd(snd(x)) \in BinopDomain(h))
   => << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)
   BECAUSE EquivToImpl;
hh(x,g,h) => (snd(fst(x)) \in BinopDomain(h) /\ snd(snd(x)) \in BinopDomain(h))   BECAUSE CIA;
hh(x,g,h) => << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(h, BinopDomain(h) \X BinopDomain(h), BinopDomain(h)) /\ << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)   BECAUSE CIA;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g) /\ h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)   BECAUSE CIA;

(g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g) /\ h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h))
   <=> << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h)
   BECAUSE \A(x <- BinopDomain(g), y <- BinopDomain(h), a <- g[fst(fst(x)),fst(snd(x))], b <- h[snd(fst(x)),snd(snd(x))]);
g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g) /\ h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)
   => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h)
   BECAUSE EquivToImpl;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h)
   BECAUSE TI;
injectHypo(a,b,c,i) == (i => a) => ((b /\ a => c) => (b => (i => c)))   PROPO_TAUTO;
IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))   BECAUSE injectHypo;
\A x : IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))   BECAUSE GENERALIZATION;
IsMonoid(g) /\ IsMonoid(h) => (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))   BECAUSE Q_SCHEME;
IsMonoid(g) /\ IsMonoid(h) => (\E b : (\A z : z = b <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))
      /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))   BECAUSE TI;

(\E b : (\A z : z = b <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   => ((\A z : z = BinopProd(g,h) <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))   BECAUSE CHOOSE BinopProd(g,h);
IsMonoid(g) /\ IsMonoid(h) => ((\A z : z = BinopProd(g,h) <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))   BECAUSE TI;
((\A z : z = BinopProd(g,h) <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   => (BinopProd(g,h) = BinopProd(g,h) <=> (IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)))   BECAUSE \A(z <- BinopProd(g,h));
IsMonoid(g) /\ IsMonoid(h) => (BinopProd(g,h) = BinopProd(g,h) <=> (IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)))   BECAUSE TI;
equalSelf   BECAUSE THEOREM;
BinopProd(g,h) = BinopProd(g,h)   BECAUSE \A(a <- BinopProd(g,h));
IsMonoid(g) /\ IsMonoid(h) => BinopProd(g,h) = BinopProd(g,h)   BECAUSE PT1;
IsMonoid(g) /\ IsMonoid(h) => (IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))   BECAUSE HITE;

\* Split x into a couple
(IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)) => (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)   BECAUSE S22;
(\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)
   => (<<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>)   BECAUSE \A(x <- <<x,y>>);
\A d : \A i : \A c : \A b : d = i /\ c = b => (BinopProd(g,h)[x,y] = << g[fst(d),fst(c)] , h[snd(d),snd(c)] >> <=> BinopProd(g,h)[x,y] = << g[fst(i),fst(b)] , h[snd(i),snd(b)] >>)   BECAUSE E_SCHEME;
x = fst(<<x,y>>) /\ y = snd(<<x,y>>) => (BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >> <=> BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>)   BECAUSE \A(d <- x, i <- fst(<<x,y>>), c <- y, b <- snd(<<x,y>>));
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >> <=> BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>   BECAUSE MODUS_PONENS;
BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >> => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>   BECAUSE EquivToImplReverse;
IsMonoid(g) /\ IsMonoid(h) => (<<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>)   BECAUSE TI2;
hti(a,b,c,h) == (h => (a => b)) => ((b => c) => (h /\ a => c))   PROPO_TAUTO;
IsMonoid(g) /\ IsMonoid(h) /\ <<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>   BECAUSE hti;
x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h))
   <=> <<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))
   BECAUSE \A(x <- (BinopDomain(g) \X BinopDomain(h)), y <- (BinopDomain(g) \X BinopDomain(h)), a <- x, b <- y);
x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h))
   => <<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))
   BECAUSE EquivToImpl;
IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE injectHypo;
\A y : IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE GENERALIZATION;
IsMonoid(g) /\ IsMonoid(h) => (\A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE Q_SCHEME;
\A x : IsMonoid(g) /\ IsMonoid(h) => (\A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE GENERALIZATION;
IsMonoid(g) /\ IsMonoid(h) => (\A x : \A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE Q_SCHEME;
(IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)) => IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))   BECAUSE S12;
IsMonoid(g) /\ IsMonoid(h) => IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) => IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : \A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE CIA;
binopProdExists   BECAUSE GENERALIZATION;
QED

productMonoidExists == \A f : \A g : IsMonoid(f) /\ IsMonoid(g) =>
   IsMonoid(BinopProd(f,g))
   /\ BinopDomain(BinopProd(f,g)) = BinopDomain(f) \X BinopDomain(g)
   /\ Neutral(BinopProd(f,g)) = <<Neutral(f), Neutral(g)>>
THEOREM productMonoidExists
PROOF
VARIABLES a,f,g,x,y;
binopProdExists   BECAUSE THEOREM;
IsMonoid(f) /\ IsMonoid(g) =>
   IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g))
   /\ (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g))
       => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)   BECAUSE \A(g <- f, h <- g);

\* Prove that Neutral(BinopProd(f,g)) = <<Neutral(f), Neutral(g)>>
IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g)) /\ (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>) => (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)   BECAUSE S22;
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>) => (<<Neutral(f), Neutral(g)>> \in (BinopDomain(f) \X BinopDomain(g)) /\ a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>)
   BECAUSE \A(x <- <<Neutral(f), Neutral(g)>>, y <- a);
IsMonoid(f) /\ IsMonoid(g) => (<<Neutral(f), Neutral(g)>> \in (BinopDomain(f) \X BinopDomain(g)) /\ a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>)
   BECAUSE TI2;
cartesianProductCouples   BECAUSE THEOREM;
(Neutral(f) \in BinopDomain(f) /\ Neutral(g) \in BinopDomain(g))
   <=> << Neutral(f),Neutral(g) >> \in BinopDomain(f) \X BinopDomain(g)
   BECAUSE \A(x <- BinopDomain(f), y <- BinopDomain(g), a <- Neutral(f), b <- Neutral(g));
(Neutral(f) \in BinopDomain(f) /\ Neutral(g) \in BinopDomain(g))
   => << Neutral(f),Neutral(g) >> \in BinopDomain(f) \X BinopDomain(g)
   BECAUSE EquivToImpl;
neutralMonoidExists   BECAUSE THEOREM;
IsMonoid(f) => Neutral(f) \in BinopDomain(f) /\ \A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a   BECAUSE \A(op <- f);
Neutral(f) \in BinopDomain(f) /\ (\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a) => Neutral(f) \in BinopDomain(f)   BECAUSE S12;
IsMonoid(f) => Neutral(f) \in BinopDomain(f)   BECAUSE TI;
\A f : IsMonoid(f) => Neutral(f) \in BinopDomain(f)   BECAUSE GENERALIZATION;
IsMonoid(g) => Neutral(g) \in BinopDomain(g)   BECAUSE \A(f <- g);
IsMonoid(f) /\ IsMonoid(g) => Neutral(f) \in BinopDomain(f) /\ Neutral(g) \in BinopDomain(g)   BECAUSE MergeImplicationsAnd;
IsMonoid(f) /\ IsMonoid(g) => <<Neutral(f),Neutral(g)>> \in BinopDomain(f) \X BinopDomain(g)   BECAUSE TI;
killMiddleHypo(a,b,c,h) == (h => (a /\ b => c)) => ((h => a) => (h /\ b => c))   PROPO_TAUTO;
hn(a,f,g) == IsMonoid(f) /\ IsMonoid(g) /\ a \in (BinopDomain(f) \X BinopDomain(g));
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>   BECAUSE killMiddleHypo;

\* TODO << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>
\* = << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = <<fst(a), snd(a)>> = a
QED

(* TODO IsMonoid(Nat,natAddition), product monoid, group of a regular monoid *)