EXTENDS Naturals

(*
   One of the most basic algebraic structures : a binary associative operation,
   with a neutral element.

   IsMonoid only has one argument, so that we can produce monoids.
*)
IsMonoid(op) == \E M : IsApplication(op, M \X M, M)
   \* Associativity
   /\ (\A a : \A b : \A c : a \in M /\ b \in M /\ c \in M => op[op[a,b],c] = op[a,op[b,c]] )
   \* Neutral element
   /\ (\E e : e \in M /\ \A a : a \in M => op[a,e] = a /\ op[e,a] = a)

BinopDomain(op) == CHOOSE_UNIQUE M : \A z : z = M <=> IsApplication(op, z \X z, z)

monoidDomainExists == \A op : IsMonoid(op) => IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op))
   /\ (\A a : \A b : \A c : a \in BinopDomain(op) /\ b \in BinopDomain(op) /\ c \in BinopDomain(op) => op[op[a,b],c] = op[a,op[b,c]] )
   /\ (\E e : e \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a)
THEOREM monoidDomainExists
PROOF
VARIABLES a,b,x,z,op,M;
hyp(M,op) == IsApplication(op, M \X M, M) /\ (\A a : \A b : \A c : a \in M /\ b \in M /\ c \in M => op[op[a,b],c] = op[a,op[b,c]] ) /\ (\E e : e \in M /\ \A a : a \in M => op[a,e] = a /\ op[e,a] = a);
hyp(M,op) => IsApplication(op, M \X M, M)   BECAUSE S13;
h(M,op) == IsApplication(op, M \X M, M);
IsMonoid(op) => \E M : h(M,op)   BECAUSE Q_SCHEME;
\A y : \A z : y = z => (h(y,op) <=> h(z,op))   BECAUSE E_SCHEME;
z = M => (h(z,op) <=> h(M,op))   BECAUSE \A(y <- z, z <- M);
pullEquiv(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
h(M,op) /\ z = M => h(z,op)   BECAUSE pullEquiv;
h(M,op) => Domain(op) = M \X M   BECAUSE S23;
h(z,op) => Domain(op) = z \X z   BECAUSE S23;
h(M,op) /\ h(z,op) => Domain(op) = M \X M /\ Domain(op) = z \X z   BECAUSE MergeImplicationsAnd;
Domain(op) = M \X M /\ Domain(op) = z \X z => M \X M = z \X z   BECAUSE E_SCHEME;
cartesianSquareInject   BECAUSE THEOREM;
M \X M = z \X z => M = z   BECAUSE \A(a <- M, b <- z);
h(M,op) /\ h(z,op) => M = z   BECAUSE TI2;
M = z => z = M   BECAUSE E_SCHEME;
h(M,op) /\ h(z,op) => z = M   BECAUSE TI;
h(M,op) => (z = M <=> h(z,op))   BECAUSE HIE;
\A z : h(M,op) => (z = M <=> h(z,op))   BECAUSE GENERALIZATION;
h(M,op) => (\A z : z = M <=> h(z,op))   BECAUSE Q_SCHEME;
(\E M : h(M,op)) => (\E M : \A z : z = M <=> h(z,op))   BECAUSE Q_SCHEME;
(\E M : \A z : z = M <=> IsApplication(op, z \X z, z))
   => (\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z))   BECAUSE CHOOSE BinopDomain(op);
IsMonoid(op) => (\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z))   BECAUSE TI2;
(\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z)) => (BinopDomain(op) = BinopDomain(op) <=> IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op)))   BECAUSE \A(z <- BinopDomain(op));
IsMonoid(op) => (BinopDomain(op) = BinopDomain(op) <=> IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op)))   BECAUSE TI;
equalSelf   BECAUSE THEOREM;
BinopDomain(op) = BinopDomain(op)   BECAUSE \A(a <- BinopDomain(op));
IsMonoid(op) => IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op))   BECAUSE ImplyTrueEquiv;
IsMonoid(op) /\ hyp(M,op) => IsMonoid(op)   BECAUSE S12;
IsMonoid(op) /\ hyp(M,op) => hyp(M,op)   BECAUSE S22;
IsMonoid(op) /\ hyp(M,op) => IsApplication(op, M \X M, M)   BECAUSE TI;
(\A z : z = BinopDomain(op) <=> IsApplication(op, z \X z, z)) => (M = BinopDomain(op) <=> IsApplication(op, M \X M, M))   BECAUSE \A(z <- M);
IsMonoid(op) /\ hyp(M,op) => (M = BinopDomain(op) <=> IsApplication(op, M \X M, M))   BECAUSE TI2;
IsMonoid(op) /\ hyp(M,op) => M = BinopDomain(op)   BECAUSE HIET;
\A y : \A z : y = z => (hyp(y,op) <=> hyp(z,op))   BECAUSE E_SCHEME;
M = BinopDomain(op) => (hyp(M,op) <=> hyp(BinopDomain(op),op))   BECAUSE \A(y <- M, z <- BinopDomain(op));
IsMonoid(op) /\ hyp(M,op) => (hyp(M,op) <=> hyp(BinopDomain(op),op))   BECAUSE TI;
IsMonoid(op) /\ hyp(M,op) => hyp(BinopDomain(op),op)   BECAUSE HITE;
\* Discharge M
IsMonoid(op) => (hyp(M,op) => hyp(BinopDomain(op),op))   BECAUSE HypoAndToImpl;
\A M : IsMonoid(op) => (hyp(M,op) => hyp(BinopDomain(op),op))   BECAUSE GENERALIZATION;
IsMonoid(op) => (\A M : hyp(M,op) => hyp(BinopDomain(op),op))   BECAUSE Q_SCHEME;
(\A M : hyp(M,op) => hyp(BinopDomain(op),op)) => ((\E M : hyp(M,op)) => \E M : hyp(BinopDomain(op),op))   BECAUSE Q_SCHEME;
IsMonoid(op) => (IsMonoid(op) => \E M : hyp(BinopDomain(op),op))   BECAUSE TI;
IsMonoid(op) => IsMonoid(op)   BECAUSE ImplySelf;
IsMonoid(op) => \E M : hyp(BinopDomain(op),op)   BECAUSE KillMiddleHypo;
(\E M : hyp(BinopDomain(op),op)) => hyp(BinopDomain(op),op)   BECAUSE Q_SCHEME;
IsMonoid(op) => hyp(BinopDomain(op),op)   BECAUSE TI;
monoidDomainExists   BECAUSE GENERALIZATION;
QED

(*
   The unique neutral element of an operation, when it exists :
   the element that leaves all other elements unchanged,
   to the left and to the right.
*)
Neutral(op) == CHOOSE_UNIQUE e : \A z : z = e <=>
   z \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a

neutralMonoidExistsUniquely == \A op : IsMonoid(op) => (\A z : z = Neutral(op) <=>
   z \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a)
THEOREM neutralMonoidExistsUniquely
PROOF
\* If there were 2 neutral elements e and e' in the monoid, then
\* op[e,e'] = e = e' by neutrality of both e and e'.
VARIABLES a,e,z,M,op;
hyp(e,op) == e \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a;
\A z : \A e : z = e => (hyp(z,op) <=> hyp(e,op))   BECAUSE E_SCHEME;
z = e => (hyp(z,op) <=> hyp(e,op))   BECAUSE \A(z <- z, e <- e);
cycleHypos(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
hyp(e,op) /\ z = e => hyp(z,op)   BECAUSE cycleHypos;
hyp(e,op) /\ hyp(z,op) => hyp(e,op)   BECAUSE S12;
hyp(e,op) /\ hyp(z,op) => hyp(z,op)   BECAUSE S22;
hyp(e,op) => e \in BinopDomain(op)   BECAUSE S12;
hyp(z,op) => z \in BinopDomain(op)   BECAUSE S12;
hyp(e,op) => \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a   BECAUSE S22;
hyp(z,op) => \A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a   BECAUSE S22;
(\A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a) => (z \in BinopDomain(op) => op[z,e] = z /\ op[e,z] = z)   BECAUSE \A(a <- z);
(\A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a) => (e \in BinopDomain(op) => op[e,z] = e /\ op[z,e] = e)   BECAUSE \A(a <- e);
hyp(e,op) /\ hyp(z,op) => (z \in BinopDomain(op) => op[z,e] = z /\ op[e,z] = z)   BECAUSE TI2;
hyp(e,op) /\ hyp(z,op) => (e \in BinopDomain(op) => op[e,z] = e /\ op[z,e] = e)   BECAUSE TI2;
hyp(e,op) /\ hyp(z,op) => e \in BinopDomain(op)   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => z \in BinopDomain(op)   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => op[z,e] = z /\ op[e,z] = z   BECAUSE KillMiddleHypo;
hyp(e,op) /\ hyp(z,op) => op[e,z] = e /\ op[z,e] = e   BECAUSE KillMiddleHypo;
op[z,e] = z /\ op[e,z] = z => op[e,z] = z   BECAUSE S22;
op[e,z] = e /\ op[z,e] = e => op[e,z] = e   BECAUSE S12;
hyp(e,op) /\ hyp(z,op) => op[e,z] = z   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => op[e,z] = e   BECAUSE TI;
hyp(e,op) /\ hyp(z,op) => op[e,z] = z /\ op[e,z] = e   BECAUSE CIA;
op[e,z] = z /\ op[e,z] = e => z = e   BECAUSE E_SCHEME;
hyp(e,op) /\ hyp(z,op) => z = e   BECAUSE TI;
hyp(e,op) => (z = e <=> hyp(z,op))   BECAUSE HIE;
\A z : hyp(e,op) => (z = e <=> hyp(z,op))   BECAUSE GENERALIZATION;
hyp(e,op) => (\A z : z = e <=> hyp(z,op))   BECAUSE Q_SCHEME;
(\E e : hyp(e,op)) => \E e : (\A z : z = e <=> hyp(z,op))   BECAUSE Q_SCHEME;
(\E e : (\A z : z = e <=> hyp(z,op))) => (\A z : z = Neutral(op) <=> hyp(z,op))   BECAUSE CHOOSE Neutral(op);

monoidDomainExists   BECAUSE THEOREM;
IsMonoid(op) => IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op))
   /\ (\A a : \A b : \A c : a \in BinopDomain(op) /\ b \in BinopDomain(op) /\ c \in BinopDomain(op) => op[op[a,b],c] = op[a,op[b,c]] )
   /\ (\E e : hyp(e,op))   BECAUSE \A(op <- op);
IsApplication(op, BinopDomain(op) \X BinopDomain(op), BinopDomain(op)) /\ (\A a : \A b : \A c : a \in BinopDomain(op) /\ b \in BinopDomain(op) /\ c \in BinopDomain(op) => op[op[a,b],c] = op[a,op[b,c]] ) /\ (\E e : hyp(e,op))
   => (\E e : hyp(e,op))   BECAUSE S22;
IsMonoid(op) => (\E e : hyp(e,op))   BECAUSE TI;
IsMonoid(op) => (\A z : z = Neutral(op) <=> hyp(z,op))   BECAUSE TI2;
neutralMonoidExistsUniquely   BECAUSE GENERALIZATION;
QED

neutralMonoidExists == \A op : IsMonoid(op) =>
   Neutral(op) \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,Neutral(op)] = a /\ op[Neutral(op),a] = a
THEOREM neutralMonoidExists
PROOF
VARIABLES op;
neutralMonoidExistsUniquely   BECAUSE THEOREM;
IsMonoid(op) => (\A z : z = Neutral(op) <=>
   z \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,z] = a /\ op[z,a] = a)   BECAUSE \A(op <- op);
hyp(e,op) == e \in BinopDomain(op) /\ \A a : a \in BinopDomain(op) => op[a,e] = a /\ op[e,a] = a;
(\A z : z = Neutral(op) <=> hyp(z,op)) => (Neutral(op) = Neutral(op) <=> hyp(Neutral(op),op))   BECAUSE \A(z <- Neutral(op));
equalSelf   BECAUSE THEOREM;
Neutral(op) = Neutral(op)   BECAUSE \A(a <- Neutral(op));
IsMonoid(op) => Neutral(op) = Neutral(op)   BECAUSE PT1;
IsMonoid(op) => (Neutral(op) = Neutral(op) <=> hyp(Neutral(op),op))   BECAUSE TI;
IsMonoid(op) => hyp(Neutral(op),op)   BECAUSE HITE;
neutralMonoidExists   BECAUSE GENERALIZATION;
QED

subMonoid == \A f : \A M : M \subseteq BinopDomain(f) /\ Neutral(f) \in M
   /\ (\A a : \A b : a \in M /\ b \in M => f[a,b] \in M) \* stability
   => IsMonoid(DomainIntersect(f, M \X M))

(*
   Product of 2 monoids f and g. Its binop domain is the product
   of binop domains and <<a,b>> (f,g) <<c,d>> = <<f[a,c], g[b,d]>>.
*)
BinopProd(g,h) == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsApplication(z, (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)), BinopDomain(g) \X BinopDomain(h))
   /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))
        => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)
   
binopProdExists == \A g : \A h : IsMonoid(g) /\ IsMonoid(h)
   => IsApplication(BinopProd(g,h), (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)), BinopDomain(g) \X BinopDomain(h))
      /\ (\A x : \A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)
THEOREM binopProdExists
PROOF
VARIABLES a,b,c,d,f,g,h,i,x,y,z;
\A d : \A i : (\A x : x \in d => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in i)
   => (\E b : (\A z : z = b <=> (IsApplication(z,d,i) /\ (\A x : x \in d => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   BECAUSE MACRO separationFunc(F <- << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>);
(\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))
   => (\E b : (\A z : z = b <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))
      /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   BECAUSE \A(d <- (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)), i <- BinopDomain(g) \X BinopDomain(h));
cartesianProductExists   BECAUSE THEOREM;
x \in ((BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))) <=> IsCouple(x) /\ fst(x) \in (BinopDomain(g) \X BinopDomain(h)) /\ snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   BECAUSE \A(i <- (BinopDomain(g) \X BinopDomain(h)), j <- (BinopDomain(g) \X BinopDomain(h)), x <- x);
x \in ((BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)))
   => IsCouple(x) /\ fst(x) \in (BinopDomain(g) \X BinopDomain(h)) /\ snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   BECAUSE EquivToImpl;
hh(x,g,h) == IsCouple(x) /\ fst(x) \in (BinopDomain(g) \X BinopDomain(h)) /\ snd(x) \in (BinopDomain(g) \X BinopDomain(h));
hh(x,g,h) => fst(x) \in (BinopDomain(g) \X BinopDomain(h))   BECAUSE S23;
hh(x,g,h) => snd(x) \in (BinopDomain(g) \X BinopDomain(h))   BECAUSE S22;
fst(x) \in (BinopDomain(g) \X BinopDomain(h))
   <=> IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h)
   BECAUSE \A(i <- BinopDomain(g), j <- BinopDomain(h), x <- fst(x));
snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   <=> IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h)
   BECAUSE \A(i <- BinopDomain(g), j <- BinopDomain(h), x <- snd(x));
fst(x) \in (BinopDomain(g) \X BinopDomain(h))
   => IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h)
   BECAUSE EquivToImpl;
snd(x) \in (BinopDomain(g) \X BinopDomain(h))
   => IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h)
   BECAUSE EquivToImpl;
IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h) => snd(fst(x)) \in BinopDomain(h)   BECAUSE S22;
IsCouple(fst(x)) /\ fst(fst(x)) \in BinopDomain(g) /\ snd(fst(x)) \in BinopDomain(h) => fst(fst(x)) \in BinopDomain(g)   BECAUSE S23;
IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h) => snd(snd(x)) \in BinopDomain(h)   BECAUSE S22;
IsCouple(snd(x)) /\ fst(snd(x)) \in BinopDomain(g) /\ snd(snd(x)) \in BinopDomain(h) => fst(snd(x)) \in BinopDomain(g)   BECAUSE S23;
hh(x,g,h) => snd(fst(x)) \in BinopDomain(h)   BECAUSE TI2;
hh(x,g,h) => fst(fst(x)) \in BinopDomain(g)   BECAUSE TI2;
hh(x,g,h) => snd(snd(x)) \in BinopDomain(h)   BECAUSE TI2;
hh(x,g,h) => fst(snd(x)) \in BinopDomain(g)   BECAUSE TI2;

monoidDomainExists   BECAUSE THEOREM;
IsMonoid(g) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))
   /\ (\A a : \A b : \A c : a \in BinopDomain(g) /\ b \in BinopDomain(g) /\ c \in BinopDomain(g) => g[g[a,b],c] = g[a,g[b,c]] )
   /\ (\E e : e \in BinopDomain(g) /\ \A a : a \in BinopDomain(g) => g[a,e] = a /\ g[e,a] = a)   BECAUSE \A(op <- g);
IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g)) /\ (\A a : \A b : \A c : a \in BinopDomain(g) /\ b \in BinopDomain(g) /\ c \in BinopDomain(g) => g[g[a,b],c] = g[a,g[b,c]] ) /\ (\E e : e \in BinopDomain(g) /\ \A a : a \in BinopDomain(g) => g[a,e] = a /\ g[e,a] = a) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE S13;
IsMonoid(g) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE TI;
\A g : IsMonoid(g) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE GENERALIZATION;
IsMonoid(h) => IsApplication(h, BinopDomain(h) \X BinopDomain(h), BinopDomain(h))   BECAUSE \A(g <- h);
appDomainToImage   BECAUSE THEOREM;
IsApplication(g,BinopDomain(g) \X BinopDomain(g),BinopDomain(g)) /\ <<fst(fst(x)),fst(snd(x))>> \in BinopDomain(g) \X BinopDomain(g)
   => g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g)
   BECAUSE \A(f <- g, d <- BinopDomain(g) \X BinopDomain(g), i <- BinopDomain(g), x <- <<fst(fst(x)),fst(snd(x))>>);
IsApplication(h,BinopDomain(h) \X BinopDomain(h),BinopDomain(h)) /\ <<snd(fst(x)),snd(snd(x))>> \in BinopDomain(h) \X BinopDomain(h)
   => h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)
   BECAUSE \A(f <- h, d <- BinopDomain(h) \X BinopDomain(h), i <- BinopDomain(h), x <- <<snd(fst(x)),snd(snd(x))>>);
cartesianProductCouples   BECAUSE THEOREM;
(fst(fst(x)) \in BinopDomain(g) /\ fst(snd(x)) \in BinopDomain(g))
   <=> << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)
   BECAUSE \A(x <- BinopDomain(g), y <- BinopDomain(g), a <- fst(fst(x)), b <- fst(snd(x)));
(fst(fst(x)) \in BinopDomain(g) /\ fst(snd(x)) \in BinopDomain(g))
   => << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)
   BECAUSE EquivToImpl;
hh(x,g,h) => (fst(fst(x)) \in BinopDomain(g) /\ fst(snd(x)) \in BinopDomain(g))   BECAUSE CIA;
hh(x,g,h) => << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsMonoid(g)   BECAUSE S13;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsMonoid(h)   BECAUSE S23;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => hh(x,g,h)   BECAUSE S22;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g))   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(h, BinopDomain(h) \X BinopDomain(h), BinopDomain(h))   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(g, BinopDomain(g) \X BinopDomain(g), BinopDomain(g)) /\ << fst(fst(x)),fst(snd(x)) >> \in BinopDomain(g) \X BinopDomain(g)   BECAUSE CIA;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g)   BECAUSE TI;

(snd(fst(x)) \in BinopDomain(h) /\ snd(snd(x)) \in BinopDomain(h))
   <=> << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)
   BECAUSE \A(x <- BinopDomain(h), y <- BinopDomain(h), a <- snd(fst(x)), b <- snd(snd(x)));
(snd(fst(x)) \in BinopDomain(h) /\ snd(snd(x)) \in BinopDomain(h))
   => << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)
   BECAUSE EquivToImpl;
hh(x,g,h) => (snd(fst(x)) \in BinopDomain(h) /\ snd(snd(x)) \in BinopDomain(h))   BECAUSE CIA;
hh(x,g,h) => << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => IsApplication(h, BinopDomain(h) \X BinopDomain(h), BinopDomain(h)) /\ << snd(fst(x)),snd(snd(x)) >> \in BinopDomain(h) \X BinopDomain(h)   BECAUSE CIA;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g) /\ h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)   BECAUSE CIA;

(g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g) /\ h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h))
   <=> << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h)
   BECAUSE \A(x <- BinopDomain(g), y <- BinopDomain(h), a <- g[fst(fst(x)),fst(snd(x))], b <- h[snd(fst(x)),snd(snd(x))]);
g[fst(fst(x)),fst(snd(x))] \in BinopDomain(g) /\ h[snd(fst(x)),snd(snd(x))] \in BinopDomain(h)
   => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h)
   BECAUSE EquivToImpl;
IsMonoid(g) /\ IsMonoid(h) /\ hh(x,g,h) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h)
   BECAUSE TI;
injectHypo(a,b,c,i) == (i => a) => ((b /\ a => c) => (b => (i => c)))   PROPO_TAUTO;
IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))   BECAUSE injectHypo;
\A x : IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))   BECAUSE GENERALIZATION;
IsMonoid(g) /\ IsMonoid(h) => (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >> \in BinopDomain(g) \X BinopDomain(h))   BECAUSE Q_SCHEME;
IsMonoid(g) /\ IsMonoid(h) => (\E b : (\A z : z = b <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))
      /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))   BECAUSE TI;

(\E b : (\A z : z = b <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   => ((\A z : z = BinopProd(g,h) <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))   BECAUSE CHOOSE BinopProd(g,h);
IsMonoid(g) /\ IsMonoid(h) => ((\A z : z = BinopProd(g,h) <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))   BECAUSE TI;
((\A z : z = BinopProd(g,h) <=> (IsApplication(z,(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => z[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))))
   => (BinopProd(g,h) = BinopProd(g,h) <=> (IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)))   BECAUSE \A(z <- BinopProd(g,h));
IsMonoid(g) /\ IsMonoid(h) => (BinopProd(g,h) = BinopProd(g,h) <=> (IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)))   BECAUSE TI;
equalSelf   BECAUSE THEOREM;
BinopProd(g,h) = BinopProd(g,h)   BECAUSE \A(a <- BinopProd(g,h));
IsMonoid(g) /\ IsMonoid(h) => BinopProd(g,h) = BinopProd(g,h)   BECAUSE PT1;
IsMonoid(g) /\ IsMonoid(h) => (IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>))   BECAUSE HITE;

\* Split x into a couple
(IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)) => (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)   BECAUSE S22;
(\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)
   => (<<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>)   BECAUSE \A(x <- <<x,y>>);
\A d : \A i : \A c : \A b : d = i /\ c = b => (BinopProd(g,h)[x,y] = << g[fst(d),fst(c)] , h[snd(d),snd(c)] >> <=> BinopProd(g,h)[x,y] = << g[fst(i),fst(b)] , h[snd(i),snd(b)] >>)   BECAUSE E_SCHEME;
x = fst(<<x,y>>) /\ y = snd(<<x,y>>) => (BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >> <=> BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>)   BECAUSE \A(d <- x, i <- fst(<<x,y>>), c <- y, b <- snd(<<x,y>>));
fstExists   BECAUSE THEOREM;
x = fst(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
sndExists   BECAUSE THEOREM;
y = snd(<<x,y>>)   BECAUSE \A(a <- x, b <- y);
x = fst(<<x,y>>) /\ y = snd(<<x,y>>)   BECAUSE IntroAndRight;
BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >> <=> BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>   BECAUSE MODUS_PONENS;
BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >> => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>   BECAUSE EquivToImplReverse;
IsMonoid(g) /\ IsMonoid(h) => (<<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(fst(<<x,y>>)),fst(snd(<<x,y>>))] , h[snd(fst(<<x,y>>)),snd(snd(<<x,y>>))] >>)   BECAUSE TI2;
hti(a,b,c,h) == (h => (a => b)) => ((b => c) => (h /\ a => c))   PROPO_TAUTO;
IsMonoid(g) /\ IsMonoid(h) /\ <<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>   BECAUSE hti;
x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h))
   <=> <<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))
   BECAUSE \A(x <- (BinopDomain(g) \X BinopDomain(h)), y <- (BinopDomain(g) \X BinopDomain(h)), a <- x, b <- y);
x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h))
   => <<x,y>> \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h))
   BECAUSE EquivToImpl;
IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE injectHypo;
\A y : IsMonoid(g) /\ IsMonoid(h) => (x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE GENERALIZATION;
IsMonoid(g) /\ IsMonoid(h) => (\A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE Q_SCHEME;
\A x : IsMonoid(g) /\ IsMonoid(h) => (\A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE GENERALIZATION;
IsMonoid(g) /\ IsMonoid(h) => (\A x : \A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE Q_SCHEME;
(IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : x \in (BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x] = << g[fst(fst(x)),fst(snd(x))] , h[snd(fst(x)),snd(snd(x))] >>)) => IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))   BECAUSE S12;
IsMonoid(g) /\ IsMonoid(h) => IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h))   BECAUSE TI;
IsMonoid(g) /\ IsMonoid(h) => IsApplication(BinopProd(g,h),(BinopDomain(g) \X BinopDomain(h)) \X (BinopDomain(g) \X BinopDomain(h)),BinopDomain(g) \X BinopDomain(h)) /\ (\A x : \A y : x \in (BinopDomain(g) \X BinopDomain(h)) /\ y \in (BinopDomain(g) \X BinopDomain(h)) => BinopProd(g,h)[x,y] = << g[fst(x),fst(y)] , h[snd(x),snd(y)] >>)   BECAUSE CIA;
binopProdExists   BECAUSE GENERALIZATION;
QED

productMonoidExists == \A f : \A g : IsMonoid(f) /\ IsMonoid(g) =>
   IsMonoid(BinopProd(f,g))
   /\ BinopDomain(BinopProd(f,g)) = BinopDomain(f) \X BinopDomain(g)
   /\ Neutral(BinopProd(f,g)) = <<Neutral(f), Neutral(g)>>
THEOREM productMonoidExists
PROOF
VARIABLES a,b,c,f,g,x,y;
binopProdExists   BECAUSE THEOREM;
IsMonoid(f) /\ IsMonoid(g) =>
   IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g))
   /\ (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g))
       => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)   BECAUSE \A(g <- f, h <- g);

\* Prove that Neutral(BinopProd(f,g)) = <<Neutral(f), Neutral(g)>>
\* hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a
IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g)) /\ (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g))   BECAUSE S12;
IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g)) /\ (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => (\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)   BECAUSE S22;
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>) => (<<Neutral(f), Neutral(g)>> \in (BinopDomain(f) \X BinopDomain(g)) /\ a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>)
   BECAUSE \A(x <- <<Neutral(f), Neutral(g)>>, y <- a);
IsMonoid(f) /\ IsMonoid(g) => (<<Neutral(f), Neutral(g)>> \in (BinopDomain(f) \X BinopDomain(g)) /\ a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>)
   BECAUSE TI2;
cartesianProductCouples   BECAUSE THEOREM;
(Neutral(f) \in BinopDomain(f) /\ Neutral(g) \in BinopDomain(g))
   <=> << Neutral(f),Neutral(g) >> \in BinopDomain(f) \X BinopDomain(g)
   BECAUSE \A(x <- BinopDomain(f), y <- BinopDomain(g), a <- Neutral(f), b <- Neutral(g));
(Neutral(f) \in BinopDomain(f) /\ Neutral(g) \in BinopDomain(g))
   => << Neutral(f),Neutral(g) >> \in BinopDomain(f) \X BinopDomain(g)
   BECAUSE EquivToImpl;
neutralMonoidExists   BECAUSE THEOREM;
IsMonoid(f) => Neutral(f) \in BinopDomain(f) /\ \A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a   BECAUSE \A(op <- f);
Neutral(f) \in BinopDomain(f) /\ (\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a) => Neutral(f) \in BinopDomain(f)   BECAUSE S12;
Neutral(f) \in BinopDomain(f) /\ (\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a) => (\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a)   BECAUSE S22;
IsMonoid(f) => Neutral(f) \in BinopDomain(f)   BECAUSE TI;
IsMonoid(f) => (\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a)   BECAUSE TI;
\A f : IsMonoid(f) => Neutral(f) \in BinopDomain(f)   BECAUSE GENERALIZATION;
IsMonoid(g) => Neutral(g) \in BinopDomain(g)   BECAUSE \A(f <- g);
IsMonoid(f) /\ IsMonoid(g) => Neutral(f) \in BinopDomain(f) /\ Neutral(g) \in BinopDomain(g)   BECAUSE MergeImplicationsAnd;
IsMonoid(f) /\ IsMonoid(g) => <<Neutral(f),Neutral(g)>> \in BinopDomain(f) \X BinopDomain(g)   BECAUSE TI;
killMiddleHypo(a,b,c,h) == (h => (a /\ b => c)) => ((h => a) => (h /\ b => c))   PROPO_TAUTO;
hn(a,f,g) == IsMonoid(f) /\ IsMonoid(g) /\ a \in (BinopDomain(f) \X BinopDomain(g));
hn(a,f,g) => IsMonoid(f)   BECAUSE S13;
hn(a,f,g) => IsMonoid(g)   BECAUSE S23;
hn(a,f,g) => a \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE S22;
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>   BECAUSE killMiddleHypo;
\A d : \A i : \A c : \A b : d = i /\ c = b => (<< f[d,fst(a)] , g[c,snd(a)] >> = << f[i,fst(a)] , g[b,snd(a)] >>)   BECAUSE E_SCHEME;
Neutral(f) = fst(<<Neutral(f), Neutral(g)>>) /\ Neutral(g) = snd(<<Neutral(f), Neutral(g)>>) => << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>   BECAUSE \A(d <- Neutral(f), i <- fst(<<Neutral(f), Neutral(g)>>), c <- Neutral(g), b <- snd(<<Neutral(f), Neutral(g)>>));
fstExists   BECAUSE THEOREM;
Neutral(f) = fst(<<Neutral(f), Neutral(g)>>)   BECAUSE \A(a <- Neutral(f), b <- Neutral(g));
sndExists   BECAUSE THEOREM;
Neutral(g) = snd(<<Neutral(f), Neutral(g)>>)   BECAUSE \A(a <- Neutral(f), b <- Neutral(g));
Neutral(f) = fst(<<Neutral(f), Neutral(g)>>) /\ Neutral(g) = snd(<<Neutral(f), Neutral(g)>>)   BECAUSE IntroAndRight;
<< f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>   BECAUSE MODUS_PONENS;
hn(a,f,g) => << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>   BECAUSE PT1;
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >> /\ << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >>   BECAUSE CIA;
BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >> /\ << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = << f[fst(<<Neutral(f), Neutral(g)>>),fst(a)] , g[snd(<<Neutral(f), Neutral(g)>>),snd(a)] >> => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >>   BECAUSE E_SCHEME;
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >>   BECAUSE TI;

(\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a) => (fst(a) \in BinopDomain(f) => f[fst(a),Neutral(f)] = fst(a) /\ f[Neutral(f),fst(a)] = fst(a))   BECAUSE \A(a <- fst(a));
IsMonoid(f) => (fst(a) \in BinopDomain(f) => f[fst(a),Neutral(f)] = fst(a) /\ f[Neutral(f),fst(a)] = fst(a))   BECAUSE TI;
IsMonoid(f) /\ fst(a) \in BinopDomain(f) => f[fst(a),Neutral(f)] = fst(a) /\ f[Neutral(f),fst(a)] = fst(a)   BECAUSE HypoImplToAnd;
\A f : IsMonoid(f) => (\A a : a \in BinopDomain(f) => f[a,Neutral(f)] = a /\ f[Neutral(f),a] = a)   BECAUSE GENERALIZATION;
IsMonoid(g) => (\A a : a \in BinopDomain(g) => g[a,Neutral(g)] = a /\ g[Neutral(g),a] = a)   BECAUSE \A(f <- g);
(\A a : a \in BinopDomain(g) => g[a,Neutral(g)] = a /\ g[Neutral(g),a] = a) => (snd(a) \in BinopDomain(g) => g[snd(a),Neutral(g)] = snd(a) /\ g[Neutral(g),snd(a)] = snd(a))   BECAUSE \A(a <- snd(a));
IsMonoid(g) => (snd(a) \in BinopDomain(g) => g[snd(a),Neutral(g)] = snd(a) /\ g[Neutral(g),snd(a)] = snd(a))   BECAUSE TI;
IsMonoid(g) /\ snd(a) \in BinopDomain(g) => g[snd(a),Neutral(g)] = snd(a) /\ g[Neutral(g),snd(a)] = snd(a)   BECAUSE HypoImplToAnd;
cartesianProductExists   BECAUSE THEOREM;
a \in (BinopDomain(f) \X BinopDomain(g)) <=> IsCouple(a) /\ fst(a) \in BinopDomain(f) /\ snd(a) \in BinopDomain(g)
   BECAUSE \A(i <- BinopDomain(f), j <- BinopDomain(g), x <- a);
a \in (BinopDomain(f) \X BinopDomain(g)) => IsCouple(a) /\ fst(a) \in BinopDomain(f) /\ snd(a) \in BinopDomain(g)
   BECAUSE EquivToImpl;
IsCouple(a) /\ fst(a) \in BinopDomain(f) /\ snd(a) \in BinopDomain(g) => IsCouple(a)   BECAUSE S13;
IsCouple(a) /\ fst(a) \in BinopDomain(f) /\ snd(a) \in BinopDomain(g) => fst(a) \in BinopDomain(f)   BECAUSE S23;
IsCouple(a) /\ fst(a) \in BinopDomain(f) /\ snd(a) \in BinopDomain(g) => snd(a) \in BinopDomain(g)   BECAUSE S22;
hn(a,f,g) => fst(a) \in BinopDomain(f)   BECAUSE TI2;
hn(a,f,g) => snd(a) \in BinopDomain(g)   BECAUSE TI2;
hn(a,f,g) => IsMonoid(f) /\ fst(a) \in BinopDomain(f)   BECAUSE CIA;
hn(a,f,g) => IsMonoid(g) /\ snd(a) \in BinopDomain(g)   BECAUSE CIA;
f[fst(a),Neutral(f)] = fst(a) /\ f[Neutral(f),fst(a)] = fst(a) => f[Neutral(f),fst(a)] = fst(a)   BECAUSE S22;
g[snd(a),Neutral(g)] = snd(a) /\ g[Neutral(g),snd(a)] = snd(a) => g[Neutral(g),snd(a)] = snd(a)   BECAUSE S22;
hn(a,f,g) => f[Neutral(f),fst(a)] = fst(a)   BECAUSE TI2;
hn(a,f,g) => g[Neutral(g),snd(a)] = snd(a)   BECAUSE TI2;
hn(a,f,g) => f[Neutral(f),fst(a)] = fst(a) /\ g[Neutral(g),snd(a)] = snd(a)   BECAUSE CIA;
\A d : \A i : \A c : \A b : d = i /\ c = b => (<<d,c>> = <<i,b>>)   BECAUSE E_SCHEME;
f[Neutral(f),fst(a)] = fst(a) /\ g[Neutral(g),snd(a)] = snd(a) => << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = <<fst(a),snd(a)>>
   BECAUSE \A(d <- f[Neutral(f),fst(a)], i <- fst(a), c <- g[Neutral(g),snd(a)], b <- snd(a));
hn(a,f,g) => << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = <<fst(a),snd(a)>>   BECAUSE TI;
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> /\ << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = <<fst(a),snd(a)>>   BECAUSE CIA;
transitEqual   BECAUSE THEOREM;
BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> /\ << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >> = <<fst(a),snd(a)>> => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = <<fst(a),snd(a)>>
   BECAUSE \A(a <- BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a], b <- << f[Neutral(f),fst(a)] , g[Neutral(g),snd(a)] >>, c <- <<fst(a),snd(a)>>);
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = <<fst(a),snd(a)>>   BECAUSE TI;
tupleComposition   BECAUSE THEOREM;
IsCouple(a) => a = <<fst(a), snd(a)>>   BECAUSE \A(c <- a);
hn(a,f,g) => IsCouple(a)   BECAUSE TI2;
hn(a,f,g) => a = <<fst(a), snd(a)>>   BECAUSE TI;
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = <<fst(a),snd(a)>> /\ a = <<fst(a), snd(a)>>   BECAUSE CIA;
BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = <<fst(a),snd(a)>> /\ a = <<fst(a), snd(a)>> => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a   BECAUSE E_SCHEME;
hn(a,f,g) => BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a   BECAUSE TI;

\* Symmetrically, prove hn(a,f,g) => BinopProd(f,g)[a, <<Neutral(f), Neutral(g)>>] = a
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ <<Neutral(f), Neutral(g)>> \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>)
   BECAUSE \A(x <- a, y <- <<Neutral(f), Neutral(g)>>);
IsMonoid(f) /\ IsMonoid(g) => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ <<Neutral(f), Neutral(g)>> \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>)   BECAUSE TI2;
killMiddleHypo2(a,b,c,h) == (h => (a /\ b => c)) => ((h => b) => (h /\ a => c))   PROPO_TAUTO;
hn(a,f,g) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>   BECAUSE killMiddleHypo2;
\A d : \A i : \A c : \A b : d = i /\ c = b => (<< f[fst(a),d] , g[snd(a),c] >> = << f[fst(a),i] , g[snd(a),b] >>)   BECAUSE E_SCHEME;
Neutral(f) = fst(<<Neutral(f), Neutral(g)>>) /\ Neutral(g) = snd(<<Neutral(f), Neutral(g)>>) => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>   BECAUSE \A(d <- Neutral(f), i <- fst(<<Neutral(f), Neutral(g)>>), c <- Neutral(g), b <- snd(<<Neutral(f), Neutral(g)>>));
<< f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>   BECAUSE MODUS_PONENS;
hn(a,f,g) => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>   BECAUSE PT1;
hn(a,f,g) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >> /\ << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >>   BECAUSE CIA;
BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >> /\ << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = << f[fst(a),fst(<<Neutral(f), Neutral(g)>>)] , g[snd(a),snd(<<Neutral(f), Neutral(g)>>)] >> => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >>   BECAUSE E_SCHEME;
hn(a,f,g) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >>   BECAUSE TI;
f[fst(a),Neutral(f)] = fst(a) /\ f[Neutral(f),fst(a)] = fst(a) => f[fst(a),Neutral(f)] = fst(a)   BECAUSE S12;
g[snd(a),Neutral(g)] = snd(a) /\ g[Neutral(g),snd(a)] = snd(a) => g[snd(a),Neutral(g)] = snd(a)   BECAUSE S12;
hn(a,f,g) => f[fst(a),Neutral(f)] = fst(a)   BECAUSE TI2;
hn(a,f,g) => g[snd(a),Neutral(g)] = snd(a)   BECAUSE TI2;
hn(a,f,g) => f[fst(a),Neutral(f)] = fst(a) /\ g[snd(a),Neutral(g)] = snd(a)   BECAUSE CIA;
f[fst(a),Neutral(f)] = fst(a) /\ g[snd(a),Neutral(g)] = snd(a) => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = <<fst(a),snd(a)>>
   BECAUSE \A(d <- f[fst(a),Neutral(f)], i <- fst(a), c <- g[snd(a),Neutral(g)], b <- snd(a));
hn(a,f,g) => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = <<fst(a),snd(a)>>   BECAUSE TI;
hn(a,f,g) => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = <<fst(a),snd(a)>> /\ a = <<fst(a), snd(a)>>   BECAUSE CIA;
<< f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = <<fst(a),snd(a)>> /\ a = <<fst(a), snd(a)>> => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = a   BECAUSE E_SCHEME;
hn(a,f,g) => << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = a   BECAUSE TI;
hn(a,f,g) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> /\ << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = a   BECAUSE CIA;
BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> /\ << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >> = a => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a
   BECAUSE \A(a <- BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>], b <- << f[fst(a),Neutral(f)] , g[snd(a),Neutral(g)] >>, c <- a);
hn(a,f,g) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a   BECAUSE TI;
hn(a,f,g) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a /\ BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a   BECAUSE CIA;
IsMonoid(f) /\ IsMonoid(g) => (a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a /\ BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a)   BECAUSE HypoAndToImpl;
\A a : IsMonoid(f) /\ IsMonoid(g) => (a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a /\ BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a)   BECAUSE GENERALIZATION;
IsMonoid(f) /\ IsMonoid(g) => (\A a : a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a /\ BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a)   BECAUSE Q_SCHEME;
(\A a : a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,<<Neutral(f), Neutral(g)>>] = a /\ BinopProd(f,g)[<<Neutral(f), Neutral(g)>>,a] = a) => \E e : (\A a : a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,e] = a /\ BinopProd(f,g)[e,a] = a)   BECAUSE \E(e <- <<Neutral(f), Neutral(g)>>);
IsMonoid(f) /\ IsMonoid(g) => \E e : (\A a : a \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,e] = a /\ BinopProd(f,g)[e,a] = a)   BECAUSE TI;

\* Prove Neutral(BinopProd(f,g)) = <<Neutral(f),Neutral(g)>> by neutralMonoidExistsUniquely

\* Prove associativity
\* (<<a,b>> . <<c,d>>) . <<e,f>> = << (a.c).e, (b.d).f >>
\* = << a.(c.e), b.(d.f) >> = <<a,b>> . (<<c,d>> . <<e,f>>)
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,b] = << f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)
   BECAUSE \A(x <- a, y <- b);
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => (b \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[b,c] = << f[fst(b),fst(c)] , g[snd(b),snd(c)] >>)
   BECAUSE \A(x <- b, y <- c);
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => (BinopProd(f,g)[a,b] \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>)
   BECAUSE \A(x <- BinopProd(f,g)[a,b], y <- c);
(\A x : \A y : x \in (BinopDomain(f) \X BinopDomain(g)) /\ y \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[x,y] = << f[fst(x),fst(y)] , g[snd(x),snd(y)] >>)
   => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ BinopProd(f,g)[b,c] \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,BinopProd(f,g)[b,c]] = << f[fst(a),fst(BinopProd(f,g)[b,c])] , g[snd(a),snd(BinopProd(f,g)[b,c])] >>)
   BECAUSE \A(x <- a, y <- BinopProd(f,g)[b,c]);
ha(a,b,c,f,g) == IsMonoid(f) /\ IsMonoid(g) /\ a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g));
ha(a,b,c,f,g) => IsMonoid(f) /\ IsMonoid(g)   BECAUSE S14;
ha(a,b,c,f,g) => a \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE S24;
ha(a,b,c,f,g) => b \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE S23;
ha(a,b,c,f,g) => c \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE S22;
IsMonoid(f) /\ IsMonoid(g) => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,b] = << f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE TI2;
ha(a,b,c,f,g) => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,b] = << f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE TI;
IsMonoid(f) /\ IsMonoid(g) => (b \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[b,c] = << f[fst(b),fst(c)] , g[snd(b),snd(c)] >>)   BECAUSE TI2;
IsMonoid(f) /\ IsMonoid(g) => (BinopProd(f,g)[a,b] \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>)   BECAUSE TI2;
IsMonoid(f) /\ IsMonoid(g) => (a \in (BinopDomain(f) \X BinopDomain(g)) /\ BinopProd(f,g)[b,c] \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,BinopProd(f,g)[b,c]] = << f[fst(a),fst(BinopProd(f,g)[b,c])] , g[snd(a),snd(BinopProd(f,g)[b,c])] >>)   BECAUSE TI2;
ha(a,b,c,f,g) => a \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE S24;
ha(a,b,c,f,g) => b \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE S23;
ha(a,b,c,f,g) => a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE CIA;
ha(a,b,c,f,g) => BinopProd(f,g)[a,b] = << f[fst(a),fst(b)] , g[snd(a),snd(b)] >>   BECAUSE KillMiddleHypo;

ha(a,b,c,f,g) => IsApplication(BinopProd(f,g), (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), BinopDomain(f) \X BinopDomain(g))   BECAUSE TI2;

appDomainToImage   BECAUSE THEOREM;
IsApplication(BinopProd(f,g),(BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), (BinopDomain(f) \X BinopDomain(g))) /\ <<a,b>> \in (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[a,b] \in (BinopDomain(f) \X BinopDomain(g))
   BECAUSE \A(f <- BinopProd(f,g), d <- (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), i <- (BinopDomain(f) \X BinopDomain(g)), x <- <<a,b>>);
ha(a,b,c,f,g) => IsApplication(BinopProd(f,g),(BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), (BinopDomain(f) \X BinopDomain(g)))   BECAUSE TI2;
(a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g)))
   <=> <<a,b>> \in (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g))
   BECAUSE \A(x <- (BinopDomain(f) \X BinopDomain(g)), y <- (BinopDomain(f) \X BinopDomain(g)), a <- a, b <- b);
(a \in (BinopDomain(f) \X BinopDomain(g)) /\ b \in (BinopDomain(f) \X BinopDomain(g)))
   => <<a,b>> \in (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g))
   BECAUSE EquivToImpl;
ha(a,b,c,f,g) => <<a,b>> \in (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g))   BECAUSE TI;
ha(a,b,c,f,g) => IsApplication(BinopProd(f,g),(BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g)), (BinopDomain(f) \X BinopDomain(g))) /\ <<a,b>> \in (BinopDomain(f) \X BinopDomain(g)) \X (BinopDomain(f) \X BinopDomain(g))   BECAUSE CIA;
ha(a,b,c,f,g) => BinopProd(f,g)[a,b] \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE TI;
ha(a,b,c,f,g) => (BinopProd(f,g)[a,b] \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g)) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>)   BECAUSE TI;
ha(a,b,c,f,g) => BinopProd(f,g)[a,b] \in (BinopDomain(f) \X BinopDomain(g)) /\ c \in (BinopDomain(f) \X BinopDomain(g))   BECAUSE CIA;
ha(a,b,c,f,g) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>   BECAUSE KillMiddleHypo;
\A d : \A i : \A x : \A b : d = i /\ x = b => (<< f[d,fst(c)] , g[x,snd(c)] >> = << f[i,fst(c)] , g[b,snd(c)] >>)   BECAUSE E_SCHEME;
f[fst(a),fst(b)] = fst(BinopProd(f,g)[a,b]) /\ g[snd(a),snd(b)] = snd(BinopProd(f,g)[a,b])
   => << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>
   BECAUSE \A(d <- f[fst(a),fst(b)], i <- fst(BinopProd(f,g)[a,b]), x <- g[snd(a),snd(b)], b <- snd(BinopProd(f,g)[a,b]));

\A x : \A y : x = y => fst(x) = fst(y)   BECAUSE E_SCHEME;
BinopProd(f,g)[a,b] = << f[fst(a),fst(b)] , g[snd(a),snd(b)] >> => fst(BinopProd(f,g)[a,b]) = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE \A(x <- BinopProd(f,g)[a,b], y <- << f[fst(a),fst(b)] , g[snd(a),snd(b)] >>);
ha(a,b,c,f,g) => fst(BinopProd(f,g)[a,b]) = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE TI;
\A x : \A y : x = y => snd(x) = snd(y)   BECAUSE E_SCHEME;
BinopProd(f,g)[a,b] = << f[fst(a),fst(b)] , g[snd(a),snd(b)] >> => snd(BinopProd(f,g)[a,b]) = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE \A(x <- BinopProd(f,g)[a,b], y <- << f[fst(a),fst(b)] , g[snd(a),snd(b)] >>);
ha(a,b,c,f,g) => snd(BinopProd(f,g)[a,b]) = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE TI;

f[fst(a),fst(b)] = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE \A(a <- f[fst(a),fst(b)], b <- g[snd(a),snd(b)]);
ha(a,b,c,f,g) => f[fst(a),fst(b)] = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE PT1;
ha(a,b,c,f,g) => f[fst(a),fst(b)] = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>) /\ fst(BinopProd(f,g)[a,b]) = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE CIA;
f[fst(a),fst(b)] = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>) /\ fst(BinopProd(f,g)[a,b]) = fst(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>) => f[fst(a),fst(b)] = fst(BinopProd(f,g)[a,b])   BECAUSE E_SCHEME;
ha(a,b,c,f,g) => f[fst(a),fst(b)] = fst(BinopProd(f,g)[a,b])   BECAUSE TI;
g[snd(a),snd(b)] = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE \A(a <- f[fst(a),fst(b)], b <- g[snd(a),snd(b)]);
ha(a,b,c,f,g) => g[snd(a),snd(b)] = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE PT1;
ha(a,b,c,f,g) => g[snd(a),snd(b)] = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>) /\ snd(BinopProd(f,g)[a,b]) = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>)   BECAUSE CIA;
g[snd(a),snd(b)] = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>) /\ snd(BinopProd(f,g)[a,b]) = snd(<< f[fst(a),fst(b)] , g[snd(a),snd(b)] >>) => g[snd(a),snd(b)] = snd(BinopProd(f,g)[a,b])   BECAUSE E_SCHEME;
ha(a,b,c,f,g) => g[snd(a),snd(b)] = snd(BinopProd(f,g)[a,b])   BECAUSE TI;

ha(a,b,c,f,g) => f[fst(a),fst(b)] = fst(BinopProd(f,g)[a,b]) /\ g[snd(a),snd(b)] = snd(BinopProd(f,g)[a,b])  BECAUSE CIA;
ha(a,b,c,f,g) => << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>   BECAUSE TI;
ha(a,b,c,f,g) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >> /\ << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >>   BECAUSE CIA;
BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >> /\ << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(BinopProd(f,g)[a,b]),fst(c)] , g[snd(BinopProd(f,g)[a,b]),snd(c)] >> => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >>   BECAUSE E_SCHEME;
ha(a,b,c,f,g) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >>   BECAUSE TI;

monoidDomainExists   BECAUSE THEOREM;
IsMonoid(f) => IsApplication(f, BinopDomain(f) \X BinopDomain(f), BinopDomain(f))
   /\ (\A a : \A b : \A c : a \in BinopDomain(f) /\ b \in BinopDomain(f) /\ c \in BinopDomain(f) => f[f[a,b],c] = f[a,f[b,c]] )
   /\ (\E e : e \in BinopDomain(f) /\ \A a : a \in BinopDomain(f) => f[a,e] = a /\ f[e,a] = a)
   BECAUSE \A(op <- f);
IsApplication(f, BinopDomain(f) \X BinopDomain(f), BinopDomain(f)) /\ (\A a : \A b : \A c : a \in BinopDomain(f) /\ b \in BinopDomain(f) /\ c \in BinopDomain(f) => f[f[a,b],c] = f[a,f[b,c]] ) /\ (\E e : e \in BinopDomain(f) /\ \A a : a \in BinopDomain(f) => f[a,e] = a /\ f[e,a] = a) => (\A a : \A b : \A c : a \in BinopDomain(f) /\ b \in BinopDomain(f) /\ c \in BinopDomain(f) => f[f[a,b],c] = f[a,f[b,c]] )   BECAUSE S23;
IsMonoid(f) => (\A a : \A b : \A c : a \in BinopDomain(f) /\ b \in BinopDomain(f) /\ c \in BinopDomain(f) => f[f[a,b],c] = f[a,f[b,c]] )   BECAUSE TI;
(\A a : \A b : \A c : a \in BinopDomain(f) /\ b \in BinopDomain(f) /\ c \in BinopDomain(f) => f[f[a,b],c] = f[a,f[b,c]] ) => (fst(a) \in BinopDomain(f) /\ fst(b) \in BinopDomain(f) /\ fst(c) \in BinopDomain(f) => f[f[fst(a),fst(b)],fst(c)] = f[fst(a),f[fst(b),fst(c)]] )   BECAUSE \A(a <- fst(a), b <- fst(b), c <- fst(c));
IsMonoid(f) /\ IsMonoid(g) => IsMonoid(f)   BECAUSE S12;
IsMonoid(f) /\ IsMonoid(g) => (fst(a) \in BinopDomain(f) /\ fst(b) \in BinopDomain(f) /\ fst(c) \in BinopDomain(f) => f[f[fst(a),fst(b)],fst(c)] = f[fst(a),f[fst(b),fst(c)]] )   BECAUSE TI2;
ha(a,b,c,f,g) => (fst(a) \in BinopDomain(f) /\ fst(b) \in BinopDomain(f) /\ fst(c) \in BinopDomain(f) => f[f[fst(a),fst(b)],fst(c)] = f[fst(a),f[fst(b),fst(c)]] )   BECAUSE TI;
a \in (BinopDomain(f) \X BinopDomain(g)) => fst(a) \in BinopDomain(f)   BECAUSE TI;
\A a : a \in (BinopDomain(f) \X BinopDomain(g)) => fst(a) \in BinopDomain(f)   BECAUSE GENERALIZATION;
b \in (BinopDomain(f) \X BinopDomain(g)) => fst(b) \in BinopDomain(f)   BECAUSE \A(a <- b);
c \in (BinopDomain(f) \X BinopDomain(g)) => fst(c) \in BinopDomain(f)   BECAUSE \A(a <- c);
ha(a,b,c,f,g) => fst(a) \in BinopDomain(f)   BECAUSE TI;
ha(a,b,c,f,g) => fst(b) \in BinopDomain(f)   BECAUSE TI;
ha(a,b,c,f,g) => fst(c) \in BinopDomain(f)   BECAUSE TI;
ha(a,b,c,f,g) => fst(a) \in BinopDomain(f) /\ fst(b) \in BinopDomain(f)   BECAUSE CIA;
ha(a,b,c,f,g) => fst(a) \in BinopDomain(f) /\ fst(b) \in BinopDomain(f) /\ fst(c) \in BinopDomain(f)   BECAUSE CIA;
ha(a,b,c,f,g) => f[f[fst(a),fst(b)],fst(c)] = f[fst(a),f[fst(b),fst(c)]]   BECAUSE KillMiddleHypo;

a \in (BinopDomain(f) \X BinopDomain(g)) => snd(a) \in BinopDomain(g)   BECAUSE TI;
\A a : a \in (BinopDomain(f) \X BinopDomain(g)) => snd(a) \in BinopDomain(g)   BECAUSE GENERALIZATION;
b \in (BinopDomain(f) \X BinopDomain(g)) => snd(b) \in BinopDomain(g)   BECAUSE \A(a <- b);
c \in (BinopDomain(f) \X BinopDomain(g)) => snd(c) \in BinopDomain(g)   BECAUSE \A(a <- c);
ha(a,b,c,f,g) => snd(a) \in BinopDomain(g)   BECAUSE TI;
ha(a,b,c,f,g) => snd(b) \in BinopDomain(g)   BECAUSE TI;
ha(a,b,c,f,g) => snd(c) \in BinopDomain(g)   BECAUSE TI;
ha(a,b,c,f,g) => snd(a) \in BinopDomain(g) /\ snd(b) \in BinopDomain(g)   BECAUSE CIA;
ha(a,b,c,f,g) => snd(a) \in BinopDomain(g) /\ snd(b) \in BinopDomain(g) /\ snd(c) \in BinopDomain(g)   BECAUSE CIA;
(\A a : \A b : \A c : a \in BinopDomain(f) /\ b \in BinopDomain(f) /\ c \in BinopDomain(f) => f[f[a,b],c] = f[a,f[b,c]] ) => (snd(a) \in BinopDomain(f) /\ snd(b) \in BinopDomain(f) /\ snd(c) \in BinopDomain(f) => f[f[snd(a),snd(b)],snd(c)] = f[snd(a),f[snd(b),snd(c)]] )   BECAUSE \A(a <- snd(a), b <- snd(b), c <- snd(c));
IsMonoid(f) => (snd(a) \in BinopDomain(f) /\ snd(b) \in BinopDomain(f) /\ snd(c) \in BinopDomain(f) => f[f[snd(a),snd(b)],snd(c)] = f[snd(a),f[snd(b),snd(c)]] )   BECAUSE TI;
\A f : IsMonoid(f) => (snd(a) \in BinopDomain(f) /\ snd(b) \in BinopDomain(f) /\ snd(c) \in BinopDomain(f) => f[f[snd(a),snd(b)],snd(c)] = f[snd(a),f[snd(b),snd(c)]] )   BECAUSE GENERALIZATION;
IsMonoid(g) => (snd(a) \in BinopDomain(g) /\ snd(b) \in BinopDomain(g) /\ snd(c) \in BinopDomain(g) => g[g[snd(a),snd(b)],snd(c)] = g[snd(a),g[snd(b),snd(c)]] )   BECAUSE \A(f <- g);
IsMonoid(f) /\ IsMonoid(g) => IsMonoid(g)   BECAUSE S22;
ha(a,b,c,f,g) => (snd(a) \in BinopDomain(g) /\ snd(b) \in BinopDomain(g) /\ snd(c) \in BinopDomain(g) => g[g[snd(a),snd(b)],snd(c)] = g[snd(a),g[snd(b),snd(c)]] )   BECAUSE TI2;
ha(a,b,c,f,g) => g[g[snd(a),snd(b)],snd(c)] = g[snd(a),g[snd(b),snd(c)]]   BECAUSE KillMiddleHypo;
ha(a,b,c,f,g) => f[f[fst(a),fst(b)],fst(c)] = f[fst(a),f[fst(b),fst(c)]] /\ g[g[snd(a),snd(b)],snd(c)] = g[snd(a),g[snd(b),snd(c)]]   BECAUSE CIA;
\A x : \A y : \A a : \A b : x = y /\ a = b => <<x,a>> = <<y,b>>   BECAUSE E_SCHEME;
f[f[fst(a),fst(b)],fst(c)] = f[fst(a),f[fst(b),fst(c)]] /\ g[g[snd(a),snd(b)],snd(c)] = g[snd(a),g[snd(b),snd(c)]] => << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>
   BECAUSE \A(x <- f[f[fst(a),fst(b)],fst(c)], y <- f[fst(a),f[fst(b),fst(c)]], a <- g[g[snd(a),snd(b)],snd(c)], b <- g[snd(a),g[snd(b),snd(c)]]);
ha(a,b,c,f,g) => << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>   BECAUSE TI;
ha(a,b,c,f,g) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> /\ << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>   BECAUSE CIA;
BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> /\ << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >> = << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>
   => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>
   BECAUSE \A(a <- BinopProd(f,g)[BinopProd(f,g)[a,b],c], b <- << f[f[fst(a),fst(b)],fst(c)] , g[g[snd(a),snd(b)],snd(c)] >>, c <- << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>);
ha(a,b,c,f,g) => BinopProd(f,g)[BinopProd(f,g)[a,b],c] = << f[fst(a), f[fst(b),fst(c)]] , g[snd(a), g[snd(b),snd(c)]] >>   BECAUSE TI;

\* TODO
\* = BinopProd(f,g)[a, BinopProd(f,g)[b,c]]
QED

(* TODO IsMonoid(Nat,natAddition), product monoid, group of a regular monoid *)