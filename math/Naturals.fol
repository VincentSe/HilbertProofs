EXTENDS Orders

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE_UNIQUE o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))

NatExists == (\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))
   /\ IsLimitOrdinal(Nat)
THEOREM NatExists
PROOF
\* By separation in a set given by the axiom of infinity
VARIABLES a,b,c,o,p,t,u,x,y,z,nat;
Infinity   BECAUSE AXIOM;
\A a : \E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE \A(a <- a);
\* Take a from the axiom of infinity and b from separation of finite ordinals
h(a,b) == {} \in a /\ (\A x : x \in a => successor(x) \in a)
   /\ \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x);
h(a,b) => \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE S22;

\* Prove UNION b is Nat, ie IsFiniteOrdinal(x) <=> x \in UNION b.
\* First prove that UNION b is an ordinal.
unionOrdinalsIsOrdinal   BECAUSE THEOREM;
(\A x : x \in b => IsOrdinal(x)) => IsOrdinal(UNION b)   BECAUSE \A(u <- b);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b <=> x \in a /\ IsFiniteOrdinal(x))
   BECAUSE \A(x <- x);
(x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE EquivToImpl;
h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE TI2;
IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE S13;
\A a : IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(a <- x);
extractProp(a,b,c,d) == (a => b) => ((c => d /\ a) => (c => b))   PROPO_TAUTO;
(x \in b => x \in a /\ IsFiniteOrdinal(x)) => (x \in b => IsOrdinal(x))   BECAUSE extractProp;
h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE TI;
\A x : h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in b => IsOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) => IsOrdinal(UNION b)   BECAUSE TI;

\* Proof that UNION b is a limit ordinal.
\* If o \in UNION b then successor(o) \in UNION b, so UNION b # successor o.
unionExists   BECAUSE AXIOM;
x \in UNION b <=> \E t : t \in b /\ x \in t   BECAUSE \A(b <- b, z <- x);
x \in UNION b => \E t : t \in b /\ x \in t   BECAUSE EquivToImpl;
\A x : h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => h(a,b)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => t \in b   BECAUSE S23;
h(a,b) /\ t \in b /\ x \in t => t \in a /\ IsFiniteOrdinal(t)   BECAUSE KillMiddleHypo;
h(a,b) => \A x : x \in a => successor(x) \in a   BECAUSE S23;
(\A x : x \in a => successor(x) \in a) => (t \in a => successor(t) \in a)   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => (t \in a => successor(t) \in a)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => t \in a   BECAUSE S12;
h(a,b) /\ t \in b /\ x \in t => t \in a   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a   BECAUSE KillMiddleHypo;
\* So successor(t) \in b.
\* Then successor(x) \in successor(t) \in b implies successor(x) \in UNION b.
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(t) => IsFiniteOrdinal( successor(t) )   BECAUSE \A(o <- t);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t)))   BECAUSE \A(x <- successor(t));
(successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t))) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE EquivToImplReverse;
h(a,b) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => IsFiniteOrdinal(t)   BECAUSE S22;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(successor(t))   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a /\ IsFiniteOrdinal(successor(t))   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in b   BECAUSE KillMiddleHypo;
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t => successor(x) \in successor(t)   BECAUSE \A(o <- x, p <- t);
IsFiniteOrdinal(t) => IsOrdinal(t)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t)   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => x \in t   BECAUSE S22;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(t) /\ x \in t => IsOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t)   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t)   BECAUSE TI;
inInUnion   BECAUSE THEOREM;
(successor(x) \in successor(t) /\ successor(t) \in b) => successor(x) \in UNION b   BECAUSE \A(a <- successor(x), b <- successor(t), c <- b);
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t) /\ successor(t) \in b   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in UNION b   BECAUSE TI;
pushHypos(h,a,b,c) == (h /\ a /\ b => c) => (h => (a /\ b => c))   PROPO_TAUTO;
h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => successor(x) \in UNION b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE Q_SCHEME;
h(a,b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE TI;
mergeHypos(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(a,b) /\ x \in UNION b => \E t : successor(x) \in UNION b   BECAUSE mergeHypos;
(\E t : successor(x) \in UNION b) => successor(x) \in UNION b   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => successor(x) \in UNION b   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(UNION b) /\ successor(x) \in UNION b => successor(x) # (UNION b) /\ (UNION b) \notin successor(x)   BECAUSE \A(o <- successor(x), p <- UNION b);
h(a,b) /\ x \in UNION b => h(a,b)   BECAUSE S12;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b)   BECAUSE TI2;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b) /\ successor(x) \in UNION b   BECAUSE CIA;
successor(x) # (UNION b) /\ (UNION b) \notin successor(x) => successor(x) # UNION b   BECAUSE S12;
h(a,b) /\ x \in UNION b => successor(x) # UNION b   BECAUSE TI2;
UNION b = successor(x) => successor(x) = UNION b   BECAUSE E_SCHEME;
successor(x) # UNION b => UNION b # successor(x)   BECAUSE Contraposition;
h(a,b) /\ x \in UNION b => UNION b # successor(x)   BECAUSE TI;
h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE HypoAndToImpl;
\A x : h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b => UNION b # successor(x))   BECAUSE Q_SCHEME;

\* {} \in successor({}) \in b, so {} \in UNION b
h(a,b) => {} \in a   BECAUSE S13;
(\A x : x \in a => successor(x) \in a) => ({} \in a => successor({}) \in a)   BECAUSE \A(x <- {});
h(a,b) => ({} \in a => successor({}) \in a)   BECAUSE TI;
h(a,b) => successor({}) \in a   BECAUSE KillMiddleHypo;
ordinalZero   BECAUSE THEOREM;
IsFiniteOrdinal({}) => IsFiniteOrdinal( successor({}) )   BECAUSE \A(o <- {});
IsFiniteOrdinal( successor({}) )   BECAUSE MODUS_PONENS;
successor({}) \in a => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE IntroAndLeft;
h(a,b) => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE TI;
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE \A(x <- successor({}));
h(a,b) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE TI;
killCase(h,a,b) == (h => a) => ((h => (b <=> a)) => (h => b))   PROPO_TAUTO;
h(a,b) => successor({}) \in b   BECAUSE killCase;
inSuccessor   BECAUSE THEOREM;
{} \in successor({})   BECAUSE \A(o <- {});
h(a,b) => {} \in successor({})   BECAUSE PT1;
h(a,b) => {} \in successor({}) /\ successor({}) \in b   BECAUSE CIA;
({} \in successor({}) /\ successor({}) \in b) => {} \in UNION b   BECAUSE \A(a <- {}, b <- successor({}), c <- b);
h(a,b) => {} \in UNION b   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
UNION b = {} <=> \A x : x \notin UNION b   BECAUSE \A(c <- UNION b);
(\E x : x \in UNION b) <=> ~\A x : x \notin UNION b   BECAUSE Q_SCHEME;
(\E x : x \in UNION b) => ~\A x : x \notin UNION b   BECAUSE EquivToImpl;
{} \in UNION b => \E x : x \in UNION b   BECAUSE \E(x <- {});
h(a,b) => ~\A x : x \notin UNION b   BECAUSE TI2;
UNION b = {} => \A x : x \notin UNION b   BECAUSE EquivToImpl;
~(\A x : x \notin UNION b) => UNION b # {}   BECAUSE Contraposition;
h(a,b) => UNION b # {}   BECAUSE TI;
h(a,b) => IsOrdinal(UNION b) /\ UNION b # {}   BECAUSE CIA;
h(a,b) => IsLimitOrdinal(UNION b)   BECAUSE CIA;

\* Proof that IsFiniteOrdinal(x) => x \in UNION b
ordinalComparison   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(UNION b) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE \A(o <- x, p <- UNION b);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => IsFiniteOrdinal(x)   BECAUSE S22;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => h(a,b)   BECAUSE S12;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(UNION b)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x) /\ IsOrdinal(UNION b)   BECAUSE CIA;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE TI;
\* because UNION b is infinite, only the first case is possible.
IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE S23;
\A o : IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE TI;
\A x : \A b : x = b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(b))   BECAUSE E_SCHEME;
x = UNION b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(UNION b))   BECAUSE \A(x <- x, b <- UNION b);
h(a,b) /\ IsFiniteOrdinal(x) => IsLimitOrdinal(UNION b)   BECAUSE TI;
killCaseB(h,a,b,c) == (h => ~a) => ((h => c) => (((b => (a <=> c)) => (h => ~b))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x # UNION b   BECAUSE killCaseB;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(x) /\ UNION b \in x => IsFiniteOrdinal(UNION b)   BECAUSE \A(o <- x, x <- UNION b);
IsFiniteOrdinal(UNION b) => ~IsLimitOrdinal(UNION b)   BECAUSE \A(o <- UNION b);
IsFiniteOrdinal(x) /\ UNION b \in x => ~IsLimitOrdinal(UNION b)   BECAUSE TI;
IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE HypoAndToImpl;
h(a,b) /\ IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE TI;
killCaseD(h,a,b) == (h => (b => ~a)) => ((h => a) => (h => ~b))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => UNION b \notin x   BECAUSE killCaseD;
killCaseE(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b   BECAUSE killCaseE;

\* Conversely, x \in UNION b is an ordinal as an element of an ordinal.
\* And x \in t \in b where t is a finite ordinal, so x is finite too.
IsFiniteOrdinal(t) /\ x \in t => IsFiniteOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => IsFiniteOrdinal(x)) => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE TI2;
h(a,b) /\ x \in UNION b => x \in UNION b   BECAUSE S22;
h(a,b) /\ x \in UNION b => (\E t : t \in b /\ x \in t)   BECAUSE TI;
h(a,b) /\ x \in UNION b => \E t : IsFiniteOrdinal(x)   BECAUSE KillMiddleHypo;
(\E t : IsFiniteOrdinal(x)) => IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE HIE;
\A x : h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;

hA(a) == {} \in a /\ (\A x : x \in a => successor(x) \in a);
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))
   => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE TI;
hA(a) => (\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x))   BECAUSE PT1;
hA(a) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE KillMiddleHypo;
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE \E(o <- UNION b);
(\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
hA(a) => (\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE TI;
(\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => (\E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
hA(a) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE TI;
(\E a : hA(a)) => \E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
(\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;

\* Proof that Nat is unique. By extensionality, being in another Nat
\* is equivalent, it is being a finite ordinal.
ho(o) == \A x : x \in o <=> IsFiniteOrdinal(x);
\A z : \A o : z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE E_SCHEME;
z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE \A(z <- z, o <- o);
killCaseF(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
ho(o) /\ z = o => (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE killCaseF;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in o) => z = o   BECAUSE \A(a <- z, b <- o);
ho(o) => (x \in o <=> IsFiniteOrdinal(x))   BECAUSE \A(x <- x);
tEquiv(a,b,c,h) == (h => (a <=> b)) => (h => ((c <=> b) => (c <=> a)))   PROPO_TAUTO;
ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE tEquiv;
\A x : ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE GENERALIZATION;
ho(o) => (\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE Q_SCHEME;
(\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o)) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE Q_SCHEME;
ho(o) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE TI;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o)   BECAUSE HypoImplToAnd;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => z = o   BECAUSE TI;
ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE HIE;
\A z : ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
ho(o) => (\A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\E o : ho(o)) => (\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE CHOOSE Nat;

\* Extract the fact that Nat is a limit ordinal
UNION b = Nat <=> (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- UNION b);
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => UNION b = Nat   BECAUSE EquivToImplReverse;
h(a,b) => UNION b = Nat   BECAUSE TI;
\A x : \A y : x = y => (IsLimitOrdinal(x) <=> IsLimitOrdinal(y))   BECAUSE E_SCHEME;
UNION b = Nat => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE \A(x <- UNION b, y <- Nat);
h(a,b) => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE TI;
(IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat)) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE EquivToImpl;
h(a,b) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE TI;
h(a,b) => IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat)) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE TI;
hA(a) => \E b : IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
(\E a : hA(a)) => \E a : \E b : IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
\E a : \E b : IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
(\E a : \E b : IsLimitOrdinal(Nat)) => (\E b : IsLimitOrdinal(Nat))  BECAUSE Q_SCHEME;
(\E b : IsLimitOrdinal(Nat))   BECAUSE MODUS_PONENS;
(\E b : IsLimitOrdinal(Nat)) => IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
NatExists   BECAUSE IntroAndRight;
QED

zeroInNat == {} \in Nat
THEOREM zeroInNat
PROOF
VARIABLES a,x,z;
ordinalZero   BECAUSE THEOREM;
\* IsFiniteOrdinal( {} )
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
{} \in Nat <=> IsFiniteOrdinal({})   BECAUSE \A(x <- {});
{} \in Nat   BECAUSE MODUS_PONENS;
QED

(*
   As the smallest limit ordinal, Nat is generated by the successor operation.
   This gives the usual proofs by induction on Nat : separate in Nat the
   subset p where a given property is satisfied, then show the 2 hypotheses
   of this theorem about p and conclude its property is satisfied on all Nat.
*)
natInduction == \A p : {} \in p /\ (\A n : n \in p => successor(n) \in p)
   => Nat \subseteq p
THEOREM natInduction
PROOF
\* Assume by contradiction that there is a natural number k not in p.
\* Nat \ p is then a non-empty subset of the ordinal Nat, take its
\* minimum m. m is not zero, because zero is in p by hypothesis.
\* So m is the successor of a natural number p.
\* This contradicts the hypothesis on p.
VARIABLES a,b,c,k,m,n,o,p,u,v,x,z;
h(p,k) == {} \in p /\ (\A n : n \in p => successor(n) \in p) /\ k \in Nat /\ k \notin p;
h(p,k) => {} \in p   BECAUSE S14;
h(p,k) => (\A n : n \in p => successor(n) \in p)   BECAUSE S24;
h(p,k) => k \in Nat   BECAUSE S23;
h(p,k) => k \notin p   BECAUSE S22;
setDifferenceExists   BECAUSE THEOREM;
k \in (Nat \ p) <=> (k \in Nat /\ k \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- k);
k \in Nat /\ k \notin p => k \in (Nat \ p)   BECAUSE EquivToImplReverse;
h(p,k) => k \in Nat /\ k \notin p   BECAUSE CIA;
h(p,k) => k \in Nat \ p   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
Nat \ p  = {} <=> \A x : x \notin Nat \ p   BECAUSE \A(c <- Nat \ p);
Nat \ p  = {} => \A x : x \notin Nat \ p   BECAUSE EquivToImpl;
(\A x : x \notin Nat \ p) => k \notin Nat \ p   BECAUSE \A(x <- k);
Nat \ p = {} => k \notin Nat \ p   BECAUSE TI;
~(k \notin Nat \ p) => Nat \ p # {}   BECAUSE Contraposition;
k \in Nat \ p => ~(k \notin Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => (Nat \ p) # {}   BECAUSE TI2;
\* Take the minimum of Nat \ p because Nat is an ordinal
NatExists   BECAUSE THEOREM;
IsLimitOrdinal(Nat)   BECAUSE S22;
IsOrdinal(Nat)   BECAUSE S13;
IsWellOrderedByIn(Nat)   BECAUSE S22;
\A p : p \subseteq Nat => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE S22;
(Nat \ p) \subseteq Nat => (Nat \ p) = {} \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE \A(p <- Nat \ p);
z \in (Nat \ p) <=> (z \in Nat /\ z \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- z);
z \in (Nat \ p) => (z \in Nat /\ z \notin p)   BECAUSE EquivToImpl;
(z \in Nat /\ z \notin p) => z \in Nat   BECAUSE S12;
z \in (Nat \ p) => z \in Nat   BECAUSE TI;
Nat \ p \subseteq Nat   BECAUSE GENERALIZATION;
(Nat \ p) = {} \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE MODUS_PONENS;
killCase(h,a,b) == (a \/ b) => ((h => ~a) => (h => b))   PROPO_TAUTO;
h(p,k) => \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE killCase;
hm(p,k,m) == h(p,k) /\ IsMinimumForIn(m, Nat \ p);
hm(p,k,m) => h(p,k)   BECAUSE S12;
hm(p,k,m) => IsMinimumForIn(m, Nat \ p)   BECAUSE S22;
\* Show that m is not empty
IsMinimumForIn(m, Nat \ p) => m \in Nat \ p   BECAUSE S12;
m \in (Nat \ p) <=> (m \in Nat /\ m \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- m);
m \in (Nat \ p) => m \in Nat /\ m \notin p   BECAUSE EquivToImpl;
m \in Nat /\ m \notin p => m \notin p    BECAUSE S22;
IsMinimumForIn(m, Nat \ p) => m \notin p    BECAUSE TI2;
hm(p,k,m) => m \notin p    BECAUSE TI;
hm(p,k,m) => {} \in p    BECAUSE TI;
\A m : \A k : m = k => (m \in p <=> k \in p)   BECAUSE E_SCHEME;
m = {} => (m \in p <=> {} \in p)   BECAUSE \A(m <- m, k <- {});
implyEquivTrue(h,a,b,c) == (h => ~a) => ((h => b) => (((c => (a <=> b)) => (h => ~c))))   PROPO_TAUTO;
hm(p,k,m) => m # {}    BECAUSE implyEquivTrue;
\* Show that m is a successor ordinal
m \in Nat /\ m \notin p => m \in Nat    BECAUSE S12;
IsMinimumForIn(m, Nat \ p) => m \in Nat    BECAUSE TI2;
(\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
(\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
m \in Nat <=> IsFiniteOrdinal(m)   BECAUSE \A(x <- m);
m \in Nat => IsFiniteOrdinal(m)   BECAUSE EquivToImpl;
hm(p,k,m) => IsFiniteOrdinal(m)   BECAUSE TI2;
IsFiniteOrdinal(m) => IsOrdinal(m)   BECAUSE S13;
IsFiniteOrdinal(m) => ~IsLimitOrdinal(m)   BECAUSE S23;
hm(p,k,m) => IsOrdinal(m)   BECAUSE TI;
hm(p,k,m) => ~IsLimitOrdinal(m)   BECAUSE TI;
hm(p,k,m) => m # {} /\ IsOrdinal(m)   BECAUSE CIA;
hm(p,k,m) => m # {} /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m)  BECAUSE CIA;
killCases(a,b,c) == a /\ b /\ ~(b /\ a /\ c) => ~c   PROPO_TAUTO;
m # {} /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m) => ~\A x : x \in m => m # successor(x)   BECAUSE killCases;
hm(p,k,m) => ~\A x : x \in m => m # successor(x)   BECAUSE TI;
(\E x : ~(x \in m => m # successor(x))) <=> ~\A x : ~~(x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : ~~(x \in m => m # successor(x))) => (\E x : ~(x \in m => m # successor(x)))   BECAUSE EquivToImplReverse;
~~(x \in m => m # successor(x)) => (x \in m => m # successor(x))   BECAUSE DropNotNot;
(\A x : ~~(x \in m => m # successor(x))) => (\A x : x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : x \in m => m # successor(x)) => ~(\A x : ~~(x \in m => m # successor(x)))   BECAUSE Contraposition;
hm(p,k,m) => \E x : ~(x \in m => m # successor(x))   BECAUSE TI2;
\* Derive a contradiction, because this x is in p
hmx(p,k,m,x) == hm(p,k,m) /\ ~(x \in m => m # successor(x));
hmx(p,k,m,x) => hm(p,k,m)   BECAUSE S12;
hmx(p,k,m,x) => ~(x \in m => m # successor(x))   BECAUSE S22;
boolImpl(a,b) == ~(a => ~b) => a /\ b   PROPO_TAUTO;
~(x \in m => m # successor(x)) => x \in m /\ m = successor(x)   BECAUSE boolImpl;
hmx(p,k,m,x) => x \in m /\ m = successor(x)   BECAUSE TI;
IsMinimumForIn(m, Nat \ p) => \A b : b \in Nat \ p => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in Nat \ p => (b = m \/ m \in b)) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE \A(b <- x);
hm(p,k,m) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(m) /\ x \in m => IsFiniteOrdinal(x)   BECAUSE \A(o <- m, x <- x);
hmx(p,k,m,x) => IsFiniteOrdinal(m)   BECAUSE TI;
x \in m /\ m = successor(x) => x \in m   BECAUSE S12;
hmx(p,k,m,x) => x \in m   BECAUSE TI;
hmx(p,k,m,x) => IsFiniteOrdinal(m) /\ x \in m   BECAUSE CIA;
hmx(p,k,m,x) => IsFiniteOrdinal(x)   BECAUSE TI;
x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE \A(x <- x);
IsFiniteOrdinal(x) => x \in Nat   BECAUSE EquivToImplReverse;
hmx(p,k,m,x) => x \in Nat   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x)   BECAUSE CIA;
x \in (Nat \ p) <=> (x \in Nat /\ x \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- x);
killCasesB(a,b,c,d) == (b <=> a /\ d) => (a /\ (b => c) => (d => c))   PROPO_TAUTO;
x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x) => (x \notin p => x = m \/ m \in x)   BECAUSE killCasesB;
hmx(p,k,m,x) => (x \notin p => x = m \/ m \in x)   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ x \in m => x # m /\ m \notin x   BECAUSE \A(o <- x, p <- m);
hmx(p,k,m,x) => IsOrdinal(m)   BECAUSE TI;
hmx(p,k,m,x) => IsOrdinal(m) /\ x \in m   BECAUSE CIA;
x # m /\ m \notin x => ~(x = m \/ m \in x)   BECAUSE FactorNotOr;
hmx(p,k,m,x) => ~(x = m \/ m \in x)   BECAUSE TI2;
killCaseB(h,a,b) == (h => ~a) => ((h => (~b => a)) => (h => b))   PROPO_TAUTO;
hmx(p,k,m,x) => x \in p   BECAUSE killCaseB;
(\A n : n \in p => successor(n) \in p) => (x \in p => successor(x) \in p)   BECAUSE \A(n <- x);
hm(p,k,m) => (x \in p => successor(x) \in p)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in p => successor(x) \in p)   BECAUSE TI;
hmx(p,k,m,x) => successor(x) \in p   BECAUSE KillMiddleHypo;
x \in m /\ m = successor(x) => m = successor(x)   BECAUSE S22;
hmx(p,k,m,x) => m = successor(x)   BECAUSE TI;
\A m : \A x : m = x => (m \in p <=> x \in p)   BECAUSE E_SCHEME;
m = successor(x) => (m \in p <=> successor(x) \in p)   BECAUSE \A(m <- m, x <- successor(x));
hmx(p,k,m,x) => (m \in p <=> successor(x) \in p)   BECAUSE TI;
implyEquivTrueB(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hmx(p,k,m,x) => m \in p   BECAUSE implyEquivTrueB; \* contradiction

\* Discharge existential hypotheses
hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE HypoAndToImpl;
\A x : hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE GENERALIZATION;
hm(p,k,m) => (\A x : ~(x \in m => m # successor(x)) => m \in p)   BECAUSE Q_SCHEME;
(\A x : ~(x \in m => m # successor(x)) => m \in p) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE Q_SCHEME;
hm(p,k,m) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE TI;
hm(p,k,m) => \E x : m \in p   BECAUSE KillMiddleHypo;
(\E x : m \in p) => m \in p   BECAUSE Q_SCHEME;
hm(p,k,m) => m \in p   BECAUSE TI; \* contradiction
hm(p,k,m) => m \in p /\ m \notin p   BECAUSE CIA;
absurd(h,a,b) == (h /\ a => b /\ ~b) => (h => ~a)   PROPO_TAUTO;
h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE absurd;
\A m : h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE GENERALIZATION;
h(p,k) => \A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) <=> ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) => ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE EquivToImpl;
~~(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~(\E m : IsMinimumForIn(m, Nat \ p))   BECAUSE Contraposition;
(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE TI2;
h(p,k) => (\E m : IsMinimumForIn(m, Nat \ p)) /\ ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE CIA;

{} \in p /\ (\A n : n \in p => successor(n) \in p) /\ k \in Nat => ~(k \notin p)   BECAUSE absurd;
~(k \notin p) => k \in p   BECAUSE DropNotNot;
{} \in p /\ (\A n : n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE TI;
\A k : {} \in p /\ (\A n : n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE GENERALIZATION;
{} \in p /\ (\A n : n \in p => successor(n) \in p) /\ z \in Nat => z \in p   BECAUSE \A(k <- z);
{} \in p /\ (\A n : n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE HypoAndToImpl;
\A z : {} \in p /\ (\A n : n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE GENERALIZATION;
{} \in p /\ (\A n : n \in p => successor(n) \in p) => Nat \subseteq p   BECAUSE Q_SCHEME;
natInduction   BECAUSE GENERALIZATION;
QED

\* Restriction of the successor operator to Nat
natSucc == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = Nat /\ \A n : n \in Nat => natSucc[n] = successor(n)

IterateFunc(f,init) == CHOOSE_UNIQUE s : \A z : z = s <=>
   IsFunction(z) /\ Domain(z) = Nat /\ z[ {} ] = init
   /\ \A n : n \in Nat => z[successor(n)] = f[z[n]]

iterateFuncExists == \A f : \A init : IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f)
   => ( \A z : z = IterateFunc(f,init) <=>
        IsFunction(z) /\ Domain(z) = Nat /\ z[ {} ] = init
        /\ \A n : n \in Nat => z[successor(n)] = f[z[n]]   )
THEOREM iterateFuncExists
PROOF
\* By natInduction, show that there is a partial solution
\* defined on [0,n] for all n.
\* Then use the replacement axiom scheme on Nat to build
\*  the complete function.
VARIABLES a,b,f,g,n,p,x,y,z,init;
h(f,x,init) == \E g : IsFunction(g) /\ successor(x) \subseteq Domain(g) /\ g[{}] = init
   /\ \A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]];
\A a : \E b : \A x : x \in b <=> x \in a /\ h(f,x,init)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ h(f,x,init)   BECAUSE \A(a <- Nat);
hb(f,x,init,b) == \A x : x \in b <=> x \in Nat /\ h(f,x,init);

natInduction   BECAUSE THEOREM;
{} \in b /\ (\A n : n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
\* Prove h(f, {}, init)
singletonFuncIsFunction   BECAUSE THEOREM;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = {{}} /\ singletonFunc({},init)[{}] = init
   BECAUSE \A(a <- {}, b <- init);
IsFunction(singletonFunc({},init))   BECAUSE S13;
Domain(singletonFunc({},init)) = {{}}   BECAUSE S23;
singletonFunc({},init)[{}] = init   BECAUSE S22;
unionInc   BECAUSE THEOREM;
z \in successor({}) <=> (z \in {} \/ z \in {{}})   BECAUSE \A(x <- {}, y <- {{}}, z <- z);
emptySetExists   BECAUSE THEOREM;
z \notin {}   BECAUSE \A(x <- z);
equivFalseOr(f,a,b) == ~f => ((a <=> f \/ b) => (a => b))   PROPO_TAUTO;
z \in successor({}) => z \in {{}}   BECAUSE equivFalseOr;
successor({}) \subseteq {{}}   BECAUSE GENERALIZATION;
\A x : \A y : x = y => (successor({}) \subseteq x <=> successor({}) \subseteq y)   BECAUSE E_SCHEME;
Domain(singletonFunc({},init)) = {{}} => (successor({}) \subseteq Domain(singletonFunc({},init)) <=> successor({}) \subseteq {{}})   BECAUSE \A(x <- Domain(singletonFunc({},init)), y <- {{}});
(successor({}) \subseteq Domain(singletonFunc({},init)) <=> successor({}) \subseteq {{}})   BECAUSE MODUS_PONENS;
successor({}) \subseteq Domain(singletonFunc({},init))   BECAUSE MODUS_PONENS;
IsFunction(singletonFunc({},init)) /\ successor({}) \subseteq Domain(singletonFunc({},init))   BECAUSE IntroAndRight;
IsFunction(singletonFunc({},init)) /\ successor({}) \subseteq Domain(singletonFunc({},init)) /\ singletonFunc({},init)[{}] = init   BECAUSE IntroAndRight;
singletonExists   BECAUSE THEOREM;
\A z : z \in successor({}) => z \in {{}}   BECAUSE GENERALIZATION;
n \in successor({}) => n \in {{}}   BECAUSE \A(z <- n);
n \in { {} } <=> n = {}   BECAUSE \A(a <- {}, x <- n);
n \in { {} } => n = {}   BECAUSE EquivToImpl;
n \in successor({}) => n = {}   BECAUSE TI;
boolImpl(a,b) == (a => b) => ~(a /\ ~b)   PROPO_TAUTO;
~(n \in successor({}) /\ n # {})   BECAUSE boolImpl;
n \in successor({}) /\ n # {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE Explosion;
\A n : n \in successor({}) /\ n # {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE GENERALIZATION;
IsFunction(singletonFunc({},init)) /\ successor({}) \subseteq Domain(singletonFunc({},init)) /\ singletonFunc({},init)[{}] = init /\ \A n : n \in successor({}) /\ n # {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE IntroAndRight;
h(f, {}, init)   BECAUSE \E(g <- singletonFunc({},init));
hb(f,{},init,b) => ({} \in b <=> {} \in Nat /\ h(f,{},init))   BECAUSE \A(x <- {});
zeroInNat   BECAUSE THEOREM;
{} \in Nat /\ h(f,{},init)   BECAUSE IntroAndRight;
hb(f,{},init,b) => {} \in b   BECAUSE ImplyEquivTrue;

\* TODO b stable by successor

hb(f,x,init,b) => Nat \subseteq b   BECAUSE TI;
Nat \subseteq b => (p \in Nat => p \in b)   BECAUSE \A(z <- b);
\A p : p \in Nat => h(f,p,init)   BECAUSE TI;

\* Then show this relation is functional in y (unicity) :
F(x,y,f,init) == x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init
        /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]])
        /\ y = <<x, g[x]>> );

\* The replacement axiom scheme invocation on F
(\A x : \A y : \A z : ((x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]]) /\ y = <<x, g[x]>> ))
        /\ (x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]]) /\ z = <<x, g[x]>> ))) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ (x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]])
        /\ y = <<x, g[x]>> )))
   BECAUSE AXIOM_SCHEME;
iterateFuncExists   BECAUSE GENERALIZATION;
QED

(*
   The usual addition operation on natural numbers.
   It could also be defined as the restriction of
   ordinal addition on Nat.
*)
NatAddition == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = (Nat \X Nat)
   /\ \A n : \A p : n \in Nat /\ p \in Nat => z[n,p] = IterateFunc(natSucc,n)[p]

natAdditionExists == \A n : \A p : n \in Nat /\ p \in Nat => NatAddition[n,p] = IterateFunc(natSucc,n)[p]
THEOREM natAdditionExists

(* TODO associativity, commutativity, multiplication, symbols for digits 0,1,2,3,4,5,6,7,8,9,10 *)