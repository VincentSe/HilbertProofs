EXTENDS Orders

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE_UNIQUE o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))

NatExists == (\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))
   /\ IsLimitOrdinal(Nat)
THEOREM NatExists
PROOF
\* By separation in a set given by the axiom of infinity
VARIABLES a,b,c,o,p,t,u,x,y,z,nat;
Infinity   BECAUSE AXIOM;
\A a : \E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE \A(a <- a);
\* Take a from the axiom of infinity and b from separation of finite ordinals
h(a,b) == {} \in a /\ (\A x : x \in a => successor(x) \in a)
   /\ \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x);
h(a,b) => \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE S22;

\* Prove UNION b is Nat, ie IsFiniteOrdinal(x) <=> x \in UNION b.
\* First prove that UNION b is an ordinal.
unionOrdinalsIsOrdinal   BECAUSE THEOREM;
(\A x : x \in b => IsOrdinal(x)) => IsOrdinal(UNION b)   BECAUSE \A(u <- b);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b <=> x \in a /\ IsFiniteOrdinal(x))
   BECAUSE \A(x <- x);
(x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE EquivToImpl;
h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE TI2;
IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE S13;
\A a : IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(a <- x);
extractProp(a,b,c,d) == (a => b) => ((c => d /\ a) => (c => b))   PROPO_TAUTO;
(x \in b => x \in a /\ IsFiniteOrdinal(x)) => (x \in b => IsOrdinal(x))   BECAUSE extractProp;
h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE TI;
\A x : h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in b => IsOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) => IsOrdinal(UNION b)   BECAUSE TI;

\* Proof that UNION b is a limit ordinal.
\* If o \in UNION b then successor(o) \in UNION b, so UNION b # successor o.
unionExists   BECAUSE AXIOM;
x \in UNION b <=> \E t : t \in b /\ x \in t   BECAUSE \A(b <- b, z <- x);
x \in UNION b => \E t : t \in b /\ x \in t   BECAUSE EquivToImpl;
\A x : h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => h(a,b)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => t \in b   BECAUSE S23;
h(a,b) /\ t \in b /\ x \in t => t \in a /\ IsFiniteOrdinal(t)   BECAUSE KillMiddleHypo;
h(a,b) => \A x : x \in a => successor(x) \in a   BECAUSE S23;
(\A x : x \in a => successor(x) \in a) => (t \in a => successor(t) \in a)   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => (t \in a => successor(t) \in a)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => t \in a   BECAUSE S12;
h(a,b) /\ t \in b /\ x \in t => t \in a   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a   BECAUSE KillMiddleHypo;
\* So successor(t) \in b.
\* Then successor(x) \in successor(t) \in b implies successor(x) \in UNION b.
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(t) => IsFiniteOrdinal( successor(t) )   BECAUSE \A(o <- t);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t)))   BECAUSE \A(x <- successor(t));
(successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t))) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE EquivToImplReverse;
h(a,b) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => IsFiniteOrdinal(t)   BECAUSE S22;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(successor(t))   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a /\ IsFiniteOrdinal(successor(t))   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in b   BECAUSE KillMiddleHypo;
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t => successor(x) \in successor(t)   BECAUSE \A(o <- x, p <- t);
IsFiniteOrdinal(t) => IsOrdinal(t)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t)   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => x \in t   BECAUSE S22;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(t) /\ x \in t => IsOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t)   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t)   BECAUSE TI;
inInUnion   BECAUSE THEOREM;
(successor(x) \in successor(t) /\ successor(t) \in b) => successor(x) \in UNION b   BECAUSE \A(a <- successor(x), b <- successor(t), c <- b);
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t) /\ successor(t) \in b   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in UNION b   BECAUSE TI;
pushHypos(h,a,b,c) == (h /\ a /\ b => c) => (h => (a /\ b => c))   PROPO_TAUTO;
h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => successor(x) \in UNION b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE Q_SCHEME;
h(a,b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE TI;
mergeHypos(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(a,b) /\ x \in UNION b => \E t : successor(x) \in UNION b   BECAUSE mergeHypos;
(\E t : successor(x) \in UNION b) => successor(x) \in UNION b   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => successor(x) \in UNION b   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(UNION b) /\ successor(x) \in UNION b => successor(x) # (UNION b) /\ (UNION b) \notin successor(x)   BECAUSE \A(o <- successor(x), p <- UNION b);
h(a,b) /\ x \in UNION b => h(a,b)   BECAUSE S12;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b)   BECAUSE TI2;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b) /\ successor(x) \in UNION b   BECAUSE CIA;
successor(x) # (UNION b) /\ (UNION b) \notin successor(x) => successor(x) # UNION b   BECAUSE S12;
h(a,b) /\ x \in UNION b => successor(x) # UNION b   BECAUSE TI2;
UNION b = successor(x) => successor(x) = UNION b   BECAUSE E_SCHEME;
successor(x) # UNION b => UNION b # successor(x)   BECAUSE Contraposition;
h(a,b) /\ x \in UNION b => UNION b # successor(x)   BECAUSE TI;
h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE HypoAndToImpl;
\A x : h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b => UNION b # successor(x))   BECAUSE Q_SCHEME;

\* {} \in successor({}) \in b, so {} \in UNION b
h(a,b) => {} \in a   BECAUSE S13;
(\A x : x \in a => successor(x) \in a) => ({} \in a => successor({}) \in a)   BECAUSE \A(x <- {});
h(a,b) => ({} \in a => successor({}) \in a)   BECAUSE TI;
h(a,b) => successor({}) \in a   BECAUSE KillMiddleHypo;
ordinalZero   BECAUSE THEOREM;
IsFiniteOrdinal({}) => IsFiniteOrdinal( successor({}) )   BECAUSE \A(o <- {});
IsFiniteOrdinal( successor({}) )   BECAUSE MODUS_PONENS;
successor({}) \in a => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE IntroAndLeft;
h(a,b) => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE TI;
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE \A(x <- successor({}));
h(a,b) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE TI;
killCase(h,a,b) == (h => a) => ((h => (b <=> a)) => (h => b))   PROPO_TAUTO;
h(a,b) => successor({}) \in b   BECAUSE killCase;
inSuccessor   BECAUSE THEOREM;
{} \in successor({})   BECAUSE \A(o <- {});
h(a,b) => {} \in successor({})   BECAUSE PT1;
h(a,b) => {} \in successor({}) /\ successor({}) \in b   BECAUSE CIA;
({} \in successor({}) /\ successor({}) \in b) => {} \in UNION b   BECAUSE \A(a <- {}, b <- successor({}), c <- b);
h(a,b) => {} \in UNION b   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
UNION b = {} <=> \A x : x \notin UNION b   BECAUSE \A(c <- UNION b);
(\E x : x \in UNION b) <=> ~\A x : x \notin UNION b   BECAUSE Q_SCHEME;
(\E x : x \in UNION b) => ~\A x : x \notin UNION b   BECAUSE EquivToImpl;
{} \in UNION b => \E x : x \in UNION b   BECAUSE \E(x <- {});
h(a,b) => ~\A x : x \notin UNION b   BECAUSE TI2;
UNION b = {} => \A x : x \notin UNION b   BECAUSE EquivToImpl;
~(\A x : x \notin UNION b) => UNION b # {}   BECAUSE Contraposition;
h(a,b) => UNION b # {}   BECAUSE TI;
h(a,b) => IsOrdinal(UNION b) /\ UNION b # {}   BECAUSE CIA;
h(a,b) => IsLimitOrdinal(UNION b)   BECAUSE CIA;

\* Proof that IsFiniteOrdinal(x) => x \in UNION b
ordinalComparison   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(UNION b) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE \A(o <- x, p <- UNION b);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => IsFiniteOrdinal(x)   BECAUSE S22;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => h(a,b)   BECAUSE S12;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(UNION b)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x) /\ IsOrdinal(UNION b)   BECAUSE CIA;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE TI;
\* because UNION b is infinite, only the first case is possible.
IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE S23;
\A o : IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE TI;
\A x : \A b : x = b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(b))   BECAUSE E_SCHEME;
x = UNION b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(UNION b))   BECAUSE \A(x <- x, b <- UNION b);
h(a,b) /\ IsFiniteOrdinal(x) => IsLimitOrdinal(UNION b)   BECAUSE TI;
killCaseB(h,a,b,c) == (h => ~a) => ((h => c) => (((b => (a <=> c)) => (h => ~b))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x # UNION b   BECAUSE killCaseB;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(x) /\ UNION b \in x => IsFiniteOrdinal(UNION b)   BECAUSE \A(o <- x, x <- UNION b);
IsFiniteOrdinal(UNION b) => ~IsLimitOrdinal(UNION b)   BECAUSE \A(o <- UNION b);
IsFiniteOrdinal(x) /\ UNION b \in x => ~IsLimitOrdinal(UNION b)   BECAUSE TI;
IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE HypoAndToImpl;
h(a,b) /\ IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE TI;
killCaseD(h,a,b) == (h => (b => ~a)) => ((h => a) => (h => ~b))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => UNION b \notin x   BECAUSE killCaseD;
killCaseE(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b   BECAUSE killCaseE;

\* Conversely, x \in UNION b is an ordinal as an element of an ordinal.
\* And x \in t \in b where t is a finite ordinal, so x is finite too.
IsFiniteOrdinal(t) /\ x \in t => IsFiniteOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => IsFiniteOrdinal(x)) => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE TI2;
h(a,b) /\ x \in UNION b => x \in UNION b   BECAUSE S22;
h(a,b) /\ x \in UNION b => (\E t : t \in b /\ x \in t)   BECAUSE TI;
h(a,b) /\ x \in UNION b => \E t : IsFiniteOrdinal(x)   BECAUSE KillMiddleHypo;
(\E t : IsFiniteOrdinal(x)) => IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE HIE;
\A x : h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;

hA(a) == {} \in a /\ (\A x : x \in a => successor(x) \in a);
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))
   => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE TI;
hA(a) => (\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x))   BECAUSE PT1;
hA(a) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE KillMiddleHypo;
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE \E(o <- UNION b);
(\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
hA(a) => (\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE TI;
(\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => (\E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
hA(a) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE TI;
(\E a : hA(a)) => \E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
(\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;

\* Proof that Nat is unique. By extensionality, being in another Nat
\* is equivalent, it is being a finite ordinal.
ho(o) == \A x : x \in o <=> IsFiniteOrdinal(x);
\A z : \A o : z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE E_SCHEME;
z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE \A(z <- z, o <- o);
killCaseF(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
ho(o) /\ z = o => (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE killCaseF;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in o) => z = o   BECAUSE \A(a <- z, b <- o);
ho(o) => (x \in o <=> IsFiniteOrdinal(x))   BECAUSE \A(x <- x);
tEquiv(a,b,c,h) == (h => (a <=> b)) => (h => ((c <=> b) => (c <=> a)))   PROPO_TAUTO;
ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE tEquiv;
\A x : ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE GENERALIZATION;
ho(o) => (\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE Q_SCHEME;
(\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o)) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE Q_SCHEME;
ho(o) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE TI;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o)   BECAUSE HypoImplToAnd;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => z = o   BECAUSE TI;
ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE HIE;
\A z : ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
ho(o) => (\A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\E o : ho(o)) => (\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE CHOOSE Nat;

\* Extract the fact that Nat is a limit ordinal
UNION b = Nat <=> (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- UNION b);
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => UNION b = Nat   BECAUSE EquivToImplReverse;
h(a,b) => UNION b = Nat   BECAUSE TI;
\A x : \A y : x = y => (IsLimitOrdinal(x) <=> IsLimitOrdinal(y))   BECAUSE E_SCHEME;
UNION b = Nat => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE \A(x <- UNION b, y <- Nat);
h(a,b) => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE TI;
(IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat)) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE EquivToImpl;
h(a,b) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE TI;
h(a,b) => IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat)) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE TI;
hA(a) => \E b : IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
(\E a : hA(a)) => \E a : \E b : IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
\E a : \E b : IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
(\E a : \E b : IsLimitOrdinal(Nat)) => (\E b : IsLimitOrdinal(Nat))  BECAUSE Q_SCHEME;
(\E b : IsLimitOrdinal(Nat))   BECAUSE MODUS_PONENS;
(\E b : IsLimitOrdinal(Nat)) => IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
NatExists   BECAUSE IntroAndRight;
QED

zeroInNat == {} \in Nat
THEOREM zeroInNat
PROOF
VARIABLES a,x,z;
ordinalZero   BECAUSE THEOREM;
\* IsFiniteOrdinal( {} )
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
{} \in Nat <=> IsFiniteOrdinal({})   BECAUSE \A(x <- {});
{} \in Nat   BECAUSE MODUS_PONENS;
QED

natSuccStable == \A n : n \in Nat => successor(n) \in Nat
THEOREM natSuccStable
PROOF
VARIABLES a,n,o,x,z;
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
n \in Nat <=> IsFiniteOrdinal(n)   BECAUSE \A(x <- n);
n \in Nat => IsFiniteOrdinal(n)   BECAUSE EquivToImpl;
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(n) => IsFiniteOrdinal( successor(n) )   BECAUSE \A(o <- n);
successor(n) \in Nat <=> IsFiniteOrdinal(successor(n))   BECAUSE \A(x <- successor(n));
IsFiniteOrdinal(successor(n)) => successor(n) \in Nat   BECAUSE EquivToImplReverse;
n \in Nat => successor(n) \in Nat   BECAUSE TI2;
natSuccStable   BECAUSE GENERALIZATION;
QED

(*
   As the smallest limit ordinal, Nat is generated by the successor operation.
   
   This gives the usual proofs by induction on Nat : separate in Nat the
   subset p where a given property is satisfied, then show the 2 hypotheses
   of this theorem about p and conclude its property is satisfied on all Nat.
*)
natInduction == \A p : {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p)
   => Nat \subseteq p
THEOREM natInduction
PROOF
\* Assume by contradiction that there is a natural number k not in p.
\* Nat \ p is then a non-empty subset of the ordinal Nat, take its
\* minimum m. m is not zero, because zero is in p by hypothesis.
\* So m is the successor of a natural number p.
\* This contradicts the hypothesis on p.
VARIABLES a,b,c,k,m,n,o,p,u,v,x,z;
h(p,k) == {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat /\ k \notin p;
h(p,k) => {} \in p   BECAUSE S14;
h(p,k) => (\A n : n \in Nat /\ n \in p => successor(n) \in p)   BECAUSE S24;
h(p,k) => k \in Nat   BECAUSE S23;
h(p,k) => k \notin p   BECAUSE S22;
setDifferenceExists   BECAUSE THEOREM;
k \in (Nat \ p) <=> (k \in Nat /\ k \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- k);
k \in Nat /\ k \notin p => k \in (Nat \ p)   BECAUSE EquivToImplReverse;
h(p,k) => k \in Nat /\ k \notin p   BECAUSE CIA;
h(p,k) => k \in Nat \ p   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
Nat \ p  = {} <=> \A x : x \notin Nat \ p   BECAUSE \A(c <- Nat \ p);
Nat \ p  = {} => \A x : x \notin Nat \ p   BECAUSE EquivToImpl;
(\A x : x \notin Nat \ p) => k \notin Nat \ p   BECAUSE \A(x <- k);
Nat \ p = {} => k \notin Nat \ p   BECAUSE TI;
~(k \notin Nat \ p) => Nat \ p # {}   BECAUSE Contraposition;
k \in Nat \ p => ~(k \notin Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => (Nat \ p) # {}   BECAUSE TI2;
\* Take the minimum of Nat \ p because Nat is an ordinal
NatExists   BECAUSE THEOREM;
IsLimitOrdinal(Nat)   BECAUSE S22;
IsOrdinal(Nat)   BECAUSE S13;
IsWellOrderedByIn(Nat)   BECAUSE S22;
\A p : p \subseteq Nat => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE S22;
(Nat \ p) \subseteq Nat => (Nat \ p) = {} \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE \A(p <- Nat \ p);
z \in (Nat \ p) <=> (z \in Nat /\ z \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- z);
z \in (Nat \ p) => (z \in Nat /\ z \notin p)   BECAUSE EquivToImpl;
(z \in Nat /\ z \notin p) => z \in Nat   BECAUSE S12;
z \in (Nat \ p) => z \in Nat   BECAUSE TI;
Nat \ p \subseteq Nat   BECAUSE GENERALIZATION;
(Nat \ p) = {} \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE MODUS_PONENS;
killCase(h,a,b) == (a \/ b) => ((h => ~a) => (h => b))   PROPO_TAUTO;
h(p,k) => \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE killCase;
hm(p,k,m) == h(p,k) /\ IsMinimumForIn(m, Nat \ p);
hm(p,k,m) => h(p,k)   BECAUSE S12;
hm(p,k,m) => IsMinimumForIn(m, Nat \ p)   BECAUSE S22;
\* Show that m is not empty
IsMinimumForIn(m, Nat \ p) => m \in Nat \ p   BECAUSE S12;
m \in (Nat \ p) <=> (m \in Nat /\ m \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- m);
m \in (Nat \ p) => m \in Nat /\ m \notin p   BECAUSE EquivToImpl;
m \in Nat /\ m \notin p => m \notin p    BECAUSE S22;
IsMinimumForIn(m, Nat \ p) => m \notin p    BECAUSE TI2;
hm(p,k,m) => m \notin p    BECAUSE TI;
hm(p,k,m) => {} \in p    BECAUSE TI;
\A m : \A k : m = k => (m \in p <=> k \in p)   BECAUSE E_SCHEME;
m = {} => (m \in p <=> {} \in p)   BECAUSE \A(m <- m, k <- {});
implyEquivTrue(h,a,b,c) == (h => ~a) => ((h => b) => (((c => (a <=> b)) => (h => ~c))))   PROPO_TAUTO;
hm(p,k,m) => m # {}    BECAUSE implyEquivTrue;
\* Show that m is a successor ordinal
m \in Nat /\ m \notin p => m \in Nat    BECAUSE S12;
IsMinimumForIn(m, Nat \ p) => m \in Nat    BECAUSE TI2;
(\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
(\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
m \in Nat <=> IsFiniteOrdinal(m)   BECAUSE \A(x <- m);
m \in Nat => IsFiniteOrdinal(m)   BECAUSE EquivToImpl;
hm(p,k,m) => IsFiniteOrdinal(m)   BECAUSE TI2;
IsFiniteOrdinal(m) => IsOrdinal(m)   BECAUSE S13;
IsFiniteOrdinal(m) => ~IsLimitOrdinal(m)   BECAUSE S23;
hm(p,k,m) => IsOrdinal(m)   BECAUSE TI;
hm(p,k,m) => ~IsLimitOrdinal(m)   BECAUSE TI;
hm(p,k,m) => m # {} /\ IsOrdinal(m)   BECAUSE CIA;
hm(p,k,m) => m # {} /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m)  BECAUSE CIA;
killCases(a,b,c) == a /\ b /\ ~(b /\ a /\ c) => ~c   PROPO_TAUTO;
m # {} /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m) => ~\A x : x \in m => m # successor(x)   BECAUSE killCases;
hm(p,k,m) => ~\A x : x \in m => m # successor(x)   BECAUSE TI;
(\E x : ~(x \in m => m # successor(x))) <=> ~\A x : ~~(x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : ~~(x \in m => m # successor(x))) => (\E x : ~(x \in m => m # successor(x)))   BECAUSE EquivToImplReverse;
~~(x \in m => m # successor(x)) => (x \in m => m # successor(x))   BECAUSE DropNotNot;
(\A x : ~~(x \in m => m # successor(x))) => (\A x : x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : x \in m => m # successor(x)) => ~(\A x : ~~(x \in m => m # successor(x)))   BECAUSE Contraposition;
hm(p,k,m) => \E x : ~(x \in m => m # successor(x))   BECAUSE TI2;
\* Derive a contradiction, because this x is in Nat \intersect p
hmx(p,k,m,x) == hm(p,k,m) /\ ~(x \in m => m # successor(x));
hmx(p,k,m,x) => hm(p,k,m)   BECAUSE S12;
hmx(p,k,m,x) => ~(x \in m => m # successor(x))   BECAUSE S22;
boolImpl(a,b) == ~(a => ~b) => a /\ b   PROPO_TAUTO;
~(x \in m => m # successor(x)) => x \in m /\ m = successor(x)   BECAUSE boolImpl;
hmx(p,k,m,x) => x \in m /\ m = successor(x)   BECAUSE TI;
IsMinimumForIn(m, Nat \ p) => \A b : b \in Nat \ p => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in Nat \ p => (b = m \/ m \in b)) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE \A(b <- x);
hm(p,k,m) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(m) /\ x \in m => IsFiniteOrdinal(x)   BECAUSE \A(o <- m, x <- x);
hmx(p,k,m,x) => IsFiniteOrdinal(m)   BECAUSE TI;
x \in m /\ m = successor(x) => x \in m   BECAUSE S12;
hmx(p,k,m,x) => x \in m   BECAUSE TI;
hmx(p,k,m,x) => IsFiniteOrdinal(m) /\ x \in m   BECAUSE CIA;
hmx(p,k,m,x) => IsFiniteOrdinal(x)   BECAUSE TI;
x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE \A(x <- x);
IsFiniteOrdinal(x) => x \in Nat   BECAUSE EquivToImplReverse;
hmx(p,k,m,x) => x \in Nat   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x)   BECAUSE CIA;
x \in (Nat \ p) <=> (x \in Nat /\ x \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- x);
killCasesB(a,b,c,d) == (b <=> a /\ d) => (a /\ (b => c) => (d => c))   PROPO_TAUTO;
x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x) => (x \notin p => x = m \/ m \in x)   BECAUSE killCasesB;
hmx(p,k,m,x) => (x \notin p => x = m \/ m \in x)   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ x \in m => x # m /\ m \notin x   BECAUSE \A(o <- x, p <- m);
hmx(p,k,m,x) => IsOrdinal(m)   BECAUSE TI;
hmx(p,k,m,x) => IsOrdinal(m) /\ x \in m   BECAUSE CIA;
x # m /\ m \notin x => ~(x = m \/ m \in x)   BECAUSE FactorNotOr;
hmx(p,k,m,x) => ~(x = m \/ m \in x)   BECAUSE TI2;
killCaseB(h,a,b) == (h => ~a) => ((h => (~b => a)) => (h => b))   PROPO_TAUTO;
hmx(p,k,m,x) => x \in p   BECAUSE killCaseB;
(\A n : n \in Nat /\ n \in p => successor(n) \in p) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE \A(n <- x);
hm(p,k,m) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ x \in p   BECAUSE CIA;
hmx(p,k,m,x) => successor(x) \in p   BECAUSE KillMiddleHypo;
x \in m /\ m = successor(x) => m = successor(x)   BECAUSE S22;
hmx(p,k,m,x) => m = successor(x)   BECAUSE TI;
\A m : \A x : m = x => (m \in p <=> x \in p)   BECAUSE E_SCHEME;
m = successor(x) => (m \in p <=> successor(x) \in p)   BECAUSE \A(m <- m, x <- successor(x));
hmx(p,k,m,x) => (m \in p <=> successor(x) \in p)   BECAUSE TI;
implyEquivTrueB(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hmx(p,k,m,x) => m \in p   BECAUSE implyEquivTrueB; \* contradiction

\* Discharge existential hypotheses
hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE HypoAndToImpl;
\A x : hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE GENERALIZATION;
hm(p,k,m) => (\A x : ~(x \in m => m # successor(x)) => m \in p)   BECAUSE Q_SCHEME;
(\A x : ~(x \in m => m # successor(x)) => m \in p) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE Q_SCHEME;
hm(p,k,m) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE TI;
hm(p,k,m) => \E x : m \in p   BECAUSE KillMiddleHypo;
(\E x : m \in p) => m \in p   BECAUSE Q_SCHEME;
hm(p,k,m) => m \in p   BECAUSE TI; \* contradiction
hm(p,k,m) => m \in p /\ m \notin p   BECAUSE CIA;
absurd(h,a,b) == (h /\ a => b /\ ~b) => (h => ~a)   PROPO_TAUTO;
h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE absurd;
\A m : h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE GENERALIZATION;
h(p,k) => \A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) <=> ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) => ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE EquivToImpl;
~~(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~(\E m : IsMinimumForIn(m, Nat \ p))   BECAUSE Contraposition;
(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE TI2;
h(p,k) => (\E m : IsMinimumForIn(m, Nat \ p)) /\ ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE CIA;

{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => ~(k \notin p)   BECAUSE absurd;
~(k \notin p) => k \in p   BECAUSE DropNotNot;
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE TI;
\A k : {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE GENERALIZATION;
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ z \in Nat => z \in p   BECAUSE \A(k <- z);
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE HypoAndToImpl;
\A z : {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE GENERALIZATION;
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => Nat \subseteq p   BECAUSE Q_SCHEME;
natInduction   BECAUSE GENERALIZATION;
QED

(*
   Infinite iteration of a function f starting at init. There is a unique sequence :
   <<init, f[init], f[f[init]], f[f[f[init]]], ...
*)
ContainsIterateFunc(a,f,init) == <<{}, init>> \in a
   /\ \A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a

IterateFuncShell(f,init) == CHOOSE_UNIQUE b : \A z : z = b <=>
   \A x : x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)

IterateFunc(f,init) == INTERSECT(IterateFuncShell(f,init))

iterateFuncExists == \A f : \A init : IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f)
   => ( IsFunction(IterateFunc(f,init))
        /\ Domain(IterateFunc(f,init)) = Nat
        /\ IterateFunc(f,init)[ {} ] = init
        /\ \A n : n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   )
THEOREM iterateFuncExists
PROOF
VARIABLES a,b,c,d,f,g,i,j,n,o,p,u,v,x,y,z,init;
h(f,init) == IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f);
h(f,init) => IsFunction(f)   BECAUSE S13;
h(f,init) => Image(f) \subseteq Domain(f)   BECAUSE S23;
h(f,init) => init \in Domain(f)   BECAUSE S22;
\* Proof that h(f,init) => ContainsIterateFunc(Nat \X Domain(f), f, init)
cartesianProductCouples   BECAUSE THEOREM;
{} \in Nat /\ init \in Domain(f) <=> <<{},init>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- {}, b <- init);
{} \in Nat /\ init \in Domain(f) => <<{},init>> \in Nat \X Domain(f)   BECAUSE EquivToImpl;
zeroInNat   BECAUSE THEOREM;
h(f,init) => {} \in Nat   BECAUSE PT1;
h(f,init) => {} \in Nat /\ init \in Domain(f)   BECAUSE CIA;
h(f,init) => <<{},init>> \in Nat \X Domain(f)   BECAUSE TI;
x \in Nat /\ y \in Domain(f) <=> <<x,y>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- x, b <- y);
<<x,y>> \in Nat \X Domain(f) => x \in Nat /\ y \in Domain(f)   BECAUSE EquivToImplReverse;
x \in Nat /\ y \in Domain(f) => x \in Nat   BECAUSE S12;
x \in Nat /\ y \in Domain(f) => y \in Domain(f)   BECAUSE S22;
natSuccStable   BECAUSE THEOREM;
x \in Nat => successor(x) \in Nat   BECAUSE \A(n <- x);
funcImageExists   BECAUSE THEOREM;
IsFunction(f) /\ y \in Domain(f) => <<y, f[y]>> \in f   BECAUSE \A(f <- f, x <- y);
imageExists   BECAUSE THEOREM;
f[y] \in Image(f) <=> Reaches(f,f[y])   BECAUSE \A(g <- f, y <- f[y]);
Reaches(f,f[y]) => f[y] \in Image(f)   BECAUSE EquivToImplReverse;
<<y, f[y]>> \in f => Reaches(f,f[y])   BECAUSE \E(x <- y);
IsFunction(f) /\ y \in Domain(f) => f[y] \in Image(f)   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => <<x,y>> \in Nat \X Domain(f)   BECAUSE S22;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => y \in Domain(f)   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => IsFunction(f)   BECAUSE TI;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => IsFunction(f) /\ y \in Domain(f)   BECAUSE CIA;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => f[y] \in Image(f)   BECAUSE TI;
Image(f) \subseteq Domain(f) => (f[y] \in Image(f) => f[y] \in Domain(f))   BECAUSE \A(z <- f[y]);
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => (f[y] \in Image(f) => f[y] \in Domain(f))   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => f[y] \in Domain(f)   BECAUSE KillMiddleHypo;
successor(x) \in Nat /\ f[y] \in Domain(f) <=> <<successor(x),f[y]>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- successor(x), b <- f[y]);
successor(x) \in Nat /\ f[y] \in Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f)   BECAUSE EquivToImpl;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => x \in Nat   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => successor(x) \in Nat   BECAUSE TI;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => successor(x) \in Nat /\ f[y] \in Domain(f)   BECAUSE CIA;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f)   BECAUSE TI;
h(f,init) => (<<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE HypoAndToImpl;
\A y : h(f,init) => (<<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => (\A y : <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE Q_SCHEME;
\A x : h(f,init) => (\A y : <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => (\A x : \A y : <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE Q_SCHEME;
h(f,init) => ContainsIterateFunc(Nat \X Domain(f),f,init)   BECAUSE CIA;

\* Prove that the shell exists, by separation in Nat \X Image(f)
\A a : \E b : \A x : x \in b <=> x \in a /\ ContainsIterateFunc(x,f,init)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)
   BECAUSE \A(a <- SUBSET (Nat \X Domain(f)));
hs(b,f,init) == \A x : x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init);
\A z : \A b : z = b => (hs(z,f,init) <=> hs(b,f,init))   BECAUSE E_SCHEME;
z = b => (hs(z,f,init) <=> hs(b,f,init))   BECAUSE \A(z <- z, b <- b);
cycleHypos(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
hs(b,f,init) /\ z = b => hs(z,f,init)   BECAUSE cycleHypos;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in b) => z = b   BECAUSE \A(a <- z, b <- b);
hs(z,f,init) => (x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init))   BECAUSE \A(x <- x);
hs(b,f,init) => (x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init))   BECAUSE \A(x <- x);
hs(b,f,init) /\ hs(z,f,init) => (x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)) /\ (x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init))   BECAUSE MergeImplicationsAnd;
transitEquiv(a,b,c) == ((a <=> c) /\ (b <=> c) => (b <=> a))   PROPO_TAUTO;
(x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)) /\ (x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)) => (x \in z <=> x \in b)   BECAUSE transitEquiv;
hs(b,f,init) /\ hs(z,f,init) => (x \in z <=> x \in b)   BECAUSE TI;
\A x : hs(b,f,init) /\ hs(z,f,init) => (x \in z <=> x \in b)   BECAUSE GENERALIZATION;
hs(b,f,init) /\ hs(z,f,init) => (\A x : x \in z <=> x \in b)   BECAUSE Q_SCHEME;
hs(b,f,init) /\ hs(z,f,init) => z = b   BECAUSE TI;
hs(b,f,init) => (z = b <=> hs(z,f,init))   BECAUSE HIE;
\A z : hs(b,f,init) => (z = b <=> hs(z,f,init))   BECAUSE GENERALIZATION;
hs(b,f,init) => (\A z : z = b <=> hs(z,f,init))   BECAUSE Q_SCHEME;
(\E b : hs(b,f,init)) => (\E b : \A z : z = b <=> hs(z,f,init))   BECAUSE Q_SCHEME;
\E b : \A z : z = b <=> hs(z,f,init)   BECAUSE MODUS_PONENS;
\A z : z = IterateFuncShell(f,init) <=>
   \A x : x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)   BECAUSE CHOOSE IterateFuncShell(f,init);
IterateFuncShell(f,init) = IterateFuncShell(f,init) <=>
   \A x : x \in IterateFuncShell(f,init) <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)   BECAUSE \A(z <- IterateFuncShell(f,init));
equalSelf   BECAUSE THEOREM;
IterateFuncShell(f,init) = IterateFuncShell(f,init)   BECAUSE \A(a <- IterateFuncShell(f,init));
\A x : x \in IterateFuncShell(f,init) <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)
   BECAUSE MODUS_PONENS;

\* Intersect the shell because it is not empty
Nat \X Domain(f) \in IterateFuncShell(f,init) <=> Nat \X Domain(f) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(Nat \X Domain(f),f,init)   BECAUSE \A(x <- Nat \X Domain(f));
Nat \X Domain(f) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(Nat \X Domain(f),f,init) => Nat \X Domain(f) \in IterateFuncShell(f,init)   BECAUSE EquivToImplReverse;
powersetExists   BECAUSE AXIOM;
(Nat \X Domain(f)) \in SUBSET (Nat \X Domain(f)) <=> (Nat \X Domain(f)) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f), z <- Nat \X Domain(f));
inclusionInOneself   BECAUSE THEOREM;
(Nat \X Domain(f)) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f));
(Nat \X Domain(f)) \in SUBSET (Nat \X Domain(f))   BECAUSE MODUS_PONENS;
h(f,init) => (Nat \X Domain(f)) \in SUBSET (Nat \X Domain(f))   BECAUSE PT1;
h(f,init) => Nat \X Domain(f) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(Nat \X Domain(f),f,init)   BECAUSE CIA;
h(f,init) => Nat \X Domain(f) \in IterateFuncShell(f,init)   BECAUSE TI;
bigIntersectExists   BECAUSE THEOREM;
IterateFuncShell(f,init) # {} => \A x : x \in IterateFunc(f,init)
   <=> \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE \A(u <- IterateFuncShell(f,init));
emptySetExistsUniquely   BECAUSE THEOREM;
IterateFuncShell(f,init) = {} <=> \A x : x \notin IterateFuncShell(f,init)   BECAUSE \A(c <- IterateFuncShell(f,init));
IterateFuncShell(f,init) = {} => \A x : x \notin IterateFuncShell(f,init)   BECAUSE EquivToImpl;
~(\A x : x \notin IterateFuncShell(f,init)) => IterateFuncShell(f,init) # {}   BECAUSE Contraposition;
(\E x : x \in IterateFuncShell(f,init)) <=> ~(\A x : x \notin IterateFuncShell(f,init))   BECAUSE Q_SCHEME;
(\E x : x \in IterateFuncShell(f,init)) => ~(\A x : x \notin IterateFuncShell(f,init))   BECAUSE EquivToImpl;
Nat \X Domain(f) \in IterateFuncShell(f,init) => (\E x : x \in IterateFuncShell(f,init))   BECAUSE \E(x <- Nat \X Domain(f));
h(f,init) => ~(\A x : x \notin IterateFuncShell(f,init))   BECAUSE TI2;
h(f,init) => IterateFuncShell(f,init) # {}   BECAUSE TI;
h(f,init) => \A x : x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE TI;

\* Prove that h(f,init) => ContainsIterateFunc(IterateFunc(f,init), f, init)
(\A x : x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => (x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE \A(x <- x);
h(f,init) => (x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE TI;
(x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => ((\A y : y \in IterateFuncShell(f,init) => x \in y) => x \in IterateFunc(f,init))   BECAUSE EquivToImplReverse;
h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => x \in y) => x \in IterateFunc(f,init))   BECAUSE TI;

ContainsIterateFunc(a,f,init) => <<{}, init>> \in a   BECAUSE S12;
\A a : ContainsIterateFunc(a,f,init) => <<{}, init>> \in a   BECAUSE GENERALIZATION;
ContainsIterateFunc(y,f,init) => <<{}, init>> \in y   BECAUSE \A(a <- y);
y \in IterateFuncShell(f,init) <=> y \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(y,f,init)   BECAUSE \A(x <- y);
y \in IterateFuncShell(f,init) => y \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(y,f,init)   BECAUSE EquivToImpl;
y \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(y,f,init) => ContainsIterateFunc(y,f,init)   BECAUSE S22;
y \in IterateFuncShell(f,init) => <<{}, init>> \in y   BECAUSE TI2;
\A y : y \in IterateFuncShell(f,init) => <<{}, init>> \in y   BECAUSE GENERALIZATION;
\A x : h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => x \in y) => x \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => <<{}, init>> \in y) => <<{}, init>> \in IterateFunc(f,init))   BECAUSE \A(x <- <<{}, init>>);
h(f,init) => (\A y : y \in IterateFuncShell(f,init) => <<{}, init>> \in y)   BECAUSE PT1;
h(f,init) => <<{}, init>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;

hc(f,init,i,j,y) == h(f,init) /\ <<i,j>> \in IterateFunc(f,init) /\ y \in IterateFuncShell(f,init);
hc(f,init,i,j,y) => h(f,init)   BECAUSE S13;
hc(f,init,i,j,y) => <<i,j>> \in IterateFunc(f,init)   BECAUSE S23;
hc(f,init,i,j,y) => y \in IterateFuncShell(f,init)   BECAUSE S22;
hc(f,init,i,j,y) => ContainsIterateFunc(y,f,init)   BECAUSE TI2;
ContainsIterateFunc(a,f,init) => (\A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a)   BECAUSE S22;
(\A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a) => (<<i,j>> \in a => <<successor(i), f[j]>> \in a)   BECAUSE \A(x <- i, y <- j);
ContainsIterateFunc(a,f,init) => (<<i,j>> \in a => <<successor(i), f[j]>> \in a)   BECAUSE TI;
\A a : ContainsIterateFunc(a,f,init) => (<<i,j>> \in a => <<successor(i), f[j]>> \in a)   BECAUSE GENERALIZATION;
ContainsIterateFunc(y,f,init) => (<<i,j>> \in y => <<successor(i), f[j]>> \in y)   BECAUSE \A(a <- y);
hc(f,init,i,j,y) => (<<i,j>> \in y => <<successor(i), f[j]>> \in y)   BECAUSE TI;
(\A x : x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => (<<i,j>> \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE \A(x <- <<i,j>>);
hc(f,init,i,j,y) => (<<i,j>> \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE TI2;
(<<i,j>> \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y) => (<<i,j>> \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE EquivToImpl;
hc(f,init,i,j,y) => (<<i,j>> \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE TI;
hc(f,init,i,j,y) => \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y   BECAUSE KillMiddleHypo;
(\A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y) => (y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE \A(y <- y);
hc(f,init,i,j,y) => (y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE TI;
hc(f,init,i,j,y) => <<i,j>>\in y   BECAUSE KillMiddleHypo;
hc(f,init,i,j,y) => <<successor(i), f[j]>> \in y   BECAUSE KillMiddleHypo;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => (y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y)   BECAUSE HypoAndToImpl;
\A y : h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => (y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y)   BECAUSE GENERALIZATION;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => (\A y : y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y)   BECAUSE Q_SCHEME;
h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y) => <<successor(i), f[j]>> \in IterateFunc(f,init))   BECAUSE \A(x <- <<successor(i), f[j]>>);
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => ((\A y : y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y) => <<successor(i), f[j]>> \in IterateFunc(f,init))   BECAUSE TI;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => <<successor(i), f[j]>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;
\A i : \A j : h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => <<successor(i), f[j]>> \in IterateFunc(f,init)   BECAUSE GENERALIZATION;
h(f,init) /\ <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init)   BECAUSE \A(i <- x, j <- y);
h(f,init) => (<<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE HypoAndToImpl;
\A y : h(f,init) => (<<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => (\A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
\A x : h(f,init) => (\A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => (\A x : \A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
h(f,init) => ContainsIterateFunc(IterateFunc(f,init), f, init)   BECAUSE CIA;

\* Prove that IterateFunc(f,init) is a graph
(x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => (x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE EquivToImpl;
h(f,init) => (x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE TI;
h(f,init) /\ x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE HypoImplToAnd;
(\A y : y \in IterateFuncShell(f,init) => x \in y) => (Nat \X Domain(f) \in IterateFuncShell(f,init) => x \in Nat \X Domain(f))   BECAUSE \A(y <- Nat \X Domain(f));
h(f,init) /\ x \in IterateFunc(f,init) => (Nat \X Domain(f) \in IterateFuncShell(f,init) => x \in Nat \X Domain(f))   BECAUSE TI;
h(f,init) /\ x \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ x \in IterateFunc(f,init) => Nat \X Domain(f) \in IterateFuncShell(f,init)   BECAUSE TI;
h(f,init) /\ x \in IterateFunc(f,init) => x \in Nat \X Domain(f)   BECAUSE KillMiddleHypo;
cartesianProductExists   BECAUSE THEOREM;
x \in (Nat \X Domain(f)) <=> (IsCouple(x) /\ fst(x) \in Nat /\ snd(x) \in Domain(f))   BECAUSE \A(i <- Nat, j <- Domain(f), x <- x);
x \in (Nat \X Domain(f)) => (IsCouple(x) /\ fst(x) \in Nat /\ snd(x) \in Domain(f))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Nat /\ snd(x) \in Domain(f)) => IsCouple(x)   BECAUSE S13;
h(f,init) /\ x \in IterateFunc(f,init) => IsCouple(x)   BECAUSE TI2;
h(f,init) => (x \in IterateFunc(f,init) => IsCouple(x))   BECAUSE HypoAndToImpl;
\A x : h(f,init) => (x \in IterateFunc(f,init) => IsCouple(x))   BECAUSE GENERALIZATION;
h(f,init) => IsGraph(IterateFunc(f,init))   BECAUSE Q_SCHEME;

\* Prove that Domain(IterateFunc(f,init)) = Nat, by induction
natInduction   BECAUSE THEOREM;
{} \in Domain(IterateFunc(f,init)) /\ (\A n : n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))
   => Nat \subseteq Domain(IterateFunc(f,init))   BECAUSE \A(p <- Domain(IterateFunc(f,init)));
<<{},init>> \in IterateFunc(f,init) => IsDefinedOn(IterateFunc(f,init), {})   BECAUSE \E(y <- init);
domainExists   BECAUSE THEOREM;
{} \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), {})   BECAUSE \A(g <- IterateFunc(f,init), x <- {});
IsDefinedOn(IterateFunc(f,init), {}) => {} \in Domain(IterateFunc(f,init))   BECAUSE EquivToImplReverse;
h(f,init) => {} \in Domain(IterateFunc(f,init))   BECAUSE TI2;
hd(f,init,n,y) == h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) /\ <<n,y>> \in IterateFunc(f,init);
hd(f,init,n,y) => h(f,init)   BECAUSE S14;
hd(f,init,n,y) => <<n,y>> \in IterateFunc(f,init)   BECAUSE S22;
\A x : h(f,init) /\ <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init)   BECAUSE GENERALIZATION;
h(f,init) /\ <<n,y>> \in IterateFunc(f,init) => <<successor(n), f[y]>> \in IterateFunc(f,init)   BECAUSE \A(x <- n);
hd(f,init,n,y) => h(f,init) /\ <<n,y>> \in IterateFunc(f,init)   BECAUSE CIA;
<<successor(n), f[y]>> \in IterateFunc(f,init) => IsDefinedOn(IterateFunc(f,init), successor(n))   BECAUSE \E(y <- f[y]);
hd(f,init,n,y) => IsDefinedOn(IterateFunc(f,init), successor(n))   BECAUSE TI2;
successor(n) \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), successor(n))   BECAUSE \A(g <- IterateFunc(f,init), x <- successor(n));
IsDefinedOn(IterateFunc(f,init), successor(n)) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE EquivToImplReverse;
hd(f,init,n,y) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE TI;
\* Discharge y
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (<<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE HypoAndToImpl;
\A y : h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (<<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE GENERALIZATION;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (\A y : <<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE Q_SCHEME;
(\A y : <<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init))) => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE Q_SCHEME;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE TI;
n \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), n)   BECAUSE \A(g <- IterateFunc(f,init), x <- n);
n \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE EquivToImpl;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => n \in Domain(IterateFunc(f,init))   BECAUSE S22;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE TI;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (\E y : successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE KillMiddleHypo;
(\E y : successor(n) \in Domain(IterateFunc(f,init))) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE Q_SCHEME;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE TI;
pushHypos(a,b,c,d) == (a /\ b /\ c => d) => (a => (b /\ c => d))   PROPO_TAUTO;
h(f,init) => (n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE pushHypos;
\A n : h(f,init) => (n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE GENERALIZATION;
h(f,init) => (\A n : n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE Q_SCHEME;
h(f,init) => {} \in Domain(IterateFunc(f,init)) /\ (\A n : n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE CIA;
h(f,init) => Nat \subseteq Domain(IterateFunc(f,init))   BECAUSE TI;

z \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), z)   BECAUSE \A(g <- IterateFunc(f,init), x <- z);
z \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init), z)   BECAUSE EquivToImpl;
\A x : h(f,init) /\ x \in IterateFunc(f,init) => x \in Nat \X Domain(f)   BECAUSE GENERALIZATION;
h(f,init) /\ <<z,y>> \in IterateFunc(f,init) => <<z,y>> \in Nat \X Domain(f)   BECAUSE \A(x <- <<z,y>>);
z \in Nat /\ y \in Domain(f) <=> <<z,y>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- z, b <- y);
<<z,y>> \in Nat \X Domain(f) => z \in Nat /\ y \in Domain(f)   BECAUSE EquivToImplReverse;
z \in Nat /\ y \in Domain(f) => z \in Nat   BECAUSE S12;
h(f,init) /\ <<z,y>> \in IterateFunc(f,init) => z \in Nat   BECAUSE TI2;
h(f,init) => (<<z,y>> \in IterateFunc(f,init) => z \in Nat)   BECAUSE HypoAndToImpl;
\A y : h(f,init) => (<<z,y>> \in IterateFunc(f,init) => z \in Nat)   BECAUSE GENERALIZATION;
h(f,init) => (\A y : <<z,y>> \in IterateFunc(f,init) => z \in Nat)   BECAUSE Q_SCHEME;
(\A y : <<z,y>> \in IterateFunc(f,init) => z \in Nat) => ((\E y : <<z,y>> \in IterateFunc(f,init)) => \E y : z \in Nat)   BECAUSE Q_SCHEME;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => h(f,init)   BECAUSE S12;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => ((\E y : <<z,y>> \in IterateFunc(f,init)) => \E y : z \in Nat)   BECAUSE TI2;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => z \in Domain(IterateFunc(f,init))   BECAUSE S22;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init),z)   BECAUSE TI;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => (\E y : z \in Nat)   BECAUSE KillMiddleHypo;
(\E y : z \in Nat) => z \in Nat   BECAUSE Q_SCHEME;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => z \in Nat   BECAUSE TI;
h(f,init) => (z \in Domain(IterateFunc(f,init)) => z \in Nat)   BECAUSE HypoAndToImpl;
\A z : h(f,init) => (z \in Domain(IterateFunc(f,init)) => z \in Nat)   BECAUSE GENERALIZATION;
h(f,init) => Domain(IterateFunc(f,init)) \subseteq Nat   BECAUSE Q_SCHEME;
bothInclusions   BECAUSE THEOREM;
(Domain(IterateFunc(f,init)) \subseteq Nat /\ Nat \subseteq Domain(IterateFunc(f,init)))
   => Domain(IterateFunc(f,init)) = Nat   BECAUSE \A(a <- Domain(IterateFunc(f,init)), b <- Nat);
h(f,init) => (Domain(IterateFunc(f,init)) \subseteq Nat /\ Nat \subseteq Domain(IterateFunc(f,init)))   BECAUSE CIA;
h(f,init) => Domain(IterateFunc(f,init)) = Nat   BECAUSE TI;

\* Prove that IterateFunc(f,init) is a function, by induction.
\A a : \E b : \A x : x \in b <=> x \in a /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE \A(a <- Nat);
hf(f,init,b) == h(f,init) /\ \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x];
hf(f,init,b) => h(f,init)   BECAUSE S12;
hf(f,init,b) => \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE S22;

\* Assume by contradiction that <<{}, z>> \in IterateFunc(f,init) and init # z.
\* Then show that IterateFunc(f,init) \ {<<{}, z>>} still satisfies ContainsIterateFunc, absurd.
hu(f,init,z) == h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) /\ init # z;
hu(f,init,z) => h(f,init)   BECAUSE S13;
hu(f,init,z) => <<{}, z>> \in IterateFunc(f,init)   BECAUSE S23;
hu(f,init,z) => init # z   BECAUSE S22;
tupleDecomposition   BECAUSE THEOREM;
<<{}, init>> = <<{}, z>>  =>  {} = {} /\ init = z    BECAUSE \A(a <- {}, b <- init, c <- {}, d <- z);
{} = {} /\ init = z => init = z   BECAUSE S22;
<<{}, init>> = <<{}, z>>  => init = z    BECAUSE TI;
init # z => <<{}, init>> # <<{}, z>>   BECAUSE Contraposition;
hu(f,init,z) => <<{}, init>> # <<{}, z>>   BECAUSE TI;
setDifferenceExists   BECAUSE THEOREM;
<<{},init>> \in (IterateFunc(f,init) \ {<<{},z>>})
   <=> (<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<{},init>>);
<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<{},z>>} => <<{},init>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE EquivToImplReverse;
singletonExists   BECAUSE THEOREM;
<<{},init>> \in {<<{},z>>} <=> <<{},init>> = <<{},z>>   BECAUSE \A(a <- <<{},z>>, x <- <<{},init>>);
<<{},init>> \in {<<{},z>>} => <<{},init>> = <<{},z>>   BECAUSE EquivToImpl;
<<{},init>> # <<{},z>> => <<{},init>> \notin {<<{},z>>}   BECAUSE Contraposition;
hu(f,init,z) => <<{},init>> \notin {<<{},z>>}   BECAUSE TI;
hu(f,init,z) => <<{},init>> \in IterateFunc(f,init)   BECAUSE TI;
hu(f,init,z) => <<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<{},z>>}   BECAUSE CIA;
hu(f,init,z) => <<{},init>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE TI;

hus(f,init,z,x,y) == hu(f,init,z) /\ <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>});
hus(f,init,z,x,y) => hu(f,init,z)   BECAUSE S12;
hus(f,init,z,x,y) => <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE S22;
<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>})
   <=> (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<x,y>>);
<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<{},z>>})   BECAUSE EquivToImpl;
<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<{},z>>} => <<x,y>> \in IterateFunc(f,init)   BECAUSE S12;
hus(f,init,z,x,y) => <<x,y>> \in IterateFunc(f,init)   BECAUSE TI2;
hus(f,init,z,x,y) => h(f,init)   BECAUSE TI;
hus(f,init,z,x,y) => h(f,init) /\ <<x,y>> \in IterateFunc(f,init)   BECAUSE CIA;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init)   BECAUSE TI;
<<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>})
   <=> (<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<successor(x),f[y]>>);
<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<{},z>>} => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE EquivToImplReverse;
emptySetExistsUniquely   BECAUSE THEOREM;
successor(p) = {} <=> \A x : x \notin successor(p)   BECAUSE \A(c <- successor(p));
successor(p) = {} => \A x : x \notin successor(p)   BECAUSE EquivToImpl;
{} = successor(p) => successor(p) = {}   BECAUSE E_SCHEME;
{} = successor(p) => \A x : x \notin successor(p)   BECAUSE TI;
~(\A x : x \notin successor(p)) => {} # successor(p)   BECAUSE Contraposition;
(\E x : x \in successor(p)) <=> ~(\A x : x \notin successor(p))   BECAUSE Q_SCHEME;
(\E x : x \in successor(p)) => ~(\A x : x \notin successor(p))   BECAUSE EquivToImpl;
p \in successor(p) => (\E x : x \in successor(p))   BECAUSE \E(x <- p);
p \in successor(p) => {} # successor(p)   BECAUSE TI2;
inSuccessor   BECAUSE THEOREM;
p \in successor(p)   BECAUSE \A(o <- p);
{} # successor(p)   BECAUSE MODUS_PONENS;
\A p : {} # successor(p)   BECAUSE GENERALIZATION;
{} # successor(x)   BECAUSE \A(p <- x);
<<successor(x),f[y]>> = <<{}, z>> => successor(x) = {} /\ f[y] = z
   BECAUSE \A(a <- successor(x), b <- f[y], c <- {}, d <- z);
successor(x) = {} /\ f[y] = z => successor(x) = {}   BECAUSE S12;
successor(x) = {} => {} = successor(x)   BECAUSE E_SCHEME;
<<successor(x),f[y]>> = <<{}, z>> => {} = successor(x)   BECAUSE TI2;
{} # successor(x) => <<successor(x),f[y]>> # <<{}, z>>   BECAUSE Contraposition;
<<successor(x),f[y]>> # <<{}, z>>   BECAUSE MODUS_PONENS;
<<successor(x),f[y]>> \in {<<{},z>>} <=> <<successor(x),f[y]>> = <<{},z>>   BECAUSE \A(a <- <<{},z>>, x <- <<successor(x),f[y]>>);
<<successor(x),f[y]>> \in {<<{},z>>} => <<successor(x),f[y]>> = <<{},z>>   BECAUSE EquivToImpl;
<<successor(x),f[y]>> # <<{},z>> => <<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE Contraposition;
<<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE MODUS_PONENS;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE PT1;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE CIA;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE TI;
hu(f,init,z) => (<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE HypoAndToImpl;
\A y : hu(f,init,z) => (<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE GENERALIZATION;
hu(f,init,z) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE Q_SCHEME;
\A x : hu(f,init,z) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE GENERALIZATION;
hu(f,init,z) => (\A x : \A y : <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE Q_SCHEME;
hu(f,init,z) => ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>}, f, init)   BECAUSE CIA;

\A x : h(f,init) /\ x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE GENERALIZATION;
h(f,init) /\ <<{},z>> \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => <<{},z>> \in y   BECAUSE \A(x <- <<{},z>>);
hu(f,init,z) => h(f,init) /\ <<{},z>> \in IterateFunc(f,init)   BECAUSE CIA;
(\A y : y \in IterateFuncShell(f,init) => <<{},z>> \in y) => (IterateFunc(f,init) \ {<<{},z>>} \in IterateFuncShell(f,init) => <<{},z>> \in IterateFunc(f,init) \ {<<{},z>>})   BECAUSE \A(y <- IterateFunc(f,init) \ {<<{},z>>});
hu(f,init,z) => (IterateFunc(f,init) \ {<<{},z>>} \in IterateFuncShell(f,init) => <<{},z>> \in IterateFunc(f,init) \ {<<{},z>>})   BECAUSE TI2;
(IterateFunc(f,init) \ {<<{},z>>}) \in IterateFuncShell(f,init)
   <=> (IterateFunc(f,init) \ {<<{},z>>} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>} ,f,init)   BECAUSE \A(x <- IterateFunc(f,init) \ {<<{},z>>} );
(IterateFunc(f,init) \ {<<{},z>>} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>} ,f,init) => (IterateFunc(f,init) \ {<<{},z>>}) \in IterateFuncShell(f,init)   BECAUSE EquivToImplReverse;
\A x : h(f,init) /\ x \in IterateFunc(f,init) => x \in Nat \X Domain(f)   BECAUSE GENERALIZATION;
h(f,init) /\ z \in IterateFunc(f,init) => z \in Nat \X Domain(f)   BECAUSE \A(x <- z);
h(f,init) => (z \in IterateFunc(f,init) => z \in Nat \X Domain(f))   BECAUSE HypoAndToImpl;
\A z : h(f,init) => (z \in IterateFunc(f,init) => z \in Nat \X Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => IterateFunc(f,init) \subseteq (Nat \X Domain(f))   BECAUSE Q_SCHEME;
z \in (IterateFunc(f,init) \ {<<{},a>>}) <=> (z \in IterateFunc(f,init) /\ z \notin {<<{},a>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},a>>}, x <- z);
z \in (IterateFunc(f,init) \ {<<{},a>>}) => (z \in IterateFunc(f,init) /\ z \notin {<<{},a>>})   BECAUSE EquivToImpl;
(z \in IterateFunc(f,init) /\ z \notin {<<{},a>>}) => z \in IterateFunc(f,init)   BECAUSE S12;
z \in (IterateFunc(f,init) \ {<<{},a>>}) => z \in IterateFunc(f,init)   BECAUSE TI;
\A a : IterateFunc(f,init) \ {<<{},a>>} \subseteq IterateFunc(f,init)   BECAUSE GENERALIZATION;
IterateFunc(f,init) \ {<<{},z>>} \subseteq IterateFunc(f,init)   BECAUSE \A(a <- z);
transitInclusion   BECAUSE THEOREM;
(IterateFunc(f,init) \ {<<{},z>>} \subseteq IterateFunc(f,init) /\ (IterateFunc(f,init) \subseteq Nat \X Domain(f))) => (IterateFunc(f,init) \ {<<{},z>>} \subseteq Nat \X Domain(f))   BECAUSE \A(a <- IterateFunc(f,init) \ {<<{},z>>}, b <- IterateFunc(f,init), c <- Nat \X Domain(f));
hu(f,init,z) => IterateFunc(f,init) \ {<<{},z>>} \subseteq IterateFunc(f,init)   BECAUSE PT1;
hu(f,init,z) => (IterateFunc(f,init) \subseteq Nat \X Domain(f))   BECAUSE TI;
hu(f,init,z) => (IterateFunc(f,init) \ {<<{},z>>} \subseteq IterateFunc(f,init) /\ (IterateFunc(f,init) \subseteq Nat \X Domain(f)))   BECAUSE CIA;
hu(f,init,z) => IterateFunc(f,init) \ {<<{},z>>} \subseteq Nat \X Domain(f)   BECAUSE TI;
(IterateFunc(f,init) \ {<<{},z>>} ) \in SUBSET (Nat \X Domain(f)) <=> (IterateFunc(f,init) \ {<<{},z>>} ) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f), z <- (IterateFunc(f,init) \ {<<{},z>>} ));
(IterateFunc(f,init) \ {<<{},z>>} ) \subseteq (Nat \X Domain(f)) => (IterateFunc(f,init) \ {<<{},z>>} ) \in SUBSET (Nat \X Domain(f))   BECAUSE EquivToImplReverse;
hu(f,init,z) => (IterateFunc(f,init) \ {<<{},z>>} ) \in SUBSET (Nat \X Domain(f))   BECAUSE TI;
hu(f,init,z) => (IterateFunc(f,init) \ {<<{},z>>} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>} ,f,init)   BECAUSE CIA;
hu(f,init,z) => (IterateFunc(f,init) \ {<<{},z>>}) \in IterateFuncShell(f,init)   BECAUSE TI;
hu(f,init,z) => <<{},z>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE KillMiddleHypo;
<<{},z>> \in (IterateFunc(f,init) \ {<<{},z>>}) <=> (<<{},z>> \in IterateFunc(f,init) /\ <<{},z>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<{},z>>);
<<{},z>> \in (IterateFunc(f,init) \ {<<{},z>>}) => (<<{},z>> \in IterateFunc(f,init) /\ <<{},z>> \notin {<<{},z>>})   BECAUSE EquivToImpl;
<<{},z>> \in IterateFunc(f,init) /\ <<{},z>> \notin {<<{},z>>} => <<{},z>> \notin {<<{},z>>}   BECAUSE S22;
hu(f,init,z) => <<{},z>> \notin {<<{},z>>}   BECAUSE TI2;
<<{},z>> \in {<<{},z>>} <=> <<{},z>> = <<{},z>>   BECAUSE \A(a <- <<{},z>>, x <- <<{},z>>);
<<{},z>> = <<{},z>>   BECAUSE \A(a <- <<{},z>>);
<<{},z>> \in {<<{},z>>}   BECAUSE MODUS_PONENS;
absurd(h,a,t) == t => ((h /\ ~a => ~t) => (h => a))   PROPO_TAUTO;
h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) => init = z   BECAUSE absurd;
init = z => z = init   BECAUSE E_SCHEME;
h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) => z = init   BECAUSE TI;
\A z : \A j : z = j => (<<{}, z>> \in IterateFunc(f,init) <=> <<{}, j>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
z = init => (<<{}, z>> \in IterateFunc(f,init) <=> <<{}, init>> \in IterateFunc(f,init))   BECAUSE \A(z <- z, j <- init);
implyEquivTrue(h,t,a,b) == (h => t) => ((b => (a <=> t)) => (h /\ b => a))   PROPO_TAUTO; 
h(f,init) /\ z = init => <<{}, z>> \in IterateFunc(f,init)   BECAUSE implyEquivTrue;
h(f,init) => (z = init <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE HIE;
\A z : h(f,init) => (z = init <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => (\A z : z = init <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
(\A z : z = init <=> <<{}, z>> \in IterateFunc(f,init)) => \E y : \A z : z = y <=> <<{}, z>> \in IterateFunc(f,init)   BECAUSE \E(y <- init);
(\E y : \A z : z = y <=> <<{}, z>> \in IterateFunc(f,init)) => \A z : z = IterateFunc(f,init)[{}] <=> <<{}, z>> \in IterateFunc(f,init)   BECAUSE CHOOSE IterateFunc(f,init)[{}];
h(f,init) => (\A z : z = IterateFunc(f,init)[{}] <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE TI2;
(\A z : z = IterateFunc(f,init)[{}] <=> <<{}, z>> \in IterateFunc(f,init)) => (init = IterateFunc(f,init)[{}] <=> <<{}, init>> \in IterateFunc(f,init))   BECAUSE \A(z <- init);
h(f,init) => (init = IterateFunc(f,init)[{}] <=> <<{}, init>> \in IterateFunc(f,init))   BECAUSE TI;
implyEquivTrueB(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
h(f,init) => init = IterateFunc(f,init)[{}]   BECAUSE implyEquivTrueB;
init = IterateFunc(f,init)[{}] => IterateFunc(f,init)[{}] = init   BECAUSE E_SCHEME;
h(f,init) => IterateFunc(f,init)[{}] = init   BECAUSE TI;

(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => ({} \in b <=> {} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE \A(x <- {});
hf(f,init,b) => ({} \in b <=> {} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE TI;
({} \in b <=> {} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]) => (({} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]) => {} \in b)   BECAUSE EquivToImplReverse;
hf(f,init,b) => (({} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]) => {} \in b)   BECAUSE TI;
hf(f,init,b) => {} \in Nat   BECAUSE PT1;
\A z : h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) => z = init   BECAUSE GENERALIZATION;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => j = init   BECAUSE \A(z <- j);
j = init /\ IterateFunc(f,init)[{}] = init => j = IterateFunc(f,init)[{}]   BECAUSE E_SCHEME;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => IterateFunc(f,init)[{}] = init   BECAUSE TI;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => j = init /\ IterateFunc(f,init)[{}] = init   BECAUSE CIA;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]   BECAUSE TI;
h(f,init) => (<<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE HypoAndToImpl;
\A j : h(f,init) => (<<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE GENERALIZATION;
h(f,init) => (\A j : <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE Q_SCHEME;
h(f,init) => {} \in Nat /\ (\A j : <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE CIA;
hf(f,init,b) => {} \in Nat /\ (\A j : <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE TI;
hf(f,init,b) => {} \in b   BECAUSE KillMiddleHypo;

\* TODO induction step for b
hfn(f,init,b,n,j) == hf(f,init,b)
   /\ n \in b
   /\ <<successor(n),j>> \in IterateFunc(f,init)
   /\ j # f[IterateFunc(f,init)[n]]; \* Hypothesis leading to a contradiction
hfn(f,init,b,n,j) => hf(f,init,b)   BECAUSE S14;
hfn(f,init,b,n,j) => n \in b   BECAUSE S24;
hfn(f,init,b,n,j) => <<successor(n),j>> \in IterateFunc(f,init)   BECAUSE S23;
hfn(f,init,b,n,j) => j # f[IterateFunc(f,init)[n]]   BECAUSE S22;
\* Prove that hf(f,init,b) => ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>} ,f,init)
\* which is a contradiction.
{} # successor(n)   BECAUSE \A(p <- n);
<<{}, init>> = <<successor(n), j>>  =>  {} = successor(n) /\ init = j    BECAUSE \A(a <- {}, b <- init, c <- successor(n), d <- j);
{} = successor(n) /\ init = j => {} = successor(n)   BECAUSE S12;
<<{}, init>> = <<successor(n), j>> => {} = successor(n)   BECAUSE TI;
{} # successor(n) => <<{}, init>> # <<successor(n), j>>   BECAUSE Contraposition;
<<{}, init>> # <<successor(n), j>>   BECAUSE MODUS_PONENS;
<<{},init>> \in {<<successor(n),j>>} <=> <<{},init>> = <<successor(n),j>>   BECAUSE \A(a <- <<successor(n),j>>, x <- <<{},init>>);
<<{},init>> \in {<<successor(n),j>>} => <<{},init>> = <<successor(n),j>>   BECAUSE EquivToImpl;
<<{},init>> # <<successor(n),j>> => <<{},init>> \notin {<<successor(n),j>>}  BECAUSE Contraposition;
<<{},init>> \notin {<<successor(n),j>>}  BECAUSE MODUS_PONENS;
hfn(f,init,b,n,j) => <<{},init>> \notin {<<successor(n),j>>}  BECAUSE PT1;
<<{}, init>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<{},init>>);
(<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<successor(n),j>>}) => <<{}, init>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE EquivToImplReverse;
hfn(f,init,b,n,j) => <<{},init>> \in IterateFunc(f,init)   BECAUSE TI2;
hfn(f,init,b,n,j) => (<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<successor(n),j>>})   BECAUSE CIA;
hfn(f,init,b,n,j) => <<{}, init>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE TI;

\* Now the inductive property of (IterateFunc(f,init) \ {<<successor(n),j>>})
\* \A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a
hfnx(f,init,b,n,j,x,y) == hfn(f,init,b,n,j) /\ <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>});
hfnx(f,init,b,n,j,x,y) => hfn(f,init,b,n,j)   BECAUSE S12;
hfnx(f,init,b,n,j,x,y) => <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE S22;
<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<x,y>>);
<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<successor(n),j>>})   BECAUSE EquivToImpl;
(<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<successor(n),j>>}) => <<x,y>> \in IterateFunc(f,init)   BECAUSE S12;
hfnx(f,init,b,n,j,x,y) => <<x,y>> \in IterateFunc(f,init)   BECAUSE TI2;
hfnx(f,init,b,n,j,x,y) => h(f,init)   BECAUSE TI2;
hfnx(f,init,b,n,j,x,y) => h(f,init) /\ <<x,y>> \in IterateFunc(f,init)   BECAUSE CIA;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init)   BECAUSE TI;
<<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<successor(x),f[y]>>);
(<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<successor(n),j>>})
   => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE EquivToImplReverse;
<<successor(x),f[y]>> \in {<<successor(n),j>>} <=> <<successor(x),f[y]>> = <<successor(n),j>>
   BECAUSE \A(a <- <<successor(n),j>>, x <- <<successor(x),f[y]>>);
<<successor(x),f[y]>> \in {<<successor(n),j>>} => <<successor(x),f[y]>> = <<successor(n),j>>   BECAUSE EquivToImpl;
<<successor(x), f[y]>> = <<successor(n), j>> => successor(x) = successor(n) /\ f[y] = j    BECAUSE \A(a <- successor(x), b <- f[y], c <- successor(n), d <- j);
hfnxy(f,init,b,n,j,x,y) == hfnx(f,init,b,n,j,x,y) /\ <<successor(x),f[y]>> \in {<<successor(n),j>>};
hfnxy(f,init,b,n,j,x,y) => hfnx(f,init,b,n,j,x,y)   BECAUSE S12;
hfnxy(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in {<<successor(n),j>>}   BECAUSE S22;
hfnxy(f,init,b,n,j,x,y) => successor(x) = successor(n) /\ f[y] = j   BECAUSE TI2;
successor(x) = successor(n) /\ f[y] = j => successor(x) = successor(n)   BECAUSE S12;
successor(x) = successor(n) /\ f[y] = j => f[y] = j   BECAUSE S22;
hfnxy(f,init,b,n,j,x,y) => successor(x) = successor(n)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => f[y] = j   BECAUSE TI;
\* Then x = n /\ f[y] = j. So <<n,y>> \in IterateFunc(f,init). So y = IterateFunc(f,init)[n].
ordinalSuccessorRegular   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(n) /\ successor(x) = successor(n) => x = n   BECAUSE \A(o <- x, p <- n);
\A z : h(f,init) /\ <<z,y>> \in IterateFunc(f,init) => z \in Nat   BECAUSE GENERALIZATION;
h(f,init) /\ <<x,y>> \in IterateFunc(f,init) => x \in Nat   BECAUSE \A(z <- x);
hfnxy(f,init,b,n,j,x,y) => h(f,init)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => <<x,y>> \in IterateFunc(f,init)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => h(f,init) /\ <<x,y>> \in IterateFunc(f,init)   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => x \in Nat   BECAUSE TI;
NatExists   BECAUSE THEOREM;
(\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
(\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE \A(x <- x);
x \in Nat => IsFiniteOrdinal(x)   BECAUSE EquivToImpl;
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
x \in Nat => IsOrdinal(x)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(x)   BECAUSE TI;
(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x])
   => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE \A(x <- n);
hf(f,init,b) => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
(n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE EquivToImpl;
hf(f,init,b) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hfn(f,init,b,n,j) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hfn(f,init,b,n,j) => (n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE KillMiddleHypo;
(n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => n \in Nat   BECAUSE S12;
hfnx(f,init,b,n,j,x,y) => n \in Nat   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => n \in Nat   BECAUSE TI;
\A x : x \in Nat => IsOrdinal(x)   BECAUSE GENERALIZATION;
n \in Nat => IsOrdinal(n)   BECAUSE \A(x <- n);
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(n)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(x) /\ IsOrdinal(n)   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(x) /\ IsOrdinal(n) /\ successor(x) = successor(n)   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => x = n   BECAUSE TI;
\A x : \A n : x = n => (<<x,y>> \in IterateFunc(f,init) <=> <<n,y>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
x = n => (<<x,y>> \in IterateFunc(f,init) <=> <<n,y>> \in IterateFunc(f,init))   BECAUSE \A(x <- x, n <- n);
hfnxy(f,init,b,n,j,x,y) => (<<x,y>> \in IterateFunc(f,init) <=> <<n,y>> \in IterateFunc(f,init))   BECAUSE TI;
implyTrueEquiv(h,t,a,b) == (h => t) => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO; 
hfnxy(f,init,b,n,j,x,y) => <<n,y>> \in IterateFunc(f,init)   BECAUSE implyTrueEquiv;
(n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE S22;
(\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])   BECAUSE \A(j <- y);
hfn(f,init,b,n,j) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => y = IterateFunc(f,init)[n]   BECAUSE KillMiddleHypo;
\* Then j = f[IterateFunc(f,init)[n]
\A x : \A n : x = n => (f[x] = f[n])   BECAUSE E_SCHEME;
y = IterateFunc(f,init)[n] => f[y] = f[IterateFunc(f,init)[n]]   BECAUSE \A(x <- y, n <- IterateFunc(f,init)[n]);
hfnxy(f,init,b,n,j,x,y) => f[y] = f[IterateFunc(f,init)[n]]   BECAUSE TI;
f[y] = j /\ f[y] = f[IterateFunc(f,init)[n]] => j = f[IterateFunc(f,init)[n]]   BECAUSE E_SCHEME;
hfnxy(f,init,b,n,j,x,y) => f[y] = j /\ f[y] = f[IterateFunc(f,init)[n]]   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => j = f[IterateFunc(f,init)[n]]   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => j # f[IterateFunc(f,init)[n]]   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => j = f[IterateFunc(f,init)[n]] /\ j # f[IterateFunc(f,init)[n]]   BECAUSE CIA;
absurdB(h,a,b) == (h /\ a => b /\ ~b) => (h => ~a)   PROPO_TAUTO;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \notin {<<successor(n),j>>}   BECAUSE absurdB;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<successor(n),j>>}   BECAUSE CIA;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE TI;

\* Discharge x,y
hfn(f,init,b,n,j) => (<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE HypoAndToImpl;
\A y : hfn(f,init,b,n,j) => (<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE GENERALIZATION;
hfn(f,init,b,n,j) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE Q_SCHEME;
\A x : hfn(f,init,b,n,j) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE GENERALIZATION;
hfn(f,init,b,n,j) => (\A x : \A y : <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE Q_SCHEME;
hfn(f,init,b,n,j) => ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>}, f, init)   BECAUSE CIA;

\* Discharge j : <<successor(n),j>> \notin IterateFunc(f,init)
h(f,init) /\ <<successor(n),j>> \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => <<successor(n),j>> \in y   BECAUSE \A(x <- <<successor(n),j>>);
hfn(f,init,b,n,j) => h(f,init)   BECAUSE TI;
hfn(f,init,b,n,j) => h(f,init) /\ <<successor(n),j>> \in IterateFunc(f,init)   BECAUSE CIA;
hfn(f,init,b,n,j) => \A y : y \in IterateFuncShell(f,init) => <<successor(n),j>> \in y   BECAUSE TI;
(\A y : y \in IterateFuncShell(f,init) => <<successor(n),j>> \in y) => (IterateFunc(f,init) \ {<<successor(n),j>>} \in IterateFuncShell(f,init) => <<successor(n),j>> \in IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE \A(y <- (IterateFunc(f,init) \ {<<successor(n),j>>}));
hfn(f,init,b,n,j) => (IterateFunc(f,init) \ {<<successor(n),j>>} \in IterateFuncShell(f,init) => <<successor(n),j>> \in IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE TI;
(IterateFunc(f,init) \ {<<successor(n),j>>}) \in IterateFuncShell(f,init)
   <=> (IterateFunc(f,init) \ {<<successor(n),j>>} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>} ,f,init)   BECAUSE \A(x <- IterateFunc(f,init) \ {<<successor(n),j>>} );
(IterateFunc(f,init) \ {<<successor(n),j>>} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>} ,f,init) => (IterateFunc(f,init) \ {<<successor(n),j>>}) \in IterateFuncShell(f,init)   BECAUSE EquivToImplReverse;

hfn(f,init,b,n,j) => IterateFunc(f,init) \subseteq (Nat \X Domain(f))   BECAUSE TI2;
z \in (IterateFunc(f,init) \ {<<successor(n),j>>}) <=> (z \in IterateFunc(f,init) /\ z \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- z);
z \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => (z \in IterateFunc(f,init) /\ z \notin {<<successor(n),j>>})   BECAUSE EquivToImpl;
(z \in IterateFunc(f,init) /\ z \notin {<<successor(n),j>>}) => z \in IterateFunc(f,init)   BECAUSE S12;
z \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => z \in IterateFunc(f,init)   BECAUSE TI;
IterateFunc(f,init) \ {<<successor(n),j>>} \subseteq IterateFunc(f,init)   BECAUSE GENERALIZATION;
(IterateFunc(f,init) \ {<<successor(n),j>>} \subseteq IterateFunc(f,init) /\ (IterateFunc(f,init) \subseteq Nat \X Domain(f))) => (IterateFunc(f,init) \ {<<successor(n),j>>} \subseteq Nat \X Domain(f))   BECAUSE \A(a <- IterateFunc(f,init) \ {<<successor(n),j>>}, b <- IterateFunc(f,init), c <- Nat \X Domain(f));
hfn(f,init,b,n,j) => (IterateFunc(f,init) \ {<<successor(n),j>>}) \subseteq IterateFunc(f,init)   BECAUSE PT1;
hfn(f,init,b,n,j) => (IterateFunc(f,init) \ {<<successor(n),j>>} \subseteq IterateFunc(f,init) /\ (IterateFunc(f,init) \subseteq Nat \X Domain(f)))   BECAUSE CIA;
hfn(f,init,b,n,j) => IterateFunc(f,init) \ {<<successor(n),j>>} \subseteq Nat \X Domain(f)   BECAUSE TI;
(IterateFunc(f,init) \ {<<successor(n),j>>} ) \in SUBSET (Nat \X Domain(f)) <=> (IterateFunc(f,init) \ {<<successor(n),j>>} ) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f), z <- (IterateFunc(f,init) \ {<<successor(n),j>>} ));
(IterateFunc(f,init) \ {<<successor(n),j>>} ) \subseteq (Nat \X Domain(f)) => (IterateFunc(f,init) \ {<<successor(n),j>>} ) \in SUBSET (Nat \X Domain(f))   BECAUSE EquivToImplReverse;
hfn(f,init,b,n,j) => (IterateFunc(f,init) \ {<<successor(n),j>>} ) \in SUBSET (Nat \X Domain(f))   BECAUSE TI;
hfn(f,init,b,n,j) => (IterateFunc(f,init) \ {<<successor(n),j>>} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>} ,f,init)   BECAUSE CIA;
hfn(f,init,b,n,j) => (IterateFunc(f,init) \ {<<successor(n),j>>}) \in IterateFuncShell(f,init)   BECAUSE TI;
hfn(f,init,b,n,j) => <<successor(n),j>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE KillMiddleHypo;
<<successor(n),j>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<successor(n),j>> \in IterateFunc(f,init) /\ <<successor(n),j>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<successor(n),j>>);
<<successor(n),j>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => (<<successor(n),j>> \in IterateFunc(f,init) /\ <<successor(n),j>> \notin {<<successor(n),j>>})   BECAUSE EquivToImpl;
(<<successor(n),j>> \in IterateFunc(f,init) /\ <<successor(n),j>> \notin {<<successor(n),j>>}) => <<successor(n),j>> \notin {<<successor(n),j>>}   BECAUSE S22;
hfn(f,init,b,n,j) => <<successor(n),j>> \notin {<<successor(n),j>>}   BECAUSE TI2;
<<successor(n),j>> \in {<<successor(n),j>>} <=> <<successor(n),j>> = <<successor(n),j>>   BECAUSE \A(a <- <<successor(n),j>>, x <- <<successor(n),j>>);
<<successor(n),j>> = <<successor(n),j>>   BECAUSE \A(a <- <<successor(n),j>>);
<<successor(n),j>> \in {<<successor(n),j>>}   BECAUSE MODUS_PONENS;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => j = f[IterateFunc(f,init)[n]]   BECAUSE absurd;

\* Prove successor(n) \in b,
\* show that <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init)
hf(f,init,b) /\ n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE HypoImplToAnd;
Nat \subseteq Domain(IterateFunc(f,init)) => (n \in Nat => n \in Domain(IterateFunc(f,init)))   BECAUSE \A(z <- n);
hf(f,init,b) => (n \in Nat => n \in Domain(IterateFunc(f,init)))   BECAUSE TI2;
hf(f,init,b) /\ n \in Nat => n \in Domain(IterateFunc(f,init))   BECAUSE HypoImplToAnd;
hf(f,init,b) /\ n \in Nat => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE TI;
hdefn(f,init,b,n,y) == hf(f,init,b) /\ n \in b /\ <<n,y>> \in IterateFunc(f,init);
hdefn(f,init,b,n,y) => hf(f,init,b)   BECAUSE S13;
hdefn(f,init,b,n,y) => n \in b   BECAUSE S23;
hdefn(f,init,b,n,y) => <<n,y>> \in IterateFunc(f,init)   BECAUSE S22;
n \in Nat /\ (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE ImplySelf;
(\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])  BECAUSE \A(j <- y);
hdefn(f,init,b,n,y) => hf(f,init,b) /\ n \in b   BECAUSE CIA;
hdefn(f,init,b,n,y) => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE TI;
hdefn(f,init,b,n,y) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])  BECAUSE TI2;
hdefn(f,init,b,n,y) => y = IterateFunc(f,init)[n]  BECAUSE KillMiddleHypo;
\A y : \A z : y = z => (<<n,y>> \in IterateFunc(f,init) <=> <<n,z>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
y = IterateFunc(f,init)[n] => (<<n,y>> \in IterateFunc(f,init) <=> <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE \A(y <- y, z <- IterateFunc(f,init)[n]);
hdefn(f,init,b,n,y) => (<<n,y>> \in IterateFunc(f,init) <=> <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE TI;
hdefn(f,init,b,n,y) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE implyTrueEquiv;
\* Discharge y
hf(f,init,b) /\ n \in b => (<<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE HypoAndToImpl;
\A y : hf(f,init,b) /\ n \in b => (<<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b => (\A y : <<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
(\A y : <<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)) => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
hf(f,init,b) /\ n \in b => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE TI;
hf(f,init,b) /\ n \in b => n \in Nat   BECAUSE TI;
hf(f,init,b) /\ n \in b => hf(f,init,b)   BECAUSE S12;
hf(f,init,b) /\ n \in b => hf(f,init,b) /\ n \in Nat   BECAUSE CIA;
hf(f,init,b) /\ n \in b => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE TI;
hf(f,init,b) /\ n \in b => \E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;
(\E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE Q_SCHEME;
hf(f,init,b) /\ n \in b => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE TI;

hf(f,init,b) /\ n \in b => \A x : \A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init)   BECAUSE TI2;
(\A x : \A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))
   => (<<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init) => <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE \A(x <- n, y <- IterateFunc(f,init)[n]);
hf(f,init,b) /\ n \in b => (<<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init) => <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE TI;
hf(f,init,b) /\ n \in b => <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;
\A z : \A x : z = x => (<<successor(n),z>> \in IterateFunc(f,init) <=> <<successor(n),x>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
z = f[IterateFunc(f,init)[n]] => (<<successor(n),z>> \in IterateFunc(f,init) <=> <<successor(n),f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE \A(z <- z, x <- f[IterateFunc(f,init)[n]]);
hf(f,init,b) /\ n \in b /\ z = f[IterateFunc(f,init)[n]] => <<successor(n),z>> \in IterateFunc(f,init)   BECAUSE implyEquivTrue;
\A j : hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => j = f[IterateFunc(f,init)[n]]   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b /\ <<successor(n),z>> \in IterateFunc(f,init) => z = f[IterateFunc(f,init)[n]]   BECAUSE \A(j <- z);
hf(f,init,b) /\ n \in b => (z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE HIE;
\A z : hf(f,init,b) /\ n \in b => (z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b => (\A z : z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
(\A z : z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init)) => (\E y : \A z : z = y <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE \E(y <- f[IterateFunc(f,init)[n]]);
hf(f,init,b) /\ n \in b => (\E y : \A z : z = y <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE TI;
(\E y : \A z : z = y <=> <<successor(n),z>> \in IterateFunc(f,init)) => (\A z : z = IterateFunc(f,init)[successor(n)] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE CHOOSE IterateFunc(f,init)[successor(n)];
hf(f,init,b) /\ n \in b => (\A z : z = IterateFunc(f,init)[successor(n)] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE TI;
(\A z : z = IterateFunc(f,init)[successor(n)] <=> <<successor(n),z>> \in IterateFunc(f,init))
   => (f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)] <=> <<successor(n),f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE \A(z <- f[IterateFunc(f,init)[n]]);
hf(f,init,b) /\ n \in b => (f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)] <=> <<successor(n),f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE TI;
hf(f,init,b) /\ n \in b => f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)]   BECAUSE implyEquivTrueB;
f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)] => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE E_SCHEME;
hf(f,init,b) /\ n \in b => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE TI;

hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => hf(f,init,b)   BECAUSE S13;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => n \in b   BECAUSE S23;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => hf(f,init,b) /\ n \in b  BECAUSE CIA;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE TI;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => j = f[IterateFunc(f,init)[n]] /\ IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE CIA;
j = f[IterateFunc(f,init)[n]] /\ IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]
   => j = IterateFunc(f,init)[successor(n)]   BECAUSE E_SCHEME;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => j = IterateFunc(f,init)[successor(n)]   BECAUSE TI;
hf(f,init,b) /\ n \in b => (<<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE HypoAndToImpl;
\A j : hf(f,init,b) /\ n \in b => (<<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b => (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE Q_SCHEME;
n \in Nat => successor(n) \in Nat   BECAUSE \A(n <- n);
hf(f,init,b) /\ n \in b => successor(n) \in Nat   BECAUSE TI;
hf(f,init,b) /\ n \in b => successor(n) \in Nat /\ (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE CIA;

(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x])
   => (successor(n) \in b <=> successor(n) \in Nat /\ \A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE \A(x <- successor(n));
hf(f,init,b) /\ n \in b => (successor(n) \in b <=> successor(n) \in Nat /\ \A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE TI2;
(successor(n) \in b <=> successor(n) \in Nat /\ \A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)]) => (successor(n) \in Nat /\ (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)]) => successor(n) \in b)   BECAUSE EquivToImplReverse;
hf(f,init,b) /\ n \in b => (successor(n) \in Nat /\ (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)]) => successor(n) \in b)   BECAUSE TI;
hf(f,init,b) /\ n \in b => successor(n) \in b   BECAUSE KillMiddleHypo;
hf(f,init,b) /\ n \in b => n \in Nat /\ successor(n) \in b   BECAUSE CIA;
shuffleHypos(a,b,c,d) == (a /\ b => c /\ d) => (a => (c /\ b => d))   PROPO_TAUTO;
hf(f,init,b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE shuffleHypos;
\A n : hf(f,init,b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE GENERALIZATION;
hf(f,init,b) => (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE Q_SCHEME;
hf(f,init,b) => {} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE CIA;
{} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
hf(f,init,b) => ({} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b)   BECAUSE PT1;
hf(f,init,b) => Nat \subseteq b   BECAUSE KillMiddleHypo; \* End of induction

Nat \subseteq b => (n \in Nat => n \in b)   BECAUSE \A(z <- n);
hf(f,init,b) => (n \in Nat => n \in b)   BECAUSE TI;
hf(f,init,b) /\ n \in Nat => n \in b   BECAUSE HypoImplToAnd;
hf(f,init,b) /\ n \in Nat => hf(f,init,b)   BECAUSE S12;
hf(f,init,b) /\ n \in Nat => hf(f,init,b) /\ n \in b   BECAUSE CIA;
(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x])
   => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE \A(x <- n);
hf(f,init,b) => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
(n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])
   => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE EquivToImpl;
hf(f,init,b) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hf(f,init,b) /\ n \in Nat => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hf(f,init,b) /\ n \in Nat => (n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE KillMiddleHypo;
(n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE S22;
hf(f,init,b) /\ n \in Nat => \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE TI;

\* Discharge b
hf(f,init,b) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))   BECAUSE HypoAndToImpl;

h(f,init) => ((\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE HypoAndToImpl;
\A b : h(f,init) => ((\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE GENERALIZATION;
h(f,init) => (\A b : (\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))) => ((\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => \E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE Q_SCHEME;
h(f,init) => ((\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => \E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE TI;
h(f,init) => \E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE PT1;
h(f,init) => (\E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE KillMiddleHypo;
(\E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))) => ((n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE Q_SCHEME;
h(f,init) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))   BECAUSE TI;
\A n : h(f,init) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))   BECAUSE GENERALIZATION;
h(f,init) => (a \in Nat => (\A j : <<a,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[a]))   BECAUSE \A(n <- a);
h(f,init) /\ a \in Nat => (\A j : <<a,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[a])   BECAUSE HypoImplToAnd;
(\A j : <<a,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[a]) => (<<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE \A(j <- b);
h(f,init) /\ a \in Nat => (<<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE TI;
shuffleHyposB(a,b,c,d) == (a /\ b => (c => d)) => (a /\ c => (b => d))   PROPO_TAUTO;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => (a \in Nat => b = IterateFunc(f,init)[a])   BECAUSE shuffleHyposB;
<<a,b>> \in IterateFunc(f,init) => IsDefinedOn(IterateFunc(f,init),a)   BECAUSE \E(y <- b);
a \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), a)   BECAUSE \A(g <- IterateFunc(f,init), x <- a);
IsDefinedOn(IterateFunc(f,init), a) => a \in Domain(IterateFunc(f,init))   BECAUSE EquivToImplReverse;
<<a,b>> \in IterateFunc(f,init) => a \in Domain(IterateFunc(f,init))   BECAUSE TI;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => <<a,b>> \in IterateFunc(f,init)   BECAUSE S22;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => a \in Domain(IterateFunc(f,init))   BECAUSE TI;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
Domain(IterateFunc(f,init)) = Nat => (a \in Domain(IterateFunc(f,init)) <=> a \in Nat)   BECAUSE \A(x <- Domain(IterateFunc(f,init)), y <- Nat);
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => (a \in Domain(IterateFunc(f,init)) <=> a \in Nat)   BECAUSE TI2;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => a \in Nat   BECAUSE implyTrueEquiv;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a]   BECAUSE KillMiddleHypo;
h(f,init) => (<<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE HypoAndToImpl;
\A b : h(f,init) => (<<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE GENERALIZATION;
h(f,init) => \A b : <<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a]   BECAUSE Q_SCHEME;
\A a : h(f,init) => (\A b : <<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE GENERALIZATION;
h(f,init) => \A a : \A b : <<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a]   BECAUSE Q_SCHEME;
h(f,init) => IsFunction(IterateFunc(f,init))   BECAUSE CIA;

h(f,init) => IsFunction(IterateFunc(f,init)) /\ Domain(IterateFunc(f,init)) = Nat   BECAUSE CIA;
h(f,init) => IsFunction(IterateFunc(f,init)) /\ Domain(IterateFunc(f,init)) = Nat /\ IterateFunc(f,init)[{}] = init   BECAUSE CIA;
iterateFuncExists   BECAUSE GENERALIZATION;
QED

(*
IterateFunc(f,init) == CHOOSE_UNIQUE s : \A z : z = s <=>
   IsFunction(z) /\ Domain(z) = Nat /\ z[ {} ] = init
   /\ \A n : n \in Nat => z[successor(n)] = f[z[n]]
*)

\* Restriction of the successor operator to Nat
natSucc == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = Nat /\ \A n : n \in Nat => natSucc[n] = successor(n)

\* The hypotheses Image(f) \subseteq Domain(f) /\ init \in Domain(f) are probably useless.
\* TODO remove this proof if the previous one by intersection above succeeds.
iterateFuncExistsBis == \A f : \A init : IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f)
   => ( \A z : z = IterateFunc(f,init) <=>
        IsFunction(z) /\ Domain(z) = Nat /\ z[ {} ] = init
        /\ \A n : n \in Nat => z[successor(n)] = f[z[n]]   )
THEOREM iterateFuncExistsBis
PROOF
\* By natInduction, show that there is a partial solution
\* defined on [0,n] for all n.
\* Then use the replacement axiom scheme on Nat to build
\* the complete function.
VARIABLES a,b,c,f,g,n,o,p,x,y,z,init;
h(f,x,init) == \E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init
   /\ \A n : n \in x => g[successor(n)] = f[g[n]];
\A a : \E b : \A x : x \in b <=> x \in a /\ h(f,x,init)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ h(f,x,init)   BECAUSE \A(a <- Nat);
hb(f,init,b) == \A x : x \in b <=> x \in Nat /\ h(f,x,init);

natInduction   BECAUSE THEOREM;
{} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
\* Prove h(f, {}, init)
singletonFuncIsFunction   BECAUSE THEOREM;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = {{}}
   /\ singletonFunc({},init)[{}] = init   BECAUSE \A(a <- {}, b <- init);
IsFunction(singletonFunc({},init))   BECAUSE S13;
Domain(singletonFunc({},init)) = {{}}   BECAUSE S23;
singletonFunc({},init)[{}] = init   BECAUSE S22;
unionInc   BECAUSE THEOREM;
x \in successor({}) <=> (x \in {} \/ x \in {{}})   BECAUSE \A(x <- {}, y <- {{}}, z <- x);
emptySetExists   BECAUSE THEOREM;
x \notin {}   BECAUSE \A(x <- x);
equivFalseOr(f,a,b) == ~f => ((a <=> f \/ b) => (a <=> b))   PROPO_TAUTO;
x \in successor({}) <=> x \in {{}}   BECAUSE equivFalseOr;
\A x : x \in successor({}) <=> x \in {{}}   BECAUSE GENERALIZATION;
extensionality   BECAUSE AXIOM;
(\A x : x \in successor({}) <=> x \in {{}}) => successor({}) = {{}}   BECAUSE \A(a <- successor({}), b <- {{}});
successor({}) = {{}}   BECAUSE MODUS_PONENS;
Domain(singletonFunc({},init)) = {{}} /\ successor({}) = {{}}
   => Domain(singletonFunc({},init)) = successor({})   BECAUSE E_SCHEME;
Domain(singletonFunc({},init)) = {{}} /\ successor({}) = {{}}   BECAUSE IntroAndRight;
Domain(singletonFunc({},init)) = successor({})   BECAUSE MODUS_PONENS;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = successor({})   BECAUSE IntroAndRight;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = successor({})
   /\ singletonFunc({},init)[{}] = init   BECAUSE IntroAndRight;
n \notin {}   BECAUSE \A(x <- n);
n \in {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE Explosion;
\A n : n \in {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE GENERALIZATION;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = successor({}) /\ singletonFunc({},init)[{}] = init /\ \A n : n \in {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE IntroAndRight;
h(f, {}, init)   BECAUSE \E(g <- singletonFunc({},init));
hb(f,init,b) => ({} \in b <=> {} \in Nat /\ h(f,{},init))   BECAUSE \A(x <- {});
zeroInNat   BECAUSE THEOREM;
{} \in Nat /\ h(f,{},init)   BECAUSE IntroAndRight;
hb(f,init,b) => {} \in b   BECAUSE ImplyEquivTrue;

\* Prove that \A p : p \in b => successor(p) \in b
hbn(f,init,b,p,g) == hb(f,init,b) /\ p \in b
   /\ (IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
       /\ \A n : n \in p => g[successor(n)] = f[g[n]]);
hbn(f,init,b,p,g) => hb(f,init,b)   BECAUSE S13;
hbn(f,init,b,p,g) => p \in b   BECAUSE S23;
hbn(f,init,b,p,g) => (IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in p => g[successor(n)] = f[g[n]])   BECAUSE S22;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => IsFunction(g)   BECAUSE S14;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => Domain(g) = successor(p)   BECAUSE S24;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => g[{}] = init   BECAUSE S23;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => \A n : n \in p => g[successor(n)] = f[g[n]]   BECAUSE S22;
hbn(f,init,b,p,g) => IsFunction(g)   BECAUSE TI;
hbn(f,init,b,p,g) => Domain(g) = successor(p)   BECAUSE TI;
hbn(f,init,b,p,g) => g[{}] = init   BECAUSE TI;
hbn(f,init,b,p,g) => \A n : n \in p => g[successor(n)] = f[g[n]]   BECAUSE TI;

unionFunc   BECAUSE THEOREM;
IsFunction(g) /\ IsFunction(singletonFunc(successor(p), f[g[p]])) /\ AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]])))
   => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))
      /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))
      /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])
      /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])
   BECAUSE \A(f <- g, g <- singletonFunc(successor(p), f[g[p]]));

IsFunction(singletonFunc(successor(p), f[g[p]])) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}
   /\ singletonFunc(successor(p), f[g[p]])[successor(p)] = f[g[p]]   BECAUSE \A(a <- successor(p), b <- f[g[p]]);
IsFunction(singletonFunc(successor(p), f[g[p]]))   BECAUSE S13;
Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}   BECAUSE S23;
singletonFunc(successor(p), f[g[p]])[successor(p)] = f[g[p]]   BECAUSE S22;

\A a : \A b : \A x : \A y : a = b /\ x = y => (AreDisjoint(a,x) <=> AreDisjoint(b,y))   BECAUSE E_SCHEME;
Domain(g) = successor(p) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}
   => (AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]]))) <=> AreDisjoint(successor(p),{successor(p)}))
   BECAUSE \A(a <- Domain(g), b <- successor(p), x <- Domain(singletonFunc(successor(p), f[g[p]])), y <- {successor(p)});
hbn(f,init,b,p,g) => Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}   BECAUSE PT1;
hbn(f,init,b,p,g) => Domain(g) = successor(p) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}   BECAUSE CIA;
hbn(f,init,b,p,g) => (AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]]))) <=> AreDisjoint(successor(p),{successor(p)}))   BECAUSE TI;

(\A x : x \in b <=> x \in Nat /\ h(f,x,init)) => (p \in b <=> p \in Nat /\ h(f,p,init))   BECAUSE \A(x <- p);
hbn(f,init,b,p,g) => (p \in b <=> p \in Nat /\ h(f,p,init))   BECAUSE TI;
(p \in b <=> p \in Nat /\ h(f,p,init)) => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE EquivToImpl;
hbn(f,init,b,p,g) => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE TI;
hbn(f,init,b,p,g) => p \in Nat /\ h(f,p,init)   BECAUSE KillMiddleHypo;
p \in Nat /\ h(f,p,init) => p \in Nat   BECAUSE S12;
hbn(f,init,b,p,g) => p \in Nat   BECAUSE TI;
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
p \in Nat <=> IsFiniteOrdinal(p)   BECAUSE \A(x <- p);
p \in Nat => IsFiniteOrdinal(p)   BECAUSE EquivToImpl;
IsFiniteOrdinal(p) => IsOrdinal(p)   BECAUSE S13;
hbn(f,init,b,p,g) => IsOrdinal(p)   BECAUSE TI2;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(p) => IsOrdinal( successor(p) )   BECAUSE \A(o <- p);
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(successor(p)) => successor(p) \notin successor(p)   BECAUSE \A(o <- successor(p));
hbn(f,init,b,p,g) => successor(p) \notin successor(p)   BECAUSE TI2;

hbn(f,init,b,p,g) => p \in Nat   BECAUSE TI;
noCommonElements   BECAUSE THEOREM;
AreDisjoint(successor(p), {successor(p)}) <=> \A z : ~(z \in successor(p) /\ z \in {successor(p)})
   BECAUSE \A(x <- successor(p), y <- {successor(p)});
singletonExists   BECAUSE THEOREM;
z \in {successor(p)} <=> z = successor(p)   BECAUSE \A(a <- successor(p), x <- z);
z \in {successor(p)} => z = successor(p)   BECAUSE EquivToImpl;
\A z : \A x : z = x => (z \in successor(p) <=> x \in successor(p))   BECAUSE E_SCHEME;
z = successor(p) => (z \in successor(p) <=> successor(p) \in successor(p))   BECAUSE \A(z <- z, x <- successor(p));
z \in {successor(p)} => (z \in successor(p) <=> successor(p) \in successor(p))   BECAUSE TI;
implyEquivFalse(h,a,b,f) == (h => ~f) => ((a => (b <=> f)) => (h => ~(b /\ a)))   PROPO_TAUTO;
hbn(f,init,b,p,g) => ~(z \in successor(p) /\ z \in {successor(p)})   BECAUSE implyEquivFalse;
\A z : hbn(f,init,b,p,g) => ~(z \in successor(p) /\ z \in {successor(p)})   BECAUSE GENERALIZATION;
hbn(f,init,b,p,g) => \A z : ~(z \in successor(p) /\ z \in {successor(p)})   BECAUSE Q_SCHEME;
(\A z : ~(z \in successor(p) /\ z \in {successor(p)})) => AreDisjoint(successor(p), {successor(p)})   BECAUSE EquivToImplReverse;
hbn(f,init,b,p,g) => AreDisjoint(successor(p), {successor(p)})   BECAUSE TI;
implyEquivTrue(h,a,t) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hbn(f,init,b,p,g) => AreDisjoint(Domain(g), Domain(singletonFunc(successor(p), f[g[p]])))   BECAUSE implyEquivTrue;
hbn(f,init,b,p,g) => IsFunction(singletonFunc(successor(p), f[g[p]]))   BECAUSE PT1;
hbn(f,init,b,p,g) => IsFunction(g) /\ IsFunction(singletonFunc(successor(p), f[g[p]]))   BECAUSE CIA;
hbn(f,init,b,p,g) => IsFunction(g) /\ IsFunction(singletonFunc(successor(p), f[g[p]])) /\ AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]])))   BECAUSE CIA;

hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))
      /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))
      /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])
      /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])
   BECAUSE TI;

IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE S14;
hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE TI;

\A a : \A b : \A x : \A y : a = b /\ x = y => a \union x = b \union y   BECAUSE E_SCHEME;
Domain(g) = successor(p) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}
   => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}
   BECAUSE \A(a <- Domain(g), b <- successor(p), x <- Domain(singletonFunc(successor(p), f[g[p]])), y <- {successor(p)});
hbn(f,init,b,p,g) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}   BECAUSE TI;
IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])
   => Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE S24;
hbn(f,init,b,p,g) => Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE TI;
Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE TI;
Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)} => Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}   BECAUSE CIA;
hbn(f,init,b,p,g) => Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p))   BECAUSE TI;

IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])   BECAUSE S23;
hbn(f,init,b,p,g) => (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])   BECAUSE TI;
(\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) => ({} \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}])   BECAUSE \A(x <- {});
hbn(f,init,b,p,g) => ({} \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}])   BECAUSE TI;
\* Domain(g) = successor(p) so {} \in Domain(g)
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq successor(p)   BECAUSE \A(x <- successor(p));
hbn(f,init,b,p,g) => {} \subseteq successor(p)   BECAUSE PT1;
includedOrdinals   BECAUSE THEOREM;
IsOrdinal({}) /\ IsOrdinal(successor(p)) /\ {} \subseteq successor(p) => {} \in successor(p) \/ {} = successor(p)   BECAUSE \A(o <- {}, p <- successor(p));
ordinalZero   BECAUSE THEOREM;
IsOrdinal({})   BECAUSE S13;
hbn(f,init,b,p,g) => IsOrdinal({})   BECAUSE PT1;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(p) => IsOrdinal( successor(p) )   BECAUSE \A(o <- p);
hbn(f,init,b,p,g) => IsOrdinal(successor(p))   BECAUSE TI;
hbn(f,init,b,p,g) => IsOrdinal({}) /\ IsOrdinal(successor(p))   BECAUSE CIA;
hbn(f,init,b,p,g) => IsOrdinal({}) /\ IsOrdinal(successor(p)) /\ {} \subseteq successor(p)   BECAUSE CIA;
hbn(f,init,b,p,g) => {} \in successor(p) \/ {} = successor(p)   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
successor(p) = {} <=> \A x : x \notin successor(p)   BECAUSE \A(c <- successor(p));
successor(p) = {} => \A x : x \notin successor(p)   BECAUSE EquivToImpl;
{} = successor(p) => successor(p) = {}   BECAUSE E_SCHEME;
{} = successor(p) => \A x : x \notin successor(p)   BECAUSE TI;
~(\A x : x \notin successor(p)) => {} # successor(p)   BECAUSE Contraposition;
(\E x : x \in successor(p)) <=> ~(\A x : x \notin successor(p))   BECAUSE Q_SCHEME;
(\E x : x \in successor(p)) => ~(\A x : x \notin successor(p))   BECAUSE EquivToImpl;
p \in successor(p) => (\E x : x \in successor(p))   BECAUSE \E(x <- p);
p \in successor(p) => {} # successor(p)   BECAUSE TI2;
inSuccessor   BECAUSE THEOREM;
p \in successor(p)   BECAUSE \A(o <- p);
{} # successor(p)   BECAUSE MODUS_PONENS;
killCase(h,a,f) == ~f => ((h => a \/ f) => (h => a))   PROPO_TAUTO;
hbn(f,init,b,p,g) => {} \in successor(p)   BECAUSE killCase;
\A x : \A y : x = y => ({} \in x <=> {} \in y)   BECAUSE E_SCHEME;
Domain(g) = successor(p) => ({} \in Domain(g) <=> {} \in successor(p))   BECAUSE \A(x <- Domain(g), y <- successor(p));
hbn(f,init,b,p,g) => ({} \in Domain(g) <=> {} \in successor(p))   BECAUSE TI;
hbn(f,init,b,p,g) => {} \in Domain(g)   BECAUSE implyEquivTrue;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}]   BECAUSE KillMiddleHypo;
(g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}]  /\ init = g[{}] => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init   BECAUSE E_SCHEME;
g[{}] = init => init = g[{}]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => init = g[{}]   BECAUSE TI;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}]  /\ init = g[{}]   BECAUSE CIA;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init   BECAUSE TI;

\* Prove that (g \union singletonFunc(successor(p), f[g[p]])) satisfies the recurrent constrain
IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])   BECAUSE S22;
hbn(f,init,b,p,g) => (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])   BECAUSE TI;
(\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => (successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)])   BECAUSE \A(x <- successor(p));

\* Last value on successor(p)
hbn(f,init,b,p,g) => (successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)])   BECAUSE TI;
successor(p) \in { successor(p) } <=> successor(p) = successor(p)   BECAUSE \A(a <- successor(p), x <- successor(p));
successor(p) = successor(p)   BECAUSE \A(a <- successor(p));
successor(p) \in { successor(p) }   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (successor(p) \in x <=> successor(p) \in y)   BECAUSE E_SCHEME;
Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)} => (successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) <=> successor(p) \in {successor(p)})   BECAUSE \A(x <- Domain(singletonFunc(successor(p), f[g[p]])), y <- {successor(p)});
successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) <=> successor(p) \in {successor(p)}   BECAUSE MODUS_PONENS;
successor(p) \in Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE MODUS_PONENS;
hbn(f,init,b,p,g) => successor(p) \in Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE PT1;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE KillMiddleHypo;
singletonFunc(successor(p), f[g[p]])[successor(p)] = f[g[p]] => f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE E_SCHEME;
f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE MODUS_PONENS;
(g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)] /\ f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]
   => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE PT1;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)] /\ f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE CIA;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]]   BECAUSE TI;
(\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) => (p \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p])   BECAUSE \A(x <- p);
hbn(f,init,b,p,g) => (p \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p])   BECAUSE TI;
\A x : \A y : x = y => (p \in x <=> p \in y)   BECAUSE E_SCHEME;
Domain(g) = successor(p) => (p \in Domain(g) <=> p \in successor(p))   BECAUSE \A(x <- Domain(g), y <- successor(p));
Domain(g) = successor(p) => p \in Domain(g)   BECAUSE ImplyEquivTrue;
hbn(f,init,b,p,g) => p \in Domain(g)   BECAUSE TI;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p]   BECAUSE KillMiddleHypo;
\A x : \A y : x = y => f[x] = f[y]   BECAUSE E_SCHEME;
(g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p] => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]]   BECAUSE \A(x <- (g \union singletonFunc(successor(p), f[g[p]]))[p], y <- g[p]);
hbn(f,init,b,p,g) => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]]   BECAUSE TI;
hbn(f,init,b,p,g) => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]] /\ (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]]   BECAUSE CIA;
f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]] /\ (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]] => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)]   BECAUSE TI;
f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[p]]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[p]]   BECAUSE TI;

\* Previous values
(\A n : n \in p => g[successor(n)] = f[g[n]]) => (n \in p => g[successor(n)] = f[g[n]])   BECAUSE \A(n <- n);
hbn(f,init,b,p,g) => (n \in p => g[successor(n)] = f[g[n]])   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => g[successor(n)] = f[g[n]]   BECAUSE HypoImplToAnd;
n \in successor(p) <=> (n \in p \/ n \in {p})   BECAUSE \A(x <- p, y <- {p}, z <- n);
n \in successor(p) => (n \in p \/ n \in {p})   BECAUSE EquivToImpl;
n \in p \/ n \in {p} => n \in successor(p)   BECAUSE EquivToImplReverse;
n \in p => n \in p \/ n \in {p}   BECAUSE IntroOrLeft;
n \in p => n \in successor(p)   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => hbn(f,init,b,p,g)   BECAUSE S12;
hbn(f,init,b,p,g) /\ n \in p => n \in p   BECAUSE S22;
hbn(f,init,b,p,g) /\ n \in p => n \in successor(p)   BECAUSE TI;
(\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) => (n \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[n] = g[n])   BECAUSE \A(x <- n);
hbn(f,init,b,p,g) => (n \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[n] = g[n])   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => (n \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[n] = g[n])   BECAUSE TI;
\A x : \A y : x = y => (n \in x <=> n \in y)   BECAUSE E_SCHEME;
Domain(g) = successor(p) => (n \in Domain(g) <=> n \in successor(p))   BECAUSE \A(x <- Domain(g), y <- successor(p));
hbn(f,init,b,p,g) => (n \in Domain(g) <=> n \in successor(p))   BECAUSE TI;
(n \in Domain(g) <=> n \in successor(p)) => (n \in successor(p) => n \in Domain(g))   BECAUSE EquivToImplReverse;
hbn(f,init,b,p,g) => (n \in successor(p) => n \in Domain(g))   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => (n \in successor(p) => n \in Domain(g))   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => n \in Domain(g)   BECAUSE KillMiddleHypo;
hbn(f,init,b,p,g) /\ n \in p => (g \union singletonFunc(successor(p), f[g[p]]))[n] = g[n]   BECAUSE KillMiddleHypo;
(g \union singletonFunc(successor(p), f[g[p]]))[n] = g[n] => f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = f[g[n]]
   BECAUSE \A(x <- (g \union singletonFunc(successor(p), f[g[p]]))[n], y <- g[n]);
hbn(f,init,b,p,g) /\ n \in p => f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = f[g[n]]   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = f[g[n]] /\ g[successor(n)] = f[g[n]]   BECAUSE CIA;
f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = f[g[n]] /\ g[successor(n)] = f[g[n]] => f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = g[successor(n)]  BECAUSE E_SCHEME;
hbn(f,init,b,p,g) /\ n \in p => f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = g[successor(n)]   BECAUSE TI;
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(n) /\ IsOrdinal(p) /\ n \in p => successor(n) \in successor(p)   BECAUSE \A(o <- n, p <- p);
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(p) /\ n \in p => IsOrdinal(n)   BECAUSE \A(o <- p, x <- n);
hbn(f,init,b,p,g) /\ n \in p => IsOrdinal(p)   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => IsOrdinal(p) /\ n \in p   BECAUSE CIA;
hbn(f,init,b,p,g) /\ n \in p => IsOrdinal(n)   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => IsOrdinal(n) /\ IsOrdinal(p)   BECAUSE CIA;
hbn(f,init,b,p,g) /\ n \in p => IsOrdinal(n) /\ IsOrdinal(p) /\ n \in p  BECAUSE CIA;
hbn(f,init,b,p,g) /\ n \in p => successor(n) \in successor(p)   BECAUSE TI;
\A n : hbn(f,init,b,p,g)  => (n \in successor(p) => n \in Domain(g))   BECAUSE GENERALIZATION;
hbn(f,init,b,p,g) => (successor(n) \in successor(p) => successor(n) \in Domain(g))   BECAUSE \A(n <- successor(n));
hbn(f,init,b,p,g) /\ n \in p => (successor(n) \in successor(p) => successor(n) \in Domain(g))   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => successor(n) \in Domain(g)   BECAUSE KillMiddleHypo;
\A n : hbn(f,init,b,p,g) => (n \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[n] = g[n])   BECAUSE GENERALIZATION;
hbn(f,init,b,p,g) => (successor(n) \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = g[successor(n)])   BECAUSE \A(n <- successor(n));
hbn(f,init,b,p,g) /\ n \in p => (successor(n) \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = g[successor(n)])   BECAUSE TI;
hbn(f,init,b,p,g) /\ n \in p => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = g[successor(n)]   BECAUSE KillMiddleHypo;
hbn(f,init,b,p,g) /\ n \in p => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = g[successor(n)] /\ f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = g[successor(n)]   BECAUSE CIA;
(g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = g[successor(n)] /\ f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] = g[successor(n)] => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]]  BECAUSE E_SCHEME;
hbn(f,init,b,p,g) /\ n \in p => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]]  BECAUSE TI;
hbn(f,init,b,p,g) => (n \in p => (g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]])  BECAUSE HypoAndToImpl;

\* TODO merge cases
\A x : \A y : x = y => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(x)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[x]] <=> (g \union singletonFunc(successor(p), f[g[p]]))[successor(y)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[y]])   BECAUSE E_SCHEME;
n = p => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] <=> (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[p]])   BECAUSE \A(x <- n, y <- p);
n \in {p} <=> n = p   BECAUSE \A(a <- p, x <- n);
n \in {p} => n = p   BECAUSE EquivToImpl;
n \in {p} => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] <=> (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[p]])   BECAUSE TI;
implyEquivTrueB(h,t,a,b) == (h => t) => ((a => (b <=> t)) => (h => (a => b)))   PROPO_TAUTO;
hbn(f,init,b,p,g) => (n \in {p} => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] ))   BECAUSE implyEquivTrueB;
mergeCases(h,a,b,c) == (h => (a => c)) => ((h => (b => c)) => (h => (a \/ b => c)))   PROPO_TAUTO;
hbn(f,init,b,p,g) => (n \in p \/ n \in {p} => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] ))   BECAUSE mergeCases;
injectHypo(h,a,b,c) == (a => b) => ((h => (b => c)) => (h => (a => c)))   PROPO_TAUTO;
hbn(f,init,b,p,g) => (n \in successor(p) => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] ))   BECAUSE injectHypo;
\A n : hbn(f,init,b,p,g) => (n \in successor(p) => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] ))   BECAUSE GENERALIZATION;
hbn(f,init,b,p,g) => (\A n : n \in successor(p) => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] ))   BECAUSE Q_SCHEME;

hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p))   BECAUSE CIA;
hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p)) /\ (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init   BECAUSE CIA;
hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p)) /\ (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init /\ (\A n : n \in successor(p) => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] ))   BECAUSE CIA;
IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p)) /\ (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init /\ (\A n : n \in successor(p) => ((g \union singletonFunc(successor(p), f[g[p]]))[successor(n)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[n]] )) => h(f,successor(p),init)   BECAUSE \E(g <- g \union singletonFunc(successor(p), f[g[p]]));
hbn(f,init,b,p,g) => h(f,successor(p),init)   BECAUSE TI;

\* Discharge g
hb(f,init,b) /\ p \in b => ((IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => h(f,successor(p),init))   BECAUSE HypoAndToImpl;
\A g : hb(f,init,b) /\ p \in b => ((IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => h(f,successor(p),init))   BECAUSE GENERALIZATION;
hb(f,init,b) /\ p \in b => (\A g : (IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => h(f,successor(p),init))   BECAUSE Q_SCHEME;
(\A g : (IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init /\ \A n : n \in p => g[successor(n)] = f[g[n]]) => h(f,successor(p),init)) => (h(f,p,init) => \E g : h(f,successor(p),init))   BECAUSE Q_SCHEME;
hb(f,init,b) /\ p \in b => (h(f,p,init) => \E g : h(f,successor(p),init))   BECAUSE TI;
hb(f,init,b) => (p \in b <=> p \in Nat /\ h(f,p,init))   BECAUSE \A(x <- p);
(p \in b <=> p \in Nat /\ h(f,p,init)) => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE EquivToImpl;
hb(f,init,b) => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE TI;
hb(f,init,b) /\ p \in b => p \in Nat /\ h(f,p,init)   BECAUSE HypoImplToAnd;
p \in Nat /\ h(f,p,init) => p \in Nat   BECAUSE S12;
p \in Nat /\ h(f,p,init) => h(f,p,init)   BECAUSE S22;
hb(f,init,b) /\ p \in b => h(f,p,init)   BECAUSE TI;
hb(f,init,b) /\ p \in b => \E g : h(f,successor(p),init)   BECAUSE KillMiddleHypo;
(\E g : h(f,successor(p),init)) => h(f,successor(p),init)   BECAUSE Q_SCHEME;
hb(f,init,b) /\ p \in b => h(f,successor(p),init)   BECAUSE TI;
hb(f,init,b) => (successor(p) \in b <=> successor(p) \in Nat /\ h(f,successor(p),init))
   BECAUSE \A(x <- successor(p));
hb(f,init,b) /\ p \in b => hb(f,init,b)   BECAUSE S12;
hb(f,init,b) /\ p \in b => (successor(p) \in b <=> successor(p) \in Nat /\ h(f,successor(p),init))   BECAUSE TI;
(successor(p) \in b <=> successor(p) \in Nat /\ h(f,successor(p),init)) => (successor(p) \in Nat /\ h(f,successor(p),init) => successor(p) \in b)   BECAUSE EquivToImplReverse;
hb(f,init,b) /\ p \in b => (successor(p) \in Nat /\ h(f,successor(p),init) => successor(p) \in b)   BECAUSE TI;
hb(f,init,b) /\ p \in b => p \in Nat   BECAUSE TI;
successor(p) \in Nat <=> IsFiniteOrdinal(successor(p))   BECAUSE \A(x <- successor(p));
IsFiniteOrdinal(successor(p)) => successor(p) \in Nat   BECAUSE EquivToImplReverse;
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(p) => IsFiniteOrdinal( successor(p) )   BECAUSE \A(o <- p);
hb(f,init,b) /\ p \in b => IsFiniteOrdinal(successor(p))   BECAUSE TI2;
hb(f,init,b) /\ p \in b => successor(p) \in Nat   BECAUSE TI;
hb(f,init,b) /\ p \in b => successor(p) \in Nat /\ h(f,successor(p),init)   BECAUSE CIA;
hb(f,init,b) /\ p \in b => successor(p) \in b   BECAUSE KillMiddleHypo;
hb(f,init,b) /\ p \in b => p \in Nat /\ successor(p) \in b   BECAUSE CIA;
shuffleHypos(h,a,b,c) == (h /\ a => b /\ c) => (h => (b /\ a => c))   PROPO_TAUTO;
hb(f,init,b) => (p \in Nat /\ p \in b => successor(p) \in b)   BECAUSE shuffleHypos;
\A p : hb(f,init,b) => (p \in Nat /\ p \in b => successor(p) \in b)   BECAUSE GENERALIZATION;
hb(f,init,b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE \A(p <- n);
\A n : hb(f,init,b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE GENERALIZATION;
hb(f,init,b) => (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE Q_SCHEME;
hb(f,init,b) => {} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE CIA;
hb(f,init,b) => Nat \subseteq b   BECAUSE TI;

\* Discharge b
Nat \subseteq b => (p \in Nat => p \in b)   BECAUSE \A(z <- p);
hb(f,init,b) => (p \in Nat => p \in b)   BECAUSE TI;
hb(f,init,b) /\ p \in Nat => p \in b   BECAUSE HypoImplToAnd;
hb(f,init,b) /\ p \in Nat => hb(f,init,b)   BECAUSE S12;
hb(f,init,b) /\ p \in Nat => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE TI;
hb(f,init,b) /\ p \in Nat => p \in Nat /\ h(f,p,init)   BECAUSE KillMiddleHypo;
shuffleHyposB(a,b,c) == (a /\ b => b /\ c) => (b => (a => c))   PROPO_TAUTO;
p \in Nat => (hb(f,init,b) => h(f,p,init))   BECAUSE shuffleHyposB;
\A b : p \in Nat => (hb(f,init,b) => h(f,p,init))   BECAUSE GENERALIZATION;
p \in Nat => (\A b : hb(f,init,b) => h(f,p,init))   BECAUSE Q_SCHEME;
(\A b : hb(f,init,b) => h(f,p,init)) => ((\E b : hb(f,init,b)) => \E b : h(f,p,init))   BECAUSE Q_SCHEME;
p \in Nat => ((\E b : hb(f,init,b)) => \E b : h(f,p,init))   BECAUSE TI;
p \in Nat => (\E b : hb(f,init,b))   BECAUSE PT1;
p \in Nat => \E b : h(f,p,init)   BECAUSE KillMiddleHypo;
(\E b : h(f,p,init)) => h(f,p,init)   BECAUSE Q_SCHEME;
p \in Nat => h(f,p,init)   BECAUSE TI;

\* Then show this relation is functional in y (unicity) :
F(x,y,f,init) == x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init
        /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]])
        /\ y = <<x, g[x]>> );

\* The replacement axiom scheme invocation on F
(\A x : \A y : \A z : ((x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]]) /\ y = <<x, g[x]>> ))
        /\ (x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]]) /\ z = <<x, g[x]>> ))) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ (x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]])
        /\ y = <<x, g[x]>> )))
   BECAUSE AXIOM_SCHEME;
iterateFuncExists   BECAUSE GENERALIZATION;
QED

(*
   The usual addition operation on natural numbers.
   It could also be defined as the restriction of
   ordinal addition on Nat.
*)
NatAddition == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = (Nat \X Nat)
   /\ \A n : \A p : n \in Nat /\ p \in Nat => z[n,p] = IterateFunc(natSucc,n)[p]

natAdditionExists == \A n : \A p : n \in Nat /\ p \in Nat => NatAddition[n,p] = IterateFunc(natSucc,n)[p]
THEOREM natAdditionExists

(* TODO associativity, commutativity, multiplication, symbols for digits 0,1,2,3,4,5,6,7,8,9,10 *)