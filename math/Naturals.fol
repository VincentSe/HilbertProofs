EXTENDS Orders

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE_UNIQUE o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))

NatExists == (\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))
   /\ IsLimitOrdinal(Nat)
THEOREM NatExists
PROOF
\* By separation in a set given by the axiom of infinity
VARIABLES a,b,c,o,p,t,u,x,y,z,nat;
Infinity   BECAUSE AXIOM;
\A a : \E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE \A(a <- a);
\* Take a from the axiom of infinity and b from separation of finite ordinals
h(a,b) == {} \in a /\ (\A x : x \in a => successor(x) \in a)
   /\ \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x);
h(a,b) => \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE S22;

\* Prove UNION b is Nat, ie IsFiniteOrdinal(x) <=> x \in UNION b.
\* First prove that UNION b is an ordinal.
unionOrdinalsIsOrdinal   BECAUSE THEOREM;
(\A x : x \in b => IsOrdinal(x)) => IsOrdinal(UNION b)   BECAUSE \A(u <- b);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b <=> x \in a /\ IsFiniteOrdinal(x))
   BECAUSE \A(x <- x);
(x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE EquivToImpl;
h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE TI2;
IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE S13;
\A a : IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(a <- x);
extractProp(a,b,c,d) == (a => b) => ((c => d /\ a) => (c => b))   PROPO_TAUTO;
(x \in b => x \in a /\ IsFiniteOrdinal(x)) => (x \in b => IsOrdinal(x))   BECAUSE extractProp;
h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE TI;
\A x : h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in b => IsOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) => IsOrdinal(UNION b)   BECAUSE TI;

\* Proof that UNION b is a limit ordinal.
\* If o \in UNION b then successor(o) \in UNION b, so UNION b # successor o.
unionExists   BECAUSE AXIOM;
x \in UNION b <=> \E t : t \in b /\ x \in t   BECAUSE \A(b <- b, z <- x);
x \in UNION b => \E t : t \in b /\ x \in t   BECAUSE EquivToImpl;
\A x : h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => h(a,b)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => t \in b   BECAUSE S23;
h(a,b) /\ t \in b /\ x \in t => t \in a /\ IsFiniteOrdinal(t)   BECAUSE KillMiddleHypo;
h(a,b) => \A x : x \in a => successor(x) \in a   BECAUSE S23;
(\A x : x \in a => successor(x) \in a) => (t \in a => successor(t) \in a)   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => (t \in a => successor(t) \in a)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => t \in a   BECAUSE S12;
h(a,b) /\ t \in b /\ x \in t => t \in a   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a   BECAUSE KillMiddleHypo;
\* So successor(t) \in b.
\* Then successor(x) \in successor(t) \in b implies successor(x) \in UNION b.
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(t) => IsFiniteOrdinal( successor(t) )   BECAUSE \A(o <- t);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t)))   BECAUSE \A(x <- successor(t));
(successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t))) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE EquivToImplReverse;
h(a,b) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => IsFiniteOrdinal(t)   BECAUSE S22;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(successor(t))   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a /\ IsFiniteOrdinal(successor(t))   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in b   BECAUSE KillMiddleHypo;
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t => successor(x) \in successor(t)   BECAUSE \A(o <- x, p <- t);
IsFiniteOrdinal(t) => IsOrdinal(t)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t)   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => x \in t   BECAUSE S22;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(t) /\ x \in t => IsOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t)   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t)   BECAUSE TI;
inInUnion   BECAUSE THEOREM;
(successor(x) \in successor(t) /\ successor(t) \in b) => successor(x) \in UNION b   BECAUSE \A(a <- successor(x), b <- successor(t), c <- b);
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t) /\ successor(t) \in b   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in UNION b   BECAUSE TI;
pushHypos(h,a,b,c) == (h /\ a /\ b => c) => (h => (a /\ b => c))   PROPO_TAUTO;
h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => successor(x) \in UNION b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE Q_SCHEME;
h(a,b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE TI;
mergeHypos(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(a,b) /\ x \in UNION b => \E t : successor(x) \in UNION b   BECAUSE mergeHypos;
(\E t : successor(x) \in UNION b) => successor(x) \in UNION b   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => successor(x) \in UNION b   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(UNION b) /\ successor(x) \in UNION b => successor(x) # (UNION b) /\ (UNION b) \notin successor(x)   BECAUSE \A(o <- successor(x), p <- UNION b);
h(a,b) /\ x \in UNION b => h(a,b)   BECAUSE S12;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b)   BECAUSE TI2;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b) /\ successor(x) \in UNION b   BECAUSE CIA;
successor(x) # (UNION b) /\ (UNION b) \notin successor(x) => successor(x) # UNION b   BECAUSE S12;
h(a,b) /\ x \in UNION b => successor(x) # UNION b   BECAUSE TI2;
UNION b = successor(x) => successor(x) = UNION b   BECAUSE E_SCHEME;
successor(x) # UNION b => UNION b # successor(x)   BECAUSE Contraposition;
h(a,b) /\ x \in UNION b => UNION b # successor(x)   BECAUSE TI;
h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE HypoAndToImpl;
\A x : h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b => UNION b # successor(x))   BECAUSE Q_SCHEME;

\* {} \in successor({}) \in b, so {} \in UNION b
h(a,b) => {} \in a   BECAUSE S13;
(\A x : x \in a => successor(x) \in a) => ({} \in a => successor({}) \in a)   BECAUSE \A(x <- {});
h(a,b) => ({} \in a => successor({}) \in a)   BECAUSE TI;
h(a,b) => successor({}) \in a   BECAUSE KillMiddleHypo;
ordinalZero   BECAUSE THEOREM;
IsFiniteOrdinal({}) => IsFiniteOrdinal( successor({}) )   BECAUSE \A(o <- {});
IsFiniteOrdinal( successor({}) )   BECAUSE MODUS_PONENS;
successor({}) \in a => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE IntroAndLeft;
h(a,b) => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE TI;
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE \A(x <- successor({}));
h(a,b) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE TI;
killCase(h,a,b) == (h => a) => ((h => (b <=> a)) => (h => b))   PROPO_TAUTO;
h(a,b) => successor({}) \in b   BECAUSE killCase;
inSuccessor   BECAUSE THEOREM;
{} \in successor({})   BECAUSE \A(o <- {});
h(a,b) => {} \in successor({})   BECAUSE PT1;
h(a,b) => {} \in successor({}) /\ successor({}) \in b   BECAUSE CIA;
({} \in successor({}) /\ successor({}) \in b) => {} \in UNION b   BECAUSE \A(a <- {}, b <- successor({}), c <- b);
h(a,b) => {} \in UNION b   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
UNION b = {} <=> \A x : x \notin UNION b   BECAUSE \A(c <- UNION b);
(\E x : x \in UNION b) <=> ~\A x : x \notin UNION b   BECAUSE Q_SCHEME;
(\E x : x \in UNION b) => ~\A x : x \notin UNION b   BECAUSE EquivToImpl;
{} \in UNION b => \E x : x \in UNION b   BECAUSE \E(x <- {});
h(a,b) => ~\A x : x \notin UNION b   BECAUSE TI2;
UNION b = {} => \A x : x \notin UNION b   BECAUSE EquivToImpl;
~(\A x : x \notin UNION b) => UNION b # {}   BECAUSE Contraposition;
h(a,b) => UNION b # {}   BECAUSE TI;
h(a,b) => IsOrdinal(UNION b) /\ UNION b # {}   BECAUSE CIA;
h(a,b) => IsLimitOrdinal(UNION b)   BECAUSE CIA;

\* Proof that IsFiniteOrdinal(x) => x \in UNION b
ordinalComparison   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(UNION b) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE \A(o <- x, p <- UNION b);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => IsFiniteOrdinal(x)   BECAUSE S22;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => h(a,b)   BECAUSE S12;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(UNION b)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x) /\ IsOrdinal(UNION b)   BECAUSE CIA;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE TI;
\* because UNION b is infinite, only the first case is possible.
IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE S23;
\A o : IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE TI;
\A x : \A b : x = b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(b))   BECAUSE E_SCHEME;
x = UNION b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(UNION b))   BECAUSE \A(x <- x, b <- UNION b);
h(a,b) /\ IsFiniteOrdinal(x) => IsLimitOrdinal(UNION b)   BECAUSE TI;
killCaseB(h,a,b,c) == (h => ~a) => ((h => c) => (((b => (a <=> c)) => (h => ~b))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x # UNION b   BECAUSE killCaseB;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(x) /\ UNION b \in x => IsFiniteOrdinal(UNION b)   BECAUSE \A(o <- x, x <- UNION b);
IsFiniteOrdinal(UNION b) => ~IsLimitOrdinal(UNION b)   BECAUSE \A(o <- UNION b);
IsFiniteOrdinal(x) /\ UNION b \in x => ~IsLimitOrdinal(UNION b)   BECAUSE TI;
IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE HypoAndToImpl;
h(a,b) /\ IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE TI;
killCaseD(h,a,b) == (h => (b => ~a)) => ((h => a) => (h => ~b))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => UNION b \notin x   BECAUSE killCaseD;
killCaseE(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b   BECAUSE killCaseE;

\* Conversely, x \in UNION b is an ordinal as an element of an ordinal.
\* And x \in t \in b where t is a finite ordinal, so x is finite too.
IsFiniteOrdinal(t) /\ x \in t => IsFiniteOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => IsFiniteOrdinal(x)) => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE TI2;
h(a,b) /\ x \in UNION b => x \in UNION b   BECAUSE S22;
h(a,b) /\ x \in UNION b => (\E t : t \in b /\ x \in t)   BECAUSE TI;
h(a,b) /\ x \in UNION b => \E t : IsFiniteOrdinal(x)   BECAUSE KillMiddleHypo;
(\E t : IsFiniteOrdinal(x)) => IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE HIE;
\A x : h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;

hA(a) == {} \in a /\ (\A x : x \in a => successor(x) \in a);
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))
   => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE TI;
hA(a) => (\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x))   BECAUSE PT1;
hA(a) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE KillMiddleHypo;
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE \E(o <- UNION b);
(\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
hA(a) => (\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE TI;
(\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => (\E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
hA(a) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE TI;
(\E a : hA(a)) => \E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
(\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;

\* Proof that Nat is unique. By extensionality, being in another Nat
\* is equivalent, it is being a finite ordinal.
ho(o) == \A x : x \in o <=> IsFiniteOrdinal(x);
\A z : \A o : z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE E_SCHEME;
z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE \A(z <- z, o <- o);
killCaseF(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
ho(o) /\ z = o => (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE killCaseF;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in o) => z = o   BECAUSE \A(a <- z, b <- o);
ho(o) => (x \in o <=> IsFiniteOrdinal(x))   BECAUSE \A(x <- x);
tEquiv(a,b,c,h) == (h => (a <=> b)) => (h => ((c <=> b) => (c <=> a)))   PROPO_TAUTO;
ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE tEquiv;
\A x : ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE GENERALIZATION;
ho(o) => (\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE Q_SCHEME;
(\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o)) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE Q_SCHEME;
ho(o) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE TI;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o)   BECAUSE HypoImplToAnd;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => z = o   BECAUSE TI;
ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE HIE;
\A z : ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
ho(o) => (\A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\E o : ho(o)) => (\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE CHOOSE Nat;

\* Extract the fact that Nat is a limit ordinal
UNION b = Nat <=> (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- UNION b);
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => UNION b = Nat   BECAUSE EquivToImplReverse;
h(a,b) => UNION b = Nat   BECAUSE TI;
\A x : \A y : x = y => (IsLimitOrdinal(x) <=> IsLimitOrdinal(y))   BECAUSE E_SCHEME;
UNION b = Nat => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE \A(x <- UNION b, y <- Nat);
h(a,b) => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE TI;
(IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat)) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE EquivToImpl;
h(a,b) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE TI;
h(a,b) => IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat)) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE TI;
hA(a) => \E b : IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
(\E a : hA(a)) => \E a : \E b : IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
\E a : \E b : IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
(\E a : \E b : IsLimitOrdinal(Nat)) => (\E b : IsLimitOrdinal(Nat))  BECAUSE Q_SCHEME;
(\E b : IsLimitOrdinal(Nat))   BECAUSE MODUS_PONENS;
(\E b : IsLimitOrdinal(Nat)) => IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
NatExists   BECAUSE IntroAndRight;
QED

(*
   Names for the first natural numbers.
*)
0 == {}
1 == successor(0)
2 == successor(1)
3 == successor(2)
4 == successor(3)
5 == successor(4)
6 == successor(5)
7 == successor(6)
8 == successor(7)
9 == successor(8)
10 == successor(9)

zeroInNat == 0 \in Nat
THEOREM zeroInNat
PROOF
VARIABLES a,x,z;
ordinalZero   BECAUSE THEOREM;
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
0 \in Nat <=> IsFiniteOrdinal(0)   BECAUSE \A(x <- 0);
0 \in Nat   BECAUSE MODUS_PONENS;
QED

natSuccStable == \A n : n \in Nat => successor(n) \in Nat
THEOREM natSuccStable
PROOF
VARIABLES a,n,o,x,z;
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
n \in Nat <=> IsFiniteOrdinal(n)   BECAUSE \A(x <- n);
n \in Nat => IsFiniteOrdinal(n)   BECAUSE EquivToImpl;
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(n) => IsFiniteOrdinal( successor(n) )   BECAUSE \A(o <- n);
successor(n) \in Nat <=> IsFiniteOrdinal(successor(n))   BECAUSE \A(x <- successor(n));
IsFiniteOrdinal(successor(n)) => successor(n) \in Nat   BECAUSE EquivToImplReverse;
n \in Nat => successor(n) \in Nat   BECAUSE TI2;
natSuccStable   BECAUSE GENERALIZATION;
QED

(*
   As the smallest limit ordinal, Nat is generated by the successor operation.
   
   This gives the usual proofs by induction on Nat : separate in Nat the
   subset p where a given property is satisfied, then show the 2 hypotheses
   of this theorem about p and conclude its property is satisfied on all Nat.
*)
natInduction == \A p : 0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p)
   => Nat \subseteq p
THEOREM natInduction
PROOF
\* Assume by contradiction that there is a natural number k not in p.
\* Nat \ p is then a non-empty subset of the ordinal Nat, take its
\* minimum m. m is not zero, because zero is in p by hypothesis.
\* So m is the successor of a natural number p.
\* This contradicts the hypothesis on p.
VARIABLES a,b,c,k,m,n,o,p,u,v,x,z;
h(p,k) == 0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat /\ k \notin p;
h(p,k) => 0 \in p   BECAUSE S14;
h(p,k) => (\A n : n \in Nat /\ n \in p => successor(n) \in p)   BECAUSE S24;
h(p,k) => k \in Nat   BECAUSE S23;
h(p,k) => k \notin p   BECAUSE S22;
setDifferenceExists   BECAUSE THEOREM;
k \in (Nat \ p) <=> (k \in Nat /\ k \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- k);
k \in Nat /\ k \notin p => k \in (Nat \ p)   BECAUSE EquivToImplReverse;
h(p,k) => k \in Nat /\ k \notin p   BECAUSE CIA;
h(p,k) => k \in Nat \ p   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
Nat \ p  = 0 <=> \A x : x \notin Nat \ p   BECAUSE \A(c <- Nat \ p);
Nat \ p  = 0 => \A x : x \notin Nat \ p   BECAUSE EquivToImpl;
(\A x : x \notin Nat \ p) => k \notin Nat \ p   BECAUSE \A(x <- k);
Nat \ p = 0 => k \notin Nat \ p   BECAUSE TI;
~(k \notin Nat \ p) => Nat \ p # 0   BECAUSE Contraposition;
k \in Nat \ p => ~(k \notin Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => (Nat \ p) # 0   BECAUSE TI2;
\* Take the minimum of Nat \ p because Nat is an ordinal
NatExists   BECAUSE THEOREM;
IsLimitOrdinal(Nat)   BECAUSE S22;
IsOrdinal(Nat)   BECAUSE S13;
IsWellOrderedByIn(Nat)   BECAUSE S22;
\A p : p \subseteq Nat => p = 0 \/ \E m : IsMinimumForIn(m, p)   BECAUSE S22;
(Nat \ p) \subseteq Nat => (Nat \ p) = 0 \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE \A(p <- Nat \ p);
z \in (Nat \ p) <=> (z \in Nat /\ z \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- z);
z \in (Nat \ p) => (z \in Nat /\ z \notin p)   BECAUSE EquivToImpl;
(z \in Nat /\ z \notin p) => z \in Nat   BECAUSE S12;
z \in (Nat \ p) => z \in Nat   BECAUSE TI;
Nat \ p \subseteq Nat   BECAUSE GENERALIZATION;
(Nat \ p) = 0 \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE MODUS_PONENS;
killCase(h,a,b) == (a \/ b) => ((h => ~a) => (h => b))   PROPO_TAUTO;
h(p,k) => \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE killCase;
hm(p,k,m) == h(p,k) /\ IsMinimumForIn(m, Nat \ p);
hm(p,k,m) => h(p,k)   BECAUSE S12;
hm(p,k,m) => IsMinimumForIn(m, Nat \ p)   BECAUSE S22;
\* Show that m is not empty
IsMinimumForIn(m, Nat \ p) => m \in Nat \ p   BECAUSE S12;
m \in (Nat \ p) <=> (m \in Nat /\ m \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- m);
m \in (Nat \ p) => m \in Nat /\ m \notin p   BECAUSE EquivToImpl;
m \in Nat /\ m \notin p => m \notin p    BECAUSE S22;
IsMinimumForIn(m, Nat \ p) => m \notin p    BECAUSE TI2;
hm(p,k,m) => m \notin p    BECAUSE TI;
hm(p,k,m) => 0 \in p    BECAUSE TI;
\A m : \A k : m = k => (m \in p <=> k \in p)   BECAUSE E_SCHEME;
m = 0 => (m \in p <=> 0 \in p)   BECAUSE \A(m <- m, k <- 0);
implyEquivTrue(h,a,b,c) == (h => ~a) => ((h => b) => (((c => (a <=> b)) => (h => ~c))))   PROPO_TAUTO;
hm(p,k,m) => m # 0    BECAUSE implyEquivTrue;
\* Show that m is a successor ordinal
m \in Nat /\ m \notin p => m \in Nat    BECAUSE S12;
IsMinimumForIn(m, Nat \ p) => m \in Nat    BECAUSE TI2;
(\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
(\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
m \in Nat <=> IsFiniteOrdinal(m)   BECAUSE \A(x <- m);
m \in Nat => IsFiniteOrdinal(m)   BECAUSE EquivToImpl;
hm(p,k,m) => IsFiniteOrdinal(m)   BECAUSE TI2;
IsFiniteOrdinal(m) => IsOrdinal(m)   BECAUSE S13;
IsFiniteOrdinal(m) => ~IsLimitOrdinal(m)   BECAUSE S23;
hm(p,k,m) => IsOrdinal(m)   BECAUSE TI;
hm(p,k,m) => ~IsLimitOrdinal(m)   BECAUSE TI;
hm(p,k,m) => m # 0 /\ IsOrdinal(m)   BECAUSE CIA;
hm(p,k,m) => m # 0 /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m)  BECAUSE CIA;
killCases(a,b,c) == a /\ b /\ ~(b /\ a /\ c) => ~c   PROPO_TAUTO;
m # 0 /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m) => ~\A x : x \in m => m # successor(x)   BECAUSE killCases;
hm(p,k,m) => ~\A x : x \in m => m # successor(x)   BECAUSE TI;
(\E x : ~(x \in m => m # successor(x))) <=> ~\A x : ~~(x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : ~~(x \in m => m # successor(x))) => (\E x : ~(x \in m => m # successor(x)))   BECAUSE EquivToImplReverse;
~~(x \in m => m # successor(x)) => (x \in m => m # successor(x))   BECAUSE DropNotNot;
(\A x : ~~(x \in m => m # successor(x))) => (\A x : x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : x \in m => m # successor(x)) => ~(\A x : ~~(x \in m => m # successor(x)))   BECAUSE Contraposition;
hm(p,k,m) => \E x : ~(x \in m => m # successor(x))   BECAUSE TI2;
\* Derive a contradiction, because this x is in Nat \intersect p
hmx(p,k,m,x) == hm(p,k,m) /\ ~(x \in m => m # successor(x));
hmx(p,k,m,x) => hm(p,k,m)   BECAUSE S12;
hmx(p,k,m,x) => ~(x \in m => m # successor(x))   BECAUSE S22;
boolImpl(a,b) == ~(a => ~b) => a /\ b   PROPO_TAUTO;
~(x \in m => m # successor(x)) => x \in m /\ m = successor(x)   BECAUSE boolImpl;
hmx(p,k,m,x) => x \in m /\ m = successor(x)   BECAUSE TI;
IsMinimumForIn(m, Nat \ p) => \A b : b \in Nat \ p => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in Nat \ p => (b = m \/ m \in b)) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE \A(b <- x);
hm(p,k,m) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(m) /\ x \in m => IsFiniteOrdinal(x)   BECAUSE \A(o <- m, x <- x);
hmx(p,k,m,x) => IsFiniteOrdinal(m)   BECAUSE TI;
x \in m /\ m = successor(x) => x \in m   BECAUSE S12;
hmx(p,k,m,x) => x \in m   BECAUSE TI;
hmx(p,k,m,x) => IsFiniteOrdinal(m) /\ x \in m   BECAUSE CIA;
hmx(p,k,m,x) => IsFiniteOrdinal(x)   BECAUSE TI;
x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE \A(x <- x);
IsFiniteOrdinal(x) => x \in Nat   BECAUSE EquivToImplReverse;
hmx(p,k,m,x) => x \in Nat   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x)   BECAUSE CIA;
x \in (Nat \ p) <=> (x \in Nat /\ x \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- x);
killCasesB(a,b,c,d) == (b <=> a /\ d) => (a /\ (b => c) => (d => c))   PROPO_TAUTO;
x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x) => (x \notin p => x = m \/ m \in x)   BECAUSE killCasesB;
hmx(p,k,m,x) => (x \notin p => x = m \/ m \in x)   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ x \in m => x # m /\ m \notin x   BECAUSE \A(o <- x, p <- m);
hmx(p,k,m,x) => IsOrdinal(m)   BECAUSE TI;
hmx(p,k,m,x) => IsOrdinal(m) /\ x \in m   BECAUSE CIA;
x # m /\ m \notin x => ~(x = m \/ m \in x)   BECAUSE FactorNotOr;
hmx(p,k,m,x) => ~(x = m \/ m \in x)   BECAUSE TI2;
killCaseB(h,a,b) == (h => ~a) => ((h => (~b => a)) => (h => b))   PROPO_TAUTO;
hmx(p,k,m,x) => x \in p   BECAUSE killCaseB;
(\A n : n \in Nat /\ n \in p => successor(n) \in p) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE \A(n <- x);
hm(p,k,m) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ x \in p   BECAUSE CIA;
hmx(p,k,m,x) => successor(x) \in p   BECAUSE KillMiddleHypo;
x \in m /\ m = successor(x) => m = successor(x)   BECAUSE S22;
hmx(p,k,m,x) => m = successor(x)   BECAUSE TI;
\A m : \A x : m = x => (m \in p <=> x \in p)   BECAUSE E_SCHEME;
m = successor(x) => (m \in p <=> successor(x) \in p)   BECAUSE \A(m <- m, x <- successor(x));
hmx(p,k,m,x) => (m \in p <=> successor(x) \in p)   BECAUSE TI;
implyEquivTrueB(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hmx(p,k,m,x) => m \in p   BECAUSE implyEquivTrueB; \* contradiction

\* Discharge existential hypotheses
hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE HypoAndToImpl;
\A x : hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE GENERALIZATION;
hm(p,k,m) => (\A x : ~(x \in m => m # successor(x)) => m \in p)   BECAUSE Q_SCHEME;
(\A x : ~(x \in m => m # successor(x)) => m \in p) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE Q_SCHEME;
hm(p,k,m) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE TI;
hm(p,k,m) => \E x : m \in p   BECAUSE KillMiddleHypo;
(\E x : m \in p) => m \in p   BECAUSE Q_SCHEME;
hm(p,k,m) => m \in p   BECAUSE TI; \* contradiction
hm(p,k,m) => m \in p /\ m \notin p   BECAUSE CIA;
absurd(h,a,b) == (h /\ a => b /\ ~b) => (h => ~a)   PROPO_TAUTO;
h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE absurd;
\A m : h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE GENERALIZATION;
h(p,k) => \A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) <=> ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) => ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE EquivToImpl;
~~(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~(\E m : IsMinimumForIn(m, Nat \ p))   BECAUSE Contraposition;
(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE TI2;
h(p,k) => (\E m : IsMinimumForIn(m, Nat \ p)) /\ ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE CIA;

0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => ~(k \notin p)   BECAUSE absurd;
~(k \notin p) => k \in p   BECAUSE DropNotNot;
0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE TI;
\A k : 0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE GENERALIZATION;
0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ z \in Nat => z \in p   BECAUSE \A(k <- z);
0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE HypoAndToImpl;
\A z : 0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE GENERALIZATION;
0 \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => Nat \subseteq p   BECAUSE Q_SCHEME;
natInduction   BECAUSE GENERALIZATION;
QED

(*
   Infinite iteration of a function f starting at init. There is a unique sequence :
   <<init, f[init], f[f[init]], f[f[f[init]]], ...
*)
ContainsIterateFunc(a,f,init) == <<{}, init>> \in a
   /\ \A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a

IterateFuncShell(f,init) == CHOOSE_UNIQUE b : \A z : z = b <=>
   \A x : x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)

IterateFunc(f,init) == INTERSECT(IterateFuncShell(f,init))

iterateFuncExists == \A f : \A init : IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f)
   => ( IsApplication(IterateFunc(f,init), Nat, Domain(f))
        /\ IterateFunc(f,init)[ {} ] = init
        /\ \A n : n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   )
THEOREM iterateFuncExists
PROOF
VARIABLES a,b,c,d,f,g,i,j,n,o,p,u,v,x,y,z,init;
h(f,init) == IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f);
h(f,init) => IsFunction(f)   BECAUSE S13;
h(f,init) => Image(f) \subseteq Domain(f)   BECAUSE S23;
h(f,init) => init \in Domain(f)   BECAUSE S22;
\* Proof that h(f,init) => ContainsIterateFunc(Nat \X Domain(f), f, init)
cartesianProductCouples   BECAUSE THEOREM;
{} \in Nat /\ init \in Domain(f) <=> <<{},init>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- {}, b <- init);
{} \in Nat /\ init \in Domain(f) => <<{},init>> \in Nat \X Domain(f)   BECAUSE EquivToImpl;
zeroInNat   BECAUSE THEOREM;
h(f,init) => {} \in Nat   BECAUSE PT1;
h(f,init) => {} \in Nat /\ init \in Domain(f)   BECAUSE CIA;
h(f,init) => <<{},init>> \in Nat \X Domain(f)   BECAUSE TI;
x \in Nat /\ y \in Domain(f) <=> <<x,y>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- x, b <- y);
<<x,y>> \in Nat \X Domain(f) => x \in Nat /\ y \in Domain(f)   BECAUSE EquivToImplReverse;
x \in Nat /\ y \in Domain(f) => x \in Nat   BECAUSE S12;
x \in Nat /\ y \in Domain(f) => y \in Domain(f)   BECAUSE S22;
natSuccStable   BECAUSE THEOREM;
x \in Nat => successor(x) \in Nat   BECAUSE \A(n <- x);
funcImageExists   BECAUSE THEOREM;
IsFunction(f) /\ y \in Domain(f) => <<y, f[y]>> \in f   BECAUSE \A(f <- f, x <- y);
imageExists   BECAUSE THEOREM;
f[y] \in Image(f) <=> Reaches(f,f[y])   BECAUSE \A(g <- f, y <- f[y]);
Reaches(f,f[y]) => f[y] \in Image(f)   BECAUSE EquivToImplReverse;
<<y, f[y]>> \in f => Reaches(f,f[y])   BECAUSE \E(x <- y);
IsFunction(f) /\ y \in Domain(f) => f[y] \in Image(f)   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => <<x,y>> \in Nat \X Domain(f)   BECAUSE S22;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => y \in Domain(f)   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => IsFunction(f)   BECAUSE TI;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => IsFunction(f) /\ y \in Domain(f)   BECAUSE CIA;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => f[y] \in Image(f)   BECAUSE TI;
Image(f) \subseteq Domain(f) => (f[y] \in Image(f) => f[y] \in Domain(f))   BECAUSE \A(z <- f[y]);
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => (f[y] \in Image(f) => f[y] \in Domain(f))   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => f[y] \in Domain(f)   BECAUSE KillMiddleHypo;
successor(x) \in Nat /\ f[y] \in Domain(f) <=> <<successor(x),f[y]>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- successor(x), b <- f[y]);
successor(x) \in Nat /\ f[y] \in Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f)   BECAUSE EquivToImpl;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => x \in Nat   BECAUSE TI2;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => successor(x) \in Nat   BECAUSE TI;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => successor(x) \in Nat /\ f[y] \in Domain(f)   BECAUSE CIA;
h(f,init) /\ <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f)   BECAUSE TI;
h(f,init) => (<<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE HypoAndToImpl;
\A y : h(f,init) => (<<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => (\A y : <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE Q_SCHEME;
\A x : h(f,init) => (\A y : <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => (\A x : \A y : <<x,y>> \in Nat \X Domain(f) => <<successor(x),f[y]>> \in Nat \X Domain(f))   BECAUSE Q_SCHEME;
h(f,init) => ContainsIterateFunc(Nat \X Domain(f),f,init)   BECAUSE CIA;

\* Prove that the shell exists, by separation in Nat \X Image(f)
\A a : \E b : \A x : x \in b <=> x \in a /\ ContainsIterateFunc(x,f,init)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)
   BECAUSE \A(a <- SUBSET (Nat \X Domain(f)));
hs(b,f,init) == \A x : x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init);
\A z : \A b : z = b => (hs(z,f,init) <=> hs(b,f,init))   BECAUSE E_SCHEME;
z = b => (hs(z,f,init) <=> hs(b,f,init))   BECAUSE \A(z <- z, b <- b);
cycleHypos(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
hs(b,f,init) /\ z = b => hs(z,f,init)   BECAUSE cycleHypos;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in b) => z = b   BECAUSE \A(a <- z, b <- b);
hs(z,f,init) => (x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init))   BECAUSE \A(x <- x);
hs(b,f,init) => (x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init))   BECAUSE \A(x <- x);
hs(b,f,init) /\ hs(z,f,init) => (x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)) /\ (x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init))   BECAUSE MergeImplicationsAnd;
transitEquiv(a,b,c) == ((a <=> c) /\ (b <=> c) => (b <=> a))   PROPO_TAUTO;
(x \in b <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)) /\ (x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)) => (x \in z <=> x \in b)   BECAUSE transitEquiv;
hs(b,f,init) /\ hs(z,f,init) => (x \in z <=> x \in b)   BECAUSE TI;
\A x : hs(b,f,init) /\ hs(z,f,init) => (x \in z <=> x \in b)   BECAUSE GENERALIZATION;
hs(b,f,init) /\ hs(z,f,init) => (\A x : x \in z <=> x \in b)   BECAUSE Q_SCHEME;
hs(b,f,init) /\ hs(z,f,init) => z = b   BECAUSE TI;
hs(b,f,init) => (z = b <=> hs(z,f,init))   BECAUSE HIE;
\A z : hs(b,f,init) => (z = b <=> hs(z,f,init))   BECAUSE GENERALIZATION;
hs(b,f,init) => (\A z : z = b <=> hs(z,f,init))   BECAUSE Q_SCHEME;
(\E b : hs(b,f,init)) => (\E b : \A z : z = b <=> hs(z,f,init))   BECAUSE Q_SCHEME;
\E b : \A z : z = b <=> hs(z,f,init)   BECAUSE MODUS_PONENS;
\A z : z = IterateFuncShell(f,init) <=>
   \A x : x \in z <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)   BECAUSE CHOOSE IterateFuncShell(f,init);
IterateFuncShell(f,init) = IterateFuncShell(f,init) <=>
   \A x : x \in IterateFuncShell(f,init) <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)   BECAUSE \A(z <- IterateFuncShell(f,init));
equalSelf   BECAUSE THEOREM;
IterateFuncShell(f,init) = IterateFuncShell(f,init)   BECAUSE \A(a <- IterateFuncShell(f,init));
\A x : x \in IterateFuncShell(f,init) <=> x \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(x,f,init)
   BECAUSE MODUS_PONENS;

\* Intersect the shell because it is not empty
Nat \X Domain(f) \in IterateFuncShell(f,init) <=> Nat \X Domain(f) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(Nat \X Domain(f),f,init)   BECAUSE \A(x <- Nat \X Domain(f));
Nat \X Domain(f) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(Nat \X Domain(f),f,init) => Nat \X Domain(f) \in IterateFuncShell(f,init)   BECAUSE EquivToImplReverse;
powersetExists   BECAUSE AXIOM;
(Nat \X Domain(f)) \in SUBSET (Nat \X Domain(f)) <=> (Nat \X Domain(f)) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f), z <- Nat \X Domain(f));
inclusionInOneself   BECAUSE THEOREM;
(Nat \X Domain(f)) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f));
(Nat \X Domain(f)) \in SUBSET (Nat \X Domain(f))   BECAUSE MODUS_PONENS;
h(f,init) => (Nat \X Domain(f)) \in SUBSET (Nat \X Domain(f))   BECAUSE PT1;
h(f,init) => Nat \X Domain(f) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(Nat \X Domain(f),f,init)   BECAUSE CIA;
h(f,init) => Nat \X Domain(f) \in IterateFuncShell(f,init)   BECAUSE TI;
bigIntersectExists   BECAUSE THEOREM;
IterateFuncShell(f,init) # {} => \A x : x \in IterateFunc(f,init)
   <=> \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE \A(u <- IterateFuncShell(f,init));
emptySetExistsUniquely   BECAUSE THEOREM;
IterateFuncShell(f,init) = {} <=> \A x : x \notin IterateFuncShell(f,init)   BECAUSE \A(c <- IterateFuncShell(f,init));
IterateFuncShell(f,init) = {} => \A x : x \notin IterateFuncShell(f,init)   BECAUSE EquivToImpl;
~(\A x : x \notin IterateFuncShell(f,init)) => IterateFuncShell(f,init) # {}   BECAUSE Contraposition;
(\E x : x \in IterateFuncShell(f,init)) <=> ~(\A x : x \notin IterateFuncShell(f,init))   BECAUSE Q_SCHEME;
(\E x : x \in IterateFuncShell(f,init)) => ~(\A x : x \notin IterateFuncShell(f,init))   BECAUSE EquivToImpl;
Nat \X Domain(f) \in IterateFuncShell(f,init) => (\E x : x \in IterateFuncShell(f,init))   BECAUSE \E(x <- Nat \X Domain(f));
h(f,init) => ~(\A x : x \notin IterateFuncShell(f,init))   BECAUSE TI2;
h(f,init) => IterateFuncShell(f,init) # {}   BECAUSE TI;
h(f,init) => \A x : x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE TI;

\* Prove that h(f,init) => ContainsIterateFunc(IterateFunc(f,init), f, init)
(\A x : x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => (x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE \A(x <- x);
h(f,init) => (x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE TI;
(x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => ((\A y : y \in IterateFuncShell(f,init) => x \in y) => x \in IterateFunc(f,init))   BECAUSE EquivToImplReverse;
h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => x \in y) => x \in IterateFunc(f,init))   BECAUSE TI;

ContainsIterateFunc(a,f,init) => <<{}, init>> \in a   BECAUSE S12;
\A a : ContainsIterateFunc(a,f,init) => <<{}, init>> \in a   BECAUSE GENERALIZATION;
ContainsIterateFunc(y,f,init) => <<{}, init>> \in y   BECAUSE \A(a <- y);
y \in IterateFuncShell(f,init) <=> y \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(y,f,init)   BECAUSE \A(x <- y);
y \in IterateFuncShell(f,init) => y \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(y,f,init)   BECAUSE EquivToImpl;
y \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(y,f,init) => ContainsIterateFunc(y,f,init)   BECAUSE S22;
y \in IterateFuncShell(f,init) => <<{}, init>> \in y   BECAUSE TI2;
\A y : y \in IterateFuncShell(f,init) => <<{}, init>> \in y   BECAUSE GENERALIZATION;
\A x : h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => x \in y) => x \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => <<{}, init>> \in y) => <<{}, init>> \in IterateFunc(f,init))   BECAUSE \A(x <- <<{}, init>>);
h(f,init) => (\A y : y \in IterateFuncShell(f,init) => <<{}, init>> \in y)   BECAUSE PT1;
h(f,init) => <<{}, init>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;

hc(f,init,i,j,y) == h(f,init) /\ <<i,j>> \in IterateFunc(f,init) /\ y \in IterateFuncShell(f,init);
hc(f,init,i,j,y) => h(f,init)   BECAUSE S13;
hc(f,init,i,j,y) => <<i,j>> \in IterateFunc(f,init)   BECAUSE S23;
hc(f,init,i,j,y) => y \in IterateFuncShell(f,init)   BECAUSE S22;
hc(f,init,i,j,y) => ContainsIterateFunc(y,f,init)   BECAUSE TI2;
ContainsIterateFunc(a,f,init) => (\A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a)   BECAUSE S22;
(\A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a) => (<<i,j>> \in a => <<successor(i), f[j]>> \in a)   BECAUSE \A(x <- i, y <- j);
ContainsIterateFunc(a,f,init) => (<<i,j>> \in a => <<successor(i), f[j]>> \in a)   BECAUSE TI;
\A a : ContainsIterateFunc(a,f,init) => (<<i,j>> \in a => <<successor(i), f[j]>> \in a)   BECAUSE GENERALIZATION;
ContainsIterateFunc(y,f,init) => (<<i,j>> \in y => <<successor(i), f[j]>> \in y)   BECAUSE \A(a <- y);
hc(f,init,i,j,y) => (<<i,j>> \in y => <<successor(i), f[j]>> \in y)   BECAUSE TI;
(\A x : x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => (<<i,j>> \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE \A(x <- <<i,j>>);
hc(f,init,i,j,y) => (<<i,j>> \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE TI2;
(<<i,j>> \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y) => (<<i,j>> \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE EquivToImpl;
hc(f,init,i,j,y) => (<<i,j>> \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE TI;
hc(f,init,i,j,y) => \A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y   BECAUSE KillMiddleHypo;
(\A y : y \in IterateFuncShell(f,init) => <<i,j>>\in y) => (y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE \A(y <- y);
hc(f,init,i,j,y) => (y \in IterateFuncShell(f,init) => <<i,j>>\in y)   BECAUSE TI;
hc(f,init,i,j,y) => <<i,j>>\in y   BECAUSE KillMiddleHypo;
hc(f,init,i,j,y) => <<successor(i), f[j]>> \in y   BECAUSE KillMiddleHypo;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => (y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y)   BECAUSE HypoAndToImpl;
\A y : h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => (y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y)   BECAUSE GENERALIZATION;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => (\A y : y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y)   BECAUSE Q_SCHEME;
h(f,init) => ((\A y : y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y) => <<successor(i), f[j]>> \in IterateFunc(f,init))   BECAUSE \A(x <- <<successor(i), f[j]>>);
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => ((\A y : y \in IterateFuncShell(f,init) => <<successor(i), f[j]>> \in y) => <<successor(i), f[j]>> \in IterateFunc(f,init))   BECAUSE TI;
h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => <<successor(i), f[j]>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;
\A i : \A j : h(f,init) /\ <<i,j>> \in IterateFunc(f,init) => <<successor(i), f[j]>> \in IterateFunc(f,init)   BECAUSE GENERALIZATION;
h(f,init) /\ <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init)   BECAUSE \A(i <- x, j <- y);
h(f,init) => (<<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE HypoAndToImpl;
\A y : h(f,init) => (<<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => (\A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
\A x : h(f,init) => (\A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => (\A x : \A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
h(f,init) => ContainsIterateFunc(IterateFunc(f,init), f, init)   BECAUSE CIA;

\* Prove that IterateFunc(f,init) is a graph
(x \in IterateFunc(f,init) <=> \A y : y \in IterateFuncShell(f,init) => x \in y) => (x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE EquivToImpl;
h(f,init) => (x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y)   BECAUSE TI;
h(f,init) /\ x \in IterateFunc(f,init) => \A y : y \in IterateFuncShell(f,init) => x \in y   BECAUSE HypoImplToAnd;
(\A y : y \in IterateFuncShell(f,init) => x \in y) => (Nat \X Domain(f) \in IterateFuncShell(f,init) => x \in Nat \X Domain(f))   BECAUSE \A(y <- Nat \X Domain(f));
h(f,init) /\ x \in IterateFunc(f,init) => (Nat \X Domain(f) \in IterateFuncShell(f,init) => x \in Nat \X Domain(f))   BECAUSE TI;
h(f,init) /\ x \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ x \in IterateFunc(f,init) => Nat \X Domain(f) \in IterateFuncShell(f,init)   BECAUSE TI;
h(f,init) /\ x \in IterateFunc(f,init) => x \in Nat \X Domain(f)   BECAUSE KillMiddleHypo;
cartesianProductExists   BECAUSE THEOREM;
x \in (Nat \X Domain(f)) <=> (IsCouple(x) /\ fst(x) \in Nat /\ snd(x) \in Domain(f))   BECAUSE \A(i <- Nat, j <- Domain(f), x <- x);
x \in (Nat \X Domain(f)) => (IsCouple(x) /\ fst(x) \in Nat /\ snd(x) \in Domain(f))   BECAUSE EquivToImpl;
(IsCouple(x) /\ fst(x) \in Nat /\ snd(x) \in Domain(f)) => IsCouple(x)   BECAUSE S13;
h(f,init) /\ x \in IterateFunc(f,init) => IsCouple(x)   BECAUSE TI2;
h(f,init) => (x \in IterateFunc(f,init) => IsCouple(x))   BECAUSE HypoAndToImpl;
\A x : h(f,init) => (x \in IterateFunc(f,init) => IsCouple(x))   BECAUSE GENERALIZATION;
h(f,init) => IsGraph(IterateFunc(f,init))   BECAUSE Q_SCHEME;

\* Prove that Domain(IterateFunc(f,init)) = Nat, by induction
natInduction   BECAUSE THEOREM;
0 \in Domain(IterateFunc(f,init)) /\ (\A n : n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))
   => Nat \subseteq Domain(IterateFunc(f,init))   BECAUSE \A(p <- Domain(IterateFunc(f,init)));
<<{},init>> \in IterateFunc(f,init) => IsDefinedOn(IterateFunc(f,init), {})   BECAUSE \E(y <- init);
domainExists   BECAUSE THEOREM;
{} \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), {})   BECAUSE \A(g <- IterateFunc(f,init), x <- {});
IsDefinedOn(IterateFunc(f,init), {}) => {} \in Domain(IterateFunc(f,init))   BECAUSE EquivToImplReverse;
h(f,init) => {} \in Domain(IterateFunc(f,init))   BECAUSE TI2;
hd(f,init,n,y) == h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) /\ <<n,y>> \in IterateFunc(f,init);
hd(f,init,n,y) => h(f,init)   BECAUSE S14;
hd(f,init,n,y) => <<n,y>> \in IterateFunc(f,init)   BECAUSE S22;
\A x : h(f,init) /\ <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init)   BECAUSE GENERALIZATION;
h(f,init) /\ <<n,y>> \in IterateFunc(f,init) => <<successor(n), f[y]>> \in IterateFunc(f,init)   BECAUSE \A(x <- n);
hd(f,init,n,y) => h(f,init) /\ <<n,y>> \in IterateFunc(f,init)   BECAUSE CIA;
<<successor(n), f[y]>> \in IterateFunc(f,init) => IsDefinedOn(IterateFunc(f,init), successor(n))   BECAUSE \E(y <- f[y]);
hd(f,init,n,y) => IsDefinedOn(IterateFunc(f,init), successor(n))   BECAUSE TI2;
successor(n) \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), successor(n))   BECAUSE \A(g <- IterateFunc(f,init), x <- successor(n));
IsDefinedOn(IterateFunc(f,init), successor(n)) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE EquivToImplReverse;
hd(f,init,n,y) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE TI;
\* Discharge y
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (<<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE HypoAndToImpl;
\A y : h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (<<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE GENERALIZATION;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (\A y : <<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE Q_SCHEME;
(\A y : <<n,y>> \in IterateFunc(f,init) => successor(n) \in Domain(IterateFunc(f,init))) => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE Q_SCHEME;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE TI;
n \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), n)   BECAUSE \A(g <- IterateFunc(f,init), x <- n);
n \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE EquivToImpl;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => n \in Domain(IterateFunc(f,init))   BECAUSE S22;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE TI;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => (\E y : successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE KillMiddleHypo;
(\E y : successor(n) \in Domain(IterateFunc(f,init))) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE Q_SCHEME;
h(f,init) /\ n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init))   BECAUSE TI;
pushHypos(a,b,c,d) == (a /\ b /\ c => d) => (a => (b /\ c => d))   PROPO_TAUTO;
h(f,init) => (n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE pushHypos;
\A n : h(f,init) => (n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE GENERALIZATION;
h(f,init) => (\A n : n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE Q_SCHEME;
h(f,init) => {} \in Domain(IterateFunc(f,init)) /\ (\A n : n \in Nat /\ n \in Domain(IterateFunc(f,init)) => successor(n) \in Domain(IterateFunc(f,init)))   BECAUSE CIA;
h(f,init) => Nat \subseteq Domain(IterateFunc(f,init))   BECAUSE TI;

z \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), z)   BECAUSE \A(g <- IterateFunc(f,init), x <- z);
z \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init), z)   BECAUSE EquivToImpl;
\A x : h(f,init) /\ x \in IterateFunc(f,init) => x \in Nat \X Domain(f)   BECAUSE GENERALIZATION;
h(f,init) /\ <<z,y>> \in IterateFunc(f,init) => <<z,y>> \in Nat \X Domain(f)   BECAUSE \A(x <- <<z,y>>);
z \in Nat /\ y \in Domain(f) <=> <<z,y>> \in Nat \X Domain(f)
   BECAUSE \A(x <- Nat, y <- Domain(f), a <- z, b <- y);
<<z,y>> \in Nat \X Domain(f) => z \in Nat /\ y \in Domain(f)   BECAUSE EquivToImplReverse;
z \in Nat /\ y \in Domain(f) => z \in Nat   BECAUSE S12;
h(f,init) /\ <<z,y>> \in IterateFunc(f,init) => z \in Nat   BECAUSE TI2;
h(f,init) => (<<z,y>> \in IterateFunc(f,init) => z \in Nat)   BECAUSE HypoAndToImpl;
\A y : h(f,init) => (<<z,y>> \in IterateFunc(f,init) => z \in Nat)   BECAUSE GENERALIZATION;
h(f,init) => (\A y : <<z,y>> \in IterateFunc(f,init) => z \in Nat)   BECAUSE Q_SCHEME;
(\A y : <<z,y>> \in IterateFunc(f,init) => z \in Nat) => ((\E y : <<z,y>> \in IterateFunc(f,init)) => \E y : z \in Nat)   BECAUSE Q_SCHEME;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => h(f,init)   BECAUSE S12;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => ((\E y : <<z,y>> \in IterateFunc(f,init)) => \E y : z \in Nat)   BECAUSE TI2;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => z \in Domain(IterateFunc(f,init))   BECAUSE S22;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => IsDefinedOn(IterateFunc(f,init),z)   BECAUSE TI;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => (\E y : z \in Nat)   BECAUSE KillMiddleHypo;
(\E y : z \in Nat) => z \in Nat   BECAUSE Q_SCHEME;
h(f,init) /\ z \in Domain(IterateFunc(f,init)) => z \in Nat   BECAUSE TI;
h(f,init) => (z \in Domain(IterateFunc(f,init)) => z \in Nat)   BECAUSE HypoAndToImpl;
\A z : h(f,init) => (z \in Domain(IterateFunc(f,init)) => z \in Nat)   BECAUSE GENERALIZATION;
h(f,init) => Domain(IterateFunc(f,init)) \subseteq Nat   BECAUSE Q_SCHEME;
bothInclusions   BECAUSE THEOREM;
(Domain(IterateFunc(f,init)) \subseteq Nat /\ Nat \subseteq Domain(IterateFunc(f,init)))
   => Domain(IterateFunc(f,init)) = Nat   BECAUSE \A(a <- Domain(IterateFunc(f,init)), b <- Nat);
h(f,init) => (Domain(IterateFunc(f,init)) \subseteq Nat /\ Nat \subseteq Domain(IterateFunc(f,init)))   BECAUSE CIA;
h(f,init) => Domain(IterateFunc(f,init)) = Nat   BECAUSE TI;

\* Prove that IterateFunc(f,init) is a function, by induction.
\A a : \E b : \A x : x \in b <=> x \in a /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE \A(a <- Nat);
hf(f,init,b) == h(f,init) /\ \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x];
hf(f,init,b) => h(f,init)   BECAUSE S12;
hf(f,init,b) => \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE S22;

\* Assume by contradiction that <<{}, z>> \in IterateFunc(f,init) and init # z.
\* Then show that IterateFunc(f,init) \ {<<{}, z>>} still satisfies ContainsIterateFunc, absurd.
hu(f,init,z) == h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) /\ init # z;
hu(f,init,z) => h(f,init)   BECAUSE S13;
hu(f,init,z) => <<{}, z>> \in IterateFunc(f,init)   BECAUSE S23;
hu(f,init,z) => init # z   BECAUSE S22;
tupleDecomposition   BECAUSE THEOREM;
<<{}, init>> = <<{}, z>>  =>  {} = {} /\ init = z    BECAUSE \A(a <- {}, b <- init, c <- {}, d <- z);
{} = {} /\ init = z => init = z   BECAUSE S22;
<<{}, init>> = <<{}, z>>  => init = z    BECAUSE TI;
init # z => <<{}, init>> # <<{}, z>>   BECAUSE Contraposition;
hu(f,init,z) => <<{}, init>> # <<{}, z>>   BECAUSE TI;
setDifferenceExists   BECAUSE THEOREM;
<<{},init>> \in (IterateFunc(f,init) \ {<<{},z>>})
   <=> (<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<{},init>>);
<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<{},z>>} => <<{},init>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE EquivToImplReverse;
singletonExists   BECAUSE THEOREM;
<<{},init>> \in {<<{},z>>} <=> <<{},init>> = <<{},z>>   BECAUSE \A(a <- <<{},z>>, x <- <<{},init>>);
<<{},init>> \in {<<{},z>>} => <<{},init>> = <<{},z>>   BECAUSE EquivToImpl;
<<{},init>> # <<{},z>> => <<{},init>> \notin {<<{},z>>}   BECAUSE Contraposition;
hu(f,init,z) => <<{},init>> \notin {<<{},z>>}   BECAUSE TI;
hu(f,init,z) => <<{},init>> \in IterateFunc(f,init)   BECAUSE TI;
hu(f,init,z) => <<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<{},z>>}   BECAUSE CIA;
hu(f,init,z) => <<{},init>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE TI;

hus(f,init,z,x,y) == hu(f,init,z) /\ <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>});
hus(f,init,z,x,y) => hu(f,init,z)   BECAUSE S12;
hus(f,init,z,x,y) => <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE S22;
<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>})
   <=> (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<x,y>>);
<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<{},z>>})   BECAUSE EquivToImpl;
<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<{},z>>} => <<x,y>> \in IterateFunc(f,init)   BECAUSE S12;
hus(f,init,z,x,y) => <<x,y>> \in IterateFunc(f,init)   BECAUSE TI2;
hus(f,init,z,x,y) => h(f,init)   BECAUSE TI;
hus(f,init,z,x,y) => h(f,init) /\ <<x,y>> \in IterateFunc(f,init)   BECAUSE CIA;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init)   BECAUSE TI;
<<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>})
   <=> (<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<{},z>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<{},z>>}, x <- <<successor(x),f[y]>>);
<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<{},z>>} => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE EquivToImplReverse;
emptySetExistsUniquely   BECAUSE THEOREM;
successor(p) = {} <=> \A x : x \notin successor(p)   BECAUSE \A(c <- successor(p));
successor(p) = {} => \A x : x \notin successor(p)   BECAUSE EquivToImpl;
{} = successor(p) => successor(p) = {}   BECAUSE E_SCHEME;
{} = successor(p) => \A x : x \notin successor(p)   BECAUSE TI;
~(\A x : x \notin successor(p)) => {} # successor(p)   BECAUSE Contraposition;
(\E x : x \in successor(p)) <=> ~(\A x : x \notin successor(p))   BECAUSE Q_SCHEME;
(\E x : x \in successor(p)) => ~(\A x : x \notin successor(p))   BECAUSE EquivToImpl;
p \in successor(p) => (\E x : x \in successor(p))   BECAUSE \E(x <- p);
p \in successor(p) => {} # successor(p)   BECAUSE TI2;
inSuccessor   BECAUSE THEOREM;
p \in successor(p)   BECAUSE \A(o <- p);
{} # successor(p)   BECAUSE MODUS_PONENS;
\A p : {} # successor(p)   BECAUSE GENERALIZATION;
{} # successor(x)   BECAUSE \A(p <- x);
<<successor(x),f[y]>> = <<{}, z>> => successor(x) = {} /\ f[y] = z
   BECAUSE \A(a <- successor(x), b <- f[y], c <- {}, d <- z);
successor(x) = {} /\ f[y] = z => successor(x) = {}   BECAUSE S12;
successor(x) = {} => {} = successor(x)   BECAUSE E_SCHEME;
<<successor(x),f[y]>> = <<{}, z>> => {} = successor(x)   BECAUSE TI2;
{} # successor(x) => <<successor(x),f[y]>> # <<{}, z>>   BECAUSE Contraposition;
<<successor(x),f[y]>> # <<{}, z>>   BECAUSE MODUS_PONENS;
<<successor(x),f[y]>> \in {<<{},z>>} <=> <<successor(x),f[y]>> = <<{},z>>   BECAUSE \A(a <- <<{},z>>, x <- <<successor(x),f[y]>>);
<<successor(x),f[y]>> \in {<<{},z>>} => <<successor(x),f[y]>> = <<{},z>>   BECAUSE EquivToImpl;
<<successor(x),f[y]>> # <<{},z>> => <<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE Contraposition;
<<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE MODUS_PONENS;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE PT1;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<{},z>>}   BECAUSE CIA;
hus(f,init,z,x,y) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>})   BECAUSE TI;
hu(f,init,z) => (<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE HypoAndToImpl;
\A y : hu(f,init,z) => (<<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE GENERALIZATION;
hu(f,init,z) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE Q_SCHEME;
\A x : hu(f,init,z) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE GENERALIZATION;
hu(f,init,z) => (\A x : \A y : <<x,y>> \in (IterateFunc(f,init) \ {<<{},z>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<{},z>>}))   BECAUSE Q_SCHEME;
hu(f,init,z) => ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>}, f, init)   BECAUSE CIA;

\* Lemma : h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x}, f, init) => x \notin IterateFunc(f,init)
hlem(f,init,x) == h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init) /\ x \in IterateFunc(f,init);
hlem(f,init,x) => h(f,init)   BECAUSE S13;
hlem(f,init,x) => ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init)   BECAUSE S23;
hlem(f,init,x) => x \in IterateFunc(f,init)   BECAUSE S22;
hlem(f,init,x) => h(f,init) /\ x \in IterateFunc(f,init)   BECAUSE CIA;
(\A y : y \in IterateFuncShell(f,init) => x \in y) => (IterateFunc(f,init) \ {x} \in IterateFuncShell(f,init) => x \in IterateFunc(f,init) \ {x})   BECAUSE \A(y <- IterateFunc(f,init) \ {x});
hlem(f,init,x) => (IterateFunc(f,init) \ {x} \in IterateFuncShell(f,init) => x \in IterateFunc(f,init) \ {x})   BECAUSE TI2;
(IterateFunc(f,init) \ {x}) \in IterateFuncShell(f,init)
   <=> (IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init)   BECAUSE \A(x <- IterateFunc(f,init) \ {x} );
(IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init) => (IterateFunc(f,init) \ {x}) \in IterateFuncShell(f,init)   BECAUSE EquivToImplReverse;
\A x : h(f,init) /\ x \in IterateFunc(f,init) => x \in Nat \X Domain(f)   BECAUSE GENERALIZATION;
h(f,init) /\ z \in IterateFunc(f,init) => z \in Nat \X Domain(f)   BECAUSE \A(x <- z);
h(f,init) => (z \in IterateFunc(f,init) => z \in Nat \X Domain(f))   BECAUSE HypoAndToImpl;
\A z : h(f,init) => (z \in IterateFunc(f,init) => z \in Nat \X Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => IterateFunc(f,init) \subseteq (Nat \X Domain(f))   BECAUSE Q_SCHEME;
z \in (IterateFunc(f,init) \ {x}) <=> (z \in IterateFunc(f,init) /\ z \notin {x})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {x}, x <- z);
z \in (IterateFunc(f,init) \ {x}) => (z \in IterateFunc(f,init) /\ z \notin {x})   BECAUSE EquivToImpl;
(z \in IterateFunc(f,init) /\ z \notin {x}) => z \in IterateFunc(f,init)   BECAUSE S12;
z \in (IterateFunc(f,init) \ {x}) => z \in IterateFunc(f,init)   BECAUSE TI;
(IterateFunc(f,init) \ {x}) \subseteq IterateFunc(f,init)   BECAUSE GENERALIZATION;
transitInclusion   BECAUSE THEOREM;
(IterateFunc(f,init) \ {x} \subseteq IterateFunc(f,init) /\ (IterateFunc(f,init) \subseteq Nat \X Domain(f)))
   => (IterateFunc(f,init) \ {x} \subseteq Nat \X Domain(f))   BECAUSE \A(a <- IterateFunc(f,init) \ {x}, b <- IterateFunc(f,init), c <- Nat \X Domain(f));
h(f,init) => IterateFunc(f,init) \ {x} \subseteq IterateFunc(f,init)   BECAUSE PT1;
h(f,init) => (IterateFunc(f,init) \ {x} \subseteq IterateFunc(f,init) /\ (IterateFunc(f,init) \subseteq Nat \X Domain(f)))   BECAUSE CIA;
h(f,init) => IterateFunc(f,init) \ {x} \subseteq Nat \X Domain(f)   BECAUSE TI;
(IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f)) <=> (IterateFunc(f,init) \ {x} ) \subseteq (Nat \X Domain(f))   BECAUSE \A(x <- Nat \X Domain(f), z <- (IterateFunc(f,init) \ {x} ));
(IterateFunc(f,init) \ {x} ) \subseteq (Nat \X Domain(f)) => (IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f))   BECAUSE EquivToImplReverse;
h(f,init) => (IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f))   BECAUSE TI;
hlem(f,init,x) => (IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f))   BECAUSE TI;
hlem(f,init,x) => (IterateFunc(f,init) \ {x} ) \in SUBSET (Nat \X Domain(f)) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init)   BECAUSE CIA;
hlem(f,init,x) => (IterateFunc(f,init) \ {x}) \in IterateFuncShell(f,init)   BECAUSE TI;
hlem(f,init,x) => x \in (IterateFunc(f,init) \ {x})   BECAUSE KillMiddleHypo;
x \in (IterateFunc(f,init) \ {x}) <=> (x \in IterateFunc(f,init) /\ x \notin {x})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {x}, x <- x);
x \in (IterateFunc(f,init) \ {x}) => (x \in IterateFunc(f,init) /\ x \notin {x})   BECAUSE EquivToImpl;
x \in IterateFunc(f,init) /\ x \notin {x} => x \notin {x}   BECAUSE S22;
hlem(f,init,x) => x \notin {x}   BECAUSE TI2;
x \in {x} <=> x = x   BECAUSE \A(a <- x, x <- x);
x = x   BECAUSE \A(a <- x);
x \in {x}   BECAUSE MODUS_PONENS;
absurdC(h,a,t) == t => ((h /\ a => ~t) => (h => ~a))   PROPO_TAUTO;
h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init) => x \notin IterateFunc(f,init)   BECAUSE absurdC;
\A x : h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {x} ,f,init) => x \notin IterateFunc(f,init)   BECAUSE GENERALIZATION;

h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>} ,f,init) => <<{},z>> \notin IterateFunc(f,init)   BECAUSE \A(x <- <<{},z>>);
hu(f,init,z) => h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<{},z>>}, f, init)   BECAUSE CIA;
hu(f,init,z) => <<{},z>> \notin IterateFunc(f,init)   BECAUSE TI;
hu(f,init,z) => <<{},z>> \in IterateFunc(f,init) /\ <<{},z>> \notin IterateFunc(f,init)   BECAUSE CIA;
absurd(h,a,b) == (h /\ ~a => b /\ ~b) => (h => a)   PROPO_TAUTO;
h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) => init = z   BECAUSE absurd;
init = z => z = init   BECAUSE E_SCHEME;
h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) => z = init   BECAUSE TI;
\A z : \A j : z = j => (<<{}, z>> \in IterateFunc(f,init) <=> <<{}, j>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
z = init => (<<{}, z>> \in IterateFunc(f,init) <=> <<{}, init>> \in IterateFunc(f,init))   BECAUSE \A(z <- z, j <- init);
implyEquivTrue(h,t,a,b) == (h => t) => ((b => (a <=> t)) => (h /\ b => a))   PROPO_TAUTO; 
h(f,init) /\ z = init => <<{}, z>> \in IterateFunc(f,init)   BECAUSE implyEquivTrue;
h(f,init) => (z = init <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE HIE;
\A z : h(f,init) => (z = init <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
h(f,init) => (\A z : z = init <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
(\A z : z = init <=> <<{}, z>> \in IterateFunc(f,init)) => \E y : \A z : z = y <=> <<{}, z>> \in IterateFunc(f,init)   BECAUSE \E(y <- init);
(\E y : \A z : z = y <=> <<x, z>> \in f) => \A z : z = f[x] <=> <<x, z>> \in f   BECAUSE CHOOSE f[x];
\A f : \A x : (\E y : \A z : z = y <=> <<x, z>> \in f) => \A z : z = f[x] <=> <<x, z>> \in f   BECAUSE GENERALIZATION;
(\E y : \A z : z = y <=> <<{}, z>> \in IterateFunc(f,init)) => \A z : z = IterateFunc(f,init)[{}] <=> <<{}, z>> \in IterateFunc(f,init)   BECAUSE \A(f <- IterateFunc(f,init), x <- {});
h(f,init) => (\A z : z = IterateFunc(f,init)[{}] <=> <<{}, z>> \in IterateFunc(f,init))   BECAUSE TI2;
(\A z : z = IterateFunc(f,init)[{}] <=> <<{}, z>> \in IterateFunc(f,init)) => (init = IterateFunc(f,init)[{}] <=> <<{}, init>> \in IterateFunc(f,init))   BECAUSE \A(z <- init);
h(f,init) => (init = IterateFunc(f,init)[{}] <=> <<{}, init>> \in IterateFunc(f,init))   BECAUSE TI;
h(f,init) => init = IterateFunc(f,init)[{}]   BECAUSE HIET;
init = IterateFunc(f,init)[{}] => IterateFunc(f,init)[{}] = init   BECAUSE E_SCHEME;
h(f,init) => IterateFunc(f,init)[{}] = init   BECAUSE TI;

(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => ({} \in b <=> {} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE \A(x <- {});
hf(f,init,b) => ({} \in b <=> {} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE TI;
({} \in b <=> {} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]) => (({} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]) => {} \in b)   BECAUSE EquivToImplReverse;
hf(f,init,b) => (({} \in Nat /\ \A j : <<{},j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]) => {} \in b)   BECAUSE TI;
hf(f,init,b) => {} \in Nat   BECAUSE PT1;
\A z : h(f,init) /\ <<{}, z>> \in IterateFunc(f,init) => z = init   BECAUSE GENERALIZATION;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => j = init   BECAUSE \A(z <- j);
j = init /\ IterateFunc(f,init)[{}] = init => j = IterateFunc(f,init)[{}]   BECAUSE E_SCHEME;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => IterateFunc(f,init)[{}] = init   BECAUSE TI;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => j = init /\ IterateFunc(f,init)[{}] = init   BECAUSE CIA;
h(f,init) /\ <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}]   BECAUSE TI;
h(f,init) => (<<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE HypoAndToImpl;
\A j : h(f,init) => (<<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE GENERALIZATION;
h(f,init) => (\A j : <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE Q_SCHEME;
h(f,init) => {} \in Nat /\ (\A j : <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE CIA;
hf(f,init,b) => {} \in Nat /\ (\A j : <<{}, j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[{}])   BECAUSE TI;
hf(f,init,b) => {} \in b   BECAUSE KillMiddleHypo;

\* TODO induction step for b
hfn(f,init,b,n,j) == hf(f,init,b)
   /\ n \in b
   /\ <<successor(n),j>> \in IterateFunc(f,init)
   /\ j # f[IterateFunc(f,init)[n]]; \* Hypothesis leading to a contradiction
hfn(f,init,b,n,j) => hf(f,init,b)   BECAUSE S14;
hfn(f,init,b,n,j) => n \in b   BECAUSE S24;
hfn(f,init,b,n,j) => <<successor(n),j>> \in IterateFunc(f,init)   BECAUSE S23;
hfn(f,init,b,n,j) => j # f[IterateFunc(f,init)[n]]   BECAUSE S22;
\* Prove that hf(f,init,b) => ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>} ,f,init)
\* which is a contradiction.
{} # successor(n)   BECAUSE \A(p <- n);
<<{}, init>> = <<successor(n), j>>  =>  {} = successor(n) /\ init = j    BECAUSE \A(a <- {}, b <- init, c <- successor(n), d <- j);
{} = successor(n) /\ init = j => {} = successor(n)   BECAUSE S12;
<<{}, init>> = <<successor(n), j>> => {} = successor(n)   BECAUSE TI;
{} # successor(n) => <<{}, init>> # <<successor(n), j>>   BECAUSE Contraposition;
<<{}, init>> # <<successor(n), j>>   BECAUSE MODUS_PONENS;
<<{},init>> \in {<<successor(n),j>>} <=> <<{},init>> = <<successor(n),j>>   BECAUSE \A(a <- <<successor(n),j>>, x <- <<{},init>>);
<<{},init>> \in {<<successor(n),j>>} => <<{},init>> = <<successor(n),j>>   BECAUSE EquivToImpl;
<<{},init>> # <<successor(n),j>> => <<{},init>> \notin {<<successor(n),j>>}  BECAUSE Contraposition;
<<{},init>> \notin {<<successor(n),j>>}  BECAUSE MODUS_PONENS;
hfn(f,init,b,n,j) => <<{},init>> \notin {<<successor(n),j>>}  BECAUSE PT1;
<<{}, init>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<{},init>>);
(<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<successor(n),j>>}) => <<{}, init>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE EquivToImplReverse;
hfn(f,init,b,n,j) => <<{},init>> \in IterateFunc(f,init)   BECAUSE TI2;
hfn(f,init,b,n,j) => (<<{},init>> \in IterateFunc(f,init) /\ <<{},init>> \notin {<<successor(n),j>>})   BECAUSE CIA;
hfn(f,init,b,n,j) => <<{}, init>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE TI;

\* Now the inductive property of (IterateFunc(f,init) \ {<<successor(n),j>>})
\* \A x : \A y : <<x,y>> \in a => <<successor(x), f[y]>> \in a
hfnx(f,init,b,n,j,x,y) == hfn(f,init,b,n,j) /\ <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>});
hfnx(f,init,b,n,j,x,y) => hfn(f,init,b,n,j)   BECAUSE S12;
hfnx(f,init,b,n,j,x,y) => <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE S22;
<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<x,y>>);
<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => (<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<successor(n),j>>})   BECAUSE EquivToImpl;
(<<x,y>> \in IterateFunc(f,init) /\ <<x,y>> \notin {<<successor(n),j>>}) => <<x,y>> \in IterateFunc(f,init)   BECAUSE S12;
hfnx(f,init,b,n,j,x,y) => <<x,y>> \in IterateFunc(f,init)   BECAUSE TI2;
hfnx(f,init,b,n,j,x,y) => h(f,init)   BECAUSE TI2;
hfnx(f,init,b,n,j,x,y) => h(f,init) /\ <<x,y>> \in IterateFunc(f,init)   BECAUSE CIA;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init)   BECAUSE TI;
<<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})
   <=> (<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<successor(n),j>>})
   BECAUSE \A(u <- IterateFunc(f,init), v <- {<<successor(n),j>>}, x <- <<successor(x),f[y]>>);
(<<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<successor(n),j>>})
   => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE EquivToImplReverse;
<<successor(x),f[y]>> \in {<<successor(n),j>>} <=> <<successor(x),f[y]>> = <<successor(n),j>>
   BECAUSE \A(a <- <<successor(n),j>>, x <- <<successor(x),f[y]>>);
<<successor(x),f[y]>> \in {<<successor(n),j>>} => <<successor(x),f[y]>> = <<successor(n),j>>   BECAUSE EquivToImpl;
<<successor(x), f[y]>> = <<successor(n), j>> => successor(x) = successor(n) /\ f[y] = j    BECAUSE \A(a <- successor(x), b <- f[y], c <- successor(n), d <- j);
hfnxy(f,init,b,n,j,x,y) == hfnx(f,init,b,n,j,x,y) /\ <<successor(x),f[y]>> \in {<<successor(n),j>>};
hfnxy(f,init,b,n,j,x,y) => hfnx(f,init,b,n,j,x,y)   BECAUSE S12;
hfnxy(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in {<<successor(n),j>>}   BECAUSE S22;
hfnxy(f,init,b,n,j,x,y) => successor(x) = successor(n) /\ f[y] = j   BECAUSE TI2;
successor(x) = successor(n) /\ f[y] = j => successor(x) = successor(n)   BECAUSE S12;
successor(x) = successor(n) /\ f[y] = j => f[y] = j   BECAUSE S22;
hfnxy(f,init,b,n,j,x,y) => successor(x) = successor(n)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => f[y] = j   BECAUSE TI;
\* Then x = n /\ f[y] = j. So <<n,y>> \in IterateFunc(f,init). So y = IterateFunc(f,init)[n].
ordinalSuccessorRegular   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(n) /\ successor(x) = successor(n) => x = n   BECAUSE \A(o <- x, p <- n);
\A z : h(f,init) /\ <<z,y>> \in IterateFunc(f,init) => z \in Nat   BECAUSE GENERALIZATION;
h(f,init) /\ <<x,y>> \in IterateFunc(f,init) => x \in Nat   BECAUSE \A(z <- x);
hfnxy(f,init,b,n,j,x,y) => h(f,init)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => <<x,y>> \in IterateFunc(f,init)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => h(f,init) /\ <<x,y>> \in IterateFunc(f,init)   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => x \in Nat   BECAUSE TI;
NatExists   BECAUSE THEOREM;
(\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
(\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE \A(x <- x);
x \in Nat => IsFiniteOrdinal(x)   BECAUSE EquivToImpl;
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
x \in Nat => IsOrdinal(x)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(x)   BECAUSE TI;
(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x])
   => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE \A(x <- n);
hf(f,init,b) => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
(n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE EquivToImpl;
hf(f,init,b) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hfn(f,init,b,n,j) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hfn(f,init,b,n,j) => (n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE KillMiddleHypo;
(n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => n \in Nat   BECAUSE S12;
hfnx(f,init,b,n,j,x,y) => n \in Nat   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => n \in Nat   BECAUSE TI;
\A x : x \in Nat => IsOrdinal(x)   BECAUSE GENERALIZATION;
n \in Nat => IsOrdinal(n)   BECAUSE \A(x <- n);
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(n)   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(x) /\ IsOrdinal(n)   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => IsOrdinal(x) /\ IsOrdinal(n) /\ successor(x) = successor(n)   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => x = n   BECAUSE TI;
\A x : \A n : x = n => (<<x,y>> \in IterateFunc(f,init) <=> <<n,y>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
x = n => (<<x,y>> \in IterateFunc(f,init) <=> <<n,y>> \in IterateFunc(f,init))   BECAUSE \A(x <- x, n <- n);
hfnxy(f,init,b,n,j,x,y) => (<<x,y>> \in IterateFunc(f,init) <=> <<n,y>> \in IterateFunc(f,init))   BECAUSE TI;
implyTrueEquiv(h,t,a,b) == (h => t) => ((h => (t <=> a)) => (h => a))   PROPO_TAUTO; 
hfnxy(f,init,b,n,j,x,y) => <<n,y>> \in IterateFunc(f,init)   BECAUSE implyTrueEquiv;
(n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE S22;
(\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])   BECAUSE \A(j <- y);
hfn(f,init,b,n,j) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => y = IterateFunc(f,init)[n]   BECAUSE KillMiddleHypo;
\* Then j = f[IterateFunc(f,init)[n]
\A x : \A n : x = n => (f[x] = f[n])   BECAUSE E_SCHEME;
y = IterateFunc(f,init)[n] => f[y] = f[IterateFunc(f,init)[n]]   BECAUSE \A(x <- y, n <- IterateFunc(f,init)[n]);
hfnxy(f,init,b,n,j,x,y) => f[y] = f[IterateFunc(f,init)[n]]   BECAUSE TI;
f[y] = j /\ f[y] = f[IterateFunc(f,init)[n]] => j = f[IterateFunc(f,init)[n]]   BECAUSE E_SCHEME;
hfnxy(f,init,b,n,j,x,y) => f[y] = j /\ f[y] = f[IterateFunc(f,init)[n]]   BECAUSE CIA;
hfnxy(f,init,b,n,j,x,y) => j = f[IterateFunc(f,init)[n]]   BECAUSE TI;
hfnxy(f,init,b,n,j,x,y) => j # f[IterateFunc(f,init)[n]]   BECAUSE TI2;
hfnxy(f,init,b,n,j,x,y) => j = f[IterateFunc(f,init)[n]] /\ j # f[IterateFunc(f,init)[n]]   BECAUSE CIA;
absurdB(h,a,b) == (h /\ a => b /\ ~b) => (h => ~a)   PROPO_TAUTO;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \notin {<<successor(n),j>>}   BECAUSE absurdB;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in IterateFunc(f,init) /\ <<successor(x),f[y]>> \notin {<<successor(n),j>>}   BECAUSE CIA;
hfnx(f,init,b,n,j,x,y) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>})   BECAUSE TI;

\* Discharge x,y
hfn(f,init,b,n,j) => (<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE HypoAndToImpl;
\A y : hfn(f,init,b,n,j) => (<<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE GENERALIZATION;
hfn(f,init,b,n,j) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE Q_SCHEME;
\A x : hfn(f,init,b,n,j) => (\A y : <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE GENERALIZATION;
hfn(f,init,b,n,j) => (\A x : \A y : <<x,y>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}) => <<successor(x),f[y]>> \in (IterateFunc(f,init) \ {<<successor(n),j>>}))   BECAUSE Q_SCHEME;
hfn(f,init,b,n,j) => ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>}, f, init)   BECAUSE CIA;
h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>}, f, init)
   => <<successor(n),j>> \notin IterateFunc(f,init)   BECAUSE \A(x <- <<successor(n),j>>);
hfn(f,init,b,n,j) => h(f,init)   BECAUSE TI;
hfn(f,init,b,n,j) => h(f,init) /\ ContainsIterateFunc(IterateFunc(f,init) \ {<<successor(n),j>>}, f, init)   BECAUSE CIA;
hfn(f,init,b,n,j) => <<successor(n),j>> \notin IterateFunc(f,init) BECAUSE TI;
hfn(f,init,b,n,j) => <<successor(n),j>> \in IterateFunc(f,init) /\ <<successor(n),j>> \notin IterateFunc(f,init) BECAUSE CIA;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => j = f[IterateFunc(f,init)[n]]   BECAUSE absurd;

\* Prove successor(n) \in b,
\* show that <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init)
hf(f,init,b) /\ n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE HypoImplToAnd;
Nat \subseteq Domain(IterateFunc(f,init)) => (n \in Nat => n \in Domain(IterateFunc(f,init)))   BECAUSE \A(z <- n);
hf(f,init,b) => (n \in Nat => n \in Domain(IterateFunc(f,init)))   BECAUSE TI2;
hf(f,init,b) /\ n \in Nat => n \in Domain(IterateFunc(f,init))   BECAUSE HypoImplToAnd;
hf(f,init,b) /\ n \in Nat => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE TI;
hdefn(f,init,b,n,y) == hf(f,init,b) /\ n \in b /\ <<n,y>> \in IterateFunc(f,init);
hdefn(f,init,b,n,y) => hf(f,init,b)   BECAUSE S13;
hdefn(f,init,b,n,y) => n \in b   BECAUSE S23;
hdefn(f,init,b,n,y) => <<n,y>> \in IterateFunc(f,init)   BECAUSE S22;
n \in Nat /\ (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE ImplySelf;
(\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])  BECAUSE \A(j <- y);
hdefn(f,init,b,n,y) => hf(f,init,b) /\ n \in b   BECAUSE CIA;
hdefn(f,init,b,n,y) => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE TI;
hdefn(f,init,b,n,y) => (<<n,y>> \in IterateFunc(f,init) => y = IterateFunc(f,init)[n])  BECAUSE TI2;
hdefn(f,init,b,n,y) => y = IterateFunc(f,init)[n]  BECAUSE KillMiddleHypo;
\A y : \A z : y = z => (<<n,y>> \in IterateFunc(f,init) <=> <<n,z>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
y = IterateFunc(f,init)[n] => (<<n,y>> \in IterateFunc(f,init) <=> <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE \A(y <- y, z <- IterateFunc(f,init)[n]);
hdefn(f,init,b,n,y) => (<<n,y>> \in IterateFunc(f,init) <=> <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE TI;
hdefn(f,init,b,n,y) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE implyTrueEquiv;
\* Discharge y
hf(f,init,b) /\ n \in b => (<<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE HypoAndToImpl;
\A y : hf(f,init,b) /\ n \in b => (<<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b => (\A y : <<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
(\A y : <<n,y>> \in IterateFunc(f,init) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)) => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
hf(f,init,b) /\ n \in b => ((\E y : <<n,y>> \in IterateFunc(f,init)) => \E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init))   BECAUSE TI;
hf(f,init,b) /\ n \in b => n \in Nat   BECAUSE TI;
hf(f,init,b) /\ n \in b => hf(f,init,b)   BECAUSE S12;
hf(f,init,b) /\ n \in b => hf(f,init,b) /\ n \in Nat   BECAUSE CIA;
hf(f,init,b) /\ n \in b => IsDefinedOn(IterateFunc(f,init), n)   BECAUSE TI;
hf(f,init,b) /\ n \in b => \E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;
(\E y : <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)) => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE Q_SCHEME;
hf(f,init,b) /\ n \in b => <<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init)   BECAUSE TI;

hf(f,init,b) /\ n \in b => \A x : \A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init)   BECAUSE TI2;
(\A x : \A y : <<x,y>> \in IterateFunc(f,init) => <<successor(x), f[y]>> \in IterateFunc(f,init))
   => (<<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init) => <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE \A(x <- n, y <- IterateFunc(f,init)[n]);
hf(f,init,b) /\ n \in b => (<<n,IterateFunc(f,init)[n]>> \in IterateFunc(f,init) => <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE TI;
hf(f,init,b) /\ n \in b => <<successor(n), f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init)   BECAUSE KillMiddleHypo;
\A z : \A x : z = x => (<<successor(n),z>> \in IterateFunc(f,init) <=> <<successor(n),x>> \in IterateFunc(f,init))   BECAUSE E_SCHEME;
z = f[IterateFunc(f,init)[n]] => (<<successor(n),z>> \in IterateFunc(f,init) <=> <<successor(n),f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE \A(z <- z, x <- f[IterateFunc(f,init)[n]]);
hf(f,init,b) /\ n \in b /\ z = f[IterateFunc(f,init)[n]] => <<successor(n),z>> \in IterateFunc(f,init)   BECAUSE implyEquivTrue;
\A j : hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => j = f[IterateFunc(f,init)[n]]   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b /\ <<successor(n),z>> \in IterateFunc(f,init) => z = f[IterateFunc(f,init)[n]]   BECAUSE \A(j <- z);
hf(f,init,b) /\ n \in b => (z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE HIE;
\A z : hf(f,init,b) /\ n \in b => (z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b => (\A z : z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE Q_SCHEME;
(\A z : z = f[IterateFunc(f,init)[n]] <=> <<successor(n),z>> \in IterateFunc(f,init)) => (\E y : \A z : z = y <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE \E(y <- f[IterateFunc(f,init)[n]]);
hf(f,init,b) /\ n \in b => (\E y : \A z : z = y <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE TI;
(\E y : \A z : z = y <=> <<successor(n),z>> \in IterateFunc(f,init)) => (\A z : z = IterateFunc(f,init)[successor(n)] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE \A(f <- IterateFunc(f,init), x <- successor(n));
hf(f,init,b) /\ n \in b => (\A z : z = IterateFunc(f,init)[successor(n)] <=> <<successor(n),z>> \in IterateFunc(f,init))   BECAUSE TI;
(\A z : z = IterateFunc(f,init)[successor(n)] <=> <<successor(n),z>> \in IterateFunc(f,init))
   => (f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)] <=> <<successor(n),f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE \A(z <- f[IterateFunc(f,init)[n]]);
hf(f,init,b) /\ n \in b => (f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)] <=> <<successor(n),f[IterateFunc(f,init)[n]]>> \in IterateFunc(f,init))   BECAUSE TI;
hf(f,init,b) /\ n \in b => f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)]   BECAUSE HIET;
f[IterateFunc(f,init)[n]] = IterateFunc(f,init)[successor(n)] => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE E_SCHEME;
hf(f,init,b) /\ n \in b => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE TI;

hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => hf(f,init,b)   BECAUSE S13;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => n \in b   BECAUSE S23;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init) => hf(f,init,b) /\ n \in b  BECAUSE CIA;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE TI;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => j = f[IterateFunc(f,init)[n]] /\ IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE CIA;
j = f[IterateFunc(f,init)[n]] /\ IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]
   => j = IterateFunc(f,init)[successor(n)]   BECAUSE E_SCHEME;
hf(f,init,b) /\ n \in b /\ <<successor(n),j>> \in IterateFunc(f,init)
   => j = IterateFunc(f,init)[successor(n)]   BECAUSE TI;
hf(f,init,b) /\ n \in b => (<<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE HypoAndToImpl;
\A j : hf(f,init,b) /\ n \in b => (<<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE GENERALIZATION;
hf(f,init,b) /\ n \in b => (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE Q_SCHEME;
n \in Nat => successor(n) \in Nat   BECAUSE \A(n <- n);
hf(f,init,b) /\ n \in b => successor(n) \in Nat   BECAUSE TI;
hf(f,init,b) /\ n \in b => successor(n) \in Nat /\ (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE CIA;

(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x])
   => (successor(n) \in b <=> successor(n) \in Nat /\ \A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE \A(x <- successor(n));
hf(f,init,b) /\ n \in b => (successor(n) \in b <=> successor(n) \in Nat /\ \A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)])   BECAUSE TI2;
(successor(n) \in b <=> successor(n) \in Nat /\ \A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)]) => (successor(n) \in Nat /\ (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)]) => successor(n) \in b)   BECAUSE EquivToImplReverse;
hf(f,init,b) /\ n \in b => (successor(n) \in Nat /\ (\A j : <<successor(n),j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[successor(n)]) => successor(n) \in b)   BECAUSE TI;
hf(f,init,b) /\ n \in b => successor(n) \in b   BECAUSE KillMiddleHypo;
hf(f,init,b) /\ n \in b => n \in Nat /\ successor(n) \in b   BECAUSE CIA;
shuffleHypos(a,b,c,d) == (a /\ b => c /\ d) => (a => (c /\ b => d))   PROPO_TAUTO;
hf(f,init,b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE shuffleHypos;
\A n : hf(f,init,b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE GENERALIZATION;
hf(f,init,b) => (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE Q_SCHEME;
hf(f,init,b) => {} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE CIA;
0 \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
hf(f,init,b) => ({} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b)   BECAUSE PT1;
hf(f,init,b) => Nat \subseteq b   BECAUSE KillMiddleHypo; \* End of induction

Nat \subseteq b => (n \in Nat => n \in b)   BECAUSE \A(z <- n);
hf(f,init,b) => (n \in Nat => n \in b)   BECAUSE TI;
hf(f,init,b) /\ n \in Nat => n \in b   BECAUSE HypoImplToAnd;
hf(f,init,b) /\ n \in Nat => hf(f,init,b)   BECAUSE S12;
hf(f,init,b) /\ n \in Nat => hf(f,init,b) /\ n \in b   BECAUSE CIA;
(\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x])
   => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE \A(x <- n);
hf(f,init,b) => (n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
(n \in b <=> n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])
   => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE EquivToImpl;
hf(f,init,b) => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hf(f,init,b) /\ n \in Nat => (n \in b => n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE TI;
hf(f,init,b) /\ n \in Nat => (n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE KillMiddleHypo;
(n \in Nat /\ \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]) => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])   BECAUSE S22;
hf(f,init,b) /\ n \in Nat => \A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]   BECAUSE TI;

\* Discharge b
hf(f,init,b) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))   BECAUSE HypoAndToImpl;

h(f,init) => ((\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE HypoAndToImpl;
\A b : h(f,init) => ((\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE GENERALIZATION;
h(f,init) => (\A b : (\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))) => ((\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => \E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE Q_SCHEME;
h(f,init) => ((\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => \E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE TI;
h(f,init) => \E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]   BECAUSE PT1;
h(f,init) => (\E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE KillMiddleHypo;
(\E b : (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))) => ((n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n])))   BECAUSE Q_SCHEME;
h(f,init) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))   BECAUSE TI;
\A n : h(f,init) => (n \in Nat => (\A j : <<n,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[n]))   BECAUSE GENERALIZATION;
h(f,init) => (a \in Nat => (\A j : <<a,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[a]))   BECAUSE \A(n <- a);
h(f,init) /\ a \in Nat => (\A j : <<a,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[a])   BECAUSE HypoImplToAnd;
(\A j : <<a,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[a]) => (<<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE \A(j <- b);
h(f,init) /\ a \in Nat => (<<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a])   BECAUSE TI;
shuffleHyposB(a,b,c,d) == (a /\ b => (c => d)) => (a /\ c => (b => d))   PROPO_TAUTO;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => (a \in Nat => b = IterateFunc(f,init)[a])   BECAUSE shuffleHyposB;
<<a,b>> \in IterateFunc(f,init) => IsDefinedOn(IterateFunc(f,init),a)   BECAUSE \E(y <- b);
a \in Domain(IterateFunc(f,init)) <=> IsDefinedOn(IterateFunc(f,init), a)   BECAUSE \A(g <- IterateFunc(f,init), x <- a);
IsDefinedOn(IterateFunc(f,init), a) => a \in Domain(IterateFunc(f,init))   BECAUSE EquivToImplReverse;
<<a,b>> \in IterateFunc(f,init) => a \in Domain(IterateFunc(f,init))   BECAUSE TI;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => <<a,b>> \in IterateFunc(f,init)   BECAUSE S22;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => a \in Domain(IterateFunc(f,init))   BECAUSE TI;
\A x : \A y : x = y => (a \in x <=> a \in y)   BECAUSE E_SCHEME;
Domain(IterateFunc(f,init)) = Nat => (a \in Domain(IterateFunc(f,init)) <=> a \in Nat)   BECAUSE \A(x <- Domain(IterateFunc(f,init)), y <- Nat);
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => h(f,init)   BECAUSE S12;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => (a \in Domain(IterateFunc(f,init)) <=> a \in Nat)   BECAUSE TI2;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => a \in Nat   BECAUSE implyTrueEquiv;
h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a]   BECAUSE KillMiddleHypo;
\A b : h(f,init) /\ <<a,b>> \in IterateFunc(f,init) => b = IterateFunc(f,init)[a]   BECAUSE GENERALIZATION;
h(f,init) /\ <<a,c>> \in IterateFunc(f,init) => c = IterateFunc(f,init)[a]   BECAUSE \A(b <- c);
combineImpl(h,a,b,c,d) == (h /\ a => b) => ((h /\ c => d) => (h /\ (a /\ c) => b /\ d))   PROPO_TAUTO;
h(f,init) /\ (<<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init))
   => (b = IterateFunc(f,init)[a] /\ c = IterateFunc(f,init)[a])   BECAUSE combineImpl;
(b = IterateFunc(f,init)[a] /\ c = IterateFunc(f,init)[a]) => b = c   BECAUSE E_SCHEME;
h(f,init) /\ (<<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init)) => b = c   BECAUSE TI;
h(f,init) => (<<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE HypoAndToImpl;
\A c : h(f,init) => (<<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE GENERALIZATION;
h(f,init) => (\A c : <<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE Q_SCHEME;
\A b : h(f,init) => (\A c : <<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE GENERALIZATION;
h(f,init) => (\A b : \A c : <<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE Q_SCHEME;
\A a : h(f,init) => (\A b : \A c : <<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE GENERALIZATION;
h(f,init) => (\A a : \A b : \A c : <<a,b>> \in IterateFunc(f,init) /\ <<a,c>> \in IterateFunc(f,init) => b = c)   BECAUSE Q_SCHEME;
h(f,init) => IsFunction(IterateFunc(f,init))   BECAUSE CIA;

\* Extract inductive equality on images
hf(f,init,b) /\ n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]   BECAUSE TI;
hf(f,init,b) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE HypoAndToImpl;
\* Discharge b
h(f,init) => ((\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]))   BECAUSE HypoAndToImpl;
\A b : h(f,init) => ((\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]))   BECAUSE GENERALIZATION;
h(f,init) => (\A b : (\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])) => ((\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => \E b : (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]))   BECAUSE Q_SCHEME;
h(f,init) => ((\E b : \A x : x \in b <=> x \in Nat /\ \A j : <<x,j>> \in IterateFunc(f,init) => j = IterateFunc(f,init)[x]) => \E b : (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]))   BECAUSE TI;
h(f,init) => \E b : (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE KillMiddleHypo;
(\E b : n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]]) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE Q_SCHEME;
h(f,init) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE TI;

\A n : h(f,init) => (n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE GENERALIZATION;
h(f,init) => (\A n : n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE Q_SCHEME;
h(f,init) => IsFunction(IterateFunc(f,init)) /\ Domain(IterateFunc(f,init)) = Nat   BECAUSE CIA;

\* Prove Image(IterateFunc(f,init)) \subseteq Domain(f)
h(f,init) /\ <<x,z>> \in IterateFunc(f,init) => <<x,z>> \in Nat \X Domain(f)   BECAUSE \A(x <- <<x,z>>);
cartesianProductCouples   BECAUSE THEOREM;
x \in Nat /\ z \in Domain(f) <=> <<x,z>> \in Nat \X Domain(f)   BECAUSE \A(x <- Nat, y <- Domain(f), a <- x, b <- z);
<<x,z>> \in Nat \X Domain(f) => x \in Nat /\ z \in Domain(f)   BECAUSE EquivToImplReverse;
x \in Nat /\ z \in Domain(f) => z \in Domain(f)   BECAUSE S22;
h(f,init) /\ <<x,z>> \in IterateFunc(f,init) => z \in Domain(f)   BECAUSE TI2;
h(f,init) => (<<x,z>> \in IterateFunc(f,init) => z \in Domain(f))   BECAUSE HypoAndToImpl;
\A x : h(f,init) => (<<x,z>> \in IterateFunc(f,init) => z \in Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => (\A x : <<x,z>> \in IterateFunc(f,init) => z \in Domain(f))   BECAUSE Q_SCHEME;
z \in Image(IterateFunc(f,init)) <=> Reaches(IterateFunc(f,init),z)   BECAUSE \A(g <- IterateFunc(f,init), y <- z);
z \in Image(IterateFunc(f,init)) => (\E x : <<x,z>> \in IterateFunc(f,init))   BECAUSE EquivToImpl;
(\A x : <<x,z>> \in IterateFunc(f,init) => z \in Domain(f)) => ((\E x : <<x,z>> \in IterateFunc(f,init)) => \E x : z \in Domain(f))   BECAUSE Q_SCHEME;
h(f,init) => ((\E x : <<x,z>> \in IterateFunc(f,init)) => \E x : z \in Domain(f))   BECAUSE TI;
injectHypo(h,p,z,a) == (p => z) => ((h => (z => a)) => (h /\ p => a))   PROPO_TAUTO;
h(f,init) /\ z \in Image(IterateFunc(f,init)) => \E x : z \in Domain(f)   BECAUSE injectHypo;
(\E x : z \in Domain(f)) => z \in Domain(f)   BECAUSE Q_SCHEME;
h(f,init) /\ z \in Image(IterateFunc(f,init)) => z \in Domain(f)   BECAUSE TI;
h(f,init) => (z \in Image(IterateFunc(f,init)) => z \in Domain(f))   BECAUSE HypoAndToImpl;
\A z : h(f,init) => (z \in Image(IterateFunc(f,init)) => z \in Domain(f))   BECAUSE GENERALIZATION;
h(f,init) => Image(IterateFunc(f,init)) \subseteq Domain(f)   BECAUSE Q_SCHEME;
h(f,init) => IsApplication(IterateFunc(f,init), Nat, Domain(f))   BECAUSE CIA;
h(f,init) => IsApplication(IterateFunc(f,init), Nat, Domain(f)) /\ IterateFunc(f,init)[{}] = init   BECAUSE CIA;
h(f,init) => IsApplication(IterateFunc(f,init), Nat, Domain(f)) /\ IterateFunc(f,init)[{}] = init /\ (\A n : n \in Nat => IterateFunc(f,init)[successor(n)] = f[IterateFunc(f,init)[n]])   BECAUSE CIA;
iterateFuncExists   BECAUSE GENERALIZATION;
QED

\* Restriction of the successor operator to Nat
natSucc == CHOOSE_UNIQUE b : \A z : z = b <=>
   IsApplication(z,Nat,Nat) /\ \A x : x \in Nat => z[x] = successor(x)

natSuccIsFunc == IsApplication(natSucc,Nat,Nat)
   /\ (\A n : n \in Nat => natSucc[n] = successor(n))
THEOREM natSuccIsFunc
PROOF
VARIABLES a,b,c,d,f,g,i,j,n,x,y,z;
\A d : \A i : (\A x : x \in d => successor(x) \in i) => (\E b : (\A z : z = b <=> (IsApplication(z,d,i) /\ (\A x : x \in d => z[x] = successor(x)))))
   BECAUSE MACRO separationFunc(F <- successor(x));
(\A x : x \in Nat => successor(x) \in Nat) => (\E b : (\A z : z = b <=> (IsApplication(z,Nat,Nat) /\ (\A x : x \in Nat => z[x] = successor(x)))))
   BECAUSE \A(d <- Nat, i <- Nat);
natSuccStable   BECAUSE THEOREM;
x \in Nat => successor(x) \in Nat   BECAUSE \A(n <- x);
\A x : x \in Nat => successor(x) \in Nat   BECAUSE GENERALIZATION;
\E b : (\A z : z = b <=> (IsApplication(z,Nat,Nat) /\ (\A x : x \in Nat => z[x] = successor(x))))   BECAUSE MODUS_PONENS;
\A z : z = natSucc <=> (IsApplication(z,Nat,Nat) /\ (\A x : x \in Nat => z[x] = successor(x)))   BECAUSE CHOOSE natSucc;
natSucc = natSucc <=> (IsApplication(natSucc,Nat,Nat) /\ (\A x : x \in Nat => natSucc[x] = successor(x)))   BECAUSE \A(z <- natSucc);
equalSelf   BECAUSE THEOREM;
natSucc = natSucc   BECAUSE \A(a <- natSucc);
IsApplication(natSucc,Nat,Nat) /\ (\A x : x \in Nat => natSucc[x] = successor(x))   BECAUSE MODUS_PONENS;
\A x : x \in Nat => natSucc[x] = successor(x)   BECAUSE S22;
n \in Nat => natSucc[n] = successor(n)   BECAUSE \A(x <- n);
\A n : n \in Nat => natSucc[n] = successor(n)   BECAUSE GENERALIZATION;
IsApplication(natSucc,Nat,Nat)   BECAUSE S12;
natSuccIsFunc   BECAUSE IntroAndRight;
QED

(*
   The usual addition operation on natural numbers.
   It could also be defined as the restriction of
   ordinal addition on Nat.
   
   Is is defined in curried form, so that it can
   be iterated again for multiplication.
*)
NatAdditionCurry(n) == IterateFunc(natSucc,n)

natAdditionIsFuncCurry == \A p : p \in Nat => IsApplication(NatAdditionCurry(p), Nat, Nat)
   /\ NatAdditionCurry(p)[0] = p
   /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]
THEOREM natAdditionIsFuncCurry
PROOF
VARIABLES x,p;
iterateFuncExists   BECAUSE THEOREM;
IsFunction(natSucc) /\ Image(natSucc) \subseteq Domain(natSucc) /\ p \in Domain(natSucc)
   => ( IsApplication(IterateFunc(natSucc,p), Nat, Domain(natSucc))
        /\ IterateFunc(natSucc,p)[0] = p
        /\ \A n : n \in Nat => IterateFunc(natSucc,p)[successor(n)] = natSucc[IterateFunc(natSucc,p)[n]]   )
   BECAUSE \A(f <- natSucc, init <- p);
natSuccIsFunc   BECAUSE THEOREM;
IsApplication(natSucc,Nat,Nat)   BECAUSE S12;
Image(natSucc) \subseteq Nat   BECAUSE S22;
Domain(natSucc) = Nat   BECAUSE S24;
inclusionInOneself   BECAUSE THEOREM;
Domain(natSucc) \subseteq Domain(natSucc)   BECAUSE \A(x <- Domain(natSucc));
\A x : \A y : x = y => (x \subseteq Domain(natSucc) <=> y \subseteq Domain(natSucc))   BECAUSE E_SCHEME;
Domain(natSucc) = Nat => (Domain(natSucc) \subseteq Domain(natSucc) <=> Nat \subseteq Domain(natSucc))   BECAUSE \A(x <- Domain(natSucc), y <- Nat);
Domain(natSucc) \subseteq Domain(natSucc) <=> Nat \subseteq Domain(natSucc)   BECAUSE MODUS_PONENS;
Nat \subseteq Domain(natSucc)   BECAUSE MODUS_PONENS;
(Image(natSucc) \subseteq Nat) /\ Nat \subseteq Domain(natSucc)   BECAUSE IntroAndRight;
transitInclusion   BECAUSE THEOREM;
((Image(natSucc) \subseteq Nat) /\ (Nat \subseteq Domain(natSucc)))
   => (Image(natSucc) \subseteq Domain(natSucc))   BECAUSE \A(a <- Image(natSucc), b <- Nat, c <- Domain(natSucc));
Image(natSucc) \subseteq Domain(natSucc)   BECAUSE MODUS_PONENS;
IsFunction(natSucc)   BECAUSE S14;
IsFunction(natSucc) /\ Image(natSucc) \subseteq Domain(natSucc)   BECAUSE IntroAndRight;
p \in Domain(natSucc) => IsFunction(natSucc) /\ Image(natSucc) \subseteq Domain(natSucc) /\ p \in Domain(natSucc)  BECAUSE IntroAndRight;
p \in Domain(natSucc) => ( IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc))
        /\ NatAdditionCurry(p)[0] = p
        /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   )
   BECAUSE TI;
( IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc))
        /\ NatAdditionCurry(p)[0] = p
        /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   ) => IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc))   BECAUSE S13;
( IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc))
        /\ NatAdditionCurry(p)[0] = p
        /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   ) => NatAdditionCurry(p)[0] = p   BECAUSE S23;
( IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc))
        /\ NatAdditionCurry(p)[0] = p
        /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   ) => \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE S22;
p \in Domain(natSucc) => IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc))   BECAUSE TI;
IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc)) => Image(NatAdditionCurry(p)) \subseteq Domain(natSucc)   BECAUSE S22;
p \in Domain(natSucc) => Image(NatAdditionCurry(p)) \subseteq Domain(natSucc)   BECAUSE TI;
IsApplication(NatAdditionCurry(p), Nat, Domain(natSucc)) => Domain(NatAdditionCurry(p)) = Nat   BECAUSE S23;
p \in Domain(natSucc) => Domain(NatAdditionCurry(p)) = Nat   BECAUSE TI;
p \in Domain(natSucc) => NatAdditionCurry(p)[0] = p   BECAUSE TI;
p \in Domain(natSucc) => \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE TI;
\A x : \A y : x = y => (IsApplication(NatAdditionCurry(p),Nat,x) <=> IsApplication(NatAdditionCurry(p),Nat,y))   BECAUSE E_SCHEME;
Domain(natSucc) = Nat => (IsApplication(NatAdditionCurry(p),Nat,Domain(natSucc)) <=> IsApplication(NatAdditionCurry(p),Nat,Nat))   BECAUSE \A(x <- Domain(natSucc), y <- Nat);
IsApplication(NatAdditionCurry(p),Nat,Domain(natSucc)) <=> IsApplication(NatAdditionCurry(p),Nat,Nat)   BECAUSE MODUS_PONENS;
IsApplication(NatAdditionCurry(p),Nat,Domain(natSucc)) => IsApplication(NatAdditionCurry(p),Nat,Nat)   BECAUSE EquivToImpl;
p \in Domain(natSucc) => IsApplication(NatAdditionCurry(p),Nat,Nat)   BECAUSE TI;
p \in Domain(natSucc) => IsApplication(NatAdditionCurry(p),Nat,Nat) /\ NatAdditionCurry(p)[0] = p   BECAUSE CIA;
p \in Domain(natSucc) => IsApplication(NatAdditionCurry(p),Nat,Nat) /\ NatAdditionCurry(p)[0] = p /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE CIA;
\A x : \A y : x = y => (p \in x <=> p \in y)   BECAUSE E_SCHEME;
Domain(natSucc) = Nat => (p \in Domain(natSucc) <=> p \in Nat)   BECAUSE \A(x <- Domain(natSucc), y <- Nat);
(p \in Domain(natSucc) <=> p \in Nat)   BECAUSE MODUS_PONENS;
p \in Nat => p \in Domain(natSucc)   BECAUSE EquivToImplReverse;
p \in Nat => IsApplication(NatAdditionCurry(p),Nat,Nat) /\ NatAdditionCurry(p)[0] = p /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE TI;
natAdditionIsFuncCurry   BECAUSE GENERALIZATION;
QED

zeroNeutralNatAddition == \A p : p \in Nat => NatAdditionCurry(0)[p] = p /\ NatAdditionCurry(p)[0] = p
THEOREM zeroNeutralNatAddition
PROOF
VARIABLES b,p,n,z;
natAdditionIsFuncCurry   BECAUSE THEOREM;
p \in Nat => IsApplication(NatAdditionCurry(p), Nat, Nat) /\ NatAdditionCurry(p)[0] = p
   /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE \A(p <- p);
IsApplication(NatAdditionCurry(p), Nat, Nat) /\ NatAdditionCurry(p)[0] = p
   /\ (\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]) => NatAdditionCurry(p)[0] = p
   BECAUSE S23;
p \in Nat => NatAdditionCurry(p)[0] = p   BECAUSE TI;

\* Prove NatAdditionCurry(0)[p] = p by induction on p
\A a : \E b : \A x : x \in b <=> x \in a /\ NatAdditionCurry(0)[x] = x   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ NatAdditionCurry(0)[x] = x   BECAUSE \A(a <- Nat);
natInduction   BECAUSE THEOREM;
0 \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
h(b) == \A x : x \in b <=> x \in Nat /\ NatAdditionCurry(0)[x] = x;
\* Prove 0 \in b
h(b) => (0 \in b <=> 0 \in Nat /\ NatAdditionCurry(0)[0] = 0)   BECAUSE \A(x <- 0);
(0 \in b <=> 0 \in Nat /\ NatAdditionCurry(0)[0] = 0) => (0 \in Nat /\ NatAdditionCurry(0)[0] = 0 => 0 \in b)   BECAUSE EquivToImplReverse;
h(b) => (0 \in Nat /\ NatAdditionCurry(0)[0] = 0 => 0 \in b)   BECAUSE TI;
zeroInNat   BECAUSE THEOREM;
\A p : p \in Nat => NatAdditionCurry(p)[0] = p   BECAUSE GENERALIZATION;
0 \in Nat => NatAdditionCurry(0)[0] = 0   BECAUSE \A(p <- 0);
NatAdditionCurry(0)[0] = 0   BECAUSE MODUS_PONENS;
0 \in Nat /\ NatAdditionCurry(0)[0] = 0   BECAUSE IntroAndRight;
h(b) => 0 \in Nat /\ NatAdditionCurry(0)[0] = 0   BECAUSE PT1;
h(b) => 0 \in b   BECAUSE KillMiddleHypo;

\* Prove induction step
h(b) => (n \in b <=> n \in Nat /\ NatAdditionCurry(0)[n] = n)   BECAUSE \A(x <- n);
pullHypo(h,a,b,c) == (h => (a <=> b /\ c)) => (h /\ (b /\ a) => c)   PROPO_TAUTO;
h(b) /\ (n \in Nat /\ n \in b) => NatAdditionCurry(0)[n] = n   BECAUSE pullHypo;
h(b) /\ (n \in Nat /\ n \in b) => n \in Nat /\ n \in b   BECAUSE S22;
n \in Nat /\ n \in b => n \in Nat   BECAUSE S12;

h(b) => (successor(n) \in b <=> successor(n) \in Nat /\ NatAdditionCurry(0)[successor(n)] = successor(n))   BECAUSE \A(x <- successor(n));
(successor(n) \in b <=> successor(n) \in Nat /\ NatAdditionCurry(0)[successor(n)] = successor(n))
   => (successor(n) \in Nat /\ NatAdditionCurry(0)[successor(n)] = successor(n) => successor(n) \in b)   BECAUSE EquivToImplReverse;
h(b) => (successor(n) \in Nat /\ NatAdditionCurry(0)[successor(n)] = successor(n) => successor(n) \in b)   BECAUSE TI;

IsApplication(NatAdditionCurry(p), Nat, Nat) /\ NatAdditionCurry(p)[0] = p
   /\ (\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])
   => (\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])   BECAUSE S22;
(\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]) => (n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])   BECAUSE \A(n <- n);
p \in Nat => (n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])   BECAUSE TI2;
\A p : p \in Nat => (n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])   BECAUSE GENERALIZATION;
0 \in Nat => (n \in Nat => NatAdditionCurry(0)[successor(n)] = natSucc[NatAdditionCurry(0)[n]])   BECAUSE \A(p <- 0);
n \in Nat => NatAdditionCurry(0)[successor(n)] = natSucc[NatAdditionCurry(0)[n]]   BECAUSE MODUS_PONENS;
h(b) /\ (n \in Nat /\ n \in b) => NatAdditionCurry(0)[successor(n)] = natSucc[NatAdditionCurry(0)[n]]   BECAUSE TI2;
\A x : \A y : x = y => (NatAdditionCurry(0)[successor(n)] = natSucc[x] <=> NatAdditionCurry(0)[successor(n)] = natSucc[y])   BECAUSE E_SCHEME;
NatAdditionCurry(0)[n] = n => (NatAdditionCurry(0)[successor(n)] = natSucc[NatAdditionCurry(0)[n]] <=> NatAdditionCurry(0)[successor(n)] = natSucc[n])   BECAUSE \A(x <- NatAdditionCurry(0)[n], y <- n);
h(b) /\ (n \in Nat /\ n \in b) => (NatAdditionCurry(0)[successor(n)] = natSucc[NatAdditionCurry(0)[n]] <=> NatAdditionCurry(0)[successor(n)] = natSucc[n])   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) => NatAdditionCurry(0)[successor(n)] = natSucc[n]   BECAUSE HITE;
natSuccIsFunc   BECAUSE THEOREM;
\A n : n \in Nat => natSucc[n] = successor(n)   BECAUSE S22;
n \in Nat => natSucc[n] = successor(n)   BECAUSE \A(n <- n);
natSucc[n] = successor(n) => successor(n) = natSucc[n]   BECAUSE E_SCHEME;
n \in Nat => successor(n) = natSucc[n]   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) = natSucc[n]   BECAUSE TI2;
h(b) /\ (n \in Nat /\ n \in b) => NatAdditionCurry(0)[successor(n)] = natSucc[n] /\ successor(n) = natSucc[n]   BECAUSE CIA;
NatAdditionCurry(0)[successor(n)] = natSucc[n] /\ successor(n) = natSucc[n] => NatAdditionCurry(0)[successor(n)] = successor(n)   BECAUSE E_SCHEME;
h(b) /\ (n \in Nat /\ n \in b) => NatAdditionCurry(0)[successor(n)] = successor(n)   BECAUSE TI;
natSuccStable   BECAUSE THEOREM;
n \in Nat => successor(n) \in Nat   BECAUSE \A(n <- n);
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in Nat   BECAUSE TI2;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in Nat /\ NatAdditionCurry(0)[successor(n)] = successor(n)   BECAUSE CIA;
h(b) /\ (n \in Nat /\ n \in b) => h(b)   BECAUSE S12;
h(b) /\ (n \in Nat /\ n \in b) => (successor(n) \in Nat /\ NatAdditionCurry(0)[successor(n)] = successor(n) => successor(n) \in b)   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in b   BECAUSE KillMiddleHypo;

\* Discharge b
h(b) => ((n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE HypoAndToImpl;
\A n : h(b) => ((n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE GENERALIZATION;
h(b) => (\A n : (n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE Q_SCHEME;
h(b) => 0 \in b /\ (\A n : (n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE CIA;
Nat \subseteq b => (z \in Nat => z \in b)   BECAUSE \A(z <- z);
h(b) => (z \in Nat => z \in b)   BECAUSE TI2;
h(b) /\ z \in Nat => z \in b   BECAUSE HypoImplToAnd;
h(b) => (z \in b <=> z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE \A(x <- z);
(z \in b <=> z \in Nat /\ NatAdditionCurry(0)[z] = z) => (z \in b => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE EquivToImpl;
h(b) => (z \in b => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE TI;
h(b) /\ z \in Nat => h(b)   BECAUSE S12;
h(b) /\ z \in Nat => (z \in b => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE TI;
h(b) /\ z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z   BECAUSE KillMiddleHypo;
h(b) => (z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE HypoAndToImpl;
(\E b : h(b)) => (\E b : z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE Q_SCHEME;
(\E b : z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE MODUS_PONENS;
(\E b : z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z) => (z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z)   BECAUSE Q_SCHEME;
z \in Nat => z \in Nat /\ NatAdditionCurry(0)[z] = z   BECAUSE MODUS_PONENS;
z \in Nat /\ NatAdditionCurry(0)[z] = z => NatAdditionCurry(0)[z] = z   BECAUSE S22;
z \in Nat => NatAdditionCurry(0)[z] = z   BECAUSE TI;
\A z : z \in Nat => NatAdditionCurry(0)[z] = z   BECAUSE GENERALIZATION;
p \in Nat => NatAdditionCurry(0)[p] = p   BECAUSE \A(z <- p);
p \in Nat => NatAdditionCurry(0)[p] = p /\ NatAdditionCurry(p)[0] = p  BECAUSE CIA;
zeroNeutralNatAddition   BECAUSE GENERALIZATION;
QED

addSuccCommute == \A n : \A p : n \in Nat /\ p \in Nat
   => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p])
      /\ NatAdditionCurry(n)[successor(p)] = successor(NatAdditionCurry(n)[p])
THEOREM addSuccCommute
PROOF
VARIABLES b,n,p,z;
natAdditionIsFuncCurry   BECAUSE THEOREM;
p \in Nat => IsApplication(NatAdditionCurry(p), Nat, Nat)
   /\ NatAdditionCurry(p)[0] = p
   /\ \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE \A(p <- p);
IsApplication(NatAdditionCurry(p), Nat, Nat)
   /\ NatAdditionCurry(p)[0] = p
   /\ (\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])
   => IsApplication(NatAdditionCurry(p), Nat, Nat)   BECAUSE S13;
IsApplication(NatAdditionCurry(p), Nat, Nat)
   /\ NatAdditionCurry(p)[0] = p
   /\ (\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])
   => \A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE S22;
(\A n : n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])
   => (n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])   BECAUSE \A(n <- n);
p \in Nat => (n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]])   BECAUSE TI2;
p \in Nat /\ n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]]   BECAUSE HypoImplToAnd;
natSuccIsFunc   BECAUSE THEOREM;
\A n : n \in Nat => natSucc[n] = successor(n)   BECAUSE S22;
NatAdditionCurry(p)[n] \in Nat => natSucc[NatAdditionCurry(p)[n]] = successor(NatAdditionCurry(p)[n])
   BECAUSE \A(n <- NatAdditionCurry(p)[n]);
IsApplication(NatAdditionCurry(p), Nat, Nat) => IsFunction(NatAdditionCurry(p))   BECAUSE S13;
IsApplication(NatAdditionCurry(p), Nat, Nat) => Domain(NatAdditionCurry(p)) = Nat   BECAUSE S23;
IsApplication(NatAdditionCurry(p), Nat, Nat) => Image(NatAdditionCurry(p)) \subseteq Nat   BECAUSE S22;
p \in Nat => IsFunction(NatAdditionCurry(p))   BECAUSE TI2;
p \in Nat => Image(NatAdditionCurry(p)) \subseteq Nat   BECAUSE TI2;
p \in Nat => Domain(NatAdditionCurry(p)) = Nat   BECAUSE TI2;
funcImageExists   BECAUSE THEOREM;
IsFunction(NatAdditionCurry(p)) /\ n \in Domain(NatAdditionCurry(p))
   => <<n, NatAdditionCurry(p)[n]>> \in NatAdditionCurry(p)   BECAUSE \A(f <- NatAdditionCurry(p), x <- n);
\A x : \A y : x = y => (n \in x <=> n \in y)   BECAUSE E_SCHEME;
Domain(NatAdditionCurry(p)) = Nat => (n \in Domain(NatAdditionCurry(p)) <=> n \in Nat)   BECAUSE \A(x <- Domain(NatAdditionCurry(p)), y <- Nat);
p \in Nat => (n \in Domain(NatAdditionCurry(p)) <=> n \in Nat)   BECAUSE TI;
(n \in Domain(NatAdditionCurry(p)) <=> n \in Nat) => (n \in Nat => n \in Domain(NatAdditionCurry(p)))   BECAUSE EquivToImplReverse;
p \in Nat => (n \in Nat => n \in Domain(NatAdditionCurry(p)))   BECAUSE TI;
p \in Nat /\ n \in Nat => n \in Domain(NatAdditionCurry(p))   BECAUSE HypoImplToAnd;
p \in Nat /\ n \in Nat => p \in Nat   BECAUSE S12;
p \in Nat /\ n \in Nat => IsFunction(NatAdditionCurry(p))   BECAUSE TI;
p \in Nat /\ n \in Nat => IsFunction(NatAdditionCurry(p)) /\ n \in Domain(NatAdditionCurry(p))   BECAUSE CIA;
p \in Nat /\ n \in Nat => <<n, NatAdditionCurry(p)[n]>> \in NatAdditionCurry(p)   BECAUSE TI;
<<n, NatAdditionCurry(p)[n]>> \in NatAdditionCurry(p) => Reaches(NatAdditionCurry(p),NatAdditionCurry(p)[n])   BECAUSE \E(x <- n);
imageExists   BECAUSE THEOREM;
NatAdditionCurry(p)[n] \in Image(NatAdditionCurry(p)) <=> Reaches(NatAdditionCurry(p),NatAdditionCurry(p)[n])
   BECAUSE \A(g <- NatAdditionCurry(p), y <- NatAdditionCurry(p)[n]);
Reaches(NatAdditionCurry(p),NatAdditionCurry(p)[n]) => NatAdditionCurry(p)[n] \in Image(NatAdditionCurry(p))   BECAUSE EquivToImplReverse;
p \in Nat /\ n \in Nat => NatAdditionCurry(p)[n] \in Image(NatAdditionCurry(p))   BECAUSE TI2;
Image(NatAdditionCurry(p)) \subseteq Nat => (NatAdditionCurry(p)[n] \in Image(NatAdditionCurry(p)) => NatAdditionCurry(p)[n] \in Nat)   BECAUSE \A(z <- NatAdditionCurry(p)[n]);
p \in Nat /\ n \in Nat => (NatAdditionCurry(p)[n] \in Image(NatAdditionCurry(p)) => NatAdditionCurry(p)[n] \in Nat)   BECAUSE TI2;
p \in Nat /\ n \in Nat => NatAdditionCurry(p)[n] \in Nat   BECAUSE KillMiddleHypo;
natSucc[NatAdditionCurry(p)[n]] = successor(NatAdditionCurry(p)[n]) => successor(NatAdditionCurry(p)[n]) = natSucc[NatAdditionCurry(p)[n]]   BECAUSE E_SCHEME;
p \in Nat /\ n \in Nat => successor(NatAdditionCurry(p)[n]) = natSucc[NatAdditionCurry(p)[n]]   BECAUSE TI2;
p \in Nat /\ n \in Nat => NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]] /\ successor(NatAdditionCurry(p)[n]) = natSucc[NatAdditionCurry(p)[n]]   BECAUSE CIA;
NatAdditionCurry(p)[successor(n)] = natSucc[NatAdditionCurry(p)[n]] /\ successor(NatAdditionCurry(p)[n]) = natSucc[NatAdditionCurry(p)[n]]
   => NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE E_SCHEME;
p \in Nat /\ n \in Nat => NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE TI;
\A p : \A n : p \in Nat /\ n \in Nat => NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE GENERALIZATION;
n \in Nat /\ p \in Nat => NatAdditionCurry(n)[successor(p)] = successor(NatAdditionCurry(n)[p])   BECAUSE \A(p <- n, n <- p);

\* Prove NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]) by induction
natInduction   BECAUSE THEOREM;
0 \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
\A a : \E b : \A x : x \in b <=> x \in a /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[x] = successor(NatAdditionCurry(p)[x])   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[x] = successor(NatAdditionCurry(p)[x])   BECAUSE \A(a <- Nat);
h(b) == \A x : x \in b <=> x \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[x] = successor(NatAdditionCurry(p)[x]);
h(b) => (0 \in b <=> 0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0]))   BECAUSE \A(x <- 0);
(0 \in b <=> 0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0]))
   => (0 \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])) => 0 \in b)   BECAUSE EquivToImplReverse;
h(b) => (0 \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])) => 0 \in b)   BECAUSE TI;
zeroNeutralNatAddition   BECAUSE THEOREM;
p \in Nat => NatAdditionCurry(0)[p] = p /\ NatAdditionCurry(p)[0] = p   BECAUSE \A(p <- p);
NatAdditionCurry(0)[p] = p /\ NatAdditionCurry(p)[0] = p => NatAdditionCurry(p)[0] = p   BECAUSE S22;
p \in Nat => NatAdditionCurry(p)[0] = p   BECAUSE TI;
successor(p) \in Nat => NatAdditionCurry(0)[successor(p)] = successor(p) /\ NatAdditionCurry(successor(p))[0] = successor(p)   BECAUSE \A(p <- successor(p));
NatAdditionCurry(0)[successor(p)] = successor(p) /\ NatAdditionCurry(successor(p))[0] = successor(p)
   => NatAdditionCurry(successor(p))[0] = successor(p)   BECAUSE S22;
natSuccStable   BECAUSE THEOREM;
p \in Nat => successor(p) \in Nat   BECAUSE \A(n <- p);
p \in Nat => NatAdditionCurry(successor(p))[0] = successor(p)   BECAUSE TI2;
\A x : \A y : x = y => successor(x) = successor(y)   BECAUSE E_SCHEME;
NatAdditionCurry(p)[0] = p => successor(NatAdditionCurry(p)[0]) = successor(p)   BECAUSE \A(x <- NatAdditionCurry(p)[0], y <- p);
p \in Nat => successor(NatAdditionCurry(p)[0]) = successor(p)   BECAUSE TI;
p \in Nat => NatAdditionCurry(successor(p))[0] = successor(p) /\ successor(NatAdditionCurry(p)[0]) = successor(p)   BECAUSE CIA;
NatAdditionCurry(successor(p))[0] = successor(p) /\ successor(NatAdditionCurry(p)[0]) = successor(p)
   => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])   BECAUSE E_SCHEME;
p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])   BECAUSE TI;
\A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])   BECAUSE GENERALIZATION;
zeroInNat   BECAUSE THEOREM;
0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])   BECAUSE IntroAndRight;
h(b) => 0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[0] = successor(NatAdditionCurry(p)[0])   BECAUSE PT1;
h(b) => 0 \in b   BECAUSE KillMiddleHypo;

\* inductive step
h(b) => (n \in b <=> n \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]))   BECAUSE \A(x <- n);
(n \in b <=> n \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n])) => (n \in b => n \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]))   BECAUSE EquivToImpl;
h(b) => (n \in b => n \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]))   BECAUSE TI;
pullHypo(h,a,b,c) == (h => (a <=> b /\ c)) => (h /\ (b /\ a) => c)   PROPO_TAUTO;
h(b) /\ (n \in Nat /\ n \in b) => \A p : p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n])   BECAUSE pullHypo;
(\A p : p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n])) => (p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]))   BECAUSE \A(p <- p);
h(b) /\ (n \in Nat /\ n \in b) => (p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]))   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n])   BECAUSE HypoImplToAnd;
NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]) => successor(NatAdditionCurry(successor(p))[n]) = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE \A(x <- NatAdditionCurry(successor(p))[n], y <- successor(NatAdditionCurry(p)[n]));
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => successor(NatAdditionCurry(successor(p))[n]) = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE TI;

h(b) => (successor(n) \in b <=> successor(n) \in Nat
   /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)]))   BECAUSE \A(x <- successor(n));
(successor(n) \in b <=> successor(n) \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)])) => (successor(n) \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)])) => successor(n) \in b)   BECAUSE EquivToImplReverse;
\A p : p \in Nat /\ n \in Nat => NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE GENERALIZATION;
successor(p) \in Nat /\ n \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(successor(p))[n])   BECAUSE \A(p <- successor(p));
n \in Nat => n \in Nat   BECAUSE ImplySelf;
p \in Nat /\ n \in Nat => successor(p) \in Nat /\ n \in Nat   BECAUSE MergeImplicationsAnd;
selectHypos(a,b,c,d) == a /\ (b /\ c) /\ d => d /\ b   PROPO_TAUTO;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => p \in Nat /\ n \in Nat   BECAUSE selectHypos;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(successor(p))[n])   BECAUSE TI2;
NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(successor(p))[n]) => successor(NatAdditionCurry(successor(p))[n]) = NatAdditionCurry(successor(p))[successor(n)]   BECAUSE E_SCHEME;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => successor(NatAdditionCurry(successor(p))[n]) = NatAdditionCurry(successor(p))[successor(n)]   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => successor(NatAdditionCurry(successor(p))[n]) = NatAdditionCurry(successor(p))[successor(n)] /\ successor(NatAdditionCurry(successor(p))[n]) = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE CIA;
successor(NatAdditionCurry(successor(p))[n]) = NatAdditionCurry(successor(p))[successor(n)] /\ successor(NatAdditionCurry(successor(p))[n]) = successor(successor(NatAdditionCurry(p)[n])) => NatAdditionCurry(successor(p))[successor(n)] = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE E_SCHEME;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE TI;

NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n]) => successor(NatAdditionCurry(p)[successor(n)]) = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE \A(x <- NatAdditionCurry(p)[successor(n)], y <- successor(NatAdditionCurry(p)[n]));
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => successor(NatAdditionCurry(p)[successor(n)]) = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE TI2;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(successor(NatAdditionCurry(p)[n])) /\ successor(NatAdditionCurry(p)[successor(n)]) = successor(successor(NatAdditionCurry(p)[n]))   BECAUSE CIA;
NatAdditionCurry(successor(p))[successor(n)] = successor(successor(NatAdditionCurry(p)[n])) /\ successor(NatAdditionCurry(p)[successor(n)]) = successor(successor(NatAdditionCurry(p)[n])) => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)])   BECAUSE E_SCHEME;
h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)])   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) => (p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)]))   BECAUSE HypoAndToImpl;
\A p : h(b) /\ (n \in Nat /\ n \in b) => (p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)]))   BECAUSE GENERALIZATION;
h(b) /\ (n \in Nat /\ n \in b) => (\A p : p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)]))   BECAUSE Q_SCHEME;
n \in Nat => successor(n) \in Nat   BECAUSE \A(n <- n);
h(b) /\ (n \in Nat /\ n \in b) => (n \in Nat /\ n \in b)   BECAUSE S22;
(n \in Nat /\ n \in b) => n \in Nat  BECAUSE S12;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in Nat   BECAUSE TI2;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)]))   BECAUSE CIA;
h(b) /\ (n \in Nat /\ n \in b) => h(b)   BECAUSE S12;
h(b) /\ (n \in Nat /\ n \in b) => (successor(n) \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(p))[successor(n)] = successor(NatAdditionCurry(p)[successor(n)])) => successor(n) \in b)   BECAUSE TI2;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in b   BECAUSE KillMiddleHypo;
h(b) => ((n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE HypoAndToImpl;
\A n : h(b) => ((n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE GENERALIZATION;
h(b) => (\A n : (n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE Q_SCHEME;
h(b) => 0 \in b /\ (\A n : (n \in Nat /\ n \in b) => successor(n) \in b)   BECAUSE CIA;
h(b) => Nat \subseteq b   BECAUSE TI;

\* Discharge b
Nat \subseteq b => (z \in Nat => z \in b)   BECAUSE \A(z <- z);
h(b) => (z \in Nat => z \in b)   BECAUSE TI;
h(b) /\ z \in Nat => z \in b   BECAUSE HypoImplToAnd;
h(b) => (z \in b <=> z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE \A(x <- z);
(z \in b <=> z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])) => (z \in b => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE EquivToImpl;
h(b) => (z \in b => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE TI;
h(b) /\ z \in Nat => h(b)   BECAUSE S12;
h(b) /\ z \in Nat => (z \in b => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE TI;
h(b) /\ z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])   BECAUSE KillMiddleHypo;
h(b) => (z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE HypoAndToImpl;
(\E b : h(b)) => (\E b : z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE Q_SCHEME;
(\E b : z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE MODUS_PONENS;
(\E b : z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])) => (z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE Q_SCHEME;
z \in Nat => z \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])   BECAUSE MODUS_PONENS;
z \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])) => \A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])   BECAUSE S22;
(\A p : p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z])) => (p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE \A(p <- p);
z \in Nat => (p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE TI2;
\A p : \A z : z \in Nat => (p \in Nat => NatAdditionCurry(successor(p))[z] = successor(NatAdditionCurry(p)[z]))   BECAUSE GENERALIZATION;
p \in Nat => (n \in Nat => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p]))
   BECAUSE \A(p <- n, z <- p);
p \in Nat /\ n \in Nat => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p])   BECAUSE HypoImplToAnd;
n \in Nat /\ p \in Nat => p \in Nat /\ n \in Nat   BECAUSE AndSymmetry;
n \in Nat /\ p \in Nat => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p])   BECAUSE TI;
n \in Nat /\ p \in Nat => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p]) /\ NatAdditionCurry(n)[successor(p)] = successor(NatAdditionCurry(n)[p])   BECAUSE CIA;
addSuccCommute   BECAUSE GENERALIZATION;
QED

natAdditionCommutes == \A n : \A p : n \in Nat /\ p \in Nat
   => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n]
THEOREM natAdditionCommutes
PROOF
VARIABLES b,n,p;
\* By induction on n
\A a : \E b : \A x : x \in b <=> x \in a
   /\ \A p : p \in Nat => NatAdditionCurry(x)[p] = NatAdditionCurry(p)[x]   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat
   /\ \A p : p \in Nat => NatAdditionCurry(x)[p] = NatAdditionCurry(p)[x]   BECAUSE \A(a <- Nat);
h(b) == \A x : x \in b <=> x \in Nat /\ \A p : p \in Nat => NatAdditionCurry(x)[p] = NatAdditionCurry(p)[x];
h(b) => (0 \in b <=> 0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0])   BECAUSE \A(x <- 0);
(0 \in b <=> 0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]) => (0 \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]) => 0 \in b)   BECAUSE EquivToImplReverse;
h(b) => (0 \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]) => 0 \in b)   BECAUSE TI;
zeroNeutralNatAddition   BECAUSE THEOREM;
p \in Nat => NatAdditionCurry(0)[p] = p /\ NatAdditionCurry(p)[0] = p   BECAUSE \A(p <- p);
NatAdditionCurry(0)[p] = p /\ NatAdditionCurry(p)[0] = p => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]   BECAUSE E_SCHEME;
p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]   BECAUSE TI;
\A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]   BECAUSE GENERALIZATION;
zeroInNat   BECAUSE THEOREM;
0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]   BECAUSE IntroAndRight;
h(b) => 0 \in Nat /\ \A p : p \in Nat => NatAdditionCurry(0)[p] = NatAdditionCurry(p)[0]   BECAUSE PT1;
h(b) => 0 \in b   BECAUSE KillMiddleHypo;

\* Induction step
h(b) => (n \in b <=> n \in Nat /\ \A p : p \in Nat => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n])   BECAUSE \A(x <- n);
pullHypo(h,a,b,c) == (h => (a <=> b /\ c)) => (h /\ (b /\ a) => c)   PROPO_TAUTO;
h(b) /\ (n \in Nat /\ n \in b) => \A p : p \in Nat => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n]   BECAUSE pullHypo;
(\A p : p \in Nat => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n]) => (p \in Nat => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n])   BECAUSE \A(p <- p);
h(b) /\ (n \in Nat /\ n \in b) => h(b)   BECAUSE S12;
h(b) /\ (n \in Nat /\ n \in b) => (n \in Nat /\ n \in b)   BECAUSE S22;
h(b) /\ (n \in Nat /\ n \in b) => (p \in Nat => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n])   BECAUSE TI;
hh(b,n,p) == h(b) /\ (n \in Nat /\ n \in b) /\ p \in Nat;
hh(b,n,p) => NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n]   BECAUSE HypoImplToAnd;
\A x : \A y : x = y => successor(x) = successor(y)   BECAUSE E_SCHEME;
NatAdditionCurry(n)[p] = NatAdditionCurry(p)[n] => successor(NatAdditionCurry(n)[p]) = successor(NatAdditionCurry(p)[n])   BECAUSE \A(x <- NatAdditionCurry(n)[p], y <- NatAdditionCurry(p)[n]);
hh(b,n,p) => successor(NatAdditionCurry(n)[p]) = successor(NatAdditionCurry(p)[n])   BECAUSE TI;

h(b) => (successor(n) \in b <=> successor(n) \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)])   BECAUSE \A(x <- successor(n));
(successor(n) \in b <=> successor(n) \in Nat /\ \A p : p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)]) => (successor(n) \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)]) => successor(n) \in b)   BECAUSE EquivToImplReverse;
h(b) /\ (n \in Nat /\ n \in b) => (successor(n) \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)]) => successor(n) \in b)   BECAUSE TI2;

addSuccCommute   BECAUSE THEOREM;
n \in Nat /\ p \in Nat => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p]) /\ NatAdditionCurry(n)[successor(p)] = successor(NatAdditionCurry(n)[p])   BECAUSE  \A(n <- n, p <- p);
selectHypos(a,b,c,d) == a /\ (b /\ c) /\ d => b /\ d   PROPO_TAUTO;
hh(b,n,p) => n \in Nat /\ p \in Nat   BECAUSE selectHypos;
NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p]) /\ NatAdditionCurry(n)[successor(p)] = successor(NatAdditionCurry(n)[p]) => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p])   BECAUSE S12;
hh(b,n,p) => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p])   BECAUSE TI2;
hh(b,n,p) => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p]) /\ successor(NatAdditionCurry(n)[p]) = successor(NatAdditionCurry(p)[n])   BECAUSE CIA;
transitEqual   BECAUSE THEOREM;
NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(n)[p]) /\ successor(NatAdditionCurry(n)[p]) = successor(NatAdditionCurry(p)[n]) => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(p)[n])
   BECAUSE \A(a <- NatAdditionCurry(successor(n))[p], b <- successor(NatAdditionCurry(n)[p]), c <- successor(NatAdditionCurry(p)[n]));
hh(b,n,p) => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(p)[n])   BECAUSE TI;

n \in Nat /\ p \in Nat => p \in Nat /\ n \in Nat   BECAUSE AndSymmetry;
p \in Nat /\ n \in Nat => NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]) /\ NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE  \A(n <- p, p <- n);
NatAdditionCurry(successor(p))[n] = successor(NatAdditionCurry(p)[n]) /\ NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n]) => NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE S22;
hh(b,n,p) => p \in Nat /\ n \in Nat   BECAUSE TI;
hh(b,n,p) => NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE TI2;
hh(b,n,p) => NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(p)[n]) /\ NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n])   BECAUSE CIA;
NatAdditionCurry(successor(n))[p] = successor(NatAdditionCurry(p)[n]) /\ NatAdditionCurry(p)[successor(n)] = successor(NatAdditionCurry(p)[n]) => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)]   BECAUSE E_SCHEME;
hh(b,n,p) => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)]   BECAUSE TI;
h(b) /\ (n \in Nat /\ n \in b) => (p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)])   BECAUSE HypoAndToImpl;
\A p : h(b) /\ (n \in Nat /\ n \in b) => (p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)])   BECAUSE GENERALIZATION;
h(b) /\ (n \in Nat /\ n \in b) => (\A p : p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)])   BECAUSE Q_SCHEME;
natSuccStable   BECAUSE THEOREM;
n \in Nat => successor(n) \in Nat   BECAUSE \A(n <- n);
(n \in Nat /\ n \in b) => n \in Nat   BECAUSE S12;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in Nat   BECAUSE TI2;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in Nat /\ (\A p : p \in Nat => NatAdditionCurry(successor(n))[p] = NatAdditionCurry(p)[successor(n)])   BECAUSE CIA;
h(b) /\ (n \in Nat /\ n \in b) => successor(n) \in b   BECAUSE KillMiddleHypo;
h(b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE HypoAndToImpl;
\A n : h(b) => (n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE GENERALIZATION;
h(b) => (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE Q_SCHEME;
h(b) => 0 \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b)   BECAUSE CIA;
natInduction   BECAUSE THEOREM;
0 \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
h(b) => Nat \subseteq b   BECAUSE TI;

\* Discharge b

\* TODO
QED

(*
   The usual multiplication operation on natural numbers.
   It could also be defined as the restriction of
   ordinal multiplication on Nat.
*)
NatMultiplication == CHOOSE b : \A z : z = b <=> IsApplication(z, Nat \X Nat, Nat)
   /\ \A x : x \in Nat \X Nat => z[x] = IterateFunc(NatAdditionCurry(fst(x)),0)[snd(x)]

(* TODO associativity, commutativity, multiplication *)