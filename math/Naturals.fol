EXTENDS Orders

(*
   Definition of the set of natural numbers. They are the finite ordinals.
*)
Nat == CHOOSE_UNIQUE o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))

NatExists == (\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))
   /\ IsLimitOrdinal(Nat)
THEOREM NatExists
PROOF
\* By separation in a set given by the axiom of infinity
VARIABLES a,b,c,o,p,t,u,x,y,z,nat;
Infinity   BECAUSE AXIOM;
\A a : \E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE \A(a <- a);
\* Take a from the axiom of infinity and b from separation of finite ordinals
h(a,b) == {} \in a /\ (\A x : x \in a => successor(x) \in a)
   /\ \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x);
h(a,b) => \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)   BECAUSE S22;

\* Prove UNION b is Nat, ie IsFiniteOrdinal(x) <=> x \in UNION b.
\* First prove that UNION b is an ordinal.
unionOrdinalsIsOrdinal   BECAUSE THEOREM;
(\A x : x \in b => IsOrdinal(x)) => IsOrdinal(UNION b)   BECAUSE \A(u <- b);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b <=> x \in a /\ IsFiniteOrdinal(x))
   BECAUSE \A(x <- x);
(x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE EquivToImpl;
h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE TI2;
IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE S13;
\A a : IsFiniteOrdinal(a) => IsOrdinal(a)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(a <- x);
extractProp(a,b,c,d) == (a => b) => ((c => d /\ a) => (c => b))   PROPO_TAUTO;
(x \in b => x \in a /\ IsFiniteOrdinal(x)) => (x \in b => IsOrdinal(x))   BECAUSE extractProp;
h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE TI;
\A x : h(a,b) => (x \in b => IsOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in b => IsOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) => IsOrdinal(UNION b)   BECAUSE TI;

\* Proof that UNION b is a limit ordinal.
\* If o \in UNION b then successor(o) \in UNION b, so UNION b # successor o.
unionExists   BECAUSE AXIOM;
x \in UNION b <=> \E t : t \in b /\ x \in t   BECAUSE \A(b <- b, z <- x);
x \in UNION b => \E t : t \in b /\ x \in t   BECAUSE EquivToImpl;
\A x : h(a,b) => (x \in b => x \in a /\ IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => h(a,b)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => (t \in b => t \in a /\ IsFiniteOrdinal(t))   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => t \in b   BECAUSE S23;
h(a,b) /\ t \in b /\ x \in t => t \in a /\ IsFiniteOrdinal(t)   BECAUSE KillMiddleHypo;
h(a,b) => \A x : x \in a => successor(x) \in a   BECAUSE S23;
(\A x : x \in a => successor(x) \in a) => (t \in a => successor(t) \in a)   BECAUSE \A(x <- t);
h(a,b) /\ t \in b /\ x \in t => (t \in a => successor(t) \in a)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => t \in a   BECAUSE S12;
h(a,b) /\ t \in b /\ x \in t => t \in a   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a   BECAUSE KillMiddleHypo;
\* So successor(t) \in b.
\* Then successor(x) \in successor(t) \in b implies successor(x) \in UNION b.
finiteOrdinalSuccessorStable   BECAUSE THEOREM;
IsFiniteOrdinal(t) => IsFiniteOrdinal( successor(t) )   BECAUSE \A(o <- t);
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t)))   BECAUSE \A(x <- successor(t));
(successor(t) \in b <=> successor(t) \in a /\ IsFiniteOrdinal(successor(t))) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE EquivToImplReverse;
h(a,b) => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI2;
t \in a /\ IsFiniteOrdinal(t) => IsFiniteOrdinal(t)   BECAUSE S22;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(successor(t))   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in a /\ IsFiniteOrdinal(successor(t))   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => (successor(t) \in a /\ IsFiniteOrdinal(successor(t)) => successor(t) \in b)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => successor(t) \in b   BECAUSE KillMiddleHypo;
successorIncreasing   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t => successor(x) \in successor(t)   BECAUSE \A(o <- x, p <- t);
IsFiniteOrdinal(t) => IsOrdinal(t)   BECAUSE S13;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t)   BECAUSE TI2;
h(a,b) /\ t \in b /\ x \in t => x \in t   BECAUSE S22;
elemOfOrdinalIsOrdinal   BECAUSE THEOREM;
IsOrdinal(t) /\ x \in t => IsOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t)   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsOrdinal(x) /\ IsOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t)   BECAUSE TI;
inInUnion   BECAUSE THEOREM;
(successor(x) \in successor(t) /\ successor(t) \in b) => successor(x) \in UNION b   BECAUSE \A(a <- successor(x), b <- successor(t), c <- b);
h(a,b) /\ t \in b /\ x \in t => successor(x) \in successor(t) /\ successor(t) \in b   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => successor(x) \in UNION b   BECAUSE TI;
pushHypos(h,a,b,c) == (h /\ a /\ b => c) => (h => (a /\ b => c))   PROPO_TAUTO;
h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => successor(x) \in UNION b)   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => successor(x) \in UNION b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE Q_SCHEME;
h(a,b) => ((\E t : t \in b /\ x \in t) => \E t : successor(x) \in UNION b)   BECAUSE TI;
mergeHypos(h,a,b,c) == (a => b) => ((h => (b => c)) => (h /\ a => c))   PROPO_TAUTO;
h(a,b) /\ x \in UNION b => \E t : successor(x) \in UNION b   BECAUSE mergeHypos;
(\E t : successor(x) \in UNION b) => successor(x) \in UNION b   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => successor(x) \in UNION b   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(UNION b) /\ successor(x) \in UNION b => successor(x) # (UNION b) /\ (UNION b) \notin successor(x)   BECAUSE \A(o <- successor(x), p <- UNION b);
h(a,b) /\ x \in UNION b => h(a,b)   BECAUSE S12;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b)   BECAUSE TI2;
h(a,b) /\ x \in UNION b => IsOrdinal(UNION b) /\ successor(x) \in UNION b   BECAUSE CIA;
successor(x) # (UNION b) /\ (UNION b) \notin successor(x) => successor(x) # UNION b   BECAUSE S12;
h(a,b) /\ x \in UNION b => successor(x) # UNION b   BECAUSE TI2;
UNION b = successor(x) => successor(x) = UNION b   BECAUSE E_SCHEME;
successor(x) # UNION b => UNION b # successor(x)   BECAUSE Contraposition;
h(a,b) /\ x \in UNION b => UNION b # successor(x)   BECAUSE TI;
h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE HypoAndToImpl;
\A x : h(a,b) => (x \in UNION b => UNION b # successor(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b => UNION b # successor(x))   BECAUSE Q_SCHEME;

\* {} \in successor({}) \in b, so {} \in UNION b
h(a,b) => {} \in a   BECAUSE S13;
(\A x : x \in a => successor(x) \in a) => ({} \in a => successor({}) \in a)   BECAUSE \A(x <- {});
h(a,b) => ({} \in a => successor({}) \in a)   BECAUSE TI;
h(a,b) => successor({}) \in a   BECAUSE KillMiddleHypo;
ordinalZero   BECAUSE THEOREM;
IsFiniteOrdinal({}) => IsFiniteOrdinal( successor({}) )   BECAUSE \A(o <- {});
IsFiniteOrdinal( successor({}) )   BECAUSE MODUS_PONENS;
successor({}) \in a => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE IntroAndLeft;
h(a,b) => successor({}) \in a /\ IsFiniteOrdinal( successor({}) )   BECAUSE TI;
(\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE \A(x <- successor({}));
h(a,b) => (successor({}) \in b <=> successor({}) \in a /\ IsFiniteOrdinal(successor({})))   BECAUSE TI;
killCase(h,a,b) == (h => a) => ((h => (b <=> a)) => (h => b))   PROPO_TAUTO;
h(a,b) => successor({}) \in b   BECAUSE killCase;
inSuccessor   BECAUSE THEOREM;
{} \in successor({})   BECAUSE \A(o <- {});
h(a,b) => {} \in successor({})   BECAUSE PT1;
h(a,b) => {} \in successor({}) /\ successor({}) \in b   BECAUSE CIA;
({} \in successor({}) /\ successor({}) \in b) => {} \in UNION b   BECAUSE \A(a <- {}, b <- successor({}), c <- b);
h(a,b) => {} \in UNION b   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
UNION b = {} <=> \A x : x \notin UNION b   BECAUSE \A(c <- UNION b);
(\E x : x \in UNION b) <=> ~\A x : x \notin UNION b   BECAUSE Q_SCHEME;
(\E x : x \in UNION b) => ~\A x : x \notin UNION b   BECAUSE EquivToImpl;
{} \in UNION b => \E x : x \in UNION b   BECAUSE \E(x <- {});
h(a,b) => ~\A x : x \notin UNION b   BECAUSE TI2;
UNION b = {} => \A x : x \notin UNION b   BECAUSE EquivToImpl;
~(\A x : x \notin UNION b) => UNION b # {}   BECAUSE Contraposition;
h(a,b) => UNION b # {}   BECAUSE TI;
h(a,b) => IsOrdinal(UNION b) /\ UNION b # {}   BECAUSE CIA;
h(a,b) => IsLimitOrdinal(UNION b)   BECAUSE CIA;

\* Proof that IsFiniteOrdinal(x) => x \in UNION b
ordinalComparison   BECAUSE THEOREM;
IsOrdinal(x) /\ IsOrdinal(UNION b) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE \A(o <- x, p <- UNION b);
IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE S13;
\A o : IsFiniteOrdinal(o) => IsOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => IsFiniteOrdinal(x)   BECAUSE S22;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => h(a,b)   BECAUSE S12;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(UNION b)   BECAUSE TI;
h(a,b) /\ IsFiniteOrdinal(x) => IsOrdinal(x) /\ IsOrdinal(UNION b)   BECAUSE CIA;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b \/ x = UNION b \/ UNION b \in x   BECAUSE TI;
\* because UNION b is infinite, only the first case is possible.
IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE S23;
\A o : IsFiniteOrdinal(o) => ~IsLimitOrdinal(o)   BECAUSE GENERALIZATION;
IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE \A(o <- x);
h(a,b) /\ IsFiniteOrdinal(x) => ~IsLimitOrdinal(x)   BECAUSE TI;
\A x : \A b : x = b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(b))   BECAUSE E_SCHEME;
x = UNION b => (IsLimitOrdinal(x) <=> IsLimitOrdinal(UNION b))   BECAUSE \A(x <- x, b <- UNION b);
h(a,b) /\ IsFiniteOrdinal(x) => IsLimitOrdinal(UNION b)   BECAUSE TI;
killCaseB(h,a,b,c) == (h => ~a) => ((h => c) => (((b => (a <=> c)) => (h => ~b))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x # UNION b   BECAUSE killCaseB;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(x) /\ UNION b \in x => IsFiniteOrdinal(UNION b)   BECAUSE \A(o <- x, x <- UNION b);
IsFiniteOrdinal(UNION b) => ~IsLimitOrdinal(UNION b)   BECAUSE \A(o <- UNION b);
IsFiniteOrdinal(x) /\ UNION b \in x => ~IsLimitOrdinal(UNION b)   BECAUSE TI;
IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE HypoAndToImpl;
h(a,b) /\ IsFiniteOrdinal(x) => (UNION b \in x => ~IsLimitOrdinal(UNION b))   BECAUSE TI;
killCaseD(h,a,b) == (h => (b => ~a)) => ((h => a) => (h => ~b))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => UNION b \notin x   BECAUSE killCaseD;
killCaseE(h,a,b,c) == (h => a \/ b \/ c) => ((h => ~b) => (((h => ~c) => (h => a))))   PROPO_TAUTO;
h(a,b) /\ IsFiniteOrdinal(x) => x \in UNION b   BECAUSE killCaseE;

\* Conversely, x \in UNION b is an ordinal as an element of an ordinal.
\* And x \in t \in b where t is a finite ordinal, so x is finite too.
IsFiniteOrdinal(t) /\ x \in t => IsFiniteOrdinal(x)   BECAUSE \A(o <- t, x <- x);
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t)   BECAUSE TI;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(t) /\ x \in t   BECAUSE CIA;
h(a,b) /\ t \in b /\ x \in t => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE pushHypos;
\A t : h(a,b) => (t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A t : t \in b /\ x \in t => IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
(\A t : t \in b /\ x \in t => IsFiniteOrdinal(x)) => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => ((\E t : t \in b /\ x \in t) => \E t : IsFiniteOrdinal(x))   BECAUSE TI2;
h(a,b) /\ x \in UNION b => x \in UNION b   BECAUSE S22;
h(a,b) /\ x \in UNION b => (\E t : t \in b /\ x \in t)   BECAUSE TI;
h(a,b) /\ x \in UNION b => \E t : IsFiniteOrdinal(x)   BECAUSE KillMiddleHypo;
(\E t : IsFiniteOrdinal(x)) => IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
h(a,b) /\ x \in UNION b => IsFiniteOrdinal(x)   BECAUSE TI;
h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE HIE;
\A x : h(a,b) => (x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE GENERALIZATION;
h(a,b) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;

hA(a) == {} \in a /\ (\A x : x \in a => successor(x) \in a);
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\A x : x \in UNION b <=> IsFiniteOrdinal(x)))
   => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)))   BECAUSE TI;
hA(a) => (\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x))   BECAUSE PT1;
hA(a) => (\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE KillMiddleHypo;
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE \E(o <- UNION b);
(\E b : \A x : x \in UNION b <=> IsFiniteOrdinal(x)) => \E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
hA(a) => (\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE TI;
(\E b : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => (\E o : \A x : x \in o <=> IsFiniteOrdinal(x))   BECAUSE Q_SCHEME;
hA(a) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE TI;
(\E a : hA(a)) => \E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
(\E a : \E o : \A x : x \in o <=> IsFiniteOrdinal(x)) => \E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE Q_SCHEME;
\E o : \A x : x \in o <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;

\* Proof that Nat is unique. By extensionality, being in another Nat
\* is equivalent, it is being a finite ordinal.
ho(o) == \A x : x \in o <=> IsFiniteOrdinal(x);
\A z : \A o : z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE E_SCHEME;
z = o => ((\A x : x \in z <=> IsFiniteOrdinal(x)) <=> (\A x : x \in o <=> IsFiniteOrdinal(x)))   BECAUSE \A(z <- z, o <- o);
killCaseF(a,b,c) == (a => (b <=> c)) => (c /\ a => b)   PROPO_TAUTO;
ho(o) /\ z = o => (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE killCaseF;
extensionality   BECAUSE AXIOM;
(\A x : x \in z <=> x \in o) => z = o   BECAUSE \A(a <- z, b <- o);
ho(o) => (x \in o <=> IsFiniteOrdinal(x))   BECAUSE \A(x <- x);
tEquiv(a,b,c,h) == (h => (a <=> b)) => (h => ((c <=> b) => (c <=> a)))   PROPO_TAUTO;
ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE tEquiv;
\A x : ho(o) => ((x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE GENERALIZATION;
ho(o) => (\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o))   BECAUSE Q_SCHEME;
(\A x : (x \in z <=> IsFiniteOrdinal(x)) => (x \in z <=> x \in o)) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE Q_SCHEME;
ho(o) => ((\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o))   BECAUSE TI;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => (\A x : x \in z <=> x \in o)   BECAUSE HypoImplToAnd;
ho(o) /\ (\A x : x \in z <=> IsFiniteOrdinal(x)) => z = o   BECAUSE TI;
ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE HIE;
\A z : ho(o) => (z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE GENERALIZATION;
ho(o) => (\A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
(\E o : ho(o)) => (\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE Q_SCHEME;
\E o : \A z : z = o <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE CHOOSE Nat;

\* Extract the fact that Nat is a limit ordinal
UNION b = Nat <=> (\A x : x \in UNION b <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- UNION b);
(\A x : x \in UNION b <=> IsFiniteOrdinal(x)) => UNION b = Nat   BECAUSE EquivToImplReverse;
h(a,b) => UNION b = Nat   BECAUSE TI;
\A x : \A y : x = y => (IsLimitOrdinal(x) <=> IsLimitOrdinal(y))   BECAUSE E_SCHEME;
UNION b = Nat => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE \A(x <- UNION b, y <- Nat);
h(a,b) => (IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat))   BECAUSE TI;
(IsLimitOrdinal(UNION b) <=> IsLimitOrdinal(Nat)) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE EquivToImpl;
h(a,b) => (IsLimitOrdinal(UNION b) => IsLimitOrdinal(Nat))   BECAUSE TI;
h(a,b) => IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE HypoAndToImpl;
\A b : hA(a) => ((\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE GENERALIZATION;
hA(a) => (\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
(\A b : (\A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => IsLimitOrdinal(Nat)) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE Q_SCHEME;
hA(a) => ((\E b : \A x : x \in b <=> x \in a /\ IsFiniteOrdinal(x)) => \E b : IsLimitOrdinal(Nat))   BECAUSE TI;
hA(a) => \E b : IsLimitOrdinal(Nat)   BECAUSE KillMiddleHypo;
(\E a : hA(a)) => \E a : \E b : IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
\E a : \E b : IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
(\E a : \E b : IsLimitOrdinal(Nat)) => (\E b : IsLimitOrdinal(Nat))  BECAUSE Q_SCHEME;
(\E b : IsLimitOrdinal(Nat))   BECAUSE MODUS_PONENS;
(\E b : IsLimitOrdinal(Nat)) => IsLimitOrdinal(Nat)   BECAUSE Q_SCHEME;
IsLimitOrdinal(Nat)   BECAUSE MODUS_PONENS;
NatExists   BECAUSE IntroAndRight;
QED

zeroInNat == {} \in Nat
THEOREM zeroInNat
PROOF
VARIABLES a,x,z;
ordinalZero   BECAUSE THEOREM;
\* IsFiniteOrdinal( {} )
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
{} \in Nat <=> IsFiniteOrdinal({})   BECAUSE \A(x <- {});
{} \in Nat   BECAUSE MODUS_PONENS;
QED

(*
   As the smallest limit ordinal, Nat is generated by the successor operation.
   
   This gives the usual proofs by induction on Nat : separate in Nat the
   subset p where a given property is satisfied, then show the 2 hypotheses
   of this theorem about p and conclude its property is satisfied on all Nat.
*)
natInduction == \A p : {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p)
   => Nat \subseteq p
THEOREM natInduction
PROOF
\* Assume by contradiction that there is a natural number k not in p.
\* Nat \ p is then a non-empty subset of the ordinal Nat, take its
\* minimum m. m is not zero, because zero is in p by hypothesis.
\* So m is the successor of a natural number p.
\* This contradicts the hypothesis on p.
VARIABLES a,b,c,k,m,n,o,p,u,v,x,z;
h(p,k) == {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat /\ k \notin p;
h(p,k) => {} \in p   BECAUSE S14;
h(p,k) => (\A n : n \in Nat /\ n \in p => successor(n) \in p)   BECAUSE S24;
h(p,k) => k \in Nat   BECAUSE S23;
h(p,k) => k \notin p   BECAUSE S22;
setDifferenceExists   BECAUSE THEOREM;
k \in (Nat \ p) <=> (k \in Nat /\ k \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- k);
k \in Nat /\ k \notin p => k \in (Nat \ p)   BECAUSE EquivToImplReverse;
h(p,k) => k \in Nat /\ k \notin p   BECAUSE CIA;
h(p,k) => k \in Nat \ p   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
Nat \ p  = {} <=> \A x : x \notin Nat \ p   BECAUSE \A(c <- Nat \ p);
Nat \ p  = {} => \A x : x \notin Nat \ p   BECAUSE EquivToImpl;
(\A x : x \notin Nat \ p) => k \notin Nat \ p   BECAUSE \A(x <- k);
Nat \ p = {} => k \notin Nat \ p   BECAUSE TI;
~(k \notin Nat \ p) => Nat \ p # {}   BECAUSE Contraposition;
k \in Nat \ p => ~(k \notin Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => (Nat \ p) # {}   BECAUSE TI2;
\* Take the minimum of Nat \ p because Nat is an ordinal
NatExists   BECAUSE THEOREM;
IsLimitOrdinal(Nat)   BECAUSE S22;
IsOrdinal(Nat)   BECAUSE S13;
IsWellOrderedByIn(Nat)   BECAUSE S22;
\A p : p \subseteq Nat => p = {} \/ \E m : IsMinimumForIn(m, p)   BECAUSE S22;
(Nat \ p) \subseteq Nat => (Nat \ p) = {} \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE \A(p <- Nat \ p);
z \in (Nat \ p) <=> (z \in Nat /\ z \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- z);
z \in (Nat \ p) => (z \in Nat /\ z \notin p)   BECAUSE EquivToImpl;
(z \in Nat /\ z \notin p) => z \in Nat   BECAUSE S12;
z \in (Nat \ p) => z \in Nat   BECAUSE TI;
Nat \ p \subseteq Nat   BECAUSE GENERALIZATION;
(Nat \ p) = {} \/ \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE MODUS_PONENS;
killCase(h,a,b) == (a \/ b) => ((h => ~a) => (h => b))   PROPO_TAUTO;
h(p,k) => \E m : IsMinimumForIn(m, Nat \ p)   BECAUSE killCase;
hm(p,k,m) == h(p,k) /\ IsMinimumForIn(m, Nat \ p);
hm(p,k,m) => h(p,k)   BECAUSE S12;
hm(p,k,m) => IsMinimumForIn(m, Nat \ p)   BECAUSE S22;
\* Show that m is not empty
IsMinimumForIn(m, Nat \ p) => m \in Nat \ p   BECAUSE S12;
m \in (Nat \ p) <=> (m \in Nat /\ m \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- m);
m \in (Nat \ p) => m \in Nat /\ m \notin p   BECAUSE EquivToImpl;
m \in Nat /\ m \notin p => m \notin p    BECAUSE S22;
IsMinimumForIn(m, Nat \ p) => m \notin p    BECAUSE TI2;
hm(p,k,m) => m \notin p    BECAUSE TI;
hm(p,k,m) => {} \in p    BECAUSE TI;
\A m : \A k : m = k => (m \in p <=> k \in p)   BECAUSE E_SCHEME;
m = {} => (m \in p <=> {} \in p)   BECAUSE \A(m <- m, k <- {});
implyEquivTrue(h,a,b,c) == (h => ~a) => ((h => b) => (((c => (a <=> b)) => (h => ~c))))   PROPO_TAUTO;
hm(p,k,m) => m # {}    BECAUSE implyEquivTrue;
\* Show that m is a successor ordinal
m \in Nat /\ m \notin p => m \in Nat    BECAUSE S12;
IsMinimumForIn(m, Nat \ p) => m \in Nat    BECAUSE TI2;
(\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x)))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
(\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE MODUS_PONENS;
m \in Nat <=> IsFiniteOrdinal(m)   BECAUSE \A(x <- m);
m \in Nat => IsFiniteOrdinal(m)   BECAUSE EquivToImpl;
hm(p,k,m) => IsFiniteOrdinal(m)   BECAUSE TI2;
IsFiniteOrdinal(m) => IsOrdinal(m)   BECAUSE S13;
IsFiniteOrdinal(m) => ~IsLimitOrdinal(m)   BECAUSE S23;
hm(p,k,m) => IsOrdinal(m)   BECAUSE TI;
hm(p,k,m) => ~IsLimitOrdinal(m)   BECAUSE TI;
hm(p,k,m) => m # {} /\ IsOrdinal(m)   BECAUSE CIA;
hm(p,k,m) => m # {} /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m)  BECAUSE CIA;
killCases(a,b,c) == a /\ b /\ ~(b /\ a /\ c) => ~c   PROPO_TAUTO;
m # {} /\ IsOrdinal(m) /\ ~IsLimitOrdinal(m) => ~\A x : x \in m => m # successor(x)   BECAUSE killCases;
hm(p,k,m) => ~\A x : x \in m => m # successor(x)   BECAUSE TI;
(\E x : ~(x \in m => m # successor(x))) <=> ~\A x : ~~(x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : ~~(x \in m => m # successor(x))) => (\E x : ~(x \in m => m # successor(x)))   BECAUSE EquivToImplReverse;
~~(x \in m => m # successor(x)) => (x \in m => m # successor(x))   BECAUSE DropNotNot;
(\A x : ~~(x \in m => m # successor(x))) => (\A x : x \in m => m # successor(x))   BECAUSE Q_SCHEME;
~(\A x : x \in m => m # successor(x)) => ~(\A x : ~~(x \in m => m # successor(x)))   BECAUSE Contraposition;
hm(p,k,m) => \E x : ~(x \in m => m # successor(x))   BECAUSE TI2;
\* Derive a contradiction, because this x is in Nat \intersect p
hmx(p,k,m,x) == hm(p,k,m) /\ ~(x \in m => m # successor(x));
hmx(p,k,m,x) => hm(p,k,m)   BECAUSE S12;
hmx(p,k,m,x) => ~(x \in m => m # successor(x))   BECAUSE S22;
boolImpl(a,b) == ~(a => ~b) => a /\ b   PROPO_TAUTO;
~(x \in m => m # successor(x)) => x \in m /\ m = successor(x)   BECAUSE boolImpl;
hmx(p,k,m,x) => x \in m /\ m = successor(x)   BECAUSE TI;
IsMinimumForIn(m, Nat \ p) => \A b : b \in Nat \ p => (b = m \/ m \in b)   BECAUSE S22;
(\A b : b \in Nat \ p => (b = m \/ m \in b)) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE \A(b <- x);
hm(p,k,m) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat \ p => x = m \/ m \in x)   BECAUSE TI;
finiteInFinite   BECAUSE THEOREM;
IsFiniteOrdinal(m) /\ x \in m => IsFiniteOrdinal(x)   BECAUSE \A(o <- m, x <- x);
hmx(p,k,m,x) => IsFiniteOrdinal(m)   BECAUSE TI;
x \in m /\ m = successor(x) => x \in m   BECAUSE S12;
hmx(p,k,m,x) => x \in m   BECAUSE TI;
hmx(p,k,m,x) => IsFiniteOrdinal(m) /\ x \in m   BECAUSE CIA;
hmx(p,k,m,x) => IsFiniteOrdinal(x)   BECAUSE TI;
x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE \A(x <- x);
IsFiniteOrdinal(x) => x \in Nat   BECAUSE EquivToImplReverse;
hmx(p,k,m,x) => x \in Nat   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x)   BECAUSE CIA;
x \in (Nat \ p) <=> (x \in Nat /\ x \notin p)   BECAUSE \A(u <- Nat, v <- p, x <- x);
killCasesB(a,b,c,d) == (b <=> a /\ d) => (a /\ (b => c) => (d => c))   PROPO_TAUTO;
x \in Nat /\ (x \in Nat \ p => x = m \/ m \in x) => (x \notin p => x = m \/ m \in x)   BECAUSE killCasesB;
hmx(p,k,m,x) => (x \notin p => x = m \/ m \in x)   BECAUSE TI;
ordinalComparesWithOwnElements   BECAUSE THEOREM;
IsOrdinal(m) /\ x \in m => x # m /\ m \notin x   BECAUSE \A(o <- x, p <- m);
hmx(p,k,m,x) => IsOrdinal(m)   BECAUSE TI;
hmx(p,k,m,x) => IsOrdinal(m) /\ x \in m   BECAUSE CIA;
x # m /\ m \notin x => ~(x = m \/ m \in x)   BECAUSE FactorNotOr;
hmx(p,k,m,x) => ~(x = m \/ m \in x)   BECAUSE TI2;
killCaseB(h,a,b) == (h => ~a) => ((h => (~b => a)) => (h => b))   PROPO_TAUTO;
hmx(p,k,m,x) => x \in p   BECAUSE killCaseB;
(\A n : n \in Nat /\ n \in p => successor(n) \in p) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE \A(n <- x);
hm(p,k,m) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE TI2;
hmx(p,k,m,x) => (x \in Nat /\ x \in p => successor(x) \in p)   BECAUSE TI;
hmx(p,k,m,x) => x \in Nat /\ x \in p   BECAUSE CIA;
hmx(p,k,m,x) => successor(x) \in p   BECAUSE KillMiddleHypo;
x \in m /\ m = successor(x) => m = successor(x)   BECAUSE S22;
hmx(p,k,m,x) => m = successor(x)   BECAUSE TI;
\A m : \A x : m = x => (m \in p <=> x \in p)   BECAUSE E_SCHEME;
m = successor(x) => (m \in p <=> successor(x) \in p)   BECAUSE \A(m <- m, x <- successor(x));
hmx(p,k,m,x) => (m \in p <=> successor(x) \in p)   BECAUSE TI;
implyEquivTrueB(h,t,a) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hmx(p,k,m,x) => m \in p   BECAUSE implyEquivTrueB; \* contradiction

\* Discharge existential hypotheses
hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE HypoAndToImpl;
\A x : hm(p,k,m) => (~(x \in m => m # successor(x)) => m \in p)   BECAUSE GENERALIZATION;
hm(p,k,m) => (\A x : ~(x \in m => m # successor(x)) => m \in p)   BECAUSE Q_SCHEME;
(\A x : ~(x \in m => m # successor(x)) => m \in p) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE Q_SCHEME;
hm(p,k,m) => ((\E x : ~(x \in m => m # successor(x))) => \E x : m \in p)   BECAUSE TI;
hm(p,k,m) => \E x : m \in p   BECAUSE KillMiddleHypo;
(\E x : m \in p) => m \in p   BECAUSE Q_SCHEME;
hm(p,k,m) => m \in p   BECAUSE TI; \* contradiction
hm(p,k,m) => m \in p /\ m \notin p   BECAUSE CIA;
absurd(h,a,b) == (h /\ a => b /\ ~b) => (h => ~a)   PROPO_TAUTO;
h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE absurd;
\A m : h(p,k) => ~IsMinimumForIn(m, Nat \ p)   BECAUSE GENERALIZATION;
h(p,k) => \A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) <=> ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE Q_SCHEME;
(\E m : IsMinimumForIn(m, Nat \ p)) => ~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE EquivToImpl;
~~(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~(\E m : IsMinimumForIn(m, Nat \ p))   BECAUSE Contraposition;
(\A m : ~IsMinimumForIn(m, Nat \ p)) => ~~\A m : ~IsMinimumForIn(m, Nat \ p)   BECAUSE IntroNotNot;
h(p,k) => ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE TI2;
h(p,k) => (\E m : IsMinimumForIn(m, Nat \ p)) /\ ~\E m : IsMinimumForIn(m, Nat \ p)   BECAUSE CIA;

{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => ~(k \notin p)   BECAUSE absurd;
~(k \notin p) => k \in p   BECAUSE DropNotNot;
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE TI;
\A k : {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ k \in Nat => k \in p   BECAUSE GENERALIZATION;
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) /\ z \in Nat => z \in p   BECAUSE \A(k <- z);
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE HypoAndToImpl;
\A z : {} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => (z \in Nat => z \in p)   BECAUSE GENERALIZATION;
{} \in p /\ (\A n : n \in Nat /\ n \in p => successor(n) \in p) => Nat \subseteq p   BECAUSE Q_SCHEME;
natInduction   BECAUSE GENERALIZATION;
QED

\* Restriction of the successor operator to Nat
natSucc == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = Nat /\ \A n : n \in Nat => natSucc[n] = successor(n)

(*
   Infinite iteration of a function f starting at init. There is a unique sequence :
   <<init, f[init], f[f[init]], f[f[f[init]]], ...
*)
IterateFunc(f,init) == CHOOSE_UNIQUE s : \A z : z = s <=>
   IsFunction(z) /\ Domain(z) = Nat /\ z[ {} ] = init
   /\ \A n : n \in Nat => z[successor(n)] = f[z[n]]

\* The hypotheses Image(f) \subseteq Domain(f) /\ init \in Domain(f) are probably useless.
iterateFuncExists == \A f : \A init : IsFunction(f) /\ Image(f) \subseteq Domain(f) /\ init \in Domain(f)
   => ( \A z : z = IterateFunc(f,init) <=>
        IsFunction(z) /\ Domain(z) = Nat /\ z[ {} ] = init
        /\ \A n : n \in Nat => z[successor(n)] = f[z[n]]   )
THEOREM iterateFuncExists
PROOF
\* By natInduction, show that there is a partial solution
\* defined on [0,n] for all n.
\* Then use the replacement axiom scheme on Nat to build
\* the complete function.
VARIABLES a,b,c,f,g,n,o,p,x,y,z,init;
h(f,x,init) == \E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init
   /\ \A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]];
\A a : \E b : \A x : x \in b <=> x \in a /\ h(f,x,init)   BECAUSE AXIOM_SCHEME;
\E b : \A x : x \in b <=> x \in Nat /\ h(f,x,init)   BECAUSE \A(a <- Nat);
hb(f,init,b) == \A x : x \in b <=> x \in Nat /\ h(f,x,init);

natInduction   BECAUSE THEOREM;
{} \in b /\ (\A n : n \in Nat /\ n \in b => successor(n) \in b) => Nat \subseteq b   BECAUSE \A(p <- b);
\* Prove h(f, {}, init)
singletonFuncIsFunction   BECAUSE THEOREM;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = {{}}
   /\ singletonFunc({},init)[{}] = init   BECAUSE \A(a <- {}, b <- init);
IsFunction(singletonFunc({},init))   BECAUSE S13;
Domain(singletonFunc({},init)) = {{}}   BECAUSE S23;
singletonFunc({},init)[{}] = init   BECAUSE S22;
unionInc   BECAUSE THEOREM;
x \in successor({}) <=> (x \in {} \/ x \in {{}})   BECAUSE \A(x <- {}, y <- {{}}, z <- x);
emptySetExists   BECAUSE THEOREM;
x \notin {}   BECAUSE \A(x <- x);
equivFalseOr(f,a,b) == ~f => ((a <=> f \/ b) => (a <=> b))   PROPO_TAUTO;
x \in successor({}) <=> x \in {{}}   BECAUSE equivFalseOr;
\A x : x \in successor({}) <=> x \in {{}}   BECAUSE GENERALIZATION;
extensionality   BECAUSE AXIOM;
(\A x : x \in successor({}) <=> x \in {{}}) => successor({}) = {{}}   BECAUSE \A(a <- successor({}), b <- {{}});
successor({}) = {{}}   BECAUSE MODUS_PONENS;

Domain(singletonFunc({},init)) = {{}} /\ successor({}) = {{}}
   => Domain(singletonFunc({},init)) = successor({})   BECAUSE E_SCHEME;
Domain(singletonFunc({},init)) = {{}} /\ successor({}) = {{}}   BECAUSE IntroAndRight;
Domain(singletonFunc({},init)) = successor({})   BECAUSE MODUS_PONENS;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = successor({})   BECAUSE IntroAndRight;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = successor({})
   /\ singletonFunc({},init)[{}] = init   BECAUSE IntroAndRight;
\A x : x \in successor({}) <=> x \in {{}}   BECAUSE GENERALIZATION;
n \in successor({}) <=> n \in {{}}   BECAUSE \A(x <- n);
n \in successor({}) => n \in {{}}   BECAUSE EquivToImpl;
singletonExists   BECAUSE THEOREM;
n \in { {} } <=> n = {}   BECAUSE \A(a <- {}, x <- n);
n \in { {} } => n = {}   BECAUSE EquivToImpl;
n \in successor({}) => n = {}   BECAUSE TI;
boolImpl(a,b) == (a => b) => ~(a /\ ~b)   PROPO_TAUTO;
~(n \in successor({}) /\ n # {})   BECAUSE boolImpl;
n \in successor({}) /\ n # {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE Explosion;
\A n : n \in successor({}) /\ n # {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE GENERALIZATION;
IsFunction(singletonFunc({},init)) /\ Domain(singletonFunc({},init)) = successor({}) /\ singletonFunc({},init)[{}] = init /\ \A n : n \in successor({}) /\ n # {} => singletonFunc({},init)[successor(n)] = f[singletonFunc({},init)[n]]   BECAUSE IntroAndRight;
h(f, {}, init)   BECAUSE \E(g <- singletonFunc({},init));
hb(f,init,b) => ({} \in b <=> {} \in Nat /\ h(f,{},init))   BECAUSE \A(x <- {});
zeroInNat   BECAUSE THEOREM;
{} \in Nat /\ h(f,{},init)   BECAUSE IntroAndRight;
hb(f,init,b) => {} \in b   BECAUSE ImplyEquivTrue;

\* Prove that \A p : p \in b => successor(p) \in b
hbn(f,init,b,p,g) == hb(f,init,b) /\ p \in b
   /\ (IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
       /\ \A n : n \in successor(p) /\ n # p => g[successor(n)] = f[g[n]]);
hbn(f,init,b,p,g) => hb(f,init,b)   BECAUSE S13;
hbn(f,init,b,p,g) => p \in b   BECAUSE S23;
hbn(f,init,b,p,g) => (IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in successor(p) /\ n # p => g[successor(n)] = f[g[n]])   BECAUSE S22;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in successor(p) /\ n # p => g[successor(n)] = f[g[n]]) => IsFunction(g)   BECAUSE S14;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in successor(p) /\ n # p => g[successor(n)] = f[g[n]]) => Domain(g) = successor(p)   BECAUSE S24;
(IsFunction(g) /\ Domain(g) = successor(p) /\ g[{}] = init
  /\ \A n : n \in successor(p) /\ n # p => g[successor(n)] = f[g[n]]) => g[{}] = init   BECAUSE S23;
hbn(f,init,b,p,g) => IsFunction(g)   BECAUSE TI;
hbn(f,init,b,p,g) => Domain(g) = successor(p)   BECAUSE TI;
hbn(f,init,b,p,g) => g[{}] = init   BECAUSE TI;

unionFunc   BECAUSE THEOREM;
IsFunction(g) /\ IsFunction(singletonFunc(successor(p), f[g[p]])) /\ AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]])))
   => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))
      /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))
      /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])
      /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])
   BECAUSE \A(f <- g, g <- singletonFunc(successor(p), f[g[p]]));

IsFunction(singletonFunc(successor(p), f[g[p]])) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}
   /\ singletonFunc(successor(p), f[g[p]])[successor(p)] = f[g[p]]   BECAUSE \A(a <- successor(p), b <- f[g[p]]);
IsFunction(singletonFunc(successor(p), f[g[p]]))   BECAUSE S13;
Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}   BECAUSE S23;
singletonFunc(successor(p), f[g[p]])[successor(p)] = f[g[p]]   BECAUSE S22;

\A a : \A b : \A x : \A y : a = b /\ x = y => (AreDisjoint(a,x) <=> AreDisjoint(b,y))   BECAUSE E_SCHEME;
Domain(g) = successor(p) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}
   => (AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]]))) <=> AreDisjoint(successor(p),{successor(p)}))
   BECAUSE \A(a <- Domain(g), b <- successor(p), x <- Domain(singletonFunc(successor(p), f[g[p]])), y <- {successor(p)});
hbn(f,init,b,p,g) => Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}   BECAUSE PT1;
hbn(f,init,b,p,g) => Domain(g) = successor(p) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}   BECAUSE CIA;
hbn(f,init,b,p,g) => (AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]]))) <=> AreDisjoint(successor(p),{successor(p)}))   BECAUSE TI;

(\A x : x \in b <=> x \in Nat /\ h(f,x,init)) => (p \in b <=> p \in Nat /\ h(f,p,init))   BECAUSE \A(x <- p);
hbn(f,init,b,p,g) => (p \in b <=> p \in Nat /\ h(f,p,init))   BECAUSE TI;
(p \in b <=> p \in Nat /\ h(f,p,init)) => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE EquivToImpl;
hbn(f,init,b,p,g) => (p \in b => p \in Nat /\ h(f,p,init))   BECAUSE TI;
hbn(f,init,b,p,g) => p \in Nat /\ h(f,p,init)   BECAUSE KillMiddleHypo;
p \in Nat /\ h(f,p,init) => p \in Nat   BECAUSE S12;
hbn(f,init,b,p,g) => p \in Nat   BECAUSE TI;
NatExists   BECAUSE THEOREM;
\A z : z = Nat <=> (\A x : x \in z <=> IsFiniteOrdinal(x))   BECAUSE S12;
Nat = Nat <=> (\A x : x \in Nat <=> IsFiniteOrdinal(x))   BECAUSE \A(z <- Nat);
equalSelf   BECAUSE THEOREM;
Nat = Nat   BECAUSE \A(a <- Nat);
\A x : x \in Nat <=> IsFiniteOrdinal(x)   BECAUSE MODUS_PONENS;
p \in Nat <=> IsFiniteOrdinal(p)   BECAUSE \A(x <- p);
p \in Nat => IsFiniteOrdinal(p)   BECAUSE EquivToImpl;
IsFiniteOrdinal(p) => IsOrdinal(p)   BECAUSE S13;
hbn(f,init,b,p,g) => IsOrdinal(p)   BECAUSE TI2;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(p) => IsOrdinal( successor(p) )   BECAUSE \A(o <- p);
ordinalsWellFounded   BECAUSE THEOREM;
IsOrdinal(successor(p)) => successor(p) \notin successor(p)   BECAUSE \A(o <- successor(p));
hbn(f,init,b,p,g) => successor(p) \notin successor(p)   BECAUSE TI2;

hbn(f,init,b,p,g) => p \in Nat   BECAUSE TI;
noCommonElements   BECAUSE THEOREM;
AreDisjoint(successor(p), {successor(p)}) <=> \A z : ~(z \in successor(p) /\ z \in {successor(p)})
   BECAUSE \A(x <- successor(p), y <- {successor(p)});
z \in {successor(p)} <=> z = successor(p)   BECAUSE \A(a <- successor(p), x <- z);
z \in {successor(p)} => z = successor(p)   BECAUSE EquivToImpl;
\A z : \A x : z = x => (z \in successor(p) <=> x \in successor(p))   BECAUSE E_SCHEME;
z = successor(p) => (z \in successor(p) <=> successor(p) \in successor(p))   BECAUSE \A(z <- z, x <- successor(p));
z \in {successor(p)} => (z \in successor(p) <=> successor(p) \in successor(p))   BECAUSE TI;
implyEquivFalse(h,a,b,f) == (h => ~f) => ((a => (b <=> f)) => (h => ~(b /\ a)))   PROPO_TAUTO;
hbn(f,init,b,p,g) => ~(z \in successor(p) /\ z \in {successor(p)})   BECAUSE implyEquivFalse;
\A z : hbn(f,init,b,p,g) => ~(z \in successor(p) /\ z \in {successor(p)})   BECAUSE GENERALIZATION;
hbn(f,init,b,p,g) => \A z : ~(z \in successor(p) /\ z \in {successor(p)})   BECAUSE Q_SCHEME;
(\A z : ~(z \in successor(p) /\ z \in {successor(p)})) => AreDisjoint(successor(p), {successor(p)})   BECAUSE EquivToImplReverse;
hbn(f,init,b,p,g) => AreDisjoint(successor(p), {successor(p)})   BECAUSE TI;
implyEquivTrue(h,a,t) == (h => t) => ((h => (a <=> t)) => (h => a))   PROPO_TAUTO;
hbn(f,init,b,p,g) => AreDisjoint(Domain(g), Domain(singletonFunc(successor(p), f[g[p]])))   BECAUSE implyEquivTrue;
hbn(f,init,b,p,g) => IsFunction(singletonFunc(successor(p), f[g[p]]))   BECAUSE PT1;
hbn(f,init,b,p,g) => IsFunction(g) /\ IsFunction(singletonFunc(successor(p), f[g[p]]))   BECAUSE CIA;
hbn(f,init,b,p,g) => IsFunction(g) /\ IsFunction(singletonFunc(successor(p), f[g[p]])) /\ AreDisjoint(Domain(g),Domain(singletonFunc(successor(p), f[g[p]])))   BECAUSE CIA;

hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))
      /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))
      /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])
      /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])
   BECAUSE TI;

IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE S14;
hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE TI;

\A a : \A b : \A x : \A y : a = b /\ x = y => a \union x = b \union y   BECAUSE E_SCHEME;
Domain(g) = successor(p) /\ Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)}
   => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}
   BECAUSE \A(a <- Domain(g), b <- successor(p), x <- Domain(singletonFunc(successor(p), f[g[p]])), y <- {successor(p)});
hbn(f,init,b,p,g) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}   BECAUSE TI;
IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])
   => Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE S24;
hbn(f,init,b,p,g) => Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE TI;
Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]]))   BECAUSE TI;
Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)} => Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = Domain(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) = successor(p) \union {successor(p)}   BECAUSE CIA;
hbn(f,init,b,p,g) => Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p))   BECAUSE TI;

IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])   BECAUSE S23;
hbn(f,init,b,p,g) => (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x])   BECAUSE TI;
(\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) => ({} \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}])   BECAUSE \A(x <- {});
hbn(f,init,b,p,g) => ({} \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}])   BECAUSE TI;
\* Domain(g) = successor(p) so {} \in Domain(g)
emptyIncludedInAny   BECAUSE THEOREM;
{} \subseteq successor(p)   BECAUSE \A(x <- successor(p));
hbn(f,init,b,p,g) => {} \subseteq successor(p)   BECAUSE PT1;
includedOrdinals   BECAUSE THEOREM;
IsOrdinal({}) /\ IsOrdinal(successor(p)) /\ {} \subseteq successor(p) => {} \in successor(p) \/ {} = successor(p)   BECAUSE \A(o <- {}, p <- successor(p));
ordinalZero   BECAUSE THEOREM;
IsOrdinal({})   BECAUSE S13;
hbn(f,init,b,p,g) => IsOrdinal({})   BECAUSE PT1;
ordinalSuccessorStable   BECAUSE THEOREM;
IsOrdinal(p) => IsOrdinal( successor(p) )   BECAUSE \A(o <- p);
hbn(f,init,b,p,g) => IsOrdinal(successor(p))   BECAUSE TI;
hbn(f,init,b,p,g) => IsOrdinal({}) /\ IsOrdinal(successor(p))   BECAUSE CIA;
hbn(f,init,b,p,g) => IsOrdinal({}) /\ IsOrdinal(successor(p)) /\ {} \subseteq successor(p)   BECAUSE CIA;
hbn(f,init,b,p,g) => {} \in successor(p) \/ {} = successor(p)   BECAUSE TI;
emptySetExistsUniquely   BECAUSE THEOREM;
successor(p) = {} <=> \A x : x \notin successor(p)   BECAUSE \A(c <- successor(p));
successor(p) = {} => \A x : x \notin successor(p)   BECAUSE EquivToImpl;
{} = successor(p) => successor(p) = {}   BECAUSE E_SCHEME;
{} = successor(p) => \A x : x \notin successor(p)   BECAUSE TI;
~(\A x : x \notin successor(p)) => {} # successor(p)   BECAUSE Contraposition;
(\E x : x \in successor(p)) <=> ~(\A x : x \notin successor(p))   BECAUSE Q_SCHEME;
(\E x : x \in successor(p)) => ~(\A x : x \notin successor(p))   BECAUSE EquivToImpl;
p \in successor(p) => (\E x : x \in successor(p))   BECAUSE \E(x <- p);
p \in successor(p) => {} # successor(p)   BECAUSE TI2;
inSuccessor   BECAUSE THEOREM;
p \in successor(p)   BECAUSE \A(o <- p);
{} # successor(p)   BECAUSE MODUS_PONENS;
killCase(h,a,f) == ~f => ((h => a \/ f) => (h => a))   PROPO_TAUTO;
hbn(f,init,b,p,g) => {} \in successor(p)   BECAUSE killCase;
\A x : \A y : x = y => ({} \in x <=> {} \in y)   BECAUSE E_SCHEME;
Domain(g) = successor(p) => ({} \in Domain(g) <=> {} \in successor(p))   BECAUSE \A(x <- Domain(g), y <- successor(p));
hbn(f,init,b,p,g) => ({} \in Domain(g) <=> {} \in successor(p))   BECAUSE TI;
hbn(f,init,b,p,g) => {} \in Domain(g)   BECAUSE implyEquivTrue;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}]   BECAUSE KillMiddleHypo;
(g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}]  /\ init = g[{}] => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init   BECAUSE E_SCHEME;
g[{}] = init => init = g[{}]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => init = g[{}]   BECAUSE TI;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = g[{}]  /\ init = g[{}]   BECAUSE CIA;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init   BECAUSE TI;

\* Prove that (g \union singletonFunc(successor(p), f[g[p]])) satisfies the recurrent constrain
IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = Domain(g) \union Domain(singletonFunc(successor(p), f[g[p]])) /\ (\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) /\ (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])   BECAUSE S22;
hbn(f,init,b,p,g) => (\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x])   BECAUSE TI;
(\A x : x \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = singletonFunc(successor(p), f[g[p]])[x]) => (successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)])   BECAUSE \A(x <- successor(p));

\* Last value on successor(p)
hbn(f,init,b,p,g) => (successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)])   BECAUSE TI;
successor(p) \in { successor(p) } <=> successor(p) = successor(p)   BECAUSE \A(a <- successor(p), x <- successor(p));
successor(p) = successor(p)   BECAUSE \A(a <- successor(p));
successor(p) \in { successor(p) }   BECAUSE MODUS_PONENS;
\A x : \A y : x = y => (successor(p) \in x <=> successor(p) \in y)   BECAUSE E_SCHEME;
Domain(singletonFunc(successor(p), f[g[p]])) = {successor(p)} => (successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) <=> successor(p) \in {successor(p)})   BECAUSE \A(x <- Domain(singletonFunc(successor(p), f[g[p]])), y <- {successor(p)});
successor(p) \in Domain(singletonFunc(successor(p), f[g[p]])) <=> successor(p) \in {successor(p)}   BECAUSE MODUS_PONENS;
successor(p) \in Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE MODUS_PONENS;
hbn(f,init,b,p,g) => successor(p) \in Domain(singletonFunc(successor(p), f[g[p]]))   BECAUSE PT1;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE KillMiddleHypo;
singletonFunc(successor(p), f[g[p]])[successor(p)] = f[g[p]] => f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE E_SCHEME;
f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE MODUS_PONENS;
(g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)] /\ f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]
   => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE PT1;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = singletonFunc(successor(p), f[g[p]])[successor(p)] /\ f[g[p]] = singletonFunc(successor(p), f[g[p]])[successor(p)]   BECAUSE CIA;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]]   BECAUSE TI;
(\A x : x \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[x] = g[x]) => (p \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p])   BECAUSE \A(x <- p);
hbn(f,init,b,p,g) => (p \in Domain(g) => (g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p])   BECAUSE TI;
\A x : \A y : x = y => (p \in x <=> p \in y)   BECAUSE E_SCHEME;
Domain(g) = successor(p) => (p \in Domain(g) <=> p \in successor(p))   BECAUSE \A(x <- Domain(g), y <- successor(p));
Domain(g) = successor(p) => p \in Domain(g)   BECAUSE ImplyEquivTrue;
hbn(f,init,b,p,g) => p \in Domain(g)   BECAUSE TI;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p]   BECAUSE KillMiddleHypo;
\A x : \A y : x = y => f[x] = f[y]   BECAUSE E_SCHEME;
(g \union singletonFunc(successor(p), f[g[p]]))[p] = g[p] => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]]   BECAUSE \A(x <- (g \union singletonFunc(successor(p), f[g[p]]))[p], y <- g[p]);
hbn(f,init,b,p,g) => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]]   BECAUSE TI;
hbn(f,init,b,p,g) => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]] /\ (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]]   BECAUSE CIA;
f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = f[g[p]] /\ (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[g[p]] => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)]   BECAUSE TI;
f[(g \union singletonFunc(successor(p), f[g[p]]))[p]] = (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[p]]   BECAUSE E_SCHEME;
hbn(f,init,b,p,g) => (g \union singletonFunc(successor(p), f[g[p]]))[successor(p)] = f[(g \union singletonFunc(successor(p), f[g[p]]))[p]]   BECAUSE TI;

\* Previous values

n \in successor(successor(p)) <=> (n \in successor(p) \/ n \in {successor(p)})   BECAUSE \A(x <- successor(p), y <- {successor(p)}, z <- n);
n \in successor(successor(p)) /\ n # successor(p) => n \in successor(p)   BECAUSE TI; 


hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p))   BECAUSE CIA;
hbn(f,init,b,p,g) => IsFunction(g \union singletonFunc(successor(p), f[g[p]])) /\ Domain(g \union singletonFunc(successor(p), f[g[p]])) = successor(successor(p)) /\ (g \union singletonFunc(successor(p), f[g[p]]))[{}] = init   BECAUSE CIA;
hbn(f,init,b,p,g) => h(f,successor(p),init)   BECAUSE \E(g <- g \union singletonFunc(successor(p), f[g[p]]));
\* Discharge g
   
hb(f,x,init,b) => Nat \subseteq b   BECAUSE TI;
Nat \subseteq b => (p \in Nat => p \in b)   BECAUSE \A(z <- b);
hb(f,x,init,b) => \A p : p \in Nat => h(f,p,init)   BECAUSE TI;
\* Discharge b

\A p : p \in Nat => h(f,p,init)   BECAUSE TI;

\* Then show this relation is functional in y (unicity) :
F(x,y,f,init) == x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init
        /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]])
        /\ y = <<x, g[x]>> );

\* The replacement axiom scheme invocation on F
(\A x : \A y : \A z : ((x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]]) /\ y = <<x, g[x]>> ))
        /\ (x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]]) /\ z = <<x, g[x]>> ))) => y = z)
   => (\A a : \E b : \A y : y \in b <=> \E x : x \in a /\ (x \in Nat /\ (\E g : IsFunction(g) /\ Domain(g) = successor(x) /\ g[{}] = init /\ (\A n : n \in successor(x) /\ n # x => g[successor(n)] = f[g[n]])
        /\ y = <<x, g[x]>> )))
   BECAUSE AXIOM_SCHEME;
iterateFuncExists   BECAUSE GENERALIZATION;
QED

(*
   The usual addition operation on natural numbers.
   It could also be defined as the restriction of
   ordinal addition on Nat.
*)
NatAddition == CHOOSE_UNIQUE f : \A z : z = f <=>
   IsFunction(z) /\ Domain(z) = (Nat \X Nat)
   /\ \A n : \A p : n \in Nat /\ p \in Nat => z[n,p] = IterateFunc(natSucc,n)[p]

natAdditionExists == \A n : \A p : n \in Nat /\ p \in Nat => NatAddition[n,p] = IterateFunc(natSucc,n)[p]
THEOREM natAdditionExists

(* TODO associativity, commutativity, multiplication, symbols for digits 0,1,2,3,4,5,6,7,8,9,10 *)